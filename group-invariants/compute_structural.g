# Structural invariants
# Usage: echo 'n:=64;;' | cat - compute_structural.g | gap -q

SetPrintFormattingStatus("*stdout*", false);

for k in [1..NumberSmallGroups(n)] do
  G := SmallGroup(n, k);
  sz := Size(G);
  
  s1 := Size(AutomorphismGroup(G));
  s2 := Length(ConjugacyClassesSubgroups(G));
  s3 := Length(NormalSubgroups(G));
  if IsNilpotent(G) then
    s4 := NilpotencyClassOfGroup(G);
  else
    s4 := -1;
  fi;
  s5 := DerivedLength(G);
  s6 := Exponent(G);
  s7 := Length(SmallGeneratingSet(G));
  
  phi := FrattiniSubgroup(G);
  s8 := sz / Size(phi);
  s13 := Size(phi);
  
  s9 := Length(CharacteristicSubgroups(G));
  
  Z1 := Center(G);
  s10 := Size(Z1);
  
  Gp := DerivedSubgroup(G);
  s11 := Size(Gp);
  
  if Size(Z1) < sz then
    Q := G/Z1;
    s12 := Size(Center(Q));
  else
    s12 := 1;
  fi;
  
  s14 := Length(ConjugacyClasses(G));
  
  s15 := Size(Intersection(Gp, Z1));
  
  # Abelian invariants encoded as sorted string
  ai_ab := ShallowCopy(AbelianInvariants(G/Gp));
  Sort(ai_ab);
  s16 := Product(ai_ab);
  
  ai_z := ShallowCopy(AbelianInvariants(Z1));
  Sort(ai_z);
  s17 := Product(ai_z);
  
  # Omega_1: generated by elements of prime order
  pp := SmallestPrimeDivisor(sz);
  gens_omega := [];
  for a in AsList(G) do
    if Order(a) = pp then Add(gens_omega, a); fi;
  od;
  if Length(gens_omega) > 0 then
    omega := Subgroup(G, gens_omega);
    s18 := Size(omega);
  else
    s18 := 1;
  fi;
  
  Print(n,",",k,",",s1,",",s2,",",s3,",",s4,",",s5,",",s6,",",s7,",",s8,",",s9,",",s10,",",s11,",",s12,",",s13,",",s14,",",s15,",",s16,",",s17,",",s18,"\n");
od;
QUIT;
