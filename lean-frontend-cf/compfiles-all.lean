-- Competition Math Formalizations (compfiles)
-- 162 IMO, Putnam, USAMO problems formalized in Lean 4 + Mathlib
-- Source: https://github.com/dwrensha/compfiles
--
-- Imo: 107 problems
-- Usa: 39 problems
-- Bulgaria: 3 problems
-- Iran: 2 problems
-- Poland: 2 problems
-- Canada: 1 problems
-- Egmo: 1 problems
-- Hungary: 1 problems
-- India: 1 problems
-- IntegersInACircle: 1 problems
-- KolmogorovStreams: 1 problems
-- Romania: 1 problems
-- Russia: 1 problems
-- UK: 1 problems

set_option warningAsError false
set_option maxHeartbeats 800000

-- ═══ Bulgaria1998P11 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Adam Kurkiewicz
-/





/-!
Bulgarian Mathematical Olympiad 1998, Problem 11

Let m,n be natural numbers such that

   A = ((m + 3)ⁿ + 1) / (3m)

is an integer. Prove that A is odd.
-/

namespace Bulgaria1998P11



lemma mod_3_add_3_under_exponent (m n : ℕ) : ((m + 3) ^ n) ≡ (m ^ n) [MOD 3] := by
  change (m + 3)^n % 3 = m ^ n % 3
  simp [Nat.pow_mod]

lemma zero_pow_mod_3 {m n : ℕ} (h1 : n > 0) (h2 : m ≡ 0 [MOD 3]) : m ^ n ≡ 0 [MOD 3]:= by
  change _ % 3 = 0 at h2 ⊢
  rw [←Nat.dvd_iff_mod_eq_zero] at h2 ⊢
  exact Dvd.dvd.pow h2 (Nat.ne_zero_of_lt h1)

lemma one_pow_mod_3 {m n : ℕ} (h2 : m ≡ 1 [MOD 3]) : m ^ n ≡ 1 [MOD 3]:= by
  change _ % _ = 1 at h2 ⊢
  simp [Nat.pow_mod, h2]

lemma two_even_pow_mod_3 {m n : ℕ} (h1 : Even n) (h2 : m ≡ 2 [MOD 3]) : m ^ n ≡ 1 [MOD 3] := by
  change _ % _ = _ at h2 ⊢
  obtain ⟨k, hk⟩ := h1
  simp +arith +decide [Nat.pow_mod, h2, hk, pow_mul]

theorem n_odd_and_m_eq_2_mod_3 (m n A : ℕ) (h : 3 * m * A = (m + 3)^n + 1) :
    Odd n ∧ m ≡ 2 [MOD 3] := by
  by_cases n_gt_zero : n > 0
  · have h_mod_3 : 0 ≡ (m ^ n + 1) [MOD 3] := by
      calc 0 ≡ 3 * (m * A) [MOD 3] := (Nat.mul_mod_right 3 (m * A)).symm
      _ ≡ (3 * m * A) [MOD 3] := by rw[show 3 * (m * A) = (3 * m * A) by ring]
      _ ≡ ((m + 3) ^ n + 1) [MOD 3] := by rw[h]
      _ ≡ (m ^ n + 1) [MOD 3] := Nat.ModEq.add (mod_3_add_3_under_exponent m n) rfl
    mod_cases mod_case : m % 3
    · have towards_contradiction : 0 ≡ 1 [MOD 3] := by
        calc 0 ≡ m ^ n + 1 [MOD 3] := h_mod_3
        _ ≡ 0 + 1 [MOD 3] := Nat.ModEq.add (zero_pow_mod_3 n_gt_zero mod_case) rfl
        _ ≡ 1 [MOD 3] := by rfl
      contradiction
    · have towards_contradiction : 0 ≡ 2 [MOD 3] := by
        rw[show 2 = 1 + 1 by ring]
        calc 0 ≡ m ^ n + 1 [MOD 3] := h_mod_3
        _ ≡ 1 + 1 [MOD 3] := Nat.ModEq.add (one_pow_mod_3 mod_case) rfl
      contradiction
    · by_cases n_even : Even n
      · have towards_contradiction : 0 ≡ 2 [MOD 3] := by
          calc 0 ≡ m ^ n + 1 [MOD 3] := h_mod_3
          _ ≡ 1 + 1 [MOD 3] := Nat.ModEq.add (two_even_pow_mod_3 n_even mod_case) rfl
          _ ≡ 2 [MOD 3] := by rfl
        contradiction
      · rw [Nat.not_even_iff_odd] at n_even
        exact ⟨n_even, mod_case⟩
  · rw [Nat.eq_zero_of_not_pos n_gt_zero] at h
    lia

lemma not_one_le_k {k : ℕ} (h : ¬1 ≤ k) : k = 0 := by
  simp_all only [not_le, Nat.lt_one_iff]

lemma two_le_pow_two (l : ℕ) : 2 ≤ 2 ^ (l + 1) := by
  rw [pow_succ]
  suffices 1 ≤ 2 ^ l from Nat.le_mul_of_pos_left 2 this
  exact Nat.one_le_two_pow

lemma two_n_and_rest_factorisation (m : ℕ) (even_m : Even m) (h: 0 < m) :
    ∃ (l : ℕ) (m₁ : ℕ), 1 ≤ l ∧ Odd m₁ ∧ m = 2 ^ l * m₁ := by
  have ⟨a, ha⟩ := Nat.maxPowDiv.pow_dvd 2 m
  refine ⟨Nat.maxPowDiv 2 m, a, ?_⟩
  obtain ⟨k, hk⟩ := even_iff_two_dvd.mp even_m
  have hk0 : 0 < k := by lia
  refine ⟨?_, ?_, ha⟩
  · rw [hk]
    rw [show 2 * k = 2^1 * k from rfl]
    rw [Nat.maxPowDiv.base_pow_mul one_lt_two hk0]
    exact Nat.le_add_left 1 (Nat.maxPowDiv 2 k)
  · by_contra! Ha
    rw [Nat.not_odd_iff_even] at Ha
    obtain ⟨b, hb⟩ := Ha
    have h3 : 2 ^ (Nat.maxPowDiv 2 m  + 1) ∣ m := by
      use b
      rw [hb] at ha
      rw [pow_succ]
      linarith only [ha]
    have h4 := Nat.maxPowDiv.le_of_dvd one_lt_two (Nat.ne_zero_of_lt h) h3
    exact (lt_self_iff_false _).mp (Nat.succ_le_iff.mp h4)

lemma m_mod_2_contradiction (m n A : ℕ)
                            (even_A : Even A)
                            (m_eq_2_mod_4 : m ≡ 2 [MOD 4])
                            (h : 3 * m * A = (m + 3)^n + 1) : False := by
  rw [← ZMod.natCast_eq_natCast_iff] at m_eq_2_mod_4
  apply_fun (fun x ↦ (x : ZMod 4)) at h
  push_cast at h
  rw [m_eq_2_mod_4] at h
  obtain ⟨a, rfl⟩ := even_A
  push_cast at h
  rw [←two_mul] at h
  ring_nf at h; reduce_mod_char at h
  rw [one_pow] at h
  simp +arith +decide at h

lemma m_add_3_pow_n_mod_m (n m : ℕ) : (m + 3)^n ≡ 3^n [MOD m] := by
  simp [Nat.ModEq, Nat.pow_mod]

lemma too_good_to_be_true (n l : ℕ)
                          (three_le_l : 3 ≤ l)
                          (two_pow_l_divides_expresion : 2^l ∣ (3^n + 1))
                          (expression_eq_4_mod_8 : 3^n + 1 ≡ 4 [MOD 8]) : False := by
  have : 8 ∣ 3 ^ n + 1 := by
    obtain ⟨a, Ha⟩ := two_pow_l_divides_expresion
    obtain ⟨b, Hb⟩ := Nat.exists_eq_add_of_le' three_le_l
    rw[Hb] at Ha
    dsimp [Dvd.dvd]
    use 2 ^ b * a
    rw[Ha]
    ring
  obtain ⟨a, Ha⟩ := this
  rw [Ha] at expression_eq_4_mod_8
  dsimp[Nat.ModEq] at expression_eq_4_mod_8
  simp at expression_eq_4_mod_8

lemma thue
    (a n : ℕ) (hn : 1 < n) :
    ∃ (x y : ℤ), (a : ZMod n) * x + y = 0 ∧ 0 < |x| ∧ x ^ 2 ≤ n ∧ y ^ 2 ≤ n := by
  -- https://services.artofproblemsolving.com/download.php?id=YXR0YWNobWVudHMvMy8yL2QzYjEzOGM0ODE3YzYwZGU4NGFmOTEwZDc0ZGNhODRjOGMyMzZlLnBkZg==&rn=dGh1ZS12NC5wZGY=

  -- let r = ⌊√n⌋, i.e. r is the unique integer for which
  -- r² ≤ n < (r + 1)².
  let r := Nat.sqrt n

  -- The number of pairs (x,y) so that 0 ≤ x,y ≤ r is (r + 1)² which
  -- is greater than n.

  --
  -- Therefore there must be two different pairs (x₁, y₁) and (x₂, y₂)
  -- such that
  --     ax₁ + y₁ = ax₂ + ay₂ (mod n)
  --     i.e.
  --     a(x₁ - x₂) = y₂ - y₁ (mod n)
  --

  let D := Fin (r + 1) × Fin (r + 1)
  let f : D → ZMod n := fun ⟨x,y⟩ ↦ a * (x.val : ZMod n) + (y.val : ZMod n)
  have cardD : Fintype.card D = (r + 1)^2 := by
    unfold D
    rw [sq, Fintype.card_prod, Fintype.card_fin]

  have : NeZero n := NeZero.of_gt hn
  have cardZ : Fintype.card (ZMod n) = n := ZMod.card n

  have hDZ : Fintype.card (ZMod n) < Fintype.card D := by
    rw [cardD, cardZ]
    exact Nat.lt_succ_sqrt' n

  obtain ⟨⟨x₁, y₁⟩, ⟨x₂, y₂⟩, hxyn, hxy⟩ :=
    Fintype.exists_ne_map_eq_of_card_lt f hDZ
  dsimp [f] at hxy
  replace hxy : (a : ZMod n) * (↑↑x₁ - ↑↑x₂) + (↑↑y₁ - ↑↑y₂) = 0 :=
    by linear_combination hxy
  use (x₁ : ℤ) - (x₂ : ℤ)
  use (y₁ : ℤ) - (y₂ : ℤ)

  have hx1 : ((x₁ : ℕ): ZMod n) = (((x₁ : ℕ): ℤ) : ZMod n)  := by
      norm_cast
  have hx2 : ((x₂ : ℕ): ZMod n) = (((x₂ : ℕ): ℤ) : ZMod n)  := by
      norm_cast

  have hx3 : (((x₁ : ℕ): ℤ) : ZMod n) - (((x₂ : ℕ): ℤ) : ZMod n) =
            (((((x₁ : ℕ): ℤ) -((x₂ : ℕ): ℤ)) : ℤ) : ZMod n) := by
    norm_cast

  have hy1 : ((y₁ : ℕ): ZMod n) = (((y₁ : ℕ): ℤ) : ZMod n)  := by
      norm_cast
  have hy2 : ((y₂ : ℕ): ZMod n) = (((y₂ : ℕ): ℤ) : ZMod n)  := by
      norm_cast
  have hy3 : (((y₁ : ℕ): ℤ) : ZMod n) - (((y₂ : ℕ): ℤ) : ZMod n) =
            (((((y₁ : ℕ): ℤ) -((y₂ : ℕ): ℤ)) : ℤ) : ZMod n) := by
    norm_cast

  refine ⟨?_, ?_, ?_, ?_⟩
  · rw [hx1, hx2, hx3, hy1, hy2, hy3] at hxy
    rw [hxy]

  · by_contra! H
    replace H : |((x₁:ℕ):ℤ) - ↑↑x₂| = 0 := by
      have : (0 : ℤ) ≤ |((x₁:ℕ):ℤ) - ↑↑x₂| := abs_nonneg _
      exact (Int.le_antisymm this H).symm
    rw [abs_eq_zero] at H
    replace H : ((x₁:ℕ):ℤ) = ↑↑x₂ := Int.eq_of_sub_eq_zero H
    replace H : x₁.val = x₂.val := Int.ofNat_inj.mp H
    replace H : x₁ = x₂ := Fin.eq_of_val_eq H
    rw [H, sub_self, mul_zero, zero_add] at hxy
    have h4 : ((y₁:ℕ): ZMod n) = ↑↑y₂ := by linear_combination hxy
    rw [ZMod.natCast_eq_natCast_iff'] at h4
    have p1 := y₁.prop
    have p2 := y₂.prop
    have : r + 1 ≤ n := by
      have h31 := Nat.sqrt_lt_self hn
      lia
    have h10 : y₁.val < n := by lia
    have h11 : y₂.val < n := by lia
    rw [Nat.mod_eq_of_lt h10, Nat.mod_eq_of_lt h11] at h4
    have h12 : y₁ = y₂ := Fin.eq_of_val_eq h4
    rw [H,h12] at hxyn
    simp at hxyn
  · have hx₁ : x₁.val < r + 1 := x₁.prop
    have hx₂ : x₂.val < r + 1 := x₂.prop
    have hr1 : r^2 ≤ n := Nat.sqrt_le' n
    nlinarith only [hx₁, hx₂, hr1]
  · have hy₁ : y₁.val < r + 1 := y₁.prop
    have hy₂ : y₂.val < r + 1 := y₂.prop
    have hr1 : r^2 ≤ n := Nat.sqrt_le' n
    nlinarith only [hy₁, hy₂, hr1]

/--
In this version of Thue's lemma, we get an `x` that is nonzero and
a `y` that might be zero. If we wanted to guarantee that `y` is nonzero,
we would need an extra hypothesis `Nat.Coprime a n`.
-/
lemma Thue's_lemma
    (a n : ℕ)
    (hn : 1 < n) :
    ∃ (x y : ℤ),
      a * x + y ≡ 0 [ZMOD n] ∧
      0 < |x| ∧
      x ^ 2 ≤ n ∧
      y ^ 2 ≤ n := by
  obtain ⟨x, y, hxay, hx, hx1, hy1⟩ := thue a n hn
  refine ⟨x, y, ?_, hx, hx1, hy1⟩
  have h1 : (a : ZMod n) * (x : ZMod n) + (y : ZMod n) =
            ((((a : ℤ) * x + y):ℤ) : ZMod n) := by norm_cast
  have h2 : ((0:ℤ):ZMod n) = 0 := by norm_cast
  rw [h1, ←h2] at hxay
  exact (ZMod.intCast_eq_intCast_iff (a * x + y) 0 n).mp hxay

example (a b n : ℕ) (ha : a < n + 1) (hb : b < n + 1) : ((a : ℤ) - (b : ℤ))^2 ≤ n^2 := by
  nlinarith

lemma square_mod_4_zmod (x : ZMod 4) : x ^ 2 = 1 ∨ x ^ 2 = 0 := by
  fin_cases x <;> simp +arith +decide

lemma square_mod_3_zmod_0 : ∀ {x : ZMod 3} (_ : x ^ 2 = 0), x = 0 := by
  decide

lemma leaf_contradiction {x y m₁ : ℤ} (h: 3 * x ^ 2 + y ^ 2 = m₁) (h2 : m₁ - 5 ≡ 0 [ZMOD 6]) :
    False := by
  replace h2 : m₁ - 5 ≡ 0 [ZMOD 3] := Int.ModEq.of_mul_left 2 h2
  rw [show 3 = ((3:ℕ):ℤ) by rfl] at h2
  rw [← ZMod.intCast_eq_intCast_iff] at h2
  apply_fun (fun x ↦ (x : ZMod 3)) at h
  push_cast at h h2
  replace h2 : (m₁:ZMod 3) = 5 := by linear_combination h2
  rw [h2] at h
  reduce_mod_char at h
  generalize hz : (y : ZMod 3) = z
  fin_cases z <;> rw [hz] at h <;> simp +arith +decide at h



theorem bulgaria1998_p11
    (m n A : ℕ)
    (h : 3 * m * A = (m + 3)^n + 1) : Odd A := by
  -- Follows the second solution in _Mathematical Olympiads 1998-1999_
  -- (edited by Titu Andreescu and Zuming Feng)

  have ⟨⟨k, Hk⟩, m_eq_2_mod_3⟩ : Odd n ∧ m ≡ 2 [MOD 3] := n_odd_and_m_eq_2_mod_3 m n A h
  by_contra even_A
  rw [Nat.not_odd_iff_even] at even_A
  have zero_lt_m : 0 < m := by
    by_contra m_eq_0
    replace m_eq_0 := not_one_le_k m_eq_0
    rw [m_eq_0] at h
    ring_nf at h
    have : 1 + 3 ^ n > 0 := by positivity
    rw [← h] at this
    contradiction
  have even_m : Even m := by
    have n_ne_zero : n ≠ 0 := by lia
    replace evenA : (A : ZMod 2) = (0:ℕ) := by
      rw [Nat.even_iff] at even_A
      exact (ZMod.natCast_eq_natCast_iff' A 0 2).mpr even_A
    suffices H : (m : ZMod 2) = (0:ℕ)
    · rw [ZMod.natCast_eq_natCast_iff] at H
      exact Nat.even_iff.mpr H
    apply_fun (fun x ↦ (x : ZMod 2)) at h
    push_cast at h
    rw [evenA] at h
    simp only [Nat.cast_zero, mul_zero] at h
    generalize hm' : (m : ZMod 2) = m'
    rw [hm'] at h
    fin_cases m'
    · rfl
    · simp +arith +decide at h; reduce_mod_char at h
      rw [zero_pow n_ne_zero, zero_add] at h
      exact (zero_ne_one h).elim

  obtain ⟨l, m₁, ⟨one_le_l, odd_m₁, m_factorisation⟩⟩ :=
    two_n_and_rest_factorisation m even_m zero_lt_m
  by_cases l_eq_one : (l = 1)
  · rw [l_eq_one] at m_factorisation
    ring_nf at m_factorisation
    have : m₁ ≡ 1 [MOD 4] ∨ m₁ ≡ 3 [MOD 4] := by
      obtain ⟨a, rfl⟩ := odd_m₁
      obtain ⟨b, rfl⟩ | ⟨b, rfl⟩ := Nat.even_or_odd a
      · left
        dsimp [Nat.ModEq]
        ring_nf
        simp
      · right
        dsimp [Nat.ModEq]
        ring_nf
        simp
    have m_eq_2_mod_4 : m ≡ 2 [MOD 4] := by
      rw [m_factorisation]
      obtain left | right := this
      · nth_rw 2 [show 2 = 1 * 2 by rfl]
        exact Nat.ModEq.mul_right _ left
      · calc m₁ * 2 ≡ 3 * 2 [MOD 4] := Nat.ModEq.mul right rfl
          _ ≡ 2 [MOD 4] := rfl
    exact m_mod_2_contradiction m n A even_A m_eq_2_mod_4 h
  · have eq_2 : 0 ≡ 3^n + 1 [MOD m] := by
      calc  0 ≡ m * (3 * A) [MOD m] := by
                rw[show 0 = 0 * (3 * A) by ring]
                refine Nat.ModEq.mul_right _ ?_
                simp [Nat.ModEq]
            _ ≡ 3 * m * A [MOD m] := by rw[show m * (3 * A) = 3 * m * A by ring]
            _ ≡ (m + 3)^n + 1 [MOD m] := by rw[h]
            _ ≡ 3^n + 1 [MOD m] := by
                refine Nat.ModEq.add_right _ ?_
                exact m_add_3_pow_n_mod_m n m

    have l_eq_2 : l = 2 := by
      have two_le_l : 2 ≤ l := by lia
      obtain left | right := lt_or_eq_of_le two_le_l
      · have two_pow_l_divides_expresion : 2 ^ l ∣ (3^n + 1) := by
          have m_divides_expression : m ∣ (3 ^ n) + 1 := by
            exact (@Nat.modEq_zero_iff_dvd m (3^n + 1)).mp eq_2.symm
          dsimp[Dvd.dvd]
          obtain ⟨a, Ha⟩ := m_divides_expression
          use m₁ * a
          rw[show 2 ^ l * (m₁ * a) = (2 ^ l * m₁) * a by ring]
          rw[← m_factorisation]
          exact Ha
        have expression_eq_4_mod_8 : 3^n + 1 ≡ 4 [MOD 8] := by
          rw [←ZMod.natCast_eq_natCast_iff, Hk]
          rw [pow_succ, pow_mul]
          rw[show (3 ^ 2) = 9 by rfl]
          push_cast
          reduce_mod_char
          rw [one_pow]
          simp +arith +decide
        exfalso
        exact too_good_to_be_true
                n l (show 3 ≤ l by exact left) two_pow_l_divides_expresion expression_eq_4_mod_8
      · exact right.symm
    have m_eq_4_m₁ : m = 4 * m₁ := by
      rw[l_eq_2] at m_factorisation
      exact m_factorisation

    have m₁_divides_expresion : m₁ ∣ (3^n + 1) := by
      have m_divides_expression : m ∣ (3 ^ n) + 1 := by
        exact (@Nat.modEq_zero_iff_dvd m (3^n + 1)).mp eq_2.symm
      dsimp[Dvd.dvd]
      obtain ⟨a, Ha⟩ := m_divides_expression
      use 2 ^ l * a
      rw[show m₁ * (2 ^ l * a) = (2 ^ l * m₁) * a by ring]
      rw[← m_factorisation]
      exact Ha

    have m₁_eq_2_mod_3 : m₁ ≡ 2 [MOD 3] := by
      have step_1 : 4 * m₁ ≡ 2 [MOD 3] := by
        rw[m_eq_4_m₁] at m_eq_2_mod_3
        exact m_eq_2_mod_3
      have step_2 : 4 * m₁ ≡ m₁ [MOD 3] := by
        nth_rw 2 [show m₁ = 1 * m₁ by ring]
        exact Nat.ModEq.mul rfl rfl
      calc  m₁ ≡ 4 * m₁ [MOD 3] := step_2.symm
            _ ≡ 2 [MOD 3] := step_1
    have m₁_eq_5_mod_6 : m₁ ≡ 5 [MOD 6] := by
      mod_cases m_mod_six : m₁ % 6
      · have step_1: m₁ * 2 ≡ 0 * 2 [MOD 6]:= Nat.ModEq.mul_right 2 m_mod_six
        have step_2: m₁ * 2 ≡ 2 * 2 [MOD 3 * 2] := Nat.ModEq.mul_right' 2 m₁_eq_2_mod_3
        simp at step_1
        simp at step_2
        exfalso
        have := Nat.ModEq.trans step_2.symm step_1
        contradiction
      · have step_1: m₁ * 2 ≡ 1 * 2 [MOD 6]:= Nat.ModEq.mul_right 2 m_mod_six
        have step_2: m₁ * 2 ≡ 2 * 2 [MOD 3 * 2] := Nat.ModEq.mul_right' 2 m₁_eq_2_mod_3
        simp at step_1
        simp at step_2
        exfalso
        have := Nat.ModEq.trans step_2.symm step_1
        contradiction
      · have : m₁ ≡ 1 [MOD 2] := by
          obtain ⟨a, Ha⟩ := odd_m₁
          rw[show 1 = 0 + 1 by norm_num]
          rw[Ha]
          refine Nat.ModEq.add_right _ ?_
          simp[Nat.ModEq]
        have step_1: m₁ * 2 ≡ 2 * 2 [MOD 3 * 2] := Nat.ModEq.mul_right' 2 m₁_eq_2_mod_3
        have step_2: m₁ * 3 ≡ 1 * 3 [MOD 2 * 3] := Nat.ModEq.mul_right' 3 this
        change m₁ * 2 + m₁ ≡ 2 * 2 + 5 [MOD 2 * 3] at step_2
        exact Nat.ModEq.add_left_cancel step_1 step_2
      · have step_1: m₁ * 2 ≡ 3 * 2 [MOD 6]:= Nat.ModEq.mul_right 2 m_mod_six
        have step_2: m₁ * 2 ≡ 2 * 2 [MOD 3 * 2] := Nat.ModEq.mul_right' 2 m₁_eq_2_mod_3
        simp at step_1
        simp at step_2
        exfalso
        have := Nat.ModEq.trans step_2.symm step_1
        contradiction
      · have step_1: m₁ * 2 ≡ 4 * 2 [MOD 6]:= Nat.ModEq.mul_right 2 m_mod_six
        have step_2: m₁ * 2 ≡ 2 * 2 [MOD 3 * 2] := Nat.ModEq.mul_right' 2 m₁_eq_2_mod_3
        simp at step_1
        simp at step_2
        exfalso
        have := Nat.ModEq.trans step_2.symm step_1
        contradiction
      · exact m_mod_six

    have exists_a : ∃ a : ℕ, a = 3 ^ (k + 1) := by
      use 3 ^ (k + 1)
    obtain ⟨a, Ha⟩ := exists_a
    have m₁_divides_for_thues_lemma : m₁ ∣ a^2 + 3 := by
      apply Nat.modEq_zero_iff_dvd.mp
      have step_1:= Nat.modEq_zero_iff_dvd.mpr m₁_divides_expresion
      rw[Hk] at step_1
      have step_2: 3 * (3 ^ (2 * k + 1) + 1) ≡ 3 * 0 [MOD m₁] := Nat.ModEq.mul_left 3 step_1
      ring_nf at step_2
      rw[show 3 ^ (k * 2) * 9 = 3 ^ ((k + 1) * 2 ) by ring] at step_2
      have step_3 : 3 ^ ((k + 1) * 2) = (3 ^ (k + 1)) ^ (2) :=
        pow_mul 3 (k + 1) 2
      rw[step_3] at step_2
      rw[← Ha] at step_2
      ring_nf
      exact step_2

    have hn1 : 1 < m₁ := by
      change _ % _ = _ % _ at m₁_eq_2_mod_3
      lia
    obtain ⟨x, y, x_y_props⟩ := Thue's_lemma a m₁ hn1
    clear hn1
    obtain ⟨mod_expression, x_lower, x_higher, y_higher⟩ := x_y_props

    have lifted_m₁_result := Int.natCast_modEq_iff.mpr (Nat.modEq_zero_iff_dvd.mpr m₁_divides_for_thues_lemma)
    norm_num at lifted_m₁_result

    have expression : 3 * x ^ 2 + y ^ 2 ≡ 0 [ZMOD m₁] := by
      have step_2 : a * x ≡ -y [ZMOD m₁] := by
        rw [show -y = 0 - y by ring]
        rw [show a * x = a * x + y - y by ring]
        exact Int.ModEq.sub_right _ mod_expression

      have step_3 : a ^ 2 * x ^ 2 ≡ y ^ 2 [ZMOD m₁] := by
        rw [show a ^ 2 * x ^ 2 = (a * x) * (a * x) by ring]
        rw [show y ^ 2 = (-y) * (-y) by ring]
        exact Int.ModEq.mul step_2 step_2

      have step_4: (-3) * x ^ 2 ≡ y ^ 2 [ZMOD m₁] := by
        have step_1 : a ^ 2 ≡ -3 [ZMOD m₁] :=
          Int.ModEq.add_right_cancel' 3 lifted_m₁_result
        trans a ^ 2 * x ^ 2
        · exact Int.ModEq.mul (step_1.symm) rfl
        · exact step_3

      have : ((-3) * x ^ 2) + (3 * x ^ 2)  ≡ (y ^ 2) + (3 * x ^ 2) [ZMOD m₁] :=
        Int.ModEq.add_right _ step_4
      rw [show (-3) * x ^ 2 + (3 * x ^ 2) = 0 by ring] at this
      rw [show y ^ 2 + 3 * x ^ 2 = 3 * x ^ 2 + y ^ 2 by ring] at this
      exact this.symm

    obtain ⟨s, Hs⟩ := Int.modEq_zero_iff_dvd.mp expression
    rw [m_eq_4_m₁] at zero_lt_m
    have zero_lt_m₁ : 0 < @Nat.cast ℤ _ m₁ := by lia

    have upper_bound_s : s ≤ 4 := by
      have upper_bound_expression: 3 * x ^ 2 + y ^ 2 ≤ 4 * m₁ := by lia
      rw [Hs] at upper_bound_expression
      rw [show m₁ * s = s * m₁ by ring] at upper_bound_expression
      exact le_of_mul_le_mul_right upper_bound_expression zero_lt_m₁

    have lower_bound_s : 0 < s := by
      have lower_bound_expression : 0 < 3 * x ^ 2 + y ^ 2 := by
        have h1 : 0 < 3 * x ^ 2 := by rw [←sq_abs]; positivity
        exact Int.add_pos_of_pos_of_nonneg h1 (sq_nonneg y)
      rw[Hs] at lower_bound_expression
      rw[show (0 : ℤ) = m₁ * 0 by ring] at lower_bound_expression
      exact lt_of_mul_lt_mul_of_nonneg_left lower_bound_expression zero_lt_m₁.le

    have m₁_sub_5_mod_6 : ↑m₁ - 5 ≡ 0 [ZMOD 6] := by
      exact Int.ModEq.sub (Int.natCast_modEq_iff.mpr m₁_eq_5_mod_6) rfl

    interval_cases s
    · -- s = 1
      rw [mul_one] at Hs
      exact leaf_contradiction Hs m₁_sub_5_mod_6

    · -- s = 2
      have := Int.modEq_zero_iff_dvd.mp m₁_sub_5_mod_6
      dsimp[Dvd.dvd] at this
      obtain ⟨c, this⟩ := this
      have expr_m₁_mod_6 : ↑m₁ = 6 * c + 5 := sub_eq_iff_eq_add.mp this
      rw[expr_m₁_mod_6] at Hs
      ring_nf at Hs
      have expression_mod_4 : ((x : (ZMod 4)) ^ 2 * 3 + y ^ 2) = ((10 + c * 12) : (ZMod 4)) := by
        norm_cast
        rw[Hs]
      reduce_mod_char at expression_mod_4
      obtain left_x | right_x := square_mod_4_zmod x
      · rw[left_x] at expression_mod_4
        obtain left_y | right_y := square_mod_4_zmod y
        · rw[left_y] at expression_mod_4
          simp +arith +decide at expression_mod_4
        · rw[right_y] at expression_mod_4
          simp +arith +decide at expression_mod_4
      · rw[right_x] at expression_mod_4
        obtain left_y | right_y := square_mod_4_zmod y
        · rw[left_y] at expression_mod_4
          simp +arith +decide at expression_mod_4
        · rw[right_y] at expression_mod_4
          simp +arith +decide at expression_mod_4
    · -- s = 3
      have := Int.modEq_zero_iff_dvd.mp m₁_sub_5_mod_6
      dsimp[Dvd.dvd] at this
      obtain ⟨c, this⟩ := this
      have expr_m₁_mod_6 : ↑m₁ = 6 * c + 5 := by lia
      rw[expr_m₁_mod_6] at Hs
      ring_nf at Hs
      have expression_mod_3 :
          ((x : (ZMod 3)) ^ 2 * 3 + y ^ 2) = ((15 + c * 18) : (ZMod 3)) := by
        norm_cast
        rw[Hs]
      reduce_mod_char at expression_mod_3
      have : (y : ZMod 3) = 0 := square_mod_3_zmod_0 expression_mod_3
      have := (ZMod.intCast_zmod_eq_zero_iff_dvd y 3).mp this
      dsimp[Dvd.dvd] at this
      obtain⟨y', Hy'⟩ := this
      rw[Hy'] at Hs
      ring_nf at Hs
      rw[show x ^ 2 * 3 + y' ^ 2 * 9 = 3 * (x ^ 2 + 3 * y' ^ 2) by ring] at Hs
      rw[show 15 + c * 18 = 3 * (5 + 6 * c) by ring] at Hs
      have reduced_expression : (x ^ 2 + 3 * y' ^ 2) = (5 + 6 * c) := by
        lia

      rw[show 5 + 6 * c = 6 * c + 5 by ring] at reduced_expression
      rw[← expr_m₁_mod_6] at reduced_expression
      rw[show x ^ 2 + 3 * y' ^ 2 = 3 * y' ^ 2 + x ^ 2 by ring] at reduced_expression
      exact leaf_contradiction reduced_expression m₁_sub_5_mod_6

    · -- s = 4
      have : y^2 < m₁ := by
        by_contra! H
        have h1 : y^2 = m₁ := (Int.le_antisymm H y_higher).symm
        rw [←sq_abs, Int.abs_eq_natAbs] at h1
        norm_cast at h1
        generalize hyy : y.natAbs = yy
        rw [hyy] at h1
        rw [←h1] at m₁_eq_2_mod_3
        mod_cases Hyy : yy % 3 <;>
           change _ % _ = _ % _ at Hyy m₁_eq_2_mod_3 <;>
           simp [Nat.pow_mod, Hyy] at m₁_eq_2_mod_3
      lia


end Bulgaria1998P11

-- ═══ Bulgaria1998P3 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# Bulgarian Mathematical Olympiad 1998, Problem 3

Let ℝ⁺ be the set of positive real numbers. Prove that there does not exist a function
f: ℝ⁺ → ℝ⁺ such that

                (f(x))² ≥ f(x + y) * (f(x) + y)

for every x,y ∈ ℝ⁺.

-/

namespace Bulgaria1998P3



lemma geom_sum_bound (n : ℕ) : ∑ i ∈ Finset.range n, (1:ℝ) / (2^i) < 3 :=
  calc ∑ i ∈ Finset.range n, (1:ℝ) / ((2:ℝ)^i)
          = ∑ i ∈ Finset.range n, ((1:ℝ) / 2)^i := by {congr; simp [div_eq_mul_inv]}
        _ ≤ 2 := sum_geometric_two_le n
        _ < 3 := by norm_num



theorem bulgaria1998_p3
    (f : ℝ → ℝ)
    (hpos : ∀ x : ℝ, 0 < x → 0 < f x)
    (hf : (∀ x y : ℝ, 0 < x → 0 < y → (f (x + y)) * (f x + y) ≤ (f x)^2)) :
    False := by
  -- Follows the "second solution" of _Mathematical Olympiads 1998-1999_
  -- (edited by Titu Andreescu and Zuming Feng)

  have f_decr : ∀ x y : ℝ, 0 < x → 0 < y → f (x + y) < f x := by
    intro x y hx hy
    have h1 := hf x y hx hy
    have h2 : 0 < f x + y := add_pos (hpos x hx) hy
    have h4 : f x < f x + y := lt_add_of_pos_right (f x) hy
    have h5 : f x / (f x + y) < 1 := (div_lt_one h2).mpr h4
    calc f (x + y)
         = f (x + y) * 1                       := (mul_one (f (x + y))).symm
       _ = f (x + y) * ((f x + y) / (f x + y)) := by rw [div_self (Ne.symm (ne_of_lt h2))]
       _ = (f (x + y) * (f x + y)) / (f x + y) := mul_div_assoc' _ _ _
       _ ≤ (f x)^2 / (f x + y)                 := (div_le_div_iff_of_pos_right h2).mpr h1
       _ = (f x) * (f x / (f x + y))           := by field_simp [pow_two]
       _ < f x                                 := (mul_lt_iff_lt_one_right (hpos x hx)).mpr h5

  have f_half : ∀ x : ℝ, 0 < x → f (x + f x) ≤ f x / 2 := by
    intro x hx
    have h0 := hpos x hx
    have h1 := hf x (f x) hx h0
    have h2 : 0 < f x + f x := add_pos h0 h0
    have h3 : 0 ≠ f x + f x := ne_of_lt h2
    have h6: 2 * f x ≠ 0 := by positivity
    have h7 : (f x / (2 * f x)) = 1 / 2 := by { rw [div_eq_iff h6]; ring }
    calc f (x + f x)
         = f (x + f x) * 1                   := (mul_one _).symm
       _ = f (x + f x) * ((f x + f x) / (f x + f x)) := by rw [div_self (Ne.symm h3)]
       _ = (f (x + f x) * (f x + f x)) / (f x + f x) := mul_div_assoc' _ _ _
       _ ≤ (f x)^2 / (f x + f x)                 := (div_le_div_iff_of_pos_right h2).mpr h1
       _ = (f x) * (f x / (f x + f x))           := by field_simp [pow_two]
       _ = (f x) * (f x / (2 * f x))             := by rw [two_mul]
       _ = f x / 2                               := by field_simp [h7]

  let x_seq : ℕ → ℝ := λ n : ℕ ↦ 1 + ∑ i ∈ Finset.range n, (f 1) / (2^i)
  have hz : x_seq 0 = 1 := by
    simp only [x_seq, add_eq_left, Finset.sum_empty, Finset.range_zero]
  have hf1 := hpos 1 zero_lt_one

  have x_seq_pos : ∀ n: ℕ, 0 < x_seq n := by
    intro n
    positivity

  have f_x_seq: ∀ n : ℕ, f (x_seq n) ≤ f 1 / 2^n := by
    intro n
    induction n with
    | zero => rw [hz]; simp only [pow_zero, div_one, le_refl]
    | succ pn hpn =>
    have hpp : x_seq pn.succ = x_seq pn + f 1 / 2^pn := by
      rw [show x_seq _ = 1 + ∑ i ∈ Finset.range _, (f 1) / (2^i) by rfl]
      have : ∑ i ∈ Finset.range pn.succ, f 1 / 2 ^ i =
              f 1 / 2 ^ pn + ∑ i ∈ Finset.range pn, f 1 / 2 ^ i :=
        Finset.sum_range_succ_comm (λ (x : ℕ) ↦ f 1 / 2 ^ x) pn
      rw [this]
      ring

    have h1 : f (x_seq pn.succ) ≤ f (x_seq pn + f (x_seq pn)) := by
     rw [hpp]
     obtain heq | hlt := eq_or_lt_of_le hpn
     · rw [heq]
     · have := le_of_lt (f_decr (x_seq pn + f (x_seq pn)) (f 1 / 2 ^ pn - f (x_seq pn))
                                (add_pos (x_seq_pos pn) (hpos (x_seq pn) (x_seq_pos pn)))
                                (sub_pos.mpr hlt))
       rw [add_add_sub_cancel] at this
       exact this

    calc f (x_seq pn.succ)
         ≤ f (x_seq pn + f (x_seq pn)) := h1
       _ ≤ f (x_seq pn) / 2 := f_half (x_seq pn) (x_seq_pos pn)
       _ ≤ (f 1 / 2 ^ pn) / 2 := (div_le_div_iff_of_pos_right two_pos).mpr hpn
       _ = f 1 / 2 ^ pn.succ := by field_simp [ne_of_gt hf1]; exact pow_succ 2 pn

  have h1: ∀ n: ℕ, x_seq n < 1 + 3 * f 1 := by
    intro n
    norm_num [x_seq]
    calc ∑ i ∈ Finset.range n, f 1 / (2:ℝ) ^ i
         = (∑ i ∈ Finset.range n, 1 / (2:ℝ) ^ i) * f 1 := by rw [Finset.sum_mul]; field_simp
       _ < 3 * f 1 := (mul_lt_mul_iff_left₀ hf1).mpr (geom_sum_bound n)

  have h2 : ∀ n : ℕ, 0 < 1 + 3 * f 1 - x_seq n := by intro n; linarith [h1 n]

  have h3 : ∀ n : ℕ, f (1 + 3 * f 1) < f 1 / 2 ^ n := by
    intro n
    calc f (1 + 3 * f 1)
        = f (x_seq n + (1 + 3 * f 1 - x_seq n)) := by
             simp only [x_seq, add_sub_add_left_eq_sub, add_add_sub_cancel]
      _ < f (x_seq n) := f_decr (x_seq n) _ (x_seq_pos n) (h2 n)
      _ ≤ f 1 / 2^n := f_x_seq n

  have he : ∃n : ℕ, f 1 / 2^n < f (1 + 3 * f 1) := by
    obtain ⟨N, hN⟩ := pow_unbounded_of_one_lt (f 1 / f (1 + 3 * f 1)) one_lt_two
    use N
    have hp : 0 < f (1 + 3 * f 1) :=
      hpos (1 + 3 * f 1) (lt_trans (x_seq_pos 0) (h1 0))

    have h2N : (0:ℝ) < 2^N := pow_pos two_pos N
    exact (div_lt_iff₀ h2N).mpr ((div_lt_iff₀' hp).mp hN)

  obtain ⟨N, hN⟩ := he
  exact lt_irrefl _ (lt_trans (h3 N) hN)


end Bulgaria1998P3

-- ═══ Bulgaria1998P8 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# Bulgarian Mathematical Olympiad 1998, Problem 8
The polynomials Pₙ(x,y) for n = 1, 2, ... are defined by P₁(x,y) = 1 and
  Pₙ₊₁(x,y) = (x + y - 1)(y + 1)Pₙ(x,y+2) + (y - y²)Pₙ(x,y)
Prove that Pₙ(x,y) = Pₙ(y,x) for all x,y,n.
-/

namespace Bulgaria1998P8

variable {R : Type} [CommRing R]

def P : ℕ → R → R → R
| 0, _, _ => 1
| n+1, x, y => (x + y - 1) * (y + 1) * P n x (y + 2) + (y - y^2) * P n x y



/- helper function
   Sₙ₋₁(x,y) = [(x + y)² - 1](y + 1)(x + 1)Pₙ₋₁(y+2, x+2).
-/
def S : ℕ → R → R → R
| n, x, y => ((x + y)^2 - 1) * (y + 1) * (x + 1) * P n (y + 2) (x + 2)

/- helper function
   Tₙ₋₁(x,y) = (y - y²)(x - x²)Pₙ₋₁(y, x).
-/
def T : ℕ → R → R → R
| n, x, y => (y - y^2) * (x - x^2) * P n y x

/- helper function
   Uₙ₋₁(x,y) = (x + y - 1) [(y + 1)(x - x²)Pₙ₋₁(y + 2, x)
                           + (x + 1)(y - y²) Pₙ₋₁(y, x + 2)]
-/
def U : ℕ → R → R → R
| n, x, y => (x + y - 1) *((y + 1)*(x - x^2) * P n (y + 2) x
                           + (x + 1) * (y - y^2) * P n y (x + 2))



theorem bulgaria1998_p8 (n : ℕ) (x y : R) : P n x y = P n y x := by
  -- Follows the proof in _Mathematical Olympiads 1998-1999_
  -- by Titu Andreescu and Zuming Feng

  -- We induct on n. For n = 1,2 the result is evident.
  -- So we take n > 1 and suppose that the result is true for
  -- Pₙ₋₁(x,y) and Pₙ₋₂(x,y).
  revert x y
  induction n using Nat.strong_induction_on with | h n ih =>
  cases n with | zero => intros; rfl | succ n =>
  cases n with | zero => intros; dsimp only [P]; ring | succ n =>

  -- in the informal proof at this point, we're trying to
  -- prove the end result at n+1.
  -- In our formal version, that corresponds to proving the result for
  -- n.succ.succ

  /- We have
     Pₙ₊₁(x,y) = (x + y - 1)(y + 1)Pₙ(x,y+2) + (y - y²)Pₙ(x,y)
               = (x + y - 1)(y + 1)Pₙ(y+2,x) + (y - y²)Pₙ(y,x)
  -/

  have ih1 := ih n.succ (lt_add_one n.succ)
  have h1 : ∀ x y : R, P n.succ.succ x y =
               (x + y - 1) * (y + 1) * (P n.succ (y + 2) x) +
                   (y - y^2) * (P n.succ y x) := by
    intro x y
    calc P (n.succ.succ) x y
        = (x + y - 1) * (y + 1) * (P n.succ x (y + 2)) +
          (y - y^2) * (P n.succ x y) := rfl
      _ = (x + y - 1) * (y + 1) * (P n.succ (y + 2) x) +
          (y - y^2) * (P n.succ y x) := by rw [ih1 x y, ih1 x (y+2)]

  have h2 : ∀ x y : R, (x + y - 1) * (y + 1) * P n.succ (y + 2) x
        = S n x y + (x + y - 1)* (y + 1) * (x - x^2)* P n (y+2) x := by
     intro x y; dsimp only [S, P]; ring

  have h_s_symm : ∀ m : ℕ, m < n.succ.succ → ∀ x y : R, S m x y = S m y x := by
    intro m hm x y; dsimp only [S]; rw [ih m hm (x + 2) (y + 2)]; ring

  have h4 : ∀ x y : R, (y - y^2) * P n.succ y x =
              (y - y^2) * (x + y -1) * (x + 1) * P n y (x + 2) + T n x y := by
    intro x y; dsimp only [T, P]; ring

  have h_t_symm : ∀ m : ℕ, m < n.succ.succ → ∀ x y : R, T m x y = T m y x := by
    intro m hm x y; dsimp only[T]; rw [ih m hm x y]; ring

  have h_u_symm : ∀ m : ℕ, m < n.succ.succ → ∀ x y : R, U m x y = U m y x := by
    intro m hm x y; dsimp only [U]; rw [ih m hm (y+2) x, ih m hm (x+2) y]; ring

  have h7 : ∀ x y : R, P n.succ.succ x y = S n x y + T n x y + U n x y := by
    intro x y; rw [h1 x y, h2 x y, h4 x y]; dsimp only [U]; ring

  have h8 : n < n.succ := lt_add_one n
  have h9 : n < n.succ.succ := Nat.lt_succ_of_lt h8

  intro x y
  calc P n.succ.succ x y
      = S n x y + T n x y + U n x y := h7 x y
    _ = S n y x + T n x y + U n x y := by rw [h_s_symm n h9 x y]
    _ = S n y x + T n y x + U n x y := by rw [h_t_symm n h9 x y]
    _ = S n y x + T n y x + U n y x := by rw [h_u_symm n h9 x y]
    _ = P n.succ.succ y x := (h7 y x).symm


end Bulgaria1998P8

-- ═══ Canada1998P3 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
Canadian Mathematical Olympiad 1998, Problem 3

Let n be a natural number such that n ≥ 2. Show that

  (1/(n + 1))(1 + 1/3 + ... + 1/(2n - 1)) > (1/n)(1/2 + 1/4 + ... + 1/2n).
-/

namespace Canada1998P3

theorem canada1998_p3 (n : ℕ) (hn : 2 ≤ n) :
    (1/(n:ℝ)) * ∑ i ∈ Finset.range n, (1/(2 * (i:ℝ) + 2)) <
    (1/((n:ℝ) + 1)) * ∑ i ∈ Finset.range n, (1/(2 * (i:ℝ) + 1)) := by
  -- Follows the proof in _Mathematical Olympiads 1998-1999_
  -- by Titu Andreescu and Zuming Feng

  cases n with | zero => norm_num at hn | succ n =>
  cases n with | zero => norm_num at hn | succ n =>

  revert hn
  intro h2; clear h2

  -- We prove
  -- (n + 1)(1/2 + 1/4 + ... + 1/2n) < n(1 + 1/3 + ... + 1/(2n - 1))
  -- by induction.
  suffices
   ((n.succ.succ:ℝ) + 1) * ∑ i ∈ Finset.range n.succ.succ, (1/(2 * (i:ℝ) + 2)) <
   (n.succ.succ:ℝ) * ∑ i ∈ Finset.range n.succ.succ, (1/(2 * (i:ℝ) + 1))
      by rw [div_mul_eq_mul_div₀, one_mul, div_mul_eq_mul_div₀, one_mul]
         apply (div_lt_div_iff₀ (by positivity) (by positivity)).mpr
         linarith

  induction n with
  | zero =>
     -- Base case: when n = 2, we have 8/3 > 9/4.
     norm_num
  | succ m ih =>
    let k := m.succ.succ

    -- Inductive case: suppose claim is true for k ≥ 2. Then we have
    -- k (1 + 1/3 + ... 1/(2k - 1)) > (k + 1)(1/2 + 1/4 + ... + 1/2k).
    -- Note that
    --  (1 + 1/3 + ... + 1/(2k-1)) + (k+1)/(2k+1)
    --    = (1/2 + 1/3 + ... + 1/(2k-1)) + 1/2 + (k+1)/(2k+1)
    --    > (1/2 + 1/4 + ... + 1/2k) + 1/2 + (k+1)/(2k+1)
    --    > (1/2 + 1/4 + ... + 1/2k) + (k + 1)/(2k + 2) + 1/(2k+1)
    --    > (1/2 + 1/4 + ... + 1/2k) + (k + 2)/(2k + 2).

    have h1 : (1:ℝ) / (2 * ↑(0:ℕ) + 1) = 1 := by norm_num

    have h2 : ∀ k' ∈ Finset.range (m + 1), (1:ℝ) / (2 * ↑(k' + 1) + 1 + 1) <
                                           (1:ℝ) / (2 * ↑(k' + 1) + 1) := by
      intro k' _
      apply div_lt_div_of_pos_left zero_lt_one
      · positivity
      · exact lt_add_one _

    have h3 : (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1)) + (k+1)/(2 * k + 1)
            = _ := rfl

    nth_rewrite 1 [Finset.sum_range_succ'] at h3
    rw [h1, add_assoc] at h3

    have h4 : Finset.Nonempty (Finset.range (m + 1)) := Finset.nonempty_range_add_one
    have h5 := Finset.sum_lt_sum_of_nonempty h4 h2
    norm_cast at h5

    have h6 : (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) = _ := rfl
    nth_rewrite 1 [Finset.sum_range_succ'] at h6

    have h7' : (2:ℝ) * (k:ℝ) ≥ 4 := by
      have hh2' : k ≥ 2 := Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le m))
      have hh2 : (k:ℝ) ≥ 2 := by exact_mod_cast hh2'
      calc
        (2:ℝ) * (k:ℝ) ≥ (2:ℝ) * 2 := mul_le_mul_of_nonneg_left hh2 zero_le_two
        _ = 4 := by norm_num

    have h7 : 1 / (2 * (k:ℝ) + 2) < 1 / 2 := by apply div_lt_div₀' <;> linarith
    have h8 : ((k:ℝ)+1)/(2 * (k:ℝ) + 2) < ((k:ℝ)+1)/(2 * (k:ℝ) + 1) :=
      by apply div_lt_div₀' <;> linarith

    have h9 :=
           --  (1 + 1/3 + ... + 1/(2k-1)) + (k+1)/(2k+1)
      calc (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1)) + (k+1)/(2 * k + 1)

      --    = (1/3 + ... + 1/(2k-1)) + (1 + (k+1)/(2k+1))
         = (∑i ∈ Finset.range (m+1), 1 / (2 * ((i + 1):ℝ) + 1))
               + (1 + (k+1)/(2 * k + 1)) := by rw [←h3]; norm_cast
                                        -- TODO shouldn't need casting?

       --    > (1/4 + ... + 1/2k) + (1 + (k+1)/(2k+1))
       _ > (∑i ∈ Finset.range (m+1), 1 / (2 * ((i + 1):ℝ) + 1 + 1))
              + (1 + (k+1)/(2 * k + 1)) := by norm_cast; linarith

       _ = (∑i ∈ Finset.range (m+1), 1 / (2 * ((i + 1):ℝ) + 1 + 1))
              + (1/2 + 1/2 + (k+1)/(2 * k + 1)) := by ring
       _ = (∑i ∈ Finset.range (m+1), 1 / (2 * ((i + 1):ℝ) + 1 + 1))
              + 1/2 + (1/2 + (k+1)/(2 * k + 1)) := by ring
       _ = (∑i ∈ Finset.range (m+1), 1 / (2 * ((i + 1):ℝ) + 1 + 1))
              + 1/(2 *(((0:ℕ)):ℝ) + 1 + 1) + (1/2 + (k+1)/(2 * k + 1)) :=
                      by norm_num
       _ = (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) +
              (1/2 + (k+1)/(2 * k + 1)) := by rw [←h6]; norm_cast

       --    > (1/2 + 1/4 + ... + 1/2k) + (k + 1)/(2k + 2) + 1/(2k+1)
       _ > (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) +
              ((k+1)/(2 * k + 2) + 1/(2 * k + 2)) := by linarith

       --    = (1/2 + 1/4 + ... + 1/2k) + (k + 2)/(2k + 2).
       _ = (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) +
              (k+2)/(2 * k + 2) := by field

   --
   -- Then we are done because
   -- (k + 1)(1 + 1/3 + ... + 1/(2k - 1) + 1/(2k + 1))
   --  = k (1 + 1/3 + ... + 1/(2k - 1))
   --     + (1 + 1/3 + ... + 1/(2k - 1)) + (k + 1)/(2k + 1)
   --  > k (1 + 1/3 + ... + 1/(2k - 1))
   --     + (1/2 + 1/4 + ... + 1/2k)) + (k + 2)/(2k + 2)
   --    (by h9, proved above)

   --  > (k + 2)(1/2 + 1/4 + ... + 1/(2k + 2)).

    have :=
      calc (k + 1) * (∑i ∈ Finset.range k.succ, 1 / (2 * (i:ℝ) + 1))
         = k * (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1)) +
             ((∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1)) +
                (k + 1) / (2 * k + 1)) := by
                   rw [Finset.sum_range_succ]; ring
       _ > k * (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1)) +
             ((∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) +
                (k + 2) / (2 * k + 2)) := add_lt_add_right h9 _
       _ > (k + 1) * (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 2)) +
             ((∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 1 + 1)) +
                (k + 2) / (2 * k + 2)) := add_lt_add_left ih _
       _ = (k + 1) * (∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 2)) +
             ((∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 2)) +
                (k + 2) / (2 * k + 2)) := by
             congr; funext x; rw [add_assoc, show (1:ℝ) + 1 = 2 by norm_num]
       _ = (k + 2) * ((∑i ∈ Finset.range k, 1 / (2 * (i:ℝ) + 2)) +
                1 / (2 * k + 2)) := by ring
       _ = (k + 2) * (∑i ∈ Finset.range k.succ, 1 / (2 * (i:ℝ) + 2))
                 := by rw [←Finset.sum_range_succ]
    norm_cast at this
    norm_cast


end Canada1998P3

-- ═══ Egmo2023P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ansar Azharov
-/





/-!
# European Girls' Mathematical Olympiad 2023, Problem 1

There are n ≥ 3 positive real numbers a_1, a_2, . . . , a_n. For each 1 ≤ i ≤ n we let
b_i = (a_(i-1) + a_(i+1)) / a_i (here we define a_0 to be a_n and a_(n+1) to be a_1).
Assume that for all i and j in the range 1 to n, we have a_i ≤ a_j if and only if b_i ≤ b_j.
Prove that a_1 = a_2 = ... = a_n.
-/

namespace Egmo2023P1

theorem egmo2023_p1 (n : ℕ) [NeZero n] (_ : n ≥ 3) (a : Fin n → ℝ) (ha : ∀ i, a i > 0)
    (b : Fin n → ℝ) (hb : ∀ i, b i = (a (i - 1) + a (i + 1)) / (a i))
    (h : ∀ i j, a i ≤ a j ↔ b i ≤ b j) : ∀ i j, a i = a j := by
  -- The solution was adapted from here: https://www.youtube.com/watch?v=PNFh789P31E.
  -- Note that indexing starts from 0 in the formalized statement.
  obtain ⟨m, hm⟩ := Finite.exists_min a
  obtain ⟨M, hM⟩ := Finite.exists_max a
  have h1 : b m ≥ 2 := calc b m
    _ ≥ (a m + a m) / (a m) := by
      rw [hb m]
      gcongr
      · exact le_of_lt (ha m)
      · exact hm (m - 1)
      · exact hm (m + 1)
    _ ≥ 2 := by
      rw [← two_mul, mul_div_cancel_right₀]
      positivity [ha m]
  have h2 : b M ≤ 2 := calc b M
    _ ≤ (a M + a M) / (a M) := by
      rw [hb M]
      gcongr
      · exact le_of_lt (ha M)
      · exact hM (M - 1)
      · exact hM (M + 1)
    _ ≤ 2 := by
      rw [← two_mul, mul_div_cancel_right₀]
      positivity [ha M]
  have h3 : ∀ i, b i = 2 := by
    intro i
    apply eq_of_le_of_ge
    · exact le_trans ((h i M).mp (hM i)) h2
    · exact le_trans h1 ((h m i).mp (hm i))
  intro i j
  apply eq_of_le_of_ge
  · rw [h i j, h3 i, h3 j]
  · rw [h j i, h3 j, h3 i]

end Egmo2023P1

-- ═══ Hungary1998P6 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# Hungarian Mathematical Olympiad 1998, Problem 6

Let x, y, z be integers with z > 1. Show that

 (x + 1)² + (x + 2)² + ... + (x + 99)² ≠ yᶻ.
-/

namespace Hungary1998P6



lemma sum_range_square_mul_six (n : ℕ) :
    (∑i ∈ Finset.range n, (i + 1)^2) * 6 = n * (n + 1) * (2 * n + 1) := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [Finset.sum_range_succ, add_mul, ih]
    ring

lemma sum_range_square (n : ℕ) :
    ∑i ∈ Finset.range n, (i + 1)^2 = n * (n + 1) * (2 * n + 1)/6 :=
  by rw [← sum_range_square_mul_six n, Nat.mul_div_cancel]
     norm_num

lemma cast_sum_square (n : ℕ) :
  ∑i ∈ Finset.range n, ((i:ℤ)+1)^2 =
   (((∑i ∈ Finset.range n, (i+1)^2) : ℕ) : ℤ) := by norm_cast



theorem hungary1998_p6 (x y : ℤ) (z : ℕ) (hz : 1 < z) :
    ∑ i ∈ Finset.range 99, (x + i + 1)^2 ≠ y^z := by
  -- Follows the proof in _Mathematical Olympiads 1998-1999_
  -- by Titu Andreescu and Zuming Feng.

  -- Suppose (x + 1)² + (x + 2)² + ... + (x + 99)² = yᶻ.

  intro he

  -- We notice that
  -- y^z = (x + 1)² + (x + 2)² + ... + (x + 99)²
  --     = 99x² + 2(1 + 2 + ... + 99)x + (1² + 2² + ... + 99²)
  --     = 99x² + 2[(99 ⬝ 100)/2]x + (99 ⬝ 100 ⬝ 199)/6
  --     = 33(3x² + 300x + 50 ⬝ 199).

  have h2 : ∑ i ∈ Finset.range 99, x^2 = 99 * x^2 := by norm_num

  have h4 : ∑ i ∈ Finset.range 99, ((i:ℤ) + 1) =
          ∑ i ∈ Finset.range 100, (i:ℤ) := by
    rw [Finset.sum_range_succ']
    simp [Finset.sum_range_succ]

  have h5 : ∑ i ∈ Finset.range 100, (i:ℤ) = 99 * 100 / 2 := by
    rw [←Nat.cast_sum, Finset.sum_range_id]; decide

  have h6 : ∑ i ∈ Finset.range 99, ((i:ℤ) + 1)^2 = (99 * 100 * 199)/6 := by
    rw [cast_sum_square, sum_range_square]; decide

  have hnn1 : (99:ℤ) * 100 / 2 = 99 * 50 := by decide
  have hnn2 : ((99:ℤ) * 100 * 199)/6 = 33 * 50 * 199 := by decide

  have h7 := calc y^z
      = ∑ i ∈ Finset.range 99, ((x + i) + 1)^2 := he.symm
    _ = ∑ i ∈ Finset.range 99,
          (x^2 + 2 * x * ((i:ℤ) + 1) + ((i:ℤ) + 1)^2) :=
               by with_reducible congr; funext; ring
    _ = ∑ i ∈ Finset.range 99, (x^2 + 2 * x * ((i:ℤ) + 1)) +
         ∑ i ∈ Finset.range 99, ((i:ℤ) + 1)^2 := Finset.sum_add_distrib
    _ = ∑ i ∈ Finset.range 99, x^2 +
          ∑ i ∈ Finset.range 99, (2 * x * ((i:ℤ) + 1)) +
         ∑ i ∈ Finset.range 99, (((i:ℤ) + 1)^2) := by rw [Finset.sum_add_distrib]
    _ = 99 * x^2 + 2 * x * (99 * 100 / 2) + (99 * 100 * 199)/6
        := by rw [h2, ←Finset.mul_sum, h4, h5, h6]
    _ = 3 * (11 * (3 * x^2 + 300 * x + 50 * 199)) := by rw [hnn1, hnn2]; ring

  -- which implies that 3∣y.
  have h8 : 3 ∣ y^z := Dvd.intro _ (Eq.symm h7)
  have h9 : 3 ∣ y := Prime.dvd_of_dvd_pow Int.prime_three h8

  obtain ⟨k, hk⟩ := h9
  rw [hk] at h7

  cases z with | zero => exact Nat.not_lt_zero 1 hz | succ z =>
  cases z with | zero => exact Nat.lt_asymm hz hz | succ z =>
  rw [pow_succ, pow_succ] at h7

  -- Since z ≥ 2, 3²∣yᶻ, but 3² does not divide
  -- 33(3x² + 300x + 50 ⬝ 199), contradiction.
  lia


end Hungary1998P6

-- ═══ Imo1959P1 ═══

/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/




/-!
# International Mathematical Olympiad 1959, Problem 1.

Prove that the fraction `(21n+4)/(14n+3)` is irreducible for every
natural number `n`.
-/

namespace Imo1959P1



lemma calculation
    (n k : ℕ)
    (h1 : k ∣ 21 * n + 4)
    (h2 : k ∣ 14 * n + 3) :
    k ∣ 1 := by
  have h3 : k ∣ 2 * (21 * n + 4) := h1.mul_left 2
  have h4 : k ∣ 3 * (14 * n + 3) := h2.mul_left 3
  have h5 : 3 * (14 * n + 3) = 2 * (21 * n + 4) + 1 := by ring
  exact (Nat.dvd_add_right h3).mp (h5 ▸ h4)



/-
Since Lean doesn't have a concept of "irreducible fractions" per se,
we just formalize this as saying the numerator and denominator are
relatively prime.
-/
theorem imo1959_p1 : ∀ n : ℕ, Nat.Coprime (21 * n + 4) (14 * n + 3) :=
fun n => Nat.coprime_of_dvd' <| λ k _ h1 h2 => calculation n k h1 h2


end Imo1959P1

-- ═══ Imo1961P3 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/





/-!
# International Mathematical Olympiad 1961, Problem 3

Solve the equation

  cosⁿ x - sinⁿ x = 1,

where n is a given positive integer.
-/

namespace Imo1961P3

open Real

noncomputable def solutionSet (n : ℕ+) : Set ℝ :=
 { x | (∃ k : ℤ, k * π = x) ∧ Even n.val ∨ (∃ k : ℤ, k * (2 * π) = x) ∧ Odd n.val ∨
          (∃ k : ℤ, -(π / 2) + k * (2 * π) = x) ∧ Odd n.val }

theorem imo1961_p3 {n : ℕ} {x : ℝ} (npos : 0 < n) :
    x ∈ solutionSet ⟨n, npos⟩ ↔
    (cos x) ^ n - (sin x) ^ n = 1 := by
  -- This solution is based on
  -- https://artofproblemsolving.com/wiki/index.php/1961_IMO_Problems/Problem_3
  have h₀ : n ≠ 0 := Nat.ne_zero_of_lt npos
  constructor
  · rintro (⟨⟨k, rfl⟩, hn⟩ | ⟨⟨k, rfl⟩, -⟩ | ⟨⟨k, rfl⟩, hn⟩)
    · dsimp at hn
      rw [sin_int_mul_pi, zero_pow h₀, sub_zero, ← hn.pow_abs, abs_cos_int_mul_pi, one_pow]
    · have : sin (k * (2 * π)) = 0 := by simpa [mul_assoc] using sin_int_mul_pi (k * 2)
      simp [h₀, this]
    · dsimp at hn; simp [hn.neg_pow, h₀]
  · intro h
    rcases eq_or_ne (sin x) 0 with hsinx | hsinx
    · rw [hsinx, zero_pow h₀, sub_zero, pow_eq_one_iff_of_ne_zero h₀, cos_eq_one_iff,
        cos_eq_neg_one_iff] at h
      rcases h with ⟨k, rfl⟩ | ⟨⟨k, rfl⟩, hn⟩
      · cases n.even_or_odd with
        | inl hn => refine .inl ⟨⟨k * 2, ?_⟩, hn⟩; simp [mul_assoc]
        | inr hn => exact .inr <| .inl ⟨⟨_, rfl⟩, hn⟩
      · exact .inl ⟨⟨2 * k + 1, by push_cast; ring⟩, hn⟩
    · rcases eq_or_ne (cos x) 0 with hcosx | hcosx
      · right; right
        rw [hcosx, zero_pow h₀, zero_sub, ← neg_inj, neg_neg, pow_eq_neg_one_iff,
          sin_eq_neg_one_iff] at h
        exact h
      · have hcos1 : |cos x| < 1 := by
          rw [abs_cos_eq_sqrt_one_sub_sin_sq, sqrt_lt' one_pos]
          simp [sq_pos_of_ne_zero hsinx]
        have hsin1 : |sin x| < 1 := by
          rw [abs_sin_eq_sqrt_one_sub_cos_sq, sqrt_lt' one_pos]
          simp [sq_pos_of_ne_zero hcosx]
        match n with
        | 1 =>
          rw [pow_one, pow_one, sub_eq_iff_eq_add] at h
          have : 2 * sin x * cos x = 0 := by
            simpa [h, add_sq, add_assoc, ← two_mul, mul_add, mul_assoc, ← sq]
              using cos_sq_add_sin_sq x
          simp [hsinx, hcosx] at this
        | 2 =>
          rw [← cos_sq_add_sin_sq x, sub_eq_add_neg, add_right_inj, CharZero.neg_eq_self_iff] at h
          exact absurd (eq_zero_of_pow_eq_zero h) hsinx
        | (n + 1 + 2) =>
          set m := n + 1
          refine absurd ?_ h.not_lt
          calc
            (cos x) ^ (m + 2) - (sin x) ^ (m + 2) ≤ |cos x| ^ (m + 2) + |sin x| ^ (m + 2) := by
              simp only [← abs_pow, sub_eq_add_neg]
              gcongr
              exacts [le_abs_self _, neg_le_abs _]
            _ = |cos x| ^ m * cos x ^ 2 + |sin x| ^ m * sin x ^ 2 := by simp [pow_add]
            _ < 1 ^ m * cos x ^ 2 + 1 ^ m * sin x ^ 2 := by gcongr
            _ = 1 := by simp

end Imo1961P3

-- ═══ Imo1962P1 ═══

/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/




/-!
# International Mathematical Olympiad 1962, Problem 1

Find the smallest natural number $n$ which has the following properties:

(a) Its decimal representation has 6 as the last digit.

(b) If the last digit 6 is erased and placed in front of the remaining digits,
the resulting number is four times as large as the original number $n$.
-/


namespace Imo1962P1

open Nat

def ProblemPredicate (n : ℕ) : Prop :=
  (digits 10 n).headI = 6 ∧ ofDigits 10 ((digits 10 n).tail.concat 6) = 4 * n


/-!
First, it's inconvenient to work with digits, so let's simplify them out of the problem.
-/

abbrev ProblemPredicate' (c n : ℕ) : Prop :=
  n = 10 * c + 6 ∧ 6 * 10 ^ (digits 10 c).length + c = 4 * n

theorem without_digits {n : ℕ} (h1 : ProblemPredicate n) : ∃ c : ℕ, ProblemPredicate' c n := by
  use n / 10
  cases n with
  | zero => have h2 : ¬ProblemPredicate 0 := by norm_num [ProblemPredicate]
            contradiction
  | succ n =>
    rw [ProblemPredicate, digits_def' (by decide : 2 ≤ 10) n.succ_pos, List.headI, List.tail_cons,
        List.concat_eq_append] at h1
    constructor
    · rw [← h1.left, div_add_mod (n + 1) 10]
    · rw [← h1.right, ofDigits_append, ofDigits_digits, ofDigits_singleton, add_comm, mul_comm]

/-!
Now we can eliminate possibilities for `(digits 10 c).length` until we get to the one that works.
-/


theorem case_0_digit {c n : ℕ} (h1 : (digits 10 c).length = 0) : ¬ProblemPredicate' c n := by
  intro h2
  have h3 : 6 * 10 ^ 0 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

theorem case_1_digit {c n : ℕ} (h1 : (digits 10 c).length = 1) : ¬ProblemPredicate' c n := by
  intro h2
  have h3 : 6 * 10 ^ 1 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

theorem case_2_digit {c n : ℕ} (h1 : (digits 10 c).length = 2) : ¬ProblemPredicate' c n := by
  intro h2
  have h3 : 6 * 10 ^ 2 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

theorem case_3_digit {c n : ℕ} (h1 : (digits 10 c).length = 3) : ¬ProblemPredicate' c n := by
  intro h2
  have h3 : 6 * 10 ^ 3 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

theorem case_4_digit {c n : ℕ} (h1 : (digits 10 c).length = 4) : ¬ProblemPredicate' c n := by
  intro h2
  have h3 : 6 * 10 ^ 4 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

/-- Putting this inline causes a deep recursion error, so we separate it out. -/
theorem helper_5_digit {c : ℤ} (h : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)) : c = 15384 := by linarith

theorem case_5_digit {c n : ℕ} (h1 : (digits 10 c).length = 5) (h2 : ProblemPredicate' c n) :
    c = 15384 := by
  have h3 : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [h1]
  lia

/-- `linarith` fails on numbers this large, so this lemma spells out some of the arithmetic
that normally would be automated.
-/
theorem case_more_digits {c n : ℕ} (h1 : (digits 10 c).length ≥ 6) (h2 : ProblemPredicate' c n) :
    n ≥ 153846 := by
  have h3 : c ≠ 0 := by
    intro h4
    have h5 : (digits 10 c).length = 0 := by simp [h4]
    exact case_0_digit h5 h2
  calc
    n ≥ 10 * c := le.intro h2.left.symm
    _ ≥ 10 ^ (digits 10 c).length := (base_pow_length_digits_le 10 c (by decide) h3)
    _ ≥ 10 ^ 6 := pow_le_pow_right₀ (by decide) h1
    _ ≥ 153846 := by norm_num

/-!
Now we combine these cases to show that 153846 is the smallest solution.
-/

theorem satisfied_by_153846 : ProblemPredicate 153846 := by
  norm_num [ProblemPredicate]
  decide

theorem no_smaller_solutions (n : ℕ) (h1 : ProblemPredicate n) : n ≥ 153846 := by
  have ⟨c, h2⟩ := without_digits h1
  have h3 : (digits 10 c).length < 6 ∨ (digits 10 c).length ≥ 6 := by apply lt_or_ge
  cases h3 with
  | inr h3 => exact case_more_digits h3 h2
  | inl h3 =>
    interval_cases h : (digits 10 c).length
    · exfalso; exact case_0_digit h h2
    · exfalso; exact case_1_digit h h2
    · exfalso; exact case_2_digit h h2
    · exfalso; exact case_3_digit h h2
    · exfalso; exact case_4_digit h h2
    · have h4 : c = 15384 := case_5_digit h h2
      have h5 : n = 10 * 15384 + 6 := h4 ▸ h2.left
      exact Nat.le_of_eq h5.symm



noncomputable def solution : ℕ := 153846

theorem imo1962_p1 : IsLeast {n | ProblemPredicate n} solution :=
  ⟨satisfied_by_153846, no_smaller_solutions⟩



end Imo1962P1

-- ═══ Imo1962P4 ═══

/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker, Heather Macbeth
-/




/-!
# International Mathematics Olympiad 1962, Problem 4

Solve the equation
     cos² x + cos² (2 * x) + cos² (3 * x) = 1.
-/

open Real

namespace Imo1962P4

def ProblemEquation (x : ℝ) : Prop :=
  cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 = 1

noncomputable def solutionSet : Set ℝ :=
  {x : ℝ | ∃ k : ℤ, x = (2 * ↑k + 1) * π / 4 ∨ x = (2 * ↑k + 1) * π / 6}



noncomputable section

/-
The key to solving this problem simply is that we can rewrite the equation as
a product of terms, shown in `alt_formula`, being equal to zero.
-/
def altFormula (x : ℝ) : ℝ :=
  cos x * (cos x ^ 2 - 1 / 2) * cos (3 * x)

theorem cos_sum_equiv {x : ℝ} :
    (cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 - 1) / 4 = altFormula x := by
  simp only [Real.cos_two_mul, cos_three_mul, altFormula]
  ring

theorem alt_equiv {x : ℝ} : ProblemEquation x ↔ altFormula x = 0 := by
  rw [ProblemEquation, ← cos_sum_equiv, div_eq_zero_iff, sub_eq_zero]
  norm_num

theorem finding_zeros {x : ℝ} : altFormula x = 0 ↔ cos x ^ 2 = 1 / 2 ∨ cos (3 * x) = 0 := by
  simp only [altFormula, mul_assoc, mul_eq_zero, sub_eq_zero]
  constructor
  · rintro (h1 | h2)
    · right
      rw [cos_three_mul, h1]
      ring
    · exact h2
  · exact Or.inr

/-
Now we can solve for `x` using basic-ish trigonometry.
-/
theorem solve_cos2_half {x : ℝ} : cos x ^ 2 = 1 / 2 ↔ ∃ k : ℤ, x = (2 * ↑k + 1) * π / 4 := by
  rw [cos_sq]
  simp only [add_eq_left, div_eq_zero_iff]
  norm_num
  rw [cos_eq_zero_iff]
  constructor <;>
    · rintro ⟨k, h⟩
      use k
      linarith

theorem solve_cos3x_0 {x : ℝ} : cos (3 * x) = 0 ↔ ∃ k : ℤ, x = (2 * ↑k + 1) * π / 6 := by
  rw [cos_eq_zero_iff]
  refine exists_congr fun k => ?_
  constructor <;> intro <;> linarith

end

/-
The final theorem is now just gluing together our lemmas.
-/



theorem imo1962_p4 {x : ℝ} : ProblemEquation x ↔ x ∈ solutionSet := by
  rw [alt_equiv, finding_zeros, solve_cos3x_0, solve_cos2_half]
  exact exists_or.symm


end Imo1962P4

-- ═══ Imo1963P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# International Mathematical Olympiad 1963, Problem 1

Find all real roots of the equation

  √(x²-p) + 2√(x²-1) = x

where *p* is a real parameter.
-/

namespace Imo1963P1



lemma iff_comm {a b c : Prop} : (a → c) → (b → c) → (c → (a ↔ b)) → (a ↔ b) := by
  grind



noncomputable def f (p : ℝ) : Set ℝ :=
  if p ≥ 0 ∧ p ≤ (4 : ℝ) / 3
  then { (4 - p) / (2 * Real.sqrt (4 - 2 * p)) }
  else ∅

theorem imo1963_p1 : ∀ (p x : ℝ), (x ^ 2 - p) ≥ 0 → (x ^ 2 - 1) ≥ 0 →
  (Real.sqrt (x ^ 2 - p) + 2 * Real.sqrt (x ^ 2 - 1) = x ↔ (x ∈ f p)) := by
  intro p x h1 h2
  simp only [f, ge_iff_le, Set.mem_ite_empty_right, Set.mem_singleton_iff]
  apply @iff_comm (c := x ≥ 0)
  · intro h; rw [←h]; positivity
  · rintro ⟨⟨-, hx12⟩, rfl⟩
    apply le_of_lt
    apply div_pos_iff.mpr
    left
    constructor
    · linarith
    · simp only [Nat.ofNat_pos, mul_pos_iff_of_pos_left, Real.sqrt_pos]
      linarith
  intro xge0
  trans (Real.sqrt (x ^ 2 - p) + 2 * Real.sqrt (x ^ 2 - 1)) ^ 2 = x ^ 2
  · refine Iff.symm (sq_eq_sq₀ ?ha ?hb) <;> positivity
  rw [add_sq]
  rw [Real.sq_sqrt h1]
  rw [mul_pow]
  rw [Real.sq_sqrt h2]
  trans Real.sqrt (x ^ 2 - p) * Real.sqrt (x ^ 2 - 1) = (p + 4 - 4 * x ^ 2) / (4 : ℝ)
  · constructor
    · intro h; linear_combination (1 / (4 : ℝ)) * h
    · intro h; linear_combination (4 : ℝ) * h
  apply @iff_comm (c := p + 4 - 4 * x ^ 2 ≥ 0)
  · intro h; rw [ge_iff_le]
    apply (div_le_div_iff_of_pos_right (by norm_num : (0 : ℝ) < (4 : ℝ))).mp
    norm_num; rw [←h]; positivity
  · rintro ⟨hx, rfl⟩
    have tmp : 0 < (4 - 2 * p) := by linarith only [hx]
    rw [div_pow, mul_pow, Real.sq_sqrt (le_of_lt tmp)]; norm_num
    rw [←mul_le_mul_iff_left₀ tmp, mul_assoc, div_mul]
    have := tmp.ne.symm
    rw [mul_div_cancel_right₀ _ tmp.ne.symm]
    nlinarith
  intro xp
  trans (Real.sqrt (x ^ 2 - p) * Real.sqrt (x ^ 2 - (1 : ℝ))) ^ 2 =
        ((p + (4 : ℝ) - (4 : ℝ) * x ^ 2) / (4 : ℝ)) ^ 2
  · symm; apply sq_eq_sq₀ <;> positivity
  rw [mul_pow, Real.sq_sqrt h1, Real.sq_sqrt h2]
  rw [div_pow]
  norm_num
  conv => lhs; rw [←mul_right_cancel_iff_of_pos (by norm_num : (0 : ℝ) < (16 : ℝ))]; norm_num
          rw [sub_sq, mul_pow, ←pow_mul];
          simp only [mul_add, add_mul, mul_sub_left_distrib, mul_sub_right_distrib]; norm_num
          rw [←pow_add]; norm_num
  trans x ^ 2 * 4 * (4 - 2 * p) = (p - 4) ^ 2
  · constructor
    · intro h; linear_combination (norm := (field_simp; ring_nf)) 1 * h
    · intro h; linear_combination (norm := (field_simp; ring_nf)) 1 * h
  apply @iff_comm (c := p < 2)
  · intro; linarith
  · intro ⟨⟨_, _⟩, _⟩; linarith
  intro hp
  have tmp : (4 - 2 * p) > 0 := by linarith
  trans x ^ 2 = (p - 4) ^ 2 / (4 * (4 - 2 * p))
  · field_simp
  rw [(by ring : (p - (4 : ℝ)) ^ (2 : ℕ) = ((4 : ℝ) - p) ^ (2 : ℕ))]
  have tmp2 :
    ((4 : ℝ) - p) ^ (2 : ℕ) / ((4 : ℝ) * ((4 : ℝ) - (2 : ℝ) * p)) =
    (((4 : ℝ) - p) / ((2 : ℝ) * Real.sqrt ((4 : ℝ) - (2 : ℝ) * p))) ^ 2 := by
    rw [div_pow, mul_pow, Real.sq_sqrt]
    · norm_num
    · exact le_of_lt tmp
  rw [tmp2,
     sq_eq_sq₀ xge0 (le_of_lt
       (by apply div_pos
           · linarith
           positivity))]
  constructor
  · intro hx
    refine ⟨?_, hx⟩
    rw [hx, ←tmp2] at xp
    simp only [ge_iff_le, sub_nonneg] at xp
    rw [←mul_le_mul_iff_left₀ (by positivity : (0 < ((4 : ℝ) * ((4 : ℝ) - (2 : ℝ) * p))))] at xp
    rw [mul_div] at xp
    rw [div_mul_cancel₀ _ (by positivity)] at xp
    ring_nf at xp
    rw [pow_two] at xp
    by_cases hp2 : p ≤ (4 / 3 : ℝ)
    · refine ⟨?_, hp2⟩
      nlinarith only [xp, hp2]
    · nlinarith only [xp, hp2]
  · intro ⟨_, hx⟩; exact hx


end Imo1963P1

-- ═══ Imo1963P5 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# International Mathematical Olympiad 1963, Problem 5

Prove that cos(π/7) - cos(2π/7) + cos(3π/7) = 1/2.
-/

namespace Imo1963P5

open scoped Real

theorem imo1963_p5 :
    Real.cos (π/7) - Real.cos (2*π/7) + Real.cos (3*π/7) = 1/2 := by
  rw [show (2*π/7) = π - (5*π/7) by linarith]
  rw [Real.cos_pi_sub]
  simp only [sub_neg_eq_add]
  have h : 2 * Real.sin (π / 7) ≠ 0 := by
    simp only [ne_eq, mul_eq_zero, OfNat.ofNat_ne_zero, false_or]
    apply ne_of_gt
    apply Real.sin_pos_of_pos_of_lt_pi
    · simp only [Nat.ofNat_pos, div_pos_iff_of_pos_right, Real.pi_pos]
    trans 1
    · rw [div_lt_one (by norm_num)]
      linarith only [Real.pi_le_four]
    · linarith only [Real.pi_gt_three]
  apply (mul_right_inj' h).mp
  rw [left_distrib, left_distrib]
  have prod_sum : ∀ (x y : ℝ),
      2 * Real.sin x * Real.cos y = Real.sin (x + y) - Real.sin (y - x) := by
    intro x y
    rw [Real.sin_add, Real.sin_sub]
    linarith only
  rw [prod_sum, prod_sum, prod_sum]
  rw [show (π / 7 + π / 7)     = 2 * π / 7 by linarith only]
  rw [show (π / 7 - π / 7)     = 0         by linarith only]
  rw [show (π / 7 + 5 * π / 7) = 6 * π / 7 by linarith only]
  rw [show (5 * π / 7 - π / 7) = 4 * π / 7 by linarith only]
  rw [show (π / 7 + 3 * π / 7) = 4 * π / 7 by linarith only]
  rw [show (3 * π / 7 - π / 7) = 2 * π / 7 by linarith only]
  rw [Real.sin_zero]
  ring_nf
  rw [← Real.sin_pi_sub]
  congr
  ring

end Imo1963P5

-- ═══ Imo1964P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Anand Rao, Harald Carlens
-/





/-!
# International Mathematical Olympiad 1964, Problem 1

(a) Find all natural numbers n for which 2ⁿ - 1 is divisible by 7.
(b) Prove that there is no positive integer n for which 2ⁿ + 1 is divisible by 7.
-/

namespace Imo1964P1

noncomputable def solution_set : Set ℕ := { n | n % 3 = 0 }

theorem imo_1964_p1a (n : ℕ) : n ∈ solution_set ↔ 2^n ≡ 1 [MOD 7] := by
  constructor
  · intro hn
    obtain ⟨m, hm⟩ := Nat.dvd_of_mod_eq_zero hn
    change 2^n % 7 = 1
    rw [hm, Nat.pow_mul, Nat.pow_mod]
    norm_num
  · intro hn
    change n % 3 = 0
    change 2^n % 7 = 1 at hn
    rw [(Nat.div_add_mod' n 3).symm] at hn
    rw [pow_add, pow_mul', Nat.mul_mod, Nat.pow_mod] at hn
    mod_cases H : n % 3
    · exact H
    · rw [H] at hn; norm_num at hn
    · rw [H] at hn; norm_num at hn

theorem imo_1964_p1b (n : ℕ) : ¬ 7 ∣ (2^n + 1) := by
  /-
  Following https://prase.cz/kalva/imo/isoln/isoln641.html:
  Let n = 3m + k; k = 0, 1, or 2.
  2^3 = 1 (mod 7).
  Hence
  2^3m + 1 = 2 (mod 7),
  2^(3m+1) + 1 = 3 (mod 7), and
  2^(3m + 2) + 1 = 5 (mod 7).
  -/
  intro h
  apply Nat.mod_eq_zero_of_dvd at h
  have h1: 2 ^ 3 % 7 = 1 := by rfl
  mod_cases h2 : n % 3 <;> rw [←Nat.div_add_mod n 3, h2] at h
  · rw [Nat.zero_mod, add_zero, Nat.add_mod, Nat.pow_mod, pow_mul, Nat.pow_mod, h1, one_pow] at h
    contradiction
  · rw [Nat.add_mod, pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod, h1, one_pow] at h
    contradiction
  · rw [Nat.add_mod, pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod, h1, one_pow] at h
    contradiction



/- An alternative proof, heavily golfed. The statement here is slightly modified from
   the original one. -/
theorem imo_1964_p1b' : ∀ (n : ℕ), (2 ^ n + 1) % 7 ≠ 0
    | 0 | 1 | 2 => by decide
    | n + 3 => by
      rw [pow_add, Nat.add_mod, Nat.mul_mod, show 2 ^ 3 % 7 = 1 by rfl]
      simp [imo_1964_p1b' n]



end Imo1964P1

-- ═══ Imo1964P2 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1964, Problem 2

Suppose that a,b,c are the side lengths of a triangle. Prove that

   a²(b + c - a) + b²(c + a - b) + c²(a + b - c) ≤ 3abc.
-/

namespace Imo1964P2



-- TODO: get this into mathlib in some form
lemma schur {a b c : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) :
    0 ≤ a * (a - b) * (a - c) + b * (b - a) * (b - c) + c * (c - a) * (c - b) := by
  -- from https://artofproblemsolving.com/wiki/index.php/Schur%27s_Inequality
  wlog Hcb : c ≤ b with h1
  · have h3 : b ≤ c := le_of_not_ge Hcb
    linarith [h1 ha hc hb h3]
  wlog Hba : b ≤ a with h2
  · have h4 : a ≤ b := le_of_not_ge Hba
    obtain hca | hac : c ≤ a ∨ a ≤ c := le_total c a
    · have := h2 hb ha hc hca h4
      linarith only [this]
    · have := h2 hb hc ha hac Hcb
      linarith only [this]
  have h5 : a * (a - b) * (a - c) + b * (b - a) * (b - c) =
            (a - b) * (a * (a - c) - b * (b - c)) := by ring

  have h6 : 0 ≤ (a - b) * (a * (a - c) - b * (b - c)) := by bound

  rw [← h5] at h6
  have h12 : 0 ≤ (c - a) * (c - b) := by nlinarith only [Hba, Hcb]
  have h13 : 0 ≤ c * (c - a) * (c - b) := by nlinarith only [hc, h12]
  positivity



theorem imo1964_p2
    (T : Affine.Triangle ℝ (EuclideanSpace ℝ (Fin 2)))
    (a b c : ℝ)
    (ha : a = dist (T.points 1) (T.points 2))
    (hb : b = dist (T.points 2) (T.points 0))
    (hc : c = dist (T.points 0) (T.points 1)) :
    a^2 * (b + c - a) + b^2 * (c + a - b) + c^2 * (a + b - c) ≤
    3 * a * b * c := by
  -- solution 3 from
  -- https://artofproblemsolving.com/wiki/index.php/1964_IMO_Problems/Problem_2

  -- The only thing we need to know about a,b,c is that they
  -- are nonnegative.
  have ha' : 0 ≤ dist (T.points 1) (T.points 2) := dist_nonneg
  rw [←ha] at ha'; clear ha
  have hb' : 0 ≤ dist (T.points 2) (T.points 0) := dist_nonneg
  rw [←hb] at hb'; clear hb
  have hc' : 0 ≤ dist (T.points 0) (T.points 1) := dist_nonneg
  rw [←hc] at hc'; clear hc
  clear T

  have h1 :
      3 * a * b * c - (a^2 * (b + c - a) + b^2 * (c + a - b) + c^2 * (a + b - c)) =
      a * (a - b) * (a - c) + b * (b - a) * (b - c) + c * (c - a) * (c - b) := by
    ring
  suffices 0 ≤
    3 * a * b * c - (a^2 * (b + c - a) + b^2 * (c + a - b) + c^2 * (a + b - c)) from
    sub_nonneg.mp this
  rw [h1]
  exact schur ha' hb' hc'


end Imo1964P2

-- ═══ Imo1964P4 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1964, Problem 4

Seventeen people correspond by mail with one another -- each one with
all the rest. In their letters only three different topics are
discussed. Each pair of correspondents deals with only one of the topics.
Prove that there are at least three people who write to each other
about the same topic.

-/

namespace Imo1964P4



/--
 Smaller version of the problem, with 6 (or more) people and 2 topics.
-/
theorem lemma1
    (Person Topic : Type)
    [Fintype Person] [DecidableEq Person]
    [Fintype Topic] [DecidableEq Topic]
    (card_person : 5 < Fintype.card Person)
    (card_topic : Fintype.card Topic = 2)
    (discusses : Person → Person → Topic)
    (discussion_sym : ∀ p1 p2 : Person, discusses p1 p2 = discusses p2 p1) :
    ∃ t : Topic, ∃ s : Finset Person,
      2 < s.card ∧
        ∀ p1 ∈ s, ∀ p2 ∈ s, p1 ≠ p2 → discusses p1 p2 = t := by
  -- Choose a person p2.
  have p2 : Person := Nonempty.some (Fintype.card_pos_iff.mp (by lia))
  let Person' := {p3 // p3 ≠ p2}
  have hfcα : 4 < Fintype.card Person' := by
    rw [Fintype.card_subtype_compl, Fintype.card_ofSubsingleton]
    exact lt_tsub_of_add_lt_left card_person
  have h1 : Fintype.card Topic * 2 < Fintype.card Person' := by lia

  -- By the pigeonhole principle, there must be some topic t2 such that the
  -- size of the set {p3 // p3 ≠ p2 ∧ discusses p2 p3 = t2} is at least 3.
  have h2 := Fintype.exists_lt_card_fiber_of_mul_lt_card
              (fun (p3: Person') ↦ discusses p2 p3.val) h1
  obtain ⟨t2, ht2⟩ := h2
  -- Call that set α.
  let α := (Finset.filter (fun (x : Person') ↦ discusses p2 ↑x = t2) Finset.univ)

  -- If any pair of people p4 p5 in α discusses topic t2, then we are done.
  -- So the people in α must all discuss only the remaining one topic t3.
  let Topic' := {t3 // t3 ≠ t2}
  have h4 : Fintype.card Topic' = 1 := by
    simp [Fintype.card_subtype_compl, card_topic, Topic']

  -- let t3 be the other element of Topic
  obtain ⟨t3, ht3⟩ := Fintype.card_eq_one_iff.mp h4

  by_cases h6 : ∃ p3 p4 : α, p3 ≠ p4 ∧ discusses p3.val p4.val = t2
  · obtain ⟨p3, p4, hp1, hp2⟩ := h6
    use t2
    -- the set we want is {p2,p3,p4}
    let s1 : Finset Person := {p3.val.val}
    let s2 : Finset Person := Finset.cons p4.val s1
                               (by rw [Finset.mem_singleton]; intro hp
                                   exact (hp1 (Subtype.val_injective
                                          (Subtype.val_injective hp)).symm).elim)
    let s3 : Finset Person := Finset.cons p2 s2 (by grind)

    use s3
    grind

  · push_neg at h6
    use t3
    let α' := Finset.map ⟨λ (x :Person') => x.val, Subtype.coe_injective⟩ α
    use α'
    constructor
    · rw [Finset.card_map]; exact ht2
    · intro p3' hp3' p4' hp4' hp3p4'
      rw [Finset.mem_map] at hp3' hp4'
      obtain ⟨⟨p3, p3_ne⟩, p3_mem_α, p3_eq⟩ := hp3'
      obtain ⟨⟨p4, p4_ne⟩, p4_mem_α, p4_eq⟩ := hp4'
      dsimp at p3_eq p4_eq
      rw [←p3_eq, ←p4_eq]
      have hne : p3 ≠ p4 := by rwa [p3_eq, p4_eq]
      have h8 := h6 ⟨⟨p3, p3_ne⟩, p3_mem_α⟩ ⟨⟨p4, p4_ne⟩, p4_mem_α⟩
                    (by simp[hne, Person'])
      let t3': Topic' := ⟨discusses p3 p4, h8⟩
      have h9 := ht3 t3'
      rw [←h9]



theorem imo1964_p4
    (Person Topic : Type)
    [Fintype Person] [DecidableEq Person]
    [Fintype Topic] [DecidableEq Topic]
    (card_person : Fintype.card Person = 17)
    (card_topic : Fintype.card Topic = 3)
    (discusses : Person → Person → Topic)
    (discussion_sym : ∀ p1 p2 : Person, discusses p1 p2 = discusses p2 p1) :
    ∃ t : Topic, ∃ s : Finset Person,
      2 < s.card ∧
        ∀ p1 ∈ s, ∀ p2 ∈ s, p1 ≠ p2 → discusses p1 p2 = t := by
  -- Choose a person p1.
  have p1 : Person := Nonempty.some (Fintype.card_pos_iff.mp (by lia))
  let Person' := {p2 // p2 ≠ p1}

  -- By the pigeonhole principle, there must be some topic t1 such
  -- that the size of the set {p2 // p2 ≠ p1 ∧ discusses p1 p2 = t1}
  -- is at least 6.

  have hfcα : Fintype.card Person' = 16 := by
      simp [Fintype.card_subtype_compl, card_person, Person']
  have h1 : Fintype.card Topic * 5 < Fintype.card Person' := by
      rw [hfcα, card_topic]; norm_num

  have h2 := Fintype.exists_lt_card_fiber_of_mul_lt_card
              (fun (p2: Person') ↦ discusses p1 p2.val) h1
  clear h1
  obtain ⟨t1, ht1⟩ := h2
  -- Call that set α.
  let α := (Finset.filter (fun (x : Person') ↦ discusses p1 ↑x = t1) Finset.univ)
  have cardα : 5 < Fintype.card α := by rw [Fintype.card_coe]; exact ht1;

  -- If any pair of people p2 p3 in α discusses topic t1, then we are done.
  by_cases h6 : ∃ p2 p3 : α, p2 ≠ p3 ∧ discusses p2.val p3.val = t1
  · obtain ⟨p3, p4, hp1, hp2⟩ := h6
    use t1
    -- the set we want is {p1,p3,p4}
    let s1 : Finset Person := {p3.val.val}

    have hs1 : ¬ p4.val.val ∈ s1 := by
      rw [Finset.mem_singleton]; intro hp
      exact (hp1 (Subtype.val_injective (Subtype.val_injective hp)).symm).elim

    let s2 : Finset Person := Finset.cons p4.val s1 hs1

    have hs2 : ¬ p1 ∈ s2 := by
      rw [Finset.mem_cons, Finset.mem_singleton]; intro hp
      cases hp with
      | inl hp => exact (p4.val.property.symm hp).elim
      | inr hp => exact (p3.val.property.symm hp).elim

    let s3 : Finset Person := Finset.cons p1 s2 hs2
    use s3
    grind

  · -- So the people in α must all discuss only the remaining two topics.
    push_neg at h6
    let Topic' := {t2 // t2 ≠ t1}
    have h3 : Fintype Topic' := Fintype.ofFinite Topic'
    have h4 : Fintype.card Topic' = 2 := by
      simp [Fintype.card_subtype_compl, card_topic, Topic']
    have t0 : Topic' := Nonempty.some (Fintype.card_pos_iff.mp (by positivity))

    let discusses' : α → α → Topic' :=
      fun (p2 p3 : α) ↦
        if heq : p2 = p3 then t0
        else
        ⟨discusses p2.val p3.val, h6 ⟨p2, p2.property⟩ ⟨p3, p3.property⟩ heq⟩
    have discusses_sym' :
        ∀ (p1 p2 : { x // x ∈ α }), discusses' p1 p2 = discusses' p2 p1 := by
      intro p3 p4
      simp only [discusses']
      split_ifs with hf1 hf2 hf3
      · rfl
      · exact (hf2 hf1.symm).elim
      · exact (hf1 hf3.symm).elim
      · simp[discussion_sym]
    have h5 := lemma1 α Topic' cardα h4 discusses' discusses_sym'
    obtain ⟨t2, s, hs1, hs2⟩ := h5
    use t2
    let s' := Finset.map ⟨λ (x : α) => x.val.val,
                          fun x y hxy ↦ Subtype.coe_injective (Subtype.coe_injective hxy)⟩ s
    use s'
    constructor
    · rwa [Finset.card_map]
    · intro p3 hp3 p4 hp4 hp34
      rw [Finset.mem_map] at hp3 hp4
      obtain ⟨⟨⟨p3', p3_mem_person'⟩, p3_mem_α⟩, p3_mem_s, hp3eq⟩ := hp3
      obtain ⟨⟨⟨p4', p4_mem_person'⟩, p4_mem_α⟩, p4_mem_s, hp4eq⟩ := hp4
      dsimp at hp3eq hp4eq
      rw [←hp3eq, ←hp4eq]
      have hne : p3' ≠ p4' := by rwa[hp3eq, hp4eq]
      have h6 := hs2 ⟨⟨p3', p3_mem_person'⟩, p3_mem_α⟩ p3_mem_s
                     ⟨⟨p4', p4_mem_person'⟩, p4_mem_α⟩ p4_mem_s
                     (by simp [hne, Person'])
      simp [hne, Person', discusses'] at h6
      exact (congrArg Subtype.val h6)


end Imo1964P4

-- ═══ Imo1965P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad
-/





/-!
# International Mathematical Olympiad 1965, Problem 1

Determine all values x in the interval 0 ≤ x ≤ 2π which
satisfy the inequality

   2 cos x ≤ |√(1 + sin 2x) − √(1 − sin 2x)| ≤ √2.
-/

namespace Imo1965P1

open Real Set

noncomputable def the_answer : Set ℝ := Icc (π/4) (7*π/4)

theorem imo1965_p1 :
    {x ∈ Icc 0 (2*π) |
       |√(1 + sin (2*x)) - √(1 - sin (2*x))| ∈ Icc (2 * cos x) √2}
     = the_answer := by
  -- We follow https://artofproblemsolving.com/wiki/index.php/1965_IMO_Problems/Problem_1.
  have h0 : ∀ x, (√(1 + sin (2*x)) - √(1 - sin (2*x)))^2 = 2 - 2*|cos (2*x)| := by
    intro x
    rw [←sqrt_sq_eq_abs (cos (2 * x)), cos_sq', sub_sq, sq_sqrt, sq_sqrt, mul_assoc,
      ←sqrt_mul]
    · ring_nf
    repeat { linarith [sin_le_one (2 * x), neg_one_le_sin (2 * x)] }
  have : ∀ x, |√(1 + sin (2*x)) - √(1 - sin (2*x))| ≤ √2 := by
    intro x
    apply nonneg_le_nonneg_of_sq_le_sq (by norm_num)
    simp [←pow_two, h0]
  simp only [Set.mem_Icc]
  simp_rw [this, and_true]
  symm; ext x; constructor
  · dsimp
    rw [the_answer]; rintro ⟨h1, h2⟩
    constructor
    · constructor <;> linarith
    have : x ∈ Ico (π/4) (π / 2) ∪ Icc (π/2) (3*π/2) ∪ Ioc (3*π/2) (7*π/4) := by
      simp only [mem_Icc, mem_union, mem_Ico, mem_Ioc]
      rcases lt_or_ge x (π/2) with h3 | h3 <;>
        rcases le_or_gt x (3*π/2) with h4 | h4 <;> simp [*]
    rcases this with (⟨_, h4⟩ | ⟨h3, h4⟩) | ⟨h3, _⟩
    · have cos2x_nonpos : cos (2*x) ≤ 0 := by
        apply cos_nonpos_of_pi_div_two_le_of_le <;> linarith
      have cosx_nonneg : 0 ≤ cos x := by
        apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
      have cosx2_nonneg : 0 ≤ 2 * cos x := by linarith
      rw [←abs_of_nonneg cosx2_nonneg, ←sq_le_sq, h0, abs_of_nonpos cos2x_nonpos, cos_two_mul]
      linarith
    · trans 0; swap;
      · simp
      suffices cos x ≤ 0 by linarith
      apply cos_nonpos_of_pi_div_two_le_of_le h3
      linarith
    · have cos2x_nonpos : cos (2*x) ≤ 0 := by
        rw [←cos_neg, ←cos_add_two_pi, ←cos_add_two_pi]
        apply cos_nonpos_of_pi_div_two_le_of_le <;> linarith
      have cosx_nonneg : 0 ≤ cos x := by
        rw [←cos_neg, ←cos_add_two_pi]
        apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
      have cosx2_nonneg : 0 ≤ 2 * cos x := by linarith
      rw [←abs_of_nonneg cosx2_nonneg, ←sq_le_sq, h0, abs_of_nonpos cos2x_nonpos, cos_two_mul]
      linarith
  rintro ⟨⟨h1, h2⟩, h3⟩
  by_contra h4
  rw [the_answer, mem_Icc, not_and_or] at h4; push_neg at h4
  have cos2x_nonneg : 0 ≤ cos (2*x) := by
    rcases h4 with h4 | h4
    · apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
    · rw [←cos_sub_two_pi, ←cos_sub_two_pi]
      apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
  have cosx_nonneg : 0 ≤ cos x := by
    rcases h4 with h4 | h4
    · apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
    · rw [←cos_neg, ←cos_add_two_pi]
      apply cos_nonneg_of_neg_pi_div_two_le_of_le <;> linarith
  have cosx2_nonneg : 0 ≤ 2 * cos x := by linarith
  rw [←abs_of_nonneg cosx2_nonneg, ←sq_le_sq, h0, abs_of_nonneg cos2x_nonneg, cos_two_mul] at h3
  ring_nf at h3
  suffices (cos (π/4))^2 < (cos x)^2 by
    rw [cos_pi_div_four, div_pow] at this; norm_num at this
    linarith
  rw [sq_lt_sq, abs_of_nonneg cosx_nonneg, abs_of_nonneg]
  swap
  · simp [cos_pi_div_four]; positivity
  rcases h4 with h5 | h5
  · apply cos_lt_cos_of_nonneg_of_le_pi_div_two h1 (by linarith) h5
  rw [←cos_neg x, ←cos_add_two_pi (-x)]
  apply cos_lt_cos_of_nonneg_of_le_pi_div_two <;> linarith

-- ═══ Imo1965P2 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1965, Problem 2

Suppose that
  a₁₁x₁ + a₁₂x₂ + a₁₃x₃ = 0
  a₂₁x₁ + a₂₂x₂ + a₂₃x₃ = 0
  a₃₁x₁ + a₃₂x₂ + a₃₃x₃ = 0

where
 (A) a₁₁, a₂₂, a₃₃ are positive
 (B) the remaining aᵢⱼ are negative
 (C) in each row i, the sum of the coefficients aᵢⱼ is positive.

Prove that x₁ = x₂ = x₃ = 0.
-/

namespace Imo1965P2



abbrev propEqs (x : Fin 3 → ℝ) (a : Fin 3 → Fin 3 → ℝ) : Prop :=
   ∀ i, ∑ j : Fin 3, (a i j * x j) = 0

lemma lemma0 (x : Fin 3 → ℝ) (a : Fin 3 → Fin 3 → ℝ) (p : Fin 3 → Fin 3)
    (hp : p.Bijective)
    (he : propEqs x a) : propEqs (x ∘ p) (fun i j ↦ a (p i) (p j)) := by
  intro i
  dsimp
  have hi := he (p i)
  rwa [Function.Bijective.sum_comp hp (fun j ↦ a (p i) j * x j)]

abbrev propsAB (a : Fin 3 → Fin 3 → ℝ) : Prop :=
       ∀ i j, if i = j then 0 < a i j else a i j < 0

lemma lemma1 (a : Fin 3 → Fin 3 → ℝ) (p : Fin 3 → Fin 3)
    (hp : p.Bijective)
    (hab : propsAB a) :
    propsAB (fun i j ↦ a (p i) (p j)) := by
  intro i j
  have h0 := hab (p i) (p j)
  split_ifs with h1
  · subst h1
    simp only [reduceIte] at h0
    exact h0
  · have h2 : p i ≠ p j := fun a ↦ h1 (hp.1 a)
    simp only [h2] at h0
    exact h0

lemma lemma2 (a : Fin 3 → Fin 3 → ℝ)
    (p : Fin 3 → Fin 3)
    (hp : p.Bijective)
    (hc : ∀ i, 0 < ∑ j : Fin 3, a i j) :
    ∀ i, 0 < ∑ j : Fin 3, a (p i) (p j) := by
  intro i
  rw [Function.Bijective.sum_comp hp]
  exact hc (p i)



theorem imo1965_p2 (x : Fin 3 → ℝ) (a : Fin 3 → Fin 3 → ℝ)
    (heqs : ∀ i, ∑ j : Fin 3, (a i j * x j) = 0)
    (hab : ∀ i j, if i = j then 0 < a i j else a i j < 0)
    (hc : ∀ i, 0 < ∑ j : Fin 3, a i j)
    : ∀ i, x i = 0 := by
  -- https://prase.cz/kalva/imo/isoln/isoln652.html
  -- wlog, |x 0| ≥ |x 1| and |x 0| ≥ |x 2|.
  wlog h1 : |x 1| ≤ |x 0| with H
  · let p : Fin 3 → Fin 3 := ![1, 0, 2]
    have hp : p.Bijective := by decide
    have h2 := H (x ∘ p) (fun i j ↦ a (p i) (p j))
                 (lemma0 x a p hp heqs)
                 (lemma1 _ p hp hab)
                 (lemma2 _ p hp hc)
                 (le_of_not_ge h1)
    intro i
    fin_cases i
    · exact h2 1
    · exact h2 0
    · exact h2 2
  wlog h2 : |x 2| ≤ |x 0| with H
  · have h2' : |x 0| ≤ |x 2| := le_of_not_ge h2
    have h3 : |x 1| ≤ |x 2| := ge_trans h2' h1
    let p : Fin 3 → Fin 3 := ![2, 0, 1]
    have hp : p.Bijective := by decide
    have h4 := H (x ∘ p) (fun i j ↦ a (p i) (p j))
                 (lemma0 x a p hp heqs)
                 (lemma1 _ p hp hab)
                 (lemma2 _ p hp hc)
                 h2' h3
    intro i
    fin_cases i
    · exact h4 1
    · exact h4 2
    · exact h4 0
  have h3' : 0 < a 0 1 + a 0 2 + a 0 0 := by
    have h4 : ∑ j : Fin 3, a 0 j = a 0 1 + a 0 2 + a 0 0 := by
      rw [Fin.sum_univ_three, add_rotate]
    rw [←h4]
    exact hc 0
  have h4 : - a 0 1 + - a 0 2 < a 0 0 := by linarith only [h3']
  have h5 : 0 < - a 0 1 := neg_pos.mpr (hab 0 1)
  have h6 : 0 < - a 0 2 := neg_pos.mpr (hab 0 2)
  have h10 : 0 < a 0 0 := hab 0 0
  have h3 : |-a 0 1| + |-a 0 2| < |a 0 0| := by
    rw [abs_of_pos h5, abs_of_pos h6, abs_of_pos h10]
    exact h4
  have h7 := heqs 0
  rw [Fin.sum_univ_three] at h7
  by_contra! H
  obtain ⟨k, hk⟩ := H
  have h8 : 0 < |x k| := abs_pos.mpr hk
  have h9 : 0 < |x 0| := by
    (obtain rfl | rfl | rfl : k = 0 ∨ k = 1 ∨ k = 2 := by fin_cases k <;> aesop)
     <;> linarith only [h1, h2, h8]
  replace h7 : a 0 0 * x 0 = - a 0 1 * x 1 + - a 0 2 * x 2 := by linarith only [h7]

  apply_fun (|·|) at h7
  have h11 := calc
     |a 0 0| * |x 0|
       = |a 0 0 * x 0| := (abs_mul _ _).symm
     _ = _ := h7
     _ ≤ |-a 0 1 * x 1| + |-a 0 2 * x 2| := abs_add_le _ _
     _ = |-a 0 1| * |x 1| + |-a 0 2| * |x 2| := by simp only [abs_mul]
     _ ≤ |-a 0 1| * |x 0| + |-a 0 2| * |x 0| := by gcongr
     _ = (|-a 0 1| + |-a 0 2|) * |x 0| := (add_mul _ _ _).symm
  have h12 : |a 0 0| ≤ |-a 0 1| + |-a 0 2| := (mul_le_mul_iff_left₀ h9).mp h11
  exact not_lt.mpr h12 h3


end Imo1965P2

-- ═══ Imo1966P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Pedro Duailibe
-/





/-!
# International Mathematical Olympiad 1966, Problem 4

Prove that for every natural number n and for every real
number x that is not of the form kπ/2ᵗ for t a non-negative
integer and k any integer,

 1 / (sin 2x) + 1 / (sin 4x) + ... + 1 / (sin 2ⁿx) = cot x - cot 2ⁿ x.
-/

namespace Imo1966P4

theorem imo1966_p4 (n : ℕ) (x : ℝ)
    (hx : ∀ t : ℕ, ∀ k : ℤ, x ≠ k * Real.pi / 2^t) :
    ∑ i ∈ Finset.range n, 1 / Real.sin (2^(i + 1) * x) =
    Real.cot x - Real.cot (2^n * x) := by
  induction n with
  | zero =>
      rw [Finset.range_zero, Finset.sum_empty, pow_zero, one_mul, sub_self]
  | succ n ih =>
      rw [Finset.sum_range_succ, ih]
      let θ := 2 ^ n * x
      have hθ : θ = 2 ^ n * x := by rfl
      have h₀ : Real.sin (2^(n+1) * x) ≠ 0 := by
        intro h
        rw [Real.sin_eq_zero_iff] at h
        obtain ⟨k, hk⟩ := h
        apply hx (n+1) k
        rw [eq_div_iff (pow_ne_zero (n+1) (by norm_num)), mul_comm, ← hk]
      have h₁ : Real.sin θ ≠ 0 ∧ Real.cos θ ≠ 0 := by
        rw [pow_succ, mul_comm (2^n) 2, mul_assoc, ← hθ] at h₀
        rw [Real.sin_two_mul] at h₀
        constructor
        · rw [mul_comm 2, mul_assoc] at h₀
          apply left_ne_zero_of_mul h₀
        · exact right_ne_zero_of_mul h₀
      have h : 1 / Real.sin (2 * θ) = Real.cot θ - Real.cot (2 * θ) := by
        simp only [Real.cot_eq_cos_div_sin]
        rw [Real.sin_two_mul, Real.cos_two_mul]
        field_simp [h₁]
        ring
      rw [pow_succ, mul_comm (2^n) 2, mul_assoc, ← hθ, h]
      abel

end Imo1966P4

-- ═══ Imo1967P3 ═══

/-
Copyright (c) 2025 Roozbeh Yousefzadeh. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/






/-!
# International Mathematical Olympiad 1967, Problem 3

Let $k, m, n$ be natural numbers such that m + k + 1 is a prime greater
than n + 1. Let c(s) = s * (s+1). Prove that the product
(c(m+1) - c(k)) * (c(m+2) - c(k)) * ... * (c(m+n) - c(k)) is divisible
by the product c(1) * c(2) * ... * c(n).
-/

namespace Imo1967P3




lemma aux_1
    (c : ℕ → ℕ)
    (h₁ : ∀ (s : ℕ), c s = s * (s + 1)) :
    ∀ (a b : ℕ), c a - c b = (a - b) * (a + b + 1) := by
  intro a b
  rw [h₁, h₁]
  have h_factor : a + a^2 - (b + b^2) = (a - b) * (a + b + 1) := by rw [tsub_mul]; grind
  grind

lemma aux_1_mono
    (c : ℕ → ℕ)
    (h₁ : ∀ (s : ℕ), c s = s * (s + 1)) :
    Monotone c := by
  intro a b h
  simp only [h₁]
  have h1 : a * (a + 1) ≤ b * (a + 1) := Nat.mul_le_mul_right _ h
  have h2 : b * (a + 1) ≤ b * (b + 1) := Nat.mul_le_mul_left _ (Nat.succ_le_succ h)
  exact h1.trans h2

lemma aux_2 :
  ∀ (n m : ℕ), 0 < n → n.factorial ∣ ∏ i ∈ Finset.Icc 1 n, (m + i) := by
  intro s t _
  -- Product equals ascending factorial: (t+1)(t+2)...(t+s) = (t+1).ascFactorial s
  have hprod : ∏ i ∈ Finset.Icc 1 s, (t + i) = (t + 1).ascFactorial s := by
    rw [Nat.ascFactorial_eq_prod_range, ← Finset.Ico_succ_right_eq_Icc, Finset.prod_Ico_eq_prod_range]
    apply Finset.prod_congr rfl; intro i _; ring
  rw [hprod]
  exact Nat.factorial_dvd_ascFactorial (t + 1) s

lemma aux_3
  (k m n : ℕ)
  (h₀ : 0 < k ∧ 0 < m ∧ 0 < n)
  (h₁ : Nat.Prime (k + m + 1))
  (h₂ : n + 1 < k + m + 1) :
  (n + 1).factorial ∣ ∏ i ∈ Finset.Icc 1 n, (m + i + k + 1) := by
  have h₃: ∀ (n m : ℕ), 0 < n → n.factorial ∣ ∏ i ∈ Finset.Icc 1 n, (m + i) := by
    exact fun (n m : ℕ) (a : 0 < n) ↦ aux_2 n m a
  have h₄: (n + (1 : ℕ)).factorial ∣ (k + m + 1) * (∏ i ∈ Finset.Icc (1 : ℕ) n, (m + i + k + (1 : ℕ))) := by
    have hn₀ : 0 < n + 1 := by exact Nat.zero_lt_succ n
    have h₈₁: ∀ i, m + i + k + (1 : ℕ) = m + k + (1 : ℕ) + i := by bound
    have h₈₂: (k + m + 1) * (∏ i ∈ Finset.Icc (1 : ℕ) n, (m + i + k + (1 : ℕ))) = ∏ i ∈ Finset.Ico (0 : ℕ) (n + 1), (m + i + k + (1 : ℕ)) := by
      simp_rw [h₈₁]
      rw [Finset.prod_eq_prod_Ico_succ_bot hn₀ (fun i ↦ m + k + (1 : ℕ) + i)]
      rw [add_zero, add_comm k m]
      exact rfl
    simp_rw [h₈₂]
    have h₈₃: ∏ i ∈ Finset.Ico (0 : ℕ) (n + (1 : ℕ)), (m + i + k + (1 : ℕ)) = ∏ i ∈ Finset.Ico (1 : ℕ) (n + 2), (m + i + k) := by
      rw [Finset.prod_Ico_eq_prod_range, Finset.prod_Ico_eq_prod_range]
      simp
      group
    have h₈₄: ∏ i ∈ Finset.Ico (1 : ℕ) (n + (2 : ℕ)), (m + i + k) = ∏ i ∈ Finset.Icc (1 : ℕ) (n + (1 : ℕ)), (m + i + k) := by rfl
    rw [h₈₃, h₈₄]
    have h₈₅: ∀ i, m + i + k = m + k + i := by exact fun (i : ℕ) ↦ Nat.add_right_comm m i k
    simp_rw [h₈₅]
    exact h₃ (n + 1) (m + k) hn₀
  refine Nat.Coprime.dvd_of_dvd_mul_left ?_ h₄
  refine Nat.Coprime.symm ?_
  exact Nat.Prime.coprime_factorial_of_lt h₁ h₂

lemma aux_4
    (k m n : ℕ)
    (_ : n ≤ k - (m + 1)) :
    ∏ i ∈ Finset.Icc 1 n, (k - (m + i)) = (k - (m + 1)).descFactorial n := by
  rw [Nat.descFactorial_eq_prod_range, ← Finset.Ico_succ_right_eq_Icc, Finset.prod_Ico_eq_prod_range]
  apply Finset.prod_congr rfl; intro i _; lia




theorem imo1967_p3
  (k m n : ℕ)
  (c : ℕ → ℕ)
  (h₀ : 0 < k ∧ 0 < m ∧ 0 < n)
  (h₁ : ∀ s, c s = s * (s + 1))
  (h₂ : Nat.Prime (k + m + 1))
  (h₃ : n + 1 < k + m + 1) :
  (∏ i ∈ Finset.Icc 1 n, (↑(c i):ℤ)) ∣ (∏ i ∈ Finset.Icc 1 n, (((c (m + i)):ℤ) - ((c k):ℤ))) := by
  have h₄: ∏ i ∈ Finset.Icc 1 n, (↑(c i):ℤ) = n.factorial * (n + 1).factorial := by
    norm_cast
    have h₄₀ : ∀ i, c i = i * (i + 1) := by
      intro i
      specialize h₁ i
      simpa using h₁
    simp_rw [h₄₀]
    refine Nat.le_induction ?_ ?_ n h₀.2.2
    · simp
    · simp only [Nat.succ_eq_add_one, zero_add]
      intro d hd₀ hd₁
      rw [Finset.prod_Icc_succ_top (by lia), hd₁]
      rw [Nat.factorial_succ (d + (1 : ℕ))]
      rw [← mul_assoc, mul_comm _ (d + (1 : ℕ)), ← mul_assoc]
      rw [← Nat.factorial_succ]
      ring_nf
  rw [h₄]
  by_cases hk₀: k ≤ m
  · have h₅: (∏ i ∈ Finset.Icc 1 n, (((c (m + i)):ℤ) - ((c k):ℤ))) = (∏ i ∈ Finset.Icc 1 n, (m + i + k + 1)) * (∏ i ∈ Finset.Icc 1 n, (m + i - k)) := by
      have h₅₁: ∏ i ∈ Finset.Icc 1 n, (((c (m + i)):ℤ) - ((c k):ℤ)) = (↑(∏ i ∈ Finset.Icc 1 n, ((c (m + i)) - (c k))):ℤ) := by
        rw [@Nat.cast_prod]
        refine Finset.prod_congr rfl ?_
        intro x hx₀
        symm
        refine Nat.cast_sub ?_

        have hk_le_mx : k ≤ m + x := hk₀.trans (Nat.le_add_right _ _)
        exact aux_1_mono c h₁ hk_le_mx
      rw [h₅₁, ← Nat.cast_mul]
      norm_cast
      simp_rw [aux_1 c h₁]
      rw [Nat.mul_comm]
      exact Finset.prod_mul_distrib
    have h₇: n.factorial ∣ (∏ i ∈ Finset.Icc 1 n, (m + i - k)) := by
      have h₇₀: ∀ i, m + i - k = m - k + i := by
        intro i
        exact Nat.sub_add_comm hk₀
      simp_rw [h₇₀]
      exact aux_2 n (m - k) h₀.2.2
    have h₈: (n + (1 : ℕ)).factorial ∣ (∏ i ∈ Finset.Icc (1 : ℕ) n, (m + i + k + (1 : ℕ))) := by
      exact aux_3 k m n h₀ h₂ h₃
    rw [h₅, mul_comm]
    refine Nat.cast_dvd_cast ?_
    exact Nat.mul_dvd_mul h₈ h₇
  · push_neg at hk₀
    by_cases hk₁: k ≤ m + n
    · have h₆ : ∏ i ∈ Finset.Icc (1 : ℕ) n, ((↑(c (m + i)) : ℤ) - (↑(c k) : ℤ)) = 0 := by
        refine Finset.prod_eq_zero_iff.mpr ?_
        use (k - m)
        constructor
        · refine Finset.mem_Icc.mpr ?_
          lia
        · grind
      rw [h₆]
      exact Int.dvd_zero ((↑n.factorial : ℤ) * (↑(n + (1 : ℕ)).factorial : ℤ))
    · push_neg at hk₁
      have h₅: ∏ i ∈ Finset.Icc (1 : ℕ) n, ((↑(c (m + i)) : ℤ) - (↑(c k) : ℤ)) =
        ∏ i ∈ Finset.Icc (1 : ℕ) n, (((↑(c k) : ℤ) - (↑(c (m + i)) : ℤ)) * (-1:ℤ)) := by
        group
      have h₆: ∏ i ∈ Finset.Icc 1 n, ((↑(c k) : ℤ) - (↑(c (m + i)) : ℤ)) = (∏ i ∈ Finset.Icc 1 n, (k - (m + i))) * (∏ i ∈ Finset.Icc 1 n, (k + (m + i) + 1)) := by
        have h₅₁: ∏ i ∈ Finset.Icc 1 n, (((c k):ℤ) - ((c (m + i)):ℤ)) = (↑(∏ i ∈ Finset.Icc 1 n, (c k - c (m + i))):ℤ) := by
          rw [@Nat.cast_prod]
          refine Finset.prod_congr rfl ?_
          simp only [Finset.mem_Icc, and_imp]
          intro x hx₀ hx₁
          symm
          refine Nat.cast_sub ?_
          -- from x ≤ n and m + n < k, we get m + x ≤ k
          have hmx_le_k : m + x ≤ k := by
            have hx' : m + x ≤ m + n := Nat.add_le_add_left hx₁ m
            exact le_of_lt (lt_of_le_of_lt hx' hk₁)
          exact aux_1_mono c h₁ hmx_le_k
        rw [h₅₁, ← Nat.cast_mul]
        norm_cast
        simp_rw [aux_1 c h₁]
        exact Finset.prod_mul_distrib
      rw [h₅, Finset.prod_mul_distrib, h₆]
      have h₇: (↑n.factorial : ℤ) * (↑(n + 1).factorial : ℤ) ∣
        (↑(∏ i ∈ Finset.Icc 1 n, (k - (m + i))) : ℤ) * (↑(∏ i ∈ Finset.Icc 1 n, (k + (m + i) + 1)) : ℤ) := by
        rw [← Nat.cast_mul, ← Nat.cast_mul]
        refine Nat.cast_dvd_cast ?_
        refine Nat.mul_dvd_mul ?_ ?_
        · have h₇₀: n ≤ k - (m + 1) := by lia
          rw [aux_4 k m n h₇₀]
          exact Nat.factorial_dvd_descFactorial (k - (m + 1)) n
        · have h₇₀: ∏ i ∈ Finset.Icc 1 n, (k + (m + i) + 1) = ∏ i ∈ Finset.Icc 1 n, (m + i + k + 1) := by group
          rw [h₇₀]
          exact aux_3 k m n h₀ h₂ h₃
      exact Dvd.dvd.mul_right h₇ (∏ x ∈ Finset.Icc 1 n, -1)

-- ═══ Imo1967P5 ═══

/-
Copyright (c) 2025 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Rydh
-/






/-!
# International Mathematical Olympiad 1967, Problem 5

Consider the sequence {cₙ}, where

   c₁ = a₁  + a₂  + ... + a₈
   c₂ = a₁² + a₂² + ... + a₈²
   ...
   cₙ = a₁ⁿ + a₂ⁿ + ... + a₈ⁿ

in which a₁, a₂, ..., a₈ are real numbers not all
equal to zero. Suppose that an infinite number of terms
of the sequence {cₙ} are equal to zero. Find all natural
numbers n such that cₙ = 0.
-/

namespace Imo1967P5

noncomputable def solution : (Fin 8 → ℝ) → Set ℕ := fun _ => { n | Odd n }



lemma odd_if_sum_eq_zero {α : Type*} {n : ℕ}
    (I : Finset α)
    (f : α → ℝ)
    (h : ∃ α ∈ I, f α ≠ 0)
    : ∑ i ∈ I, f i^n = 0 → Odd n := by
  intro h2
  obtain ⟨m, hm, hm2⟩ := h
  by_contra! h_not_odd
  have h_even := Nat.not_odd_iff_even.mp h_not_odd
  have h_pos : 0 < ∑ i ∈ I, f i^n := by calc
    0 < f m^n := Even.pow_pos h_even hm2
    _ ≤ ∑ i ∈ I, f i^n := Finset.single_le_sum (fun i a ↦ Even.pow_nonneg h_even (f i)) hm
  simp [h2] at h_pos

lemma aux_recursive (I : Finset (Fin 8)) (a : Fin 8 → ℝ)
    (h₁ : Set.Infinite {n | ∑ i ∈ I, a i ^ n = 0})
    (h₂ : ∃ i ∈ I, a i ≠ 0) :
    ∀ n, Odd n → ∑ i ∈ I, a i ^ n = 0 := by
  by_cases! h_empty_I : I = ∅
  · subst h_empty_I
    intro _ _
    rfl
  · obtain ⟨imax⟩ := Finset.exists_max_image I (fun i ↦ |a i|) h_empty_I
    let amax := |a imax|
    have h_pos_amax : 0 < amax := by grind
    -- Split the index set into those having the max absolute value (J) and those that do not (K)
    let J := I.filter (fun i ↦ amax ≤ |a i|)
    let K := I.filter (fun i ↦ |a i| < amax)

    -- Sum over I can be split over K and J
    have h_sum_union_eq_sum_disj : ∀ n, ∑ i ∈ I, a i^n = (∑ k ∈ K, a k^ n) + (∑ j ∈ J, a j ^ n) := by
      intro n
      have h_disj : Disjoint K J := by
        apply Finset.disjoint_left.mpr
        intro x hk hj
        grind only [= Finset.mem_filter]
      have : K ∪ J = I := by grind only [= Finset.mem_union, = Finset.mem_filter]
      rw [← this]
      exact Finset.sum_union h_disj

    -- This is the core of the actual IMO problem
    -- We prove that for large N, the sum over J is large compared to the sum over K
    -- From that we deduce that the sum over J must be zero for odd n, otherwise
    -- the sum over I cannot be zero. We then use this to reduce the problem to K
    -- and apply the lemma recursively.
    have h_sum_J_eq_zero_of_odd : ∀ n, Odd n → ∑ j ∈ J, a j ^ n = 0 := by
      -- Prepare bound q for the terms in K
      have hq : ∃ q : ℝ, 0 ≤ q ∧ q < amax ∧ ∀ k ∈ K, |a k| ≤ q := by
        by_cases! h_empty_K : K = ∅
        · use 0
          grind
        obtain ⟨kmax, h_kmax, _⟩ := Finset.exists_max_image K (fun k ↦ |a k|) h_empty_K
        use |a kmax|
        constructor
        · exact abs_nonneg (a kmax)
        constructor
        · exact (Finset.mem_filter.mp h_kmax).2
        trivial
      obtain ⟨q, h_pos_q, h_q_lt_amax, h_ak_le_q⟩ := hq
      -- Show that for large n, the bound for sum over K is small compared to amax^n
      have h_eventually_dominated : ∀ᶠ n in Filter.atTop, 8 * q^n < amax^n := by
        rw [Filter.eventually_atTop]
        by_cases! h_case : q = 0
        · use 1
          intro N h_pos_N
          simp [h_case, zero_pow (Nat.ne_zero_of_lt h_pos_N), pow_pos h_pos_amax N]
        · have h_pos_q : 0 < q := Std.lt_of_le_of_ne h_pos_q (Ne.symm h_case)
          have h_ratio_pos : 1 < amax / q := (one_lt_div₀ h_pos_q).mpr h_q_lt_amax
          have := (tendsto_pow_atTop_atTop_of_one_lt h_ratio_pos).eventually_gt_atTop 8
          obtain ⟨N, hlt⟩ := this.exists
          use N
          intro M h_M_ge_N
          calc
            8 * q^M < (amax / q)^N * q^M := by
              apply mul_lt_mul_of_pos_right hlt
              exact pow_pos h_pos_q M
            _ ≤ (amax / q)^M * q^M := by
              have : (amax / q)^N ≤ (amax / q)^M := (pow_le_pow_iff_right₀ h_ratio_pos).mpr h_M_ge_N
              aesop
            _ = amax^M := by
              rw [← mul_pow]
              congr
              field_simp
      -- Finally we are ready to obtain N where the sum over I is zero and the sum over K is small
      have h_freq := Nat.frequently_atTop_iff_infinite.mpr h₁
      obtain ⟨N, h_sum_I_pow_N_zero, h_bounds⟩ := (Filter.Frequently.and_eventually h_freq h_eventually_dominated).exists
      -- N is odd since the sum over I is zero
      have h_odd_N : Odd N := odd_if_sum_eq_zero I a h₂ h_sum_I_pow_N_zero

      let p := fun i ↦ SignType.sign (a i)

      -- The sum over J must be a multiple of amax^n (all terms have the same absolute value)
      have h_sum_I_mult_amax : ∃ m : ℤ, ∀ n, Odd n → ∑ j ∈ J, a j^n = m * amax^n := by
        have h_eq : ∀ j ∈ J, a j = (p j) * amax := by
          intro j hj
          have : |a j| = amax := by grind
          rw [← this]
          exact Eq.symm (sign_mul_abs (a j))

        use ∑ j ∈ J, p j
        intro n h_odd
        have h_eq_pow_n : ∀ j ∈ J, a j^n = (p j) * amax^n := by
          intro i hi
          have hp_pow_odd_n : ∀ i n, Odd n → p i = p i^n := by
            intro i n h_odd
            rcases SignType.trichotomy (p i) with hneg | hzero | hpos
            · simp [hneg, Odd.neg_one_pow h_odd]
            · exact Eq.symm (SignType.pow_odd (p i) h_odd)
            · simp [hpos]
          calc
            a i^n = ((p i) * amax)^n := by simp [h_eq i hi]
            _ = p i^n * amax^n := mul_pow ↑(p i) amax n
            _ = p i * amax^n := by
              field_simp
              norm_cast
              rw [← hp_pow_odd_n i n h_odd]

        rw [Int.cast_sum, Finset.sum_mul, Finset.sum_congr rfl]
        simp only [SignType.intCast_cast]
        intro i hi
        exact h_eq_pow_n i hi
      obtain ⟨m, hm⟩ := h_sum_I_mult_amax

      -- First part of proving that m must be zero.
      -- This corresponds to half of the a j = amax and half a j = -amax.
      have hmIneq : |m| * amax^N < amax^N := by
        have h_pow_ak_le_q : ∀ i ∈ K, |a i|^N ≤ q^N := by
          intro i hI
          have hq : |a i| ≤ q := by exact RCLike.ofReal_le_ofReal.mp (h_ak_le_q i hI)
          have haipos : 0 ≤ |a i| := by exact abs_nonneg (a i)
          exact pow_le_pow_left₀ haipos hq N

        calc
          |m| * amax^N = |m * amax^N| := by simp [abs_mul, abs_of_pos (pow_pos h_pos_amax N)]
          _ = |∑ k ∈ J, a k^N| := Eq.symm (congr_arg abs (hm N h_odd_N))
          _ = |∑ k ∈ I, a k^N - ∑ k ∈ K, a k^N| := by simp [h_sum_union_eq_sum_disj N, add_comm]
          _ = |∑ k ∈ K, a k^N| := by simp [h_sum_I_pow_N_zero]
          _ ≤ ∑ k ∈ K, |a k^N| := Finset.abs_sum_le_sum_abs (fun i ↦ a i ^ N) K
          _ = ∑ k ∈ K, |a k|^N := by simp
          _ ≤ ∑ k ∈ K, q^N := by exact Finset.sum_le_sum h_pow_ak_le_q
          _ = K.card * q^N := by simp
          _ ≤ 8 * q^N := by
            gcongr
            simp only [Nat.cast_le_ofNat]
            exact card_finset_fin_le K
          _ < amax^N := RCLike.ofReal_lt_ofReal.mp h_bounds

      -- Conclude that m = 0
      have hmZero : m = 0 := by
        field_simp [h_pos_amax] at hmIneq
        norm_cast at hmIneq
        exact Int.abs_lt_one_iff.mp hmIneq

      -- Finally conclude that the sum over J is zero for all odd n
      intro n h_odd
      simp [hm n h_odd, hmZero]

    -- Now proceed to prove that the sum over I is zero for all odd n
    -- We split into two cases, since if all a k are zero, the infinite sum condition
    -- does not imply that there are infinite number of odd n for which it holds.
    by_cases! hai : ∀ k ∈ K, a k = 0
    -- Simple case, all terms in sum over K are zero
    · intro N h_odd_N
      rw [h_sum_union_eq_sum_disj N]
      have h_sum_K_zero : ∑ k ∈ K, a k^N = 0 := by
        have h_terms_K_zero : ∀ k ∈ K, a k^N = 0 := by
          intro k h_k
          rw [hai k h_k]
          have h_pos_N : 0 < N := Odd.pos h_odd_N
          simp only [pow_eq_zero_iff', ne_eq, true_and]
          exact Nat.ne_zero_of_lt h_pos_N
        exact Finset.sum_eq_zero h_terms_K_zero
      rw [h_sum_J_eq_zero_of_odd N h_odd_N, h_sum_K_zero, zero_add]

    -- Interesting case, not all remaining a k are zero
    · have h_inf_sum_K_zero : Set.Infinite {n | ∑ k ∈ K, a k^n = 0} := by
        have hSame : {n | ∑ i ∈ I, a i^n = 0} = {n | ∑ k ∈ K, a k^n = 0} := by
          ext N
          simp only [Set.mem_setOf_eq]
          constructor <;> intro hS
          · have hOdd : Odd N := odd_if_sum_eq_zero I a h₂ hS
            rw [h_sum_union_eq_sum_disj, h_sum_J_eq_zero_of_odd N hOdd, add_zero] at hS
            exact hS
          · have hOdd : Odd N := odd_if_sum_eq_zero K a hai hS
            simp [h_sum_union_eq_sum_disj, h_sum_J_eq_zero_of_odd N hOdd, add_zero, hS]
        simp [← hSame, h₁]
      have h_rec := aux_recursive K a h_inf_sum_K_zero
      have h_sum : ∀ n, Odd n → (∑ k ∈ K, a k ^ n) + (∑ k ∈ J, a k ^ n) = 0 := by
        intro N h_odd
        simp_all only [add_zero, J, K]
      intro N h_odd
      rw [h_sum_union_eq_sum_disj, h_sum N h_odd]
  termination_by I.card
  decreasing_by
    have hTSubset : K ⊂ I := by grind
    exact Finset.card_lt_card hTSubset



theorem imo1967_p5 (a : Fin 8 → ℝ)
    (h₁ : Set.Infinite {n | ∑ i, a i ^ n = 0})
    (h₂ : ¬∀ i, a i = 0) :
    solution a = {n | ∑ i, a i ^ n = 0} := by
  rw [solution]
  ext N
  let I : Finset (Fin 8) := Finset.univ
  have h₃ : ∃ i ∈ I, a i ≠ 0 := by aesop
  constructor
  -- If N is odd, use the aux_recursive lemma to prove that the sum is zero
  · intro h_odd
    exact aux_recursive Finset.univ a h₁ h₃ N h_odd
  -- If sum is zero, prove that N cannot be even (all terms would be non-negative, not all zero)
  · intro h_zero_sum
    exact odd_if_sum_eq_zero Finset.univ a h₃ h_zero_sum

end Imo1967P5

-- ═══ Imo1968P6 ═══

/-
Copyright (c) 2026 lean-tom. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: lean-tom (with assistance from Gemini)
-/




/-!
# International Mathematical Olympiad 1968, Problem 6

For every natural number n, evaluate the sum
∑_{k=0}^{∞} [(n + 2^k) / 2^(k+1)]
where [x] denotes the greatest integer less than or equal to x.
-/

namespace Imo1968P6



-- Lemma for the telescoping term structure
lemma term_telescope (n k : ℕ) :
    (n + 2^k) / 2^(k+1) = n / 2^k - n / 2^(k+1) := by
  rw [pow_succ, ← Nat.div_div_eq_div_mul]
  have h_pos : 0 < 2^k := pow_pos (by norm_num) k
  rw [Nat.add_div_right n h_pos]
  -- Use the identity (a + 1) / 2 = a - a / 2
  have identity (a : ℕ) : (a + 1) / 2 = a - a / 2 := by lia
  rw [identity]
  rw [Nat.div_div_eq_div_mul, ← pow_succ]



/--
The answer is n. We pull this into a `determine` statement as required.
-/
noncomputable def n_ans (n : ℕ) : ℕ := n

theorem imo1968_p6 (n : ℕ) : ∑' k, (n + 2^k) / 2^(k+1) = n_ans n := by
  -- Proof starts here. We first unfold the answer definition.
  unfold n_ans
  -- We truncate the sum at k_max = n + 1, since terms are zero afterwards.
  let k_max := n + 1

  have sum_eq_finite : ∑' k, (n + 2^k) / 2^(k+1) =
                       ∑ k ∈ Finset.range k_max, (n + 2^k) / 2^(k+1) := by
    apply tsum_eq_sum
    intro k hk
    simp only [Finset.mem_range, not_lt] at hk
    apply Nat.div_eq_of_lt
    calc
      n + 2^k < 2^k + 2^k := by
        apply add_lt_add_left
        calc
          n < 2^n := n.lt_two_pow_self
          _ < 2^(n + 1) := Nat.pow_lt_pow_right (by norm_num) (by lia)
          _ ≤ 2^k_max := le_refl _
          _ ≤ 2^k := Nat.pow_le_pow_right (by norm_num) hk
      _ = 2^(k+1) := by rw [pow_succ, mul_two]
  rw [sum_eq_finite]

  -- Rewrite the sum using the telescoping lemma
  have sum_rewrite : ∑ k ∈ Finset.range k_max, (n + 2^k) / 2^(k+1) =
                     ∑ k ∈ Finset.range k_max, (n / 2^k - n / 2^(k+1)) := by
    apply Finset.sum_congr rfl
    intro k hk
    rw [term_telescope]
  rw [sum_rewrite]

  -- Prove the telescoping sum formula for natural numbers (requiring decreasing terms)
  have telescoping (m : ℕ) : ∑ k ∈ Finset.range m, (n / 2^k - n / 2^(k+1)) = n - n / 2^m := by
    induction m with
    | zero => simp
    | succ m hm =>
      rw [Finset.sum_range_succ, hm, Nat.sub_add_sub_cancel]
      · apply Nat.div_le_self
      · gcongr
        · norm_num
        · norm_num

  rw [telescoping k_max]

  -- Show that the remainder term is zero
  have term_vanish : n / 2^k_max = 0 := by
    apply Nat.div_eq_of_lt
    calc
      n < 2^n := n.lt_two_pow_self
      _ < 2^(n+1) := Nat.pow_lt_pow_right (by norm_num) (by lia)

  rw [term_vanish, Nat.sub_zero]

end Imo1968P6

-- ═══ Imo1969P1 ═══

/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/




/-!
# International Mathematical Olympiad 1969, Problem 1

Prove that there are infinitely many natural numbers a with the following property:
the number z = n⁴ + a is not prime for any natural number n.
-/

open Int Nat

namespace Imo1969P1



/-- `goodNats` is the set of natural numbers satisfying the condition in the problem
statement, namely the `a : ℕ` such that `n^4 + a` is not prime for any `n : ℕ`. -/
def goodNats : Set ℕ :=
  {a : ℕ | ∀ n : ℕ, ¬Nat.Prime (n ^ 4 + a)}

/--
The key to the solution is that you can factor $z$ into the product of two polynomials,
if $a = 4*m^4$. This is Sophie Germain's identity, called `pow_four_add_four_mul_pow_four`
in mathlib.
-/
theorem factorization {m n : ℤ} :
    ((n - m) ^ 2 + m ^ 2) * ((n + m) ^ 2 + m ^ 2) = n ^ 4 + 4 * m ^ 4 :=
  pow_four_add_four_mul_pow_four.symm

/-
To show that the product is not prime, we need to show each of the factors is at least 2,
which `nlinarith` can solve since they are each expressed as a sum of squares.
-/

theorem left_factor_large {m : ℤ} (n : ℤ) (h : 1 < m) : 1 < (n - m) ^ 2 + m ^ 2 := by nlinarith
theorem right_factor_large {m : ℤ} (n : ℤ) (h : 1 < m) : 1 < (n + m) ^ 2 + m ^ 2 := by nlinarith

/-
The factorization is over the integers, but we need the nonprimality over the natural numbers.
-/

theorem int_large {m : ℤ} (h : 1 < m) : 1 < m.natAbs := by
  exact_mod_cast lt_of_lt_of_le h le_natAbs

theorem not_prime_of_int_mul' {m n : ℤ} {c : ℕ} (hm : 1 < m) (hn : 1 < n) (hc : m * n = (c : ℤ)) :
    ¬Nat.Prime c :=
  not_prime_of_int_mul (int_large hm).ne' (int_large hn).ne' hc

/-- Every natural number of the form `n^4 + 4*m^4` is not prime. -/
theorem polynomial_not_prime {m : ℕ} (h1 : 1 < m) (n : ℕ) : ¬Nat.Prime (n ^ 4 + 4 * m ^ 4) := by
  have h2 : 1 < (m : ℤ) := Int.ofNat_lt.mpr h1
  refine not_prime_of_int_mul' (left_factor_large (n : ℤ) h2) (right_factor_large (n : ℤ) h2) ?_
  apply factorization

/-- We define $a_{choice}(b) := 4*(2+b)^4$, so that we can take $m = 2+b$ in `polynomial_not_prime`.
-/
def aChoice (b : ℕ) : ℕ := 4 * (2 + b) ^ 4

theorem aChoice_good (b : ℕ) : aChoice b ∈ goodNats :=
  polynomial_not_prime (show 1 < 2 + b by lia)

/-- `aChoice` is a strictly monotone function; this is easily proven by chaining together lemmas
in the `strictMono` namespace. -/
theorem aChoice_strictMono : StrictMono aChoice :=
  ((strictMono_id.const_add 2).nat_pow (by decide)).const_mul (by decide)

/- We conclude by using the fact that `aChoice` is an injective function from the natural numbers
to the set `goodNats`. -/



theorem imo1969_p1 : Set.Infinite {a : ℕ | ∀ n : ℕ, ¬Nat.Prime (n ^ 4 + a)} :=
  Set.infinite_of_injective_forall_mem aChoice_strictMono.injective aChoice_good


end Imo1969P1

-- ═══ Imo1969P2 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/





/-!
# International Mathematical Olympiad 1969, Problem 2

Let a₁, a₂, ..., aₙ be real constants, x be a real variable, and

  f(x) = cos(a₁ + x) + (1/2)cos(a₂ + x) + (1/4)cos(a₃ + x) + ...
         + (1/2ⁿ⁻¹)cos(aₙ + x).

Given that f(x₁) = f(x₂) = 0 for some x₁, x₂, prove that
x₂ - x₁ = mπ for some integer m.
-/

namespace Imo1969P2

open scoped Real

theorem imo1969_p2
    (x₁ x₂ : ℝ)
    (n : ℕ)
    (a : ℕ → ℝ)
    (f : ℝ → ℝ)
    (h₁ : ∀ x, f x = ∑ i ∈ Finset.range n, (Real.cos (a i + x)) / (2^i))
    (h₂ : f x₂ = 0)
    (h₃ : f x₁ = 0)
    (h₄: ∑ i ∈ Finset.range n, (Real.cos (a i) / (2 ^ i)) ≠ 0) :
    ∃ m : ℤ, x₂ - x₁ = m * π := by
  let Ccos := ∑ i ∈ Finset.range n, (Real.cos (a i) / (2 ^ i))
  let Csin := ∑ i ∈ Finset.range n, (Real.sin (a i) / (2 ^ i))
  have hCcos: Ccos = ∑ i ∈ Finset.range n, (Real.cos (a i) / (2 ^ i)) := rfl
  have hCsin: Csin = ∑ i ∈ Finset.range n, (Real.sin (a i) / (2 ^ i)) := rfl
  have h₅: ∀ x, f x = Ccos * Real.cos x - Csin * Real.sin x := by
    intro x
    rw [h₁ x]
    have h₅₀: ∑ i ∈ Finset.range n, (Real.cos (a i + x) / 2 ^ i)
              = ∑ i ∈ Finset.range n,
                (((Real.cos (a i) * Real.cos (x) - Real.sin (a i) * Real.sin (x)) / (2^i))) := by
      refine Finset.sum_congr (by rfl) ?_
      intro i _
      rw [Real.cos_add]
    rw [h₅₀]
    ring_nf
    rw [Finset.sum_sub_distrib]
    have h₅₂: ∑ i ∈ Finset.range n, Real.cos (a i) * Real.cos x * (2⁻¹) ^ i
            = ∑ i ∈ Finset.range n, (Real.cos (a i) * (2⁻¹) ^ i) * Real.cos x := by
      refine Finset.sum_congr (by rfl) ?_
      intro i _
      ring
    have h₅₃: ∑ x_1 ∈ Finset.range n, Real.sin (a x_1) * Real.sin x * (2⁻¹) ^ x_1
            = ∑ x_1 ∈ Finset.range n, ((Real.sin (a x_1) * (2⁻¹) ^ x_1) * Real.sin x) := by
      refine Finset.sum_congr (by rfl) ?_
      intro i _
      ring
    rw [h₅₂, ← Finset.sum_mul _ _ (Real.cos x)]
    rw [h₅₃, ← Finset.sum_mul _ _ (Real.sin x)]
    ring_nf at hCcos
    ring_nf at hCsin
    rw [hCcos, hCsin]
    ring
  have h₆: (∃ x, (f x = 0 ∧ Real.cos x = 0)) → ∀ y, f y = Ccos * Real.cos y := by
    intro g₀
    obtain ⟨x, hx₀, hx₁⟩ := g₀
    have g₁: ∑ i ∈ Finset.range n, (Real.sin (a i) / (2 ^ i)) = 0 := by
      rw [h₅ x, hx₁] at hx₀
      simp at hx₀
      obtain hx₂ | hx₃ := hx₀
      · exact hx₂
      · exfalso
        apply Real.sin_eq_zero_iff_cos_eq.mp at hx₃
        obtain hx₃ | hx₄ := hx₃
        · linarith
        · linarith
    intro y
    rw [h₅ y]
    have g₂: Csin = 0 := by linarith
    rw [g₂, zero_mul]
    exact sub_zero (Ccos * Real.cos y)
  by_cases hmn: (Real.cos x₂ = 0) ∨ (Real.cos x₁ = 0)
  · have h₇: ∀ (x : ℝ), f x = Ccos * Real.cos x := by
      refine h₆ ?_
      obtain hm | hn := hmn
      · use x₂
      · use x₁
    have h₈: ∀ x, f x = 0 → Real.cos x = 0 := by
      intro x hx₀
      rw [h₇ x] at hx₀
      refine eq_zero_of_ne_zero_of_mul_left_eq_zero ?_ hx₀
      exact h₄
    have hm₀: ∃ t:ℤ , x₂ = (2 * ↑ t + 1) * π / 2 := by
      refine Real.cos_eq_zero_iff.mp ?_
      exact h₈ x₂ h₂
    have hn₀: ∃ t:ℤ , x₁ = (2 * ↑ t + 1) * π / 2 := by
      refine Real.cos_eq_zero_iff.mp ?_
      exact h₈ x₁ h₃
    obtain ⟨tm, hm₁⟩ := hm₀
    obtain ⟨tn, hn₁⟩ := hn₀
    rw [hm₁, hn₁]
    use (tm - tn)
    rw [Int.cast_sub]
    ring_nf
  · push_neg at hmn
    have h₇: Real.tan x₂ = Real.tan x₁ := by
      have h₇₀: ∀ (x:ℝ), (f x = 0 ∧ Real.cos x ≠ 0) → Real.tan x = Ccos / Csin := by
        intro x hx₀
        rw [Real.tan_eq_sin_div_cos]
        symm
        refine (div_eq_div_iff ?_ ?_).mp ?_
        · simp
          exact hx₀.2
        · grind
        · rw [h₅ x, sub_eq_zero] at hx₀
          simp only [div_inv_eq_mul, mul_comm (Real.sin x) _]
          exact hx₀.1
      have h₇₁: Real.tan x₂ = Ccos / Csin := h₇₀ x₂ ⟨h₂, hmn.1⟩
      have h₇₂: Real.tan x₁ = Ccos / Csin := h₇₀ x₁ ⟨h₃, hmn.2⟩
      rw [h₇₁, h₇₂]
    have h₈: Real.sin (x₂ - x₁) = 0 := by
      have h₈₂: Real.sin (x₂ - x₁) / (Real.cos x₂ * Real.cos x₁) = 0 := by
        rw [Real.sin_sub]
        rw [← div_sub_div (Real.sin x₂) (Real.sin x₁) hmn.1 hmn.2]
        simp only [← Real.tan_eq_sin_div_cos]
        exact sub_eq_zero_of_eq h₇
      have h_nonzero : Real.cos x₂ * Real.cos x₁ ≠ 0 := mul_ne_zero hmn.1 hmn.2
      rw [div_eq_zero_iff, or_iff_left h_nonzero] at h₈₂
      exact h₈₂
    apply Real.sin_eq_zero_iff.mp at h₈
    let ⟨t, ht⟩ := h₈
    use t
    exact ht.symm

end Imo1969P2

-- ═══ Imo1970P3 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tomas Ortega
-/




/-!
# International Mathematical Olympiad 1970, Problem 3

 The real numbers a₀, a₁, a₂, ... satisfy 1 = a₀ ≤ a₁ ≤ a₂ ≤ ... . b₁, b₂, b₃, ... are defined by bₙ = ∑_{k=1}^{n} (1 - a_{k-1}/a_k)/√a_k.

(a)  Prove that 0 ≤ bₙ < 2.

(b)  Given c satisfying 0 ≤ c < 2, prove that we can find an so that bₙ > c for all sufficiently large n.
-/

namespace Imo1970P3


open scoped Real

/-- A sequence of real numbers satisfying the given conditions -/
structure IncreasingSequenceFromOne where
  a : ℕ → ℝ
  a_zero : a 0 = 1
  a_mono : Monotone a

/-- The b_n sequence defined in terms of the a sequence -/
noncomputable def b_seq (seq : IncreasingSequenceFromOne) (n : ℕ) : ℝ :=
  ∑ k ∈ Finset.range n, (1 - seq.a k / seq.a (k + 1)) / √ (seq.a (k + 1))

def ValidBounds : Set ℝ :=
  { b | 0 ≤ b ∧ b < 2 }



/-- Helper: c_k = √(a_k) -/
noncomputable def c_seq (seq : IncreasingSequenceFromOne) (k : ℕ) : ℝ := Real.sqrt (seq.a k)

/-- All elements of the sequence are positive -/
lemma seq_pos (seq: IncreasingSequenceFromOne) : ∀ n, 0 < seq.a n := by
  intro n
  induction n with
  | zero =>
    rw [seq.a_zero]
    exact zero_lt_one
  | succ n ih =>
    have h1 : seq.a n ≤ seq.a (n + 1) := seq.a_mono (Nat.le_succ n)
    exact lt_of_lt_of_le ih h1

/-- Key lemma: each term is bounded by 2(1/c_{k-1} - 1/c_k) -/
lemma term_bound (seq : IncreasingSequenceFromOne) (k : ℕ) :
  (1 - seq.a (k - 1) / seq.a k) / Real.sqrt (seq.a k) ≤
  2 * (1 / c_seq seq (k - 1) - 1 / c_seq seq k) := by
  -- Let c_k = √(a_k)
  have ck_pos : ∀ j, 0 < c_seq seq j := fun j => Real.sqrt_pos.mpr (seq_pos seq j)
  have ck_is_ak_squared: ∀ j, seq.a j = (c_seq seq j)^2 := by
    intro j
    simp [c_seq, Real.sq_sqrt (le_of_lt (seq_pos seq j))]

  have hcseq : c_seq seq (k - 1) ≤ c_seq seq k := Real.sqrt_le_sqrt (seq.a_mono (Nat.sub_le k 1))

  -- The term equals c_{k-1}²/c_k · (1/a_{k-1} - 1/a_k)
  have h1 : (1 - seq.a (k - 1) / seq.a k) / Real.sqrt (seq.a k) = (c_seq seq (k - 1))^2 / c_seq seq k * (1 / seq.a (k - 1) - 1 / seq.a k) := by
    simp [c_seq, Real.sq_sqrt (le_of_lt (seq_pos seq _))]
    have haUnit : IsUnit (seq.a (k - 1)) := by
      rw [isUnit_iff_ne_zero]
      let j := k - 1
      have hj : j = k-1 := rfl
      rw [←hj]
      have := seq_pos seq j
      linarith
    ring_nf
    simp [field]
    rw [IsUnit.div_mul_left haUnit]
    exact inv_eq_one_div √(seq.a k)

  -- Factor 1/a_{k-1} - 1/a_k using difference of squares
  have h2 : 1 / seq.a (k - 1) - 1 / seq.a k =
    (1 / c_seq seq (k - 1) + 1 / c_seq seq k) * (1 / c_seq seq (k - 1) - 1 / c_seq seq k) := by
    rw [ck_is_ak_squared (k-1), ck_is_ak_squared k]
    ring

  -- Show c_{k-1}²/c_k · (1/c_{k-1} + 1/c_k) ≤ 2
  have h3 : (c_seq seq (k - 1))^2 / c_seq seq k * (1 / c_seq seq (k - 1) + 1 / c_seq seq k) ≤ 2 := by
    calc
      _ = c_seq seq (k - 1) / c_seq seq k + (c_seq seq (k - 1) / c_seq seq k)^2 := by
        have := ck_pos k
        have := ck_pos (k - 1)
        field_simp
      _ ≤ 1 + 1 := by
        apply add_le_add
        · exact (div_le_one (ck_pos k)).mpr hcseq
        · rw [sq_le_one_iff_abs_le_one, abs_div, abs_of_pos (ck_pos (k-1)), abs_of_pos (ck_pos k)]
          exact (div_le_one (ck_pos k)).mpr hcseq
      _ = 2 := one_add_one_eq_two

  rw [h1, h2, ←mul_assoc]
  apply mul_le_mul_of_nonneg_right h3
  rw [sub_nonneg]
  exact one_div_le_one_div_of_le (ck_pos (k - 1)) hcseq



theorem imo1970_p3 :
    (∀ seq : IncreasingSequenceFromOne, ∀ n : ℕ, b_seq seq n ∈ ValidBounds) ∧
    (∀ c ∈ ValidBounds, ∃ seq : IncreasingSequenceFromOne, ∃ N : ℕ,
      ∀ n ≥ N, b_seq seq n > c) := by
  constructor
  /-
  Part (a): All b_n are in [0, 2)
  Each term of the sum is non-negative, so b_n is non-negative. Let c_k = √a_k. Then the kth term = (1 - a_{k-1}/a_k)/√a_k = c_{k-1}²/c_k (1/a_{k-1} - 1/a_k) = c_{k-1}²/c_k (1/c_{k-1} + 1/c_k)(1/c_{k-1} - 1/c_k). But c_{k-1}²/c_k (1/c_{k-1} + 1/c_k) ≤ 2, so the kth term ≤ 2(1/c_{k-1} - 1/c_k). Hence b_n ≤ 2 - 2/c_n < 2.
  -/
  · intro seq n
    constructor
    · -- 0 ≤ b_n
      apply Finset.sum_nonneg
      intro k hk
      have h1 : seq.a k ≤ seq.a (k + 1) := seq.a_mono (Nat.le_succ k)
      have h2 : 0 < seq.a (k + 1) := seq_pos seq (k + 1)
      have h3 : seq.a k / seq.a (k + 1) ≤ 1 := (div_le_one h2).mpr h1
      exact div_nonneg (sub_nonneg.mpr h3) (Real.sqrt_nonneg _)

    · -- b_n < 2
      cases n with
      | zero => simp only [b_seq, Finset.range_zero, Finset.sum_empty, zero_lt_two]
      | succ n =>
        -- Use telescoping sum
        -- Change of index: the k-th term for k ≥ 1 is bounded by 2(1/√a_{k-1} - 1/√a_k)
        have bound : b_seq seq (n + 1) ≤ 2 * (1 - 1 / c_seq seq (n + 1)) := by
          -- Split the sum to handle k = 0 separately
          have split_sum : b_seq seq (n + 1) =
            (1 - seq.a 0 / seq.a 1) / Real.sqrt (seq.a 1) +
            ∑ k ∈ Finset.range n, (1 - seq.a (k + 1) / seq.a (k + 2)) / Real.sqrt (seq.a (k + 2)) := by
            rw [b_seq, Finset.sum_range_succ', add_comm]

          -- Apply term_bound to each term k ≥ 1
          have sum_bound : ∑ k ∈ Finset.range n, (1 - seq.a (k + 1) / seq.a (k + 2)) / Real.sqrt (seq.a (k + 2)) ≤
            2 * ∑ k ∈ Finset.range n, (1 / c_seq seq (k + 1) - 1 / c_seq seq (k + 2)) := by
            rw [Finset.mul_sum]
            apply Finset.sum_le_sum
            intro k hk
            exact term_bound seq (k + 2)

          -- The sum telescopes
          have telescoping : ∑ k ∈ Finset.range n, (1 / c_seq seq (k + 1) - 1 / c_seq seq (k + 2)) =
            1 / c_seq seq 1 - 1 / c_seq seq (n + 1) := by
            induction n with
            | zero => simp
            | succ n ih =>
              exact Finset.sum_range_sub' (fun i ↦ 1 / c_seq seq (i + 1)) (n + 1)

          -- Handle the k = 0 term
          have first_term_bound : (1 - seq.a 0 / seq.a 1) / Real.sqrt (seq.a 1) ≤ 2 * (1 / c_seq seq 0 - 1 / c_seq seq 1) := by
            convert term_bound seq 1 using 1

          -- Combine everything
          calc b_seq seq (n + 1)
            = _ := split_sum
            _ ≤ 2 * (1 / c_seq seq 0 - 1 / c_seq seq 1) + 2 * ∑ k ∈ Finset.range n, (1 / c_seq seq (k + 1) - 1 / c_seq seq (k + 2)) := add_le_add first_term_bound sum_bound
            _ = 2 * (1 / c_seq seq 0 - 1 / c_seq seq 1) + 2 * (1 / c_seq seq 1 - 1 / c_seq seq (n + 1)) := by
              rw [telescoping]
            _ = 2 * (1 / c_seq seq 0 - 1 / c_seq seq (n + 1)) := by ring
            _ = 2 * (1 - 1 / c_seq seq (n + 1)) := by
              rw [c_seq, seq.a_zero, Real.sqrt_one]
              simp only [ne_eq, one_ne_zero, not_false_eq_true, div_self, one_div]

        -- Since c_seq seq (n + 1) > 0, we have 1 / c_seq seq (n + 1) > 0
        have pos : 0 < 1 / c_seq seq (n + 1) := by
          apply div_pos one_pos
          exact Real.sqrt_pos.mpr (seq_pos seq (n + 1))

        exact lt_of_le_of_lt bound (by linarith)

  /-
  Part (b): For each c ∈ [0, 2), there exists a sequence with b_n > c for large n
  Note that we can use d = √(c/2) for the solution, unless c = 0, in which case we can use d = 1/2.
  Let 1/√aₖ = d^k, where 0 < d < 1 is a constant, which we will choose later. Then the kth term is (1 - d²)d^k, so bₙ = d(1+d)(1 - d^n). Now take d such that d(1+d) > c, which we can do, since since d(1+d) tends to 2 when d tends to 1, and then take n sufficiently large so that bₙ > c.
  -/

  · intro c hc
    obtain ⟨hc_nonneg, hc_lt_two⟩ := hc

    have existsD : ∃ d : ℝ, 0 < d ∧ d < 1 ∧ d*(1 + d) > c := by
      by_cases h : c = 0
      · use 1 / 2
        constructor
        · exact one_half_pos
        · constructor
          · exact one_half_lt_one
          · linarith
      -- If c > 0, we can find a d such that d(1 + d) > c
      · use √ (c / 2)
        have hc : 0 < c := lt_of_le_of_ne hc_nonneg fun a ↦ h a.symm
        have hc' : 0 < c / 2 := half_pos hc
        have : c / 2 < 1 := by linarith
        have hd : 0 < √ (c / 2) := Real.sqrt_pos.mpr hc'
        constructor
        · exact hd
        · constructor
          · -- square both sides
            rwa [Real.sqrt_lt (le_of_lt hc') zero_le_one, one_pow]
          · rw [mul_add, mul_one, Real.mul_self_sqrt (le_of_lt hc')]
            suffices c / 2 < √(c / 2) by linarith
            nth_rw 1 [show c / 2 = √(c / 2) ^ 2 by rw [Real.sq_sqrt (le_of_lt hc')]]
            apply pow_lt_self_of_lt_one₀ hd _ one_lt_two
            rwa [Real.sqrt_lt' zero_lt_one, one_pow]

    obtain ⟨d, dpos, d_lt_one, d_bound⟩ := existsD
    have d_nonneg : 0 ≤ d := le_of_lt dpos
    have d_leq_one : d ≤ 1 := le_of_lt d_lt_one
    have d_neq_one : d ≠ 1 := Ne.symm (ne_of_gt d_lt_one)
    have one_minus_d_neq_zero : 1 - d ≠ 0 := sub_ne_zero_of_ne (id (Ne.symm d_neq_one))
    have daux : d * (1 + d) > 0 := mul_pos dpos (add_pos one_pos dpos)


    -- Define the geometric sequence aₙ = d^(-k/2)
    let a_seq : IncreasingSequenceFromOne := {
      a := fun k => d^(-(k:ℝ) * 2)
      a_zero := by simp
      a_mono := by
        intro i j hij
        aesop
    }

    use a_seq

    let N := Nat.ceil (1 + Real.log (1 - c / (d * (1 + d))) / Real.log d)

    use N
    intro n hn

    dsimp [b_seq, a_seq]
    simp only [neg_mul, Nat.cast_add, Nat.cast_one, neg_add_rev, gt_iff_lt]
    calc
      c < d * (1 + d) * (1 - d ^ N) := by
        -- divide both sides by d * (1 + d)
        rw [←inv_mul_lt_iff₀ daux]
        suffices d ^ N < 1 - (d * (1 + d))⁻¹ * c by linarith
        rw [←Real.log_lt_log_iff]
        · rw [Real.log_pow d N]
          suffices Real.log (1 - (d * (1 + d))⁻¹ * c) / Real.log d < ↑N by
            rwa [←div_lt_iff_of_neg (Real.log_neg dpos d_lt_one)]
          calc
            _ < 1 + Real.log (1 - (d * (1 + d))⁻¹ * c) / Real.log d := lt_one_add _
            _ = 1 + Real.log (1 - c / (d * (1 + d))) / Real.log d := by field_simp
            _ ≤ _ := by apply Nat.le_ceil
        · exact pow_pos dpos N
        · suffices (d * (1 + d))⁻¹ * c < 1 by linarith
          rwa [inv_mul_lt_one₀ daux]
      _ ≤ d * (1 + d) * (1 - d ^ (n:ℝ)) := by
        norm_cast
        apply mul_le_mul_of_nonneg_left _ (le_of_lt daux)
        apply tsub_le_tsub (le_refl 1)
        exact pow_le_pow_of_le_one d_nonneg d_leq_one hn
      _ = ∑ x ∈ Finset.range n, (1 - d^2) * d^(x + 1) := by
        rw [←Finset.mul_sum]
        have : ∑ i ∈ Finset.range n, d ^ (i + 1) = d * ∑ i ∈ Finset.range n, d ^ i := by
          rw [Finset.mul_sum]
          congr
          ring_nf
        rw [this, geom_sum_eq d_neq_one n]
        norm_cast
        calc
          _ = (1 - d ^ 2) * (d * ((1 - d ^ n) * (1 - d)⁻¹)) := by
            field_simp
            ring_nf
          _ = (1 - d ^ 2) * (d * (-(1 - d ^ n) / -(1 - d))) := by rw [←div_eq_mul_inv, neg_div_neg_eq]
          _ = _ := by ring_nf
      _ = _ := by
        congr
        ext x
        have : √(d ^ ((-1 + -(x:ℝ)) * 2)) = d ^ ((-1 + -(x:ℝ))) := by
          rw [Real.sqrt_eq_rpow, ←Real.rpow_mul d_nonneg]
          ring_nf
        rw [this]
        field_simp
        calc
          _ = (1 - d ^ 2) * (d ^ (x + 1) * d ^ (-(1 + (x:ℝ)))) * d ^ (-(1 + (x:ℝ)) * 2) := by ring_nf
          _ = (1 - d ^ 2) * (d ^ ((-1 + -(x:ℝ)) * 2)) := by
            suffices d ^ (x + 1) * d ^ (-(1 + (x:ℝ))) = 1 by
              rw [this, mul_one, neg_add_rev, add_comm]
            rw [Real.rpow_neg d_nonneg, add_comm]
            norm_cast
            field_simp
          _ = _ := by
            ring_nf
            rw [add_comm]
            suffices d ^ 2 * d ^ (-2 - (x:ℝ) * 2) = d ^ (-((x:ℝ ) * 2)) by
              rw [this]
              rfl
            calc
              _ = d ^ (2 + (-2 - (x:ℝ) * 2)) := by
                rw [Real.rpow_add dpos, Real.rpow_ofNat]
              _ = _ := by ring_nf

end Imo1970P3

-- ═══ Imo1971P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Francesco Cappetti
-/





/-!
# International Mathematical Olympiad 1971, Problem 1

Prove that the following assertion is true for n = 3 and n = 5, and that it is
false for every other natural number n > 2:

If a1, a2, ..., an are arbitrary real numbers, then
(a1 − a2)(a1 − a3) · · · (a1 − an) + (a2 − a1)(a2 − a3) · · · (a2 − an)
+ · · · + (an − a1)(an − a2) · · · (an − an−1) ≥ 0
-/

namespace Imo1971P1

def E {n : ℕ} (a : Fin n → ℝ) : ℝ :=
  ∑ i, ∏ j ≠ i, (a i - a j)

def P (n : ℕ) : Prop :=
  ∀ (a : Fin n → ℝ), E a ≥ 0



-- This makes working with the sum easier and simp more powerful.
lemma prod_ne_eq_prod_ite {n : ℕ} {i : Fin n} {a : Fin n → ℝ} : ∏ j ≠ i, (a i - a j) = ∏ j, if j = i then 1 else a i - a j := by
  rw [← Finset.mul_prod_erase Finset.univ _ (Finset.mem_univ i)]
  grind [Finset.prod_congr]

-- A proof that E a = E b, where b is obtained by permuting a's indices.
lemma E_equiv_perm {n : ℕ} {a b : Fin n → ℝ} (h : ∃ σ : Equiv.Perm (Fin n), b = a ∘ σ) : E a = E b := by
  obtain ⟨σ, hσ⟩ := h
  simp [E]
  apply Finset.sum_equiv (e := σ.symm) (by simp)
  intro i hi
  apply Finset.prod_equiv (e := σ.symm) (by simp)
  intro j hj
  simp [hσ, Equiv.apply_symm_apply]

-- This gets a permutation of the indices of a such that the resulting sequence is antitone.
-- Uses Tuple.sort (which gives monotone) composed with Fin.revPerm (which reverses) to get antitone.
lemma antitone_of_monotone_comp_rev {n : ℕ} (f : Fin n → ℝ) (σ : Equiv.Perm (Fin n))
    (hm : Monotone (f ∘ σ)) : Antitone (f ∘ σ ∘ Fin.revPerm) := by
  intro i j hij
  simp only [Function.comp_apply]
  exact hm (by simp [Fin.revPerm_apply, Fin.rev_le_rev, hij])

lemma exists_antitone_perm {n : ℕ} (a : Fin n → ℝ) :
    ∃ b, ∃ σ : Equiv.Perm (Fin n), b = a ∘ σ ∧ Antitone b := by
  let σ : Equiv.Perm (Fin n) := Tuple.sort a * Fin.revPerm
  use a ∘ σ, σ
  constructor
  · rfl
  · simp only [σ, Equiv.Perm.coe_mul, Function.comp_def]
    exact antitone_of_monotone_comp_rev a _ (Tuple.monotone_sort a)



theorem imo1971_p1 : P 3 ∧ P 5 ∧ ∀ n > 2, n ≠ 3 ∧ n ≠ 5 → ¬P n := by
  -- Solution from https://artofproblemsolving.com/wiki/index.php/1971_IMO_Problems/Problem_1

  -- Note that indices start from 0 in the formalization

  -- Show that P is false for even n > 2
  have h1 : ∀ n > 2, Even n → ¬P n := by
    intro n n_gt_2 n_even

    have n_pos : 0 < n := by omega

    -- Rewriting now lets us decompose the sum later
    rw [show n = n - 1 + 1 by omega]
    simp [P]

    -- Our counterexample
    let a : Fin (n - 1 + 1) → ℝ := fun i ↦ if i = 0 then -1 else 0
    use a

    rw [E, Fin.sum_univ_succ]

    -- Show that the first term is negative
    have h₀ : ∏ j ≠ 0, (a 0 - a j) = -1 := by
      rw [prod_ne_eq_prod_ite]
      simp [Finset.prod, a, Odd.neg_one_pow (Nat.Even.sub_odd n_pos n_even odd_one)]

    -- Show that the sum of the remaining terms is zero, by showing that every remaining term is zero
    have h₁ : ∑ i : Fin (n - 1), ∏ j ≠ i.succ, (a i.succ - a j) = 0 := by
      apply Finset.sum_eq_zero
      intro i hi
      rw [Finset.prod_eq_zero_iff]
      by_cases hi' : i.succ = ⟨2, by linarith [Nat.sub_one_add_one_eq_of_pos n_pos]⟩
      · use ⟨1, by linarith [Nat.sub_one_add_one_eq_of_pos n_pos]⟩
        simp [hi', a]
      · use ⟨2, by linarith [Nat.sub_one_add_one_eq_of_pos n_pos]⟩
        simp [hi', a, eq_comm]

    -- Close the goal
    linarith

  -- Show that P is false for n ≥ 7
  have h2 : ∀ n ≥ 7, Odd n → ¬P n := by
    intro n n_ge_7 n_odd

    have n_pos : 4 ≤ n := by omega

    -- Rewriting now lets us decompose the sum later
    rw [show n = n - 4 + 4 by omega]
    simp [P]

    -- Our counterexample
    let a : Fin (n - 4 + 4) → ℝ := fun i ↦ if i = 0 then 2 else if i = 1 ∨ i = 2 ∨ i = 3 then 1 else 3
    use a

    simp [E, Fin.sum_univ_succ]

    -- Show that the first term is negative
    have h₀ : ∏ j ≠ 0, (a 0 - a j) < 0 := by
      rw [prod_ne_eq_prod_ite]
      have h_0 : Fin.succ (2 : Fin (n - 4 + 3)) = 3 := rfl
      have h_1 {i : Fin (n - 4)} : i.succ.succ.succ.succ ≠ 1 := not_eq_of_beq_eq_false rfl
      have h_2 {i : Fin (n - 4)} : i.succ.succ.succ.succ ≠ 2 := not_eq_of_beq_eq_false rfl
      have h_3 {i : Fin (n - 4)} : i.succ.succ.succ.succ ≠ 3 := not_eq_of_beq_eq_false rfl
      simp [Fin.prod_univ_succ, a, h_0,  h_1, h_2, h_3]
      calc ((2 : ℝ) - 1) * ((2 - 1) * ((2 - 1) * (2 - 3) ^ (n - 4)))
        _ = (-1) ^ (n - 4) := by norm_num
        _ < 0 := by simp [Odd.neg_one_pow (Nat.Odd.sub_even (by omega) n_odd (by decide))]

    -- Prove that the second, third and fourth terms are zero
    have h₁ : ∏ j ≠ 1, (a 1 - a j) = 0 := by
      rw [Finset.prod_eq_zero_iff]
      use ⟨2, by omega⟩
      simp [a]
      norm_cast
    have h₂ : ∏ j ≠ 2, (a 2 - a j) = 0 := by
      rw [prod_ne_eq_prod_ite, Finset.prod_eq_zero_iff]
      use ⟨1, by omega⟩
      simp [a]
      norm_cast
    have h₃ : ∏ j ≠ Fin.succ 2, (a (Fin.succ 2) - a j) = 0 := by
      rw [prod_ne_eq_prod_ite, Finset.prod_eq_zero_iff]
      use ⟨1, by omega⟩
      simp [a]
      norm_cast

    -- Show that the sum of the remaining terms is zero, by showing that every remaining term is zero
    have h₄ : ∑ i : Fin (n - 4), ∏ j ≠ i.succ.succ.succ.succ, (a i.succ.succ.succ.succ - a j) = 0 := by
      apply Finset.sum_eq_zero
      intro i hi
      apply Finset.prod_eq_zero_iff.mpr
      by_cases hi' : i.succ.succ.succ.succ = ⟨4, by omega⟩
      · use ⟨5, by omega⟩
        simp [hi', a]
        norm_cast
      · use ⟨4, by omega⟩
        simp [hi', a, eq_comm]
        norm_cast

    -- Close the goal
    linarith

  -- Case n = 3
  constructor
  · simp [P]
    intro a

    -- WLOG we assume that a is sorted in non-increasing order
    wlog h : a 0 ≥ a 1 ∧ a 1 ≥ a 2
    · -- We need to show that we can always "go back" to the sorted case
      obtain ⟨b, ⟨σ, ⟨hσ, b_Antitone⟩⟩⟩ := exists_antitone_perm a

      -- We can now prove that b is sorted
      have b0_ge_b1 : b 0 ≥ b 1 := b_Antitone (by simp)
      have b1_ge_b2 : b 1 ≥ b 2 := b_Antitone (by simp)

      rw [E_equiv_perm ⟨σ, hσ⟩]
      exact this h1 h2 b ⟨b0_ge_b1, b1_ge_b2⟩
    · -- Unfold the expression, as n is small
      simp [E, prod_ne_eq_prod_ite]
      simp [Finset.sum, Finset.prod]

      -- Show that the sum of the first two terms is non-negative
      have h₁ : 0 ≤ (a 0 - a 1) * (a 0 - a 2) + (a 1 - a 0) * (a 1 - a 2) := by
        rw [← sub_neg_eq_add, sub_nonneg]
        calc -((a 1 - a 0) * (a 1 - a 2))
          _ = (a 0 - a 1) * (a 1 - a 2) := by rw [← neg_sub, neg_mul, neg_neg]
          _ ≤ (a 0 - a 1) * (a 0 - a 2) := by apply mul_le_mul <;> linarith

      -- Show that the third term is also non-negative
      have h₂ : 0 ≤ (a 2 - a 0) * (a 2 - a 1) := by apply mul_nonneg_of_nonpos_of_nonpos <;> linarith

      -- Close the goal
      linarith

  -- Case n = 5
  constructor
  · simp [P]

    -- WLOG we assume that a is sorted in non-increasing order
    intro a
    wlog h : a 0 ≥ a 1 ∧ a 1 ≥ a 2 ∧ a 2 ≥ a 3 ∧ a 3 ≥ a 4
    · -- We need to show that we can always "go back" to the sorted case
      obtain ⟨b, ⟨σ, ⟨hσ, b_Antitone⟩⟩⟩ := exists_antitone_perm a

      -- We can now prove that b is sorted
      have b0_ge_b1 : b 0 ≥ b 1 := b_Antitone (by simp)
      have b1_ge_b2 : b 1 ≥ b 2 := b_Antitone (by simp)
      have b2_ge_b3 : b 2 ≥ b 3 := b_Antitone (by simp)
      have b3_ge_b4 : b 3 ≥ b 4 := b_Antitone (by simp)

      rw [E_equiv_perm ⟨σ, hσ⟩]
      exact this h1 h2 b ⟨b0_ge_b1, ⟨b1_ge_b2, ⟨b2_ge_b3, b3_ge_b4⟩⟩⟩
    · -- Unfold the expression, as n is small
      simp [E, prod_ne_eq_prod_ite]
      simp [Finset.sum, Finset.prod]

      -- Show that the sum of the first two terms is non-negative
      have h₁ : 0 ≤ (a 0 - a 1) * ((a 0 - a 2) * ((a 0 - a 3) * (a 0 - a 4))) +
          (a 1 - a 0) * ((a 1 - a 2) * ((a 1 - a 3) * (a 1 - a 4))) := by
        rw [← neg_sub (a 0) (a 1), neg_mul, ← sub_eq_add_neg, ← mul_sub]
        apply mul_nonneg
        · linarith
        · rw [sub_nonneg]
          apply mul_le_mul
          · linarith
          · apply mul_le_mul <;> linarith
          · apply mul_nonneg <;> linarith
          · linarith

      -- Show that the third term is non-negative
      have h₂ : 0 ≤ (a 2 - a 0) * ((a 2 - a 1) * ((a 2 - a 3) * (a 2 - a 4))) := by
        rw [← neg_sub (a 0) (a 2), ← neg_sub (a 1) (a 2), ← mul_assoc, neg_mul_neg]
        apply mul_nonneg <;> apply mul_nonneg <;> linarith

      -- Show that the sum of the last two terms is non-negative
      have h₃ : 0 ≤ (a 3 - a 0) * ((a 3 - a 1) * ((a 3 - a 2) * (a 3 - a 4))) +
          (a 4 - a 0) * ((a 4 - a 1) * ((a 4 - a 2) * (a 4 - a 3))) := by
        simp [← mul_assoc]
        rw [← neg_sub (a 3) (a 4), mul_neg, ← sub_eq_add_neg, ← sub_mul]
        have hp : (a 3 - a 0) * (a 3 - a 1) * (a 3 - a 2) = -((a 0 - a 3) * (a 1 - a 3) * (a 2 - a 3)) := by linarith
        have hq : (a 4 - a 0) * (a 4 - a 1) * (a 4 - a 2) = -((a 0 - a 4) * (a 1 - a 4) * (a 2 - a 4)) := by linarith
        rw [hp, hq, sub_neg_eq_add, add_comm, ← sub_eq_add_neg]
        apply mul_nonneg
        · rw [sub_nonneg]
          apply mul_le_mul
          · apply mul_le_mul <;> linarith
          · linarith
          · linarith
          · apply mul_nonneg <;> linarith
        · linarith

      -- Close the goal
      linarith

  -- Case n > 2
  · grind


end Imo1971P1

-- ═══ Imo1971P5 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 1971, Problem 5

Prove that for every natural number m there exists a nonempty finite
set S of points in the plane with the following property:
For every point s in S, there are exactly m points which are at a unit
distance from s.
-/

namespace Imo1971P5

open scoped EuclideanGeometry

abbrev Pt := EuclideanSpace ℝ (Fin 2)



lemma norm_one_infinity : {p : Pt | ‖p‖ = 1}.Infinite := by
  set f := fun n : ℕ+ ↦ (!₂[1 / n, √(n ^ 2 - 1) / n] : Pt) with hf
  have h' : ∀ n : ℕ+, (0 : ℝ) ≤ ↑↑n ^ 2 - 1 := by
    intro n
    rw [sub_nonneg]
    norm_cast
    exact PNat.one_le (n ^ 2)
  have hf' : (Set.range f) ⊆ {p : Pt | ‖p‖ = 1} := by
    intro p hp
    rcases hp with ⟨n, hn⟩
    dsimp
    rw [← hn, hf]
    dsimp
    rw [EuclideanSpace.norm_eq]
    simp
    field_simp
    rw [pow_two, Real.mul_self_sqrt (h' n)]
    ring
  apply Set.Infinite.mono hf'
  apply Set.infinite_range_of_injective
  intro n m hfnm
  rw [hf] at hfnm
  simp at hfnm
  exact hfnm.left

universe u

lemma exists_three_of_infinite
  {α : Type u} {s : Set α} (hs : s.Infinite)
  : ∃ p q r : α, p ∈ s ∧ q ∈ s ∧ r ∈ s
    ∧ p ≠ q ∧ q ≠ r ∧ r ≠ p := by
  have h₁ : s.Nonempty := hs.nonempty
  rw [Set.nonempty_def] at h₁
  rcases h₁ with ⟨p, hp⟩
  have h₂ : (s \ {p}).Nonempty := by
    apply Set.Infinite.nonempty
    apply Set.Infinite.diff hs
    apply Set.finite_singleton
  rcases h₂ with ⟨q, hq⟩
  have h₃ : (s \ {p, q}).Nonempty := by
    apply Set.Infinite.nonempty
    apply Set.Infinite.diff hs
    exact Set.toFinite {p, q}
  rcases h₃ with ⟨r, hr⟩
  rw [Set.mem_diff] at hq hr
  rw [Set.mem_insert_iff] at hr
  rw [Set.mem_singleton_iff] at hq hr
  use p, q, r
  grind only

lemma sphere_inter_finite
  {s₁ s₂ : EuclideanGeometry.Sphere Pt} (hs : s₁ ≠ s₂) :
  ((s₁ : Set Pt) ∩ s₂).Finite := by
  by_contra! h'
  rcases exists_three_of_infinite h' with ⟨p, q, r, hp, hq, hr, hpq, hqr, hrp⟩
  have hd : Module.finrank ℝ (EuclideanSpace ℝ (Fin 2)) = 2 := finrank_euclideanSpace_fin
  rw [Set.mem_inter_iff, EuclideanGeometry.Sphere.mem_coe, EuclideanGeometry.Sphere.mem_coe] at hp hq hr
  have h'' := EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two
    hd hs hpq hp.left hq.left hr.left hp.right hq.right hr.right
  grind only

lemma sphere_eq_sub_norm (o : Pt) (r : ℝ)
  : {p : Pt | ‖p - o‖ = r} = (EuclideanGeometry.Sphere.mk o r : Set Pt) := by
  ext p
  rw [EuclideanGeometry.Sphere.mem_coe, EuclideanGeometry.mem_sphere]
  dsimp
  rw [dist_eq_norm]

lemma norm_one_inter_finite {s : Pt} (hs : s ≠ 0)
  : ({p : Pt | ‖p - 0‖ = 1} ∩ {p : Pt | ‖p - s‖ = 1}).Finite := by
  rw [sphere_eq_sub_norm 0 1, sphere_eq_sub_norm s 1]
  apply sphere_inter_finite
  rw [ne_eq, EuclideanGeometry.Sphere.ext_iff]
  dsimp
  rw [and_iff_left rfl, ← ne_eq]
  symm
  exact hs

lemma finite₁ {S : Set Pt} (hS : S.Finite)
  : {p | ∃ s t, s ∈ S ∧ t ∈ S ∧ s - t = p}.Finite := by
  have h' : {p | ∃ s t, s ∈ S ∧ t ∈ S ∧ s - t = p}
    = ⋃ s ∈ S, ⋃ t ∈ S, {s - t} := by
    ext p
    simp
    constructor <;> rintro ⟨s, hs, t, ht, hstp⟩ <;> use s <;> rw [and_iff_right hs]
      <;> use t <;> rw [and_iff_right ht, hstp]
  rw [h']
  apply Set.Finite.biUnion hS
  intro s hs
  apply Set.Finite.biUnion hS
  intro t ht
  apply Set.finite_singleton

lemma finite₂ {S : Set Pt} (hS : S.Finite)
  : {p : Pt | ∃ (s t : Pt), s ∈ S ∧ t ∈ S ∧ s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1}.Finite := by
  have h' : {p : Pt | ∃ (s t : Pt), s ∈ S ∧ t ∈ S ∧ s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1}
    = ⋃ s ∈ S, ⋃ t ∈ S, {p : Pt | s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1} := by
    ext p
    simp
    constructor <;> rintro ⟨s, hs, t, ht, hstp⟩ <;> use s <;> rw [and_iff_right hs]
      <;> use t <;> rw [and_iff_right ht] <;> grind only
  rw [h']
  apply Set.Finite.biUnion hS
  intro s hs
  apply Set.Finite.biUnion hS
  intro t ht
  by_cases! hst : s = t
  · have h'' :  {p | s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1} = ∅ := by
      rw [Set.eq_empty_iff_forall_notMem]
      intro p
      contrapose! hst
      dsimp at hst
      exact hst.left
    rw [h'']
    exact Set.finite_empty
  · have h'' :  {p | s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1}
      = {p : Pt | ‖p - 0‖ = 1} ∩ {p : Pt | ‖p - (s - t)‖ = 1} := by
      ext p
      simp [- ne_eq]
      rw [and_iff_right hst]
      constructor <;> rintro ⟨hp₁, hp₂⟩ <;> rw [and_iff_right hp₁, ← hp₂]
        <;> rw [← sub_add, dist_comm, dist_eq_norm] <;> abel_nf
    rw [h'']
    rw [← sub_eq_zero.ne] at hst
    exact norm_one_inter_finite hst



theorem imo1971_p5 (m : ℕ) :
    ∃ S : Set Pt, S.Nonempty ∧ S.Finite ∧
      ∀ s ∈ S, {t ∈ S | dist s t = 1}.encard = m := by
  induction' m with m h
  · have h_pt : Nonempty Pt := by
      apply Infinite.nonempty
    rw [← exists_true_iff_nonempty] at h_pt
    rcases h_pt with ⟨p⟩
    use {p}
    constructorm* _ ∧ _
    · apply Set.singleton_nonempty
    · apply Set.finite_singleton
    · intro s hs
      rw [Nat.cast_zero, Set.encard_eq_zero, Set.eq_empty_iff_forall_notMem]
      rintro t ⟨ht, hst⟩
      rw [Set.mem_singleton_iff] at hs ht
      contrapose! hst
      rw [hs, ht, dist_self]
      norm_num
  · rcases h with ⟨S', ⟨hS'₁, hS'₂, hS'₃⟩⟩
    have hd_set : ({p : Pt | ‖p‖ = 1}
      \ ({p : Pt | ∃ (s t : Pt), s ∈ S' ∧ t ∈ S' ∧ s - t = p}
      ∪ {p : Pt | ∃ (s t : Pt), s ∈ S' ∧ t ∈ S' ∧ s ≠ t ∧ ‖p‖ = 1 ∧ dist s (t + p) = 1})).Nonempty := by
      apply Set.Infinite.nonempty
      apply Set.Infinite.diff
      · exact norm_one_infinity
      · apply Set.Finite.union
        · exact finite₁ hS'₂
        · exact finite₂ hS'₂
    rw [← Set.diff_diff] at hd_set
    rcases hd_set with ⟨d, ⟨⟨hd₁, hd₂⟩, hd₃⟩⟩
    dsimp at hd₁ hd₂ hd₃
    push_neg at hd₂ hd₃
    set f := fun p ↦ p + d with hf
    set S'' := {p : Pt | ∃ p' ∈ S', p = p' + d} with hS''
    have h'S'' : S'' = f '' S' := by
      ext p
      rw [Set.mem_image, hS'']
      dsimp
      constructor <;> rintro ⟨p', ⟨hp'₁, hp'₂⟩⟩ <;> use p' <;> rw [and_iff_right hp'₁]
        <;> symm <;> exact hp'₂
    have hS''₁ : S''.Nonempty := by
      rw [h'S'', Set.image_nonempty]
      exact hS'₁
    have hS''₂ : S''.Finite := by
      rw [h'S'']
      apply Set.Finite.image
      exact hS'₂
    have hf' : Function.Injective f := add_left_injective d
    have hf'' : ∀ s ∈ S', {t | t ∈ f '' S' ∧ dist (f s) t = 1} = f '' {t | t ∈ S' ∧ dist s t = 1} := by
      intro s hs
      ext t
      rw [Set.mem_image]
      dsimp
      rw [Set.mem_image, hf]
      dsimp
      constructor
      · rintro ⟨⟨t', ⟨ht', ht't⟩⟩, hst⟩
        use t'
        constructorm* _ ∧ _
        · exact ht'
        · rw [← ht't, dist_add_right] at hst
          exact hst
        · exact ht't
      · rintro ⟨t', ⟨⟨ht', hst'⟩, ht't⟩⟩
        constructor
        · use t'
        · rw [← ht't, dist_add_right, hst']
    have hS''₃ : ∀ s ∈ S'', {t | t ∈ S'' ∧ dist s t = 1}.encard = ↑m := by
      intro s hs
      rw [h'S''] at hs ⊢
      rcases hs with ⟨s', ⟨hs'S', hfs's⟩⟩
      rw [← hS'₃ s' hs'S', ← hfs's, hf'' s' hs'S']
      apply Function.Injective.encard_image hf'
    clear hf' hf'' h'S''
    use S' ∪ S''
    constructorm* _ ∧ _
    · rw [Set.union_nonempty]
      left
      exact hS'₁
    · apply Set.Finite.union hS'₂ hS''₂
    · intro s hs
      wlog hsS' : s ∈ S' generalizing S' d
      · have hsS'' : s ∈ S'' := by
          rw [Set.mem_union, or_iff_right hsS'] at hs
          exact hs
        have hd'₁ : ‖-d‖ = 1 := by
          rw [norm_neg, hd₁]
        have hd'₂ : ∀ (s t : Pt), s ∈ S'' → t ∈ S'' → s - t ≠ -d := by
          intro s t hs ht
          rcases hs with ⟨s', ⟨hs', hss'd⟩⟩
          rcases ht with ⟨t', ⟨ht', htt'd⟩⟩
          rw [hss'd, htt'd, ← neg_eq_iff_eq_neg.ne, (by abel : -(s' + d - (t' + d)) = t' - s')]
          apply hd₂ t' s' ht' hs'
        have hd'₃ : ∀ (s t : Pt), s ∈ S'' → t ∈ S'' → s ≠ t → ‖-d‖ = 1 → dist s (t + -d) ≠ 1 := by
          intro s t hs ht hst hd
          rw [hS''] at hs ht
          rcases hs with ⟨s', ⟨hs', hss'd⟩⟩
          rcases ht with ⟨t', ⟨ht', htt'd⟩⟩
          rw [hss'd, htt'd, ← sub_eq_add_neg, add_sub_cancel_right, dist_comm]
          rw [hss'd, htt'd, add_right_cancel_iff.ne,] at hst
          apply hd₃ t' s' ht' hs' hst.symm hd₁
        have hS'''_eq_S' : {p | ∃ p' ∈ S'', p = p' + -d} = S' := by
          rw [hS'']
          ext p
          constructor
          · rintro ⟨p', ⟨⟨p'', ⟨hp''S', hp''⟩⟩, hp'⟩⟩
            rw [hp', hp'', ← sub_eq_add_neg, add_sub_cancel_right]
            exact hp''S'
          · intro hp
            use p + d
            constructor
            · use p
            · rw [← sub_eq_add_neg, add_sub_cancel_right]
        rw [← hS'''_eq_S'] at hS'₁ hS'₂ hS'₃ hs
        rw [Set.union_comm] at hs
        have h := this S'' hS''₁ hS''₂ hS''₃ (-d)
          hd'₁ hd'₂ hd'₃ rfl rfl hS'₁ hS'₂ hS'₃ hs hsS''
        rw [hS'''_eq_S', Set.union_comm] at h
        exact h
      have heq : {t | t ∈ S' ∪ S'' ∧ dist s t = 1} = {t | t ∈ S' ∧ dist s t = 1} ∪ {s + d} := by
        ext t
        rw [Set.mem_union, Set.mem_singleton_iff]
        constructor
        · rintro ⟨ht, hts⟩
          rw [Set.mem_union] at ht
          rcases ht with htS'|htS''
          · left
            exact ⟨htS', hts⟩
          · right
            rw [hS''] at htS''
            rcases htS'' with ⟨s', ⟨hs'S', hts'd⟩⟩
            by_cases! hss' : s = s'
            · rw [hts'd, hss']
            · rw [hts'd] at hts
              contrapose! hts
              apply hd₃ s s' hsS' hs'S' hss' hd₁
        · rintro (⟨htS', hts⟩|htsd)
          · dsimp
            rw [and_iff_left hts]
            apply Set.mem_union_left
            exact htS'
          · constructor
            · apply Set.mem_union_right
              rw [hS'']
              use s
            · rw [← sub_eq_iff_eq_add'] at htsd
              rw [dist_eq_norm', htsd, hd₁]
      rw [heq]
      have h_disj : Disjoint {t | t ∈ S' ∧ dist s t = 1} {s + d} := by
        rw [Set.disjoint_singleton_right]
        rintro ⟨h'⟩
        set t := s + d with ht
        rw [← sub_eq_iff_eq_add'] at ht
        contrapose! ht
        apply hd₂ t s h' hsS'
      rw [Set.encard_union_eq h_disj, Set.encard_singleton, hS'₃ s hsS', Nat.cast_add, Nat.cast_one]


end Imo1971P5

-- ═══ Imo1972P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1972, Problem 1

Prove that from a set of ten distinct two-digit numbers (in
decimal), it is possible to select two disjoint subsets whose
members have the same sum.
-/

namespace Imo1972P1

theorem imo1972_p1 (S : Finset ℕ)
    (Scard : S.card = 10)
    (Sdigits : ∀ n ∈ S, (Nat.digits 10 n).length = 2) :
    ∃ S1 S2 : Finset ℕ, S1 ⊆ S ∧ S2 ⊆ S ∧
       Disjoint S1 S2 ∧ ∑ n ∈ S1, n = ∑ n ∈ S2, n := by
  -- https://prase.cz/kalva/imo/isoln/isoln721.html
  replace Sdigits : S ⊆ Finset.Ico 10 100 := by
    have one_lt_ten : 1 < 10 := by norm_num
    intro n hn
    have h2 := Sdigits n hn
    have h3 : n < 10 ^ ((Nat.digits 10 n).length) :=
      Nat.lt_base_pow_length_digits one_lt_ten

    have h4 : n ≠ 0 := by rintro rfl; norm_num at h2
    have h5 := Nat.base_pow_length_digits_le _ n one_lt_ten h4
    rw [h2] at h3 h5
    rw [sq] at h5
    have h6 : 10 ≤ n := by lia
    rw [Finset.mem_Ico]
    exact ⟨h6, h3⟩
  have h2 := Finset.card_powerset S
  rw [Scard] at h2
  have h3 : ∀ s ∈ Finset.powerset S, ∑ n ∈ s, n ∈ Finset.range 991 := by
    intro s hs
    have h4 : ∀ n ∈ s, n ≤ 99 := by
      intro n hn
      have h5 : n ∈ Finset.Ico 10 100 := by
        rw [Finset.mem_powerset] at hs
        exact Sdigits (hs hn)
      rw [Finset.mem_Ico] at h5
      lia

    have h5 : ∑ n ∈ s, n ≤ ∑ n ∈ s, 99 := Finset.sum_le_sum h4
    simp only [Finset.sum_const, smul_eq_mul] at h5
    have h6 : s.card ≤ S.card := by
      rw [Finset.mem_powerset] at hs
      exact Finset.card_le_card hs
    rw [Finset.mem_range]
    lia
  let t : Finset ℕ := Finset.range 991
  have h7 : t.card = 991 := Finset.card_range _
  have h8 : t.card < S.powerset.card := by lia
  replace h3 : Set.MapsTo _ _ _ := h3
  have h9 := Finset.exists_ne_map_eq_of_card_lt_of_maps_to h8 h3
  obtain ⟨A, hA, B, hB, hAB1, hAB2⟩ := h9
  let C := A ∩ B
  let A' := A \ C
  let B' := B \ C
  refine ⟨A', B', ?_, ?_, ?_, ?_⟩
  · have h10 : A' ⊆ A := Finset.sdiff_subset
    have h11 : A ⊆ S := Finset.mem_powerset.mp hA
    exact h10.trans h11
  · have h10 : B' ⊆ B := Finset.sdiff_subset
    have h11 : B ⊆ S := Finset.mem_powerset.mp hB
    exact h10.trans h11
  · rw[Finset.disjoint_iff_ne]
    intro a ha b hb
    clear h2 h3 h7 h8 Sdigits Scard hA hB
    aesop
  · have h12 : C ⊆ A := Finset.inter_subset_left
    have h13 : C ⊆ B := Finset.inter_subset_right
    have h14 := Finset.sum_sdiff (f := id) h12
    have h15 := Finset.sum_sdiff (f := id) h13
    unfold A' B'
    dsimp at h14 h15
    lia

end Imo1972P1

-- ═══ Imo1972P3 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# International Mathematical Olympiad 1972, Problem 3

Let m and n be non-negative integers. Prove that

     (2m)!(2n)! / (m!n!(m + n)!)

is an integer.
-/

namespace Imo1972P3

open scoped Nat

theorem imo1972_p3 (m n : ℕ) :
    m ! * n ! * (m + n)! ∣ (2 * m)! * (2 * n)! := by
  let f := fun m n => ((2 * m)! * (2 * n)!) / (m ! * n ! * (m + n)!)
  revert m
  induction' n with n ih
  · intro m
    simp only [Nat.factorial_zero, mul_one, add_zero, mul_zero]
    use Nat.choose (2*m) m
    rw [← Nat.choose_mul_factorial_mul_factorial (n := 2 * m) (k := m)]
    · rw [show 2*m-m = m by lia]
      ring_nf
    lia
  · intro m
    zify
    use (4 * f m n - f (m + 1) n)
    rify
    dsimp only [f]
    rw [Nat.cast_div, Nat.cast_div]
    · rw [show 2 * Nat.succ n = Nat.succ (Nat.succ (2 * n)) by lia]
      rw [show m + Nat.succ n = Nat.succ (m + n) by lia]
      rw [show 2 * (m + 1) = Nat.succ (Nat.succ (2 * m)) by lia]
      rw [show (m + 1 + n) = Nat.succ (m + n) by lia]
      simp only [Nat.factorial_succ]
      push_cast
      field_simp
      ring
    · apply ih
    · positivity
    · apply ih
    · positivity


end Imo1972P3

-- ═══ Imo1972P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1, Maximiliano Onofre-Martínez
-/





/-!
# International Mathematical Olympiad 1972, Problem 4

Find all positive real solutions to:

(x_1^2 - x_3x_5)(x_2^2 - x_3x_5) ≤ 0
(x_2^2 - x_4x_1)(x_3^2 - x_4x_1) ≤ 0
(x_3^2 - x_5x_2)(x_4^2 - x_5x_2) ≤ 0
(x_4^2 - x_1x_3)(x_5^2 - x_1x_3) ≤ 0
(x_5^2 - x_2x_4)(x_1^2 - x_2x_4) ≤ 0
-/

namespace Imo1972P4

noncomputable def solution_set : Set (ℝ × ℝ × ℝ × ℝ × ℝ) :=
  {(a, b, c, d, e) | a = b ∧ b = c ∧ c = d ∧ d = e}

theorem imo1972_p4 (a b c d e : ℝ)
  (h₀ : 0 < a ∧ 0 < b ∧ 0 < c ∧ 0 < d ∧ 0 < e):
    (a^2 - c * e) * (b^2 - c * e) ≤ 0 ∧
    (b^2 - d * a) * (c^2 - d * a) ≤ 0 ∧
    (c^2 - e * b) * (d^2 - e * b) ≤ 0 ∧
    (d^2 - a * c) * (e^2 - a * c) ≤ 0 ∧
    (e^2 - b * d) * (a^2 - b * d) ≤ 0 ↔
      (a, b, c, d, e) ∈ solution_set := by
  constructor
  · intro _
    have : (a * b - a * d)^2 + (b * c - b * e)^2 +
           (c * d - c * a)^2 + (d * e - d * b)^2 +
           (e * a - e * c)^2 + (a * c - a * e)^2 +
           (b * d - b * a)^2 + (c * e - c * b)^2 +
           (d * a - d * c)^2 + (e * b - e * d)^2 ≤ 0 := by linarith

    have : 0 ≤ (a * b - a * d)^2 ∧ 0 ≤ (b * c - b * e)^2 ∧
           0 ≤ (c * d - c * a)^2 ∧ 0 ≤ (d * e - d * b)^2 ∧
           0 ≤ (e * a - e * c)^2 ∧ 0 ≤ (a * c - a * e)^2 ∧
           0 ≤ (b * d - b * a)^2 ∧ 0 ≤ (c * e - c * b)^2 ∧
           0 ≤ (d * a - d * c)^2 ∧ 0 ≤ (e * b - e * d)^2 := by simp [sq_nonneg]

    have bd : b = d := by
      have h₁ : (a * b - a * d)^2 = 0 := by linarith
      have h₂ : a * b - a * d = 0 := by rwa [sq_eq_zero_iff] at h₁
      have h₃ : a * b = a * d := by rwa [sub_eq_zero] at h₂
      exact mul_left_cancel₀ (ne_of_gt h₀.1) h₃

    have ce : c = e := by
      have h₁ : (b * c - b * e)^2 = 0 := by linarith
      have h₂ : b * c - b * e = 0 := by rwa [sq_eq_zero_iff] at h₁
      have h₃ : b * c = b * e := by rwa [sub_eq_zero] at h₂
      exact mul_left_cancel₀ (ne_of_gt h₀.2.1) h₃

    have da : d = a := by
      have h₁ : (c * d - c * a)^2 = 0 := by linarith
      have h₂ : c * d - c * a = 0 := by rwa [sq_eq_zero_iff] at h₁
      have h₃ : c * d = c * a := by rwa [sub_eq_zero] at h₂
      exact mul_left_cancel₀ (ne_of_gt h₀.2.2.1) h₃

    have eb : e = b := by
      have h₁ : (d * e - d * b)^2 = 0 := by linarith
      have h₂ : d * e - d * b = 0 := by rwa [sq_eq_zero_iff] at h₁
      have h₃ : d * e = d * b := by rwa [sub_eq_zero] at h₂
      exact mul_left_cancel₀ (ne_of_gt h₀.2.2.2.1) h₃

    have ab : a = b := by rw [← da]; exact bd.symm
    have bc : b = c := by rw [← eb]; exact ce.symm
    have cd : c = d := by rwa [← bc]
    have de : d = e := by rwa [cd] at ce
    exact ⟨ab, bc, cd, de⟩
  · intro h
    obtain ⟨rfl, rfl, rfl, rfl⟩ := h
    ring_nf; trivial

end Imo1972P4

-- ═══ Imo1972P5 ═══

/-
Copyright (c) 2020 Ruben Van de Velde, Stanislas Polu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ruben Van de Velde, Stanislas Polu
-/




/-!
# International Mathematical Olympiad 1972, Problem 5

`f` and `g` are real-valued functions defined on the real line. For all `x` and `y`,
`f(x + y) + f(x - y) = 2f(x)g(y)`. `f` is not identically zero and `|f(x)| ≤ 1` for all `x`.
Prove that `|g(x)| ≤ 1` for all `x`.
-/

namespace Imo1972P5

theorem imo1972_p5 (f g : ℝ → ℝ) (hf1 : ∀ x, ∀ y, f (x + y) + f (x - y) = 2 * f x * g y)
    (hf2 : BddAbove (Set.range fun x => ‖f x‖)) (hf3 : ∃ x, f x ≠ 0) (y : ℝ) : ‖g y‖ ≤ 1 := by
  by_contra! H
  obtain ⟨x, hx⟩ := hf3
  set k := ⨆ x, ‖f x‖
  have h : ∀ x, ‖f x‖ ≤ k := le_ciSup hf2
  have hgy : 0 < ‖g y‖ := by linarith only [H]
  have k_pos : 0 < k := lt_of_lt_of_le (norm_pos_iff.mpr hx) (h x)
  have : k / ‖g y‖ < k := (div_lt_iff₀ hgy).mpr (lt_mul_of_one_lt_right k_pos H)
  have : k ≤ k / ‖g y‖ := by
    suffices ∀ x, ‖f x‖ ≤ k / ‖g y‖ from ciSup_le this
    intro x
    suffices 2 * (‖f x‖ * ‖g y‖) ≤ 2 * k by
      rwa [le_div_iff₀ hgy, ← mul_le_mul_iff_right₀ zero_lt_two]
    calc
      2 * (‖f x‖ * ‖g y‖) = ‖2 * f x * g y‖ := by simp [mul_assoc]
      _ = ‖f (x + y) + f (x - y)‖ := by rw [hf1]
      _ ≤ ‖f (x + y)‖ + ‖f (x - y)‖ := abs_add_le _ _
      _ ≤ 2 * k := by linarith [h (x + y), h (x - y)]
  order


end Imo1972P5

-- ═══ Imo1973P3 ═══

/-
Copyright (c) 2025 Roozbeh Yousefzadeh. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/





/-!
# International Mathematical Olympiad 1973, Problem 3

Let $a$ and $b$ be real numbers for which the equation
$x^4 + ax^3 + bx^2 + ax + 1 = 0$ has at least one real solution.
For all such pairs $(a, b)$, find the minimum value of $a^2 + b^2$.

-/

namespace Imo1973P3

noncomputable abbrev solution : ℝ := (4:ℝ)/5



lemma aux_1
    (a b : ℝ)
    (h₀ : ∃ (x : ℝ), x ^ 4 + a * x ^ 3 + b * x ^ 2 + a * x + 1 = 0) :
    4 / 5 ≤ a^2 + b^2 := by
  obtain ⟨x, h₁⟩ := h₀
  let t :=  x + 1 / x
  have ht₀: t = x + 1 / x := by rfl
  have hx: x ≠ 0 := by
    by_contra hc
    rw [hc] at h₁
    simp at h₁
  have h₂: t ^ 2 + a * t + (b - 2) = 0 := by
    rw [ht₀]
    ring_nf
    rw [mul_inv_cancel₀ hx]
    simp only [one_mul, neg_add_cancel, zero_add, inv_pow]
    have h₂₀: (x ^ 4 + a * x ^ 3 + b * x ^ 2 + a * x + 1) / (x ^ 2) = 0 / (x ^ 2) := by
      exact congr(HDiv.hDiv $h₁ (x ^ 2))
    ring_nf at h₂₀
    have hx₁: x ^ 2 ≠ 0 := by exact pow_ne_zero 2 hx
    rw [mul_comm (x ^ 2), mul_assoc b, inv_pow, mul_inv_cancel₀ hx₁, mul_one] at h₂₀
    rw [mul_comm x a, mul_assoc a, pow_two, mul_inv,
        ← mul_assoc x, mul_inv_cancel₀ hx, one_mul] at h₂₀
    rw [mul_comm _ a, mul_assoc a, ← pow_two, inv_pow, ← pow_sub₀ _ hx, ← pow_sub₀ _ hx] at h₂₀
    all_goals try linarith
  have ht₁: 2 ≤ abs t := by
    have g₀: 1 * (x * x) + (-t) * x + 1 = 0 := by
      rw [ht₀]
      ring_nf
      rw [mul_inv_cancel₀ hx]
      exact sub_eq_zero_of_eq rfl
    have g₁: discrim 1 (-t) 1 = (-t) ^ 2 - 4 * 1 * 1 := by exact rfl
    simp at g₁
    by_contra hc₀
    push_neg at hc₀
    have hc₁: t ^ 2 < 2 ^ 2 := by
      refine sq_lt_sq.mpr ?_
      refine lt_of_lt_of_le hc₀ ?_
      norm_num
    apply sub_neg_of_lt at hc₁
    have hc₂: ∀ (s : ℝ), discrim 1 (-t) 1 ≠ s ^ 2 := by
      intro s
      have hs: 0 ≤ s ^ 2 := by exact sq_nonneg s
      linarith
    have hc₃: 1 * (x * x) + -t * x + 1 ≠ 0 := by
      exact quadratic_ne_zero_of_discrim_ne_sq hc₂ x
    exact hc₃ g₀
  have ht₂: 0 < t ^ 2 := by
    refine sq_pos_iff.mpr ?_
    by_contra hc
    rw [hc] at ht₁
    simp at ht₁
    linarith
  have h₃: (a * t + b * 1) ^ 2 ≤ (a ^ 2 + b ^ 2) * (t ^ 2 + 1 ^ 2) := by
    let s := Finset.range 2
    let f : ℕ → ℝ := fun x => a * (1 - x) + b * x
    let g : ℕ → ℝ := fun x => t * (1 - x) + 1 * x
    have hhf: f = fun x:ℕ => a * (1 - x) + b * x := by rfl
    have hhg: g = fun x:ℕ => t * (1 - x) + 1 * x := by rfl
    have h₃₀: f 0 = a := by rw [hhf]; bound
    have h₃₁: f 1 = b := by rw [hhf]; ring_nf
    have h₃₂: g 0 = t := by rw [hhg]; ring_nf
    have h₃₃: g 1 = 1 := by rw [hhg]; ring_nf
    have h₃₄: a * t + b * 1 = ∑ i ∈ s, f i * g i := by
      rw [Finset.sum_range_succ, Finset.sum_range_succ, Finset.sum_range_zero]
      rw [h₃₀, h₃₁, h₃₂, h₃₃, zero_add]
    rw [h₃₄]
    have h₃₅: (∑ i ∈ s, f i * g i) ^ 2 ≤ (∑ i ∈ s, f i ^ 2) * ∑ i ∈ s, g i ^ 2 := by
      exact Finset.sum_mul_sq_le_sq_mul_sq s f g
    refine le_trans h₃₅ ?_
    rw [Finset.sum_range_succ, Finset.sum_range_succ, Finset.sum_range_succ, Finset.sum_range_succ]
    simp only [Finset.range_zero, Finset.sum_empty, zero_add, one_pow]
    rw [h₃₀, h₃₁, h₃₂, h₃₃]
    linarith
  rw [mul_one, one_pow] at h₃
  have h₄: (a * t + b) ^ 2 = (t ^ 2 - 2) ^ 2 := by
    refine (pow_eq_pow_iff_of_ne_zero two_ne_zero).mpr ?_
    right
    constructor
    · linarith
    · decide
  have h₅: 4 / 5 ≤ (t ^ 2 - 2) ^ 2 / (t ^ 2 + 1) := by
    refine (div_le_div_iff₀ (by norm_num) ?_).mpr ?_
    · positivity
    · rw [mul_add, mul_one, sub_sq, add_mul, sub_mul, ← pow_mul]
      norm_num
      have h₅₀: 0 ≤ 5 * t ^ 4 + 16 - 24 * t ^ 2 := by
        have h₅₁: 5 * t ^ 4 + 16 - 24 * t ^ 2 = (5 * t ^ 2 - 4) * (t ^ 2 - 4) := by ring_nf
        have h₅₂: 2 ^ 2 ≤ t ^ 2 := by
          refine sq_le_sq.mpr ?_
          refine le_trans ?_ ht₁
          norm_num
        have h₅₃: 0 ≤ t ^ 2 - 4 := by linarith
        have h₅₄: 0 ≤ 5 * t ^ 2 - 4 := by linarith
        rw [h₅₁]
        exact Left.mul_nonneg h₅₄ h₅₃
      linarith
  refine le_trans h₅ ?_
  rw [h₄] at h₃
  refine (div_le_iff₀ ?_).mpr h₃
  positivity



theorem imo1973_p3
    (S : Set (ℝ × ℝ))
    (hS : S = {(a, b) | ∃ x : ℝ, x ^ 4 + a * x ^ 3 + b * x ^ 2 + a * x + 1 = 0}) :
    IsLeast { x.1 ^ 2 + x.2 ^ 2 | x ∈ S } solution := by
  constructor
  · simp only [Prod.exists, Set.mem_setOf_eq]
    use 4/5, -2/5
    constructor
    · simp only [hS, Set.mem_setOf_eq]
      use -1
      norm_num
    · norm_num
  · refine mem_lowerBounds.mpr ?_
    simp only [Prod.exists, Set.mem_setOf_eq, forall_exists_index, and_imp]
    intro x a b h₀ h₁
    rw [←h₁]
    refine aux_1 a b ?_
    simpa only [hS, Set.mem_setOf_eq] using h₀

end Imo1973P3

-- ═══ Imo1973P5 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1 , Shahar Blumentzvaig
-/




/-!
# International Mathematical Olympiad 1973, Problem 5

$G$ is a set of non-constant functions of the real variable $x$ of the form
\[f(x) = ax + b, a \text{ and } b \text{ are real numbers,}\] and $G$ has the following properties:
(a) If $f$ and $g$ are in $G$, then $g \circ f$ is in $G$; here $(g \circ f)(x) = g[f(x)]$.
(b) If $f$ is in $G$, then its inverse $f^{-1}$ is in $G$;
    here the inverse of $f(x) = ax + b$ is $f^{-1}(x) = (x - b) / a$.
(c) For every $f$ in $G$, there exists a real number $x_f$ such that $f(x_f) = x_f$.
Prove that there exists a real number $k$ such that $f(k) = k$ for all $f$ in $G$.
-/

namespace Imo1973P5

theorem imo1973_p5 {G : Set (ℝ → ℝ)}
    (hf: ∀ f ∈ G, ∃ a b : ℝ, a ≠ 0 ∧ ∀ x : ℝ, f x = a * x + b)
    (hG : ∀ f ∈ G, ∀ g ∈ G, g ∘ f ∈ G)
    (hinv : ∀ f ∈ G, (Function.invFun f) ∈ G)
    (hfix : ∀ f ∈ G, ∃ x, f x = x) :
    ∃ k : ℝ, ∀ f ∈ G, f k = k := by
  by_cases hnep : Set.Nonempty G
  · by_cases non_id : ∃f∈G , f≠id
    · obtain ⟨f,hf1⟩ := non_id
      obtain ⟨hf2,hf3⟩ := hf1

      have h1 := hfix f hf2
      obtain ⟨x,hx⟩ := h1
      use x
      intro g hg2
      have hf3 := hf f hf2
      obtain ⟨a,ha⟩ := hf3
      obtain ⟨b,hb⟩ := ha
      obtain ⟨hb1,hb2⟩ := hb

      have hf3 := hf g hg2
      obtain ⟨c,hc⟩ := hf3
      obtain ⟨d,hd⟩ := hc
      obtain ⟨hd1,hd2⟩ := hd

      have r1 := hG f hf2 g hg2
      have s1 : ∀x:ℝ , (g ∘ f) x = a*c*x + c*b+d := by
        intro x
        simp
        rw [hb2 x, hd2 (a*x+b)]
        grind
      have r2 := hG g hg2 f hf2
      have s2 : ∀x:ℝ , (f ∘ g) x = a*c*x + a*d+b := by
        intro x
        simp
        rw [hd2 x, hb2 (c*x+d)]
        grind
      have r3 := hinv (g ∘ f) r1

      have inj : Function.Injective (g ∘ f) := by
        intro a1 a2
        rw [s1,s1]
        simp
        intro h
        rcases h with h1|h1|h1
        · exact h1
        · exfalso
          exact hb1 h1
        · exfalso
          exact hd1 h1

      have s3 : ∀x:ℝ , (Function.invFun (g ∘ f)) x = (1/(a*c))*x - (c*b+d)/(a*c) := by
        intro x
        have t : (g ∘ f) ((1/(a*c))*x - (c*b+d)/(a*c)) = x := by
          rw [s1]
          field_simp
          ring
        nth_rw 1 [← t]
        rw [Function.leftInverse_invFun inj]

      have r4 := hG (Function.invFun (g∘f)) r3 (f∘g) r2
      have s4 : ∀x:ℝ , ((f ∘ g) ∘ Function.invFun (g ∘ f)) x = x + (a*d+b) - (c*b+d) := by
        intro x
        simp
        rw [s3,hd2,hb2]
        field_simp
        ring
      obtain ⟨y,hy⟩ := hfix (((f ∘ g) ∘ Function.invFun (g ∘ f))) r4
      rw [s4] at hy
      have h1 : (a * d + b) = (c * b + d) := by
        grind
      by_cases ha1 : a - 1 = 0
      · replace ha1 : a = 1 := by
          calc
            a = (a-1)+1 := by ring
            _ = 0+1 := by rw[ha1]
            _ = 1 := by ring
        rw [hb2, ha1] at hx
        simp at hx
        rw [ha1,hx] at hb2
        simp at hb2
        exfalso
        have r : f = id := by
          exact Function.forall_isFixedPt_iff.mp hb2
        exact hf3 r
      · grind
    · push_neg at non_id
      use 0
      intro f hf2
      rw [non_id f hf2]
      rfl
  · push_neg at hnep
    use 0
    intro f hf2
    exfalso
    rw [hnep] at hf2
    exact hf2

end Imo1973P5

-- ═══ Imo1974P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lynn Van Hauwe
-/





/-!

# International Mathematical Olympiad 1974, Problem 1

Three players $A, B$ and $C$ play the following game:

* On each of three cards an integer is written.
* These three numbers $p, q, r$ satisfy $0 < p < q < r$.
* The three cards are shuffled and one is dealt to each player.
* Each then receives the number of counters indicated by the card he holds.
* Then the cards are shuffled again; the counters remain with the players.

This process (shuffling, dealing, giving out counters) takes place
for at least two rounds. After the last round, $A$ has 20 counters in all,
$B$ has 10 and $C$ has 9. At the last round $B$ received $r$ counters.

Who received $q$ counters on the first round?
-/



/-
Translation of [this proof](https://artofproblemsolving.com/wiki/index.php/1974_IMO_Problems/Problem_1).

We'll model the `game` as a function ℕ → (Fin 3 ≃ Fin 3), mapping round
numbers to bijections between player-indices and card-indices.

Then, for example, `![p,q,r] (game k 2)` is the number of counters won by
player `2` in round `k`.
-/



namespace Imo1974P1

abbrev Player := Fin 3

noncomputable def solution : Player := 2  -- player C

theorem imo1974_p1
  (p q r : ℕ)
  (hpqr : 0 < p ∧ p < q ∧ q < r)
  (n : ℕ)
  (hn : 1 < n)
  (game : ℕ → (Player ≃ Fin 3))
  (hA : ∑ k ∈ Finset.range n, ![p,q,r] (game k 0) = 20)
  (hB : ∑ k ∈ Finset.range n, ![p,q,r] (game k 1) = 10)
  (hC : ∑ k ∈ Finset.range n, ![p,q,r] (game k 2) = 9)
  (hl : ![p,q,r] (game (n-1) 1) = r)
  : game 0 solution = 1 := by

  obtain ⟨h0p, hpq, hqr⟩ := hpqr

  -- Counters won by player j in round i.
  let C i j := ![p,q,r] (game i j)

  -- Any score is at least p.
  have p_le : ∀i, p ≤ ![p,q,r] i := by
    intro i; fin_cases i <;> simp <;> lia

  -- Any score is at most r.
  have le_r : ∀i, ![p,q,r] i ≤ r := by
    intro i; fin_cases i <;> simp <;> lia

  -- Because 1 ≤ p and 2 ≤ q and 3 ≤ r, we have 6 ≤ p+q+r.
  have hs : 6 ≤ p+q+r := by lia

  -- Each round, the players win p+q+r counters in total.
  have h_total i : C i 0 + C i 1 + C i 2 = p + q + r := by
    rw [←Fin.sum_univ_three]
    unfold C
    rw [←Fintype.sum_equiv (game i)⁻¹ _ _ (fun _ ↦ rfl)]
    simp [Fin.sum_univ_three]

  -- The total score, 39, equals n(p+q+r).
  have h1 : n*(p+q+r) = 39 := calc
    _ = ∑ k ∈ Finset.range n, (p+q+r) := by simp
    _ = ∑ k ∈ Finset.range n, (C k 0 + C k 1 + C k 2) := by congr; ext i; rw [←h_total]
    _ = ∑ k ∈ Finset.range n, (C k 0)
      + ∑ k ∈ Finset.range n, (C k 1)
      + ∑ k ∈ Finset.range n, (C k 2) := by repeat rw [Finset.sum_add_distrib]
    _ = 20 + 10 + 9                   := by rw [hA, hB, hC]

  -- Thus n ∈ {1,3,13,39}.
  have h2 : n ∣ 39 := Dvd.intro (p + q + r) h1
  have h3 : n ∈ Nat.divisors 39 := by
    apply Nat.mem_divisors.mpr; exact ⟨h2, by decide⟩

  -- In fact, n = 3, and p+q+r = 13.
  fin_cases h3 <;> try lia
  simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Nat.one_lt_ofNat,
    Fin.isValue, Nat.add_one_sub_one, Nat.reduceDvd] at *
  clear h2 hn
  have h4 : p+q+r = 13 := by lia

  -- Simplify the score sums.
  rw [Finset.sum] at hA hB hC
  simp only [Finset.range_val, Multiset.range_succ, Multiset.range_zero, Multiset.cons_zero,
    Fin.isValue, Multiset.map_cons, Multiset.map_singleton, Multiset.sum_cons,
    Multiset.sum_singleton] at hA hB hC
  rw [←Nat.add_assoc] at hA hB hC

  -- Show 2+r ≤ 10, and thus r ≤ 8:
  have h5 : 2+r ≤ 10 := calc
    2+r ≤ r     + p     + p     := by lia
    _   ≤ r     + C 1 1 + C 0 1 := by gcongr <;> apply p_le
    _   = C 2 1 + C 1 1 + C 0 1 := by unfold C; rw [hl]
    _   = 10                    := hB

  have h6 : r ≤ 8 := by lia

  -- Show 20 ≤ r+r+r, and thus r > 6:
  have h7 : 20 ≤ r+r+r := calc
    20 = C 2 0 + C 1 0 + C 0 0 := hA.symm
    _  ≤ r+r+r                 := by gcongr <;> apply le_r

  have h8 : r > 6 := by lia

  -- Proof idea:
  -- hB claims: r + (p|q|r) + (p|q|r) = 10.
  -- But neither can be r, because r+r+... > 10.
  -- And they can't be (p,q) or (q,p) because we know 13 = r+p+q ≠ 10.
  -- So the only options are r+p+p and r+q+q.
  have h9 : r + p + p = 10 ∨ r + q + q = 10 := by grind

  -- r = 7 leads to a contradiction. Thus r = 8:
  have hr : r = 8 := by lia

  -- Then p and q are also determined.
  have hp : p = 1 := by lia
  have hq : q = 4 := by lia

  -- Clean up now that we know (p,q,r).
  rw [hl] at hB
  rw [hp, hq, hr] at hA hB hC p_le le_r
  clear h0p hpq hqr hs h1 h4 h5 h6 h7 h8 h9 hl hp hq hr

  -- Looking at hB : 8 + G 1 1 + G 0 1 = 10
  -- we can deduce that this must be 8 + 1 + 1 = 10
  -- and so (game 1) 1 = 0 and (game 0) 1 = 0.
  have hg01 : game 0 1 = 0 := by
    generalize hg01 : game 0 1 = g01 at hB
    generalize hg11 : game 1 1 = g11 at hB
    fin_cases g01 <;> fin_cases g11 <;> simp at hB ⊢

  -- So (game 0) 2 ≠ 0 (bijective).
  have hg020 : game 0 2 ≠ 0 := by
    intro h; rw [←h] at hg01
    have := Equiv.injective (game 0) hg01
    simp only [Fin.isValue, Fin.reduceEq] at this

  -- But (game 0) 2 = 2 would make the sum in hC too big.
  have hg022 : game 0 2 ≠ 2 := by
    intro h; rw [h] at hC
    simp only [Fin.isValue, Matrix.cons_val, Nat.reduceEqDiff] at hC; grind

  -- So there is only one option left: (game 0) 2 = 1.
  unfold solution; lia

end Imo1974P1

-- ═══ Imo1974P3 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/





/-!
# International Mathematical Olympiad 1974, Problem 3

Prove that the sum from k = 0 to n inclusive of
   Choose[2n + 1, 2k + 1] * 2³ᵏ
is not divisible by 5 for any integer n ≥ 0.
-/

namespace Imo1974P3



lemma aux_1 (a : ℕ) :
    ¬ a ^ 2 ≡ 2 [MOD 5] := by
  intro ha
  change _ = _ at ha
  rw [Nat.pow_mod] at ha
  mod_cases H : a % 5 <;>
    change _ % _ = _ % 5 at H <;> rw [H] at ha <;> norm_num at ha

lemma aux_2
  (a : ℕ) :
  ¬ a ^ 2 ≡ 3 [MOD 5] := by
  intro ha
  change _ = _ at ha
  rw [Nat.pow_mod] at ha
  mod_cases H : a % 5 <;>
    change _ % _ = _ % 5 at H <;> rw [H] at ha <;> norm_num at ha

lemma aux_3 (n : ℕ) :
    7 ^ (2 * n + 1) ≡ 2 [MOD 5] ∨ 7 ^ (2 * n + 1) ≡ 3 [MOD 5] := by
  change _ = _ ∨ _ = _
  rw [Nat.pow_mod, Nat.pow_succ, Nat.pow_mul]
  norm_num1
  rw [Nat.mul_mod]
  obtain he | ho := Nat.even_or_odd n
  · rw [even_iff_exists_two_mul] at he
    obtain ⟨b, hb⟩ := he
    left
    rw [hb, Nat.pow_mul, Nat.pow_mod]
    norm_num
  · right
    rw [odd_iff_exists_bit1] at ho
    obtain ⟨b, hb⟩ := ho
    rw [hb, Nat.pow_add, Nat.mul_mod (4^(2 * b)), Nat.pow_mul, Nat.pow_mod]
    norm_num

lemma aux_4
  (n b a : ℕ)
  (k : ℝ)
  (hb₁ : ↑b = 1 / k * ∑ x ∈ Finset.range (n + 1),
                        ↑((2 * n + 1).choose (2 * x + 1)) * k ^ (2 * x + 1))
  (ha₁ : ↑a = ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x)) * k ^ (2 * x))
  (hk₀ : k * k⁻¹ = 1) :
  (1 + k) ^ (2 * n + 1) = ↑a + ↑b * k := by
  rw [mul_comm _ k, hb₁, ← mul_assoc]
  rw [← inv_eq_one_div, hk₀, one_mul, ha₁]
  rw [add_comm, add_pow k 1 (2 * n + 1)]
  simp
  clear hb₁ ha₁ b a hk₀
  let f : ℕ → ℝ := fun i => ↑((2 * n + 1).choose (i)) * k ^ i
  let fs₂ := Finset.range (2 * n + 2)
  -- let fs₀ : Finset ℕ := Finset.filter (fun x => Odd x) (Finset.range (2 * n + 2))
  let fs₀ : Finset ℕ := fs₂.filter (fun x => Odd x)
  let fs₁ : Finset ℕ := fs₂.filter (fun x => Even x)
  let fs₃ : Finset ℕ := Finset.range (n + 1)
  have h₀: ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x + 1)) * k ^ (2 * x + 1) =
    ∑ x ∈ fs₀, ↑((2 * n + 1).choose (x)) * k ^ (x) := by
    have h₀₁: ∑ x ∈ fs₃, f (2 * x + 1) = ∑ x ∈ (fs₀), f x := by
      refine Finset.sum_bij ?i ?_ ?i_inj ?i_surj ?h
      · intro a _
        exact (2 * a + 1)
      · intro a ha₀
        have ha₁: a ≤ n := Finset.mem_range_succ_iff.mp ha₀
        have ha₂: 2 * a + 1 ≤ 2 * n + 1 := by lia
        have ha₃: (2 * a + 1) ∈ fs₂ := Finset.mem_range_succ_iff.mpr ha₂
        have ha₄: Odd (2 * a + 1) := odd_two_mul_add_one a
        refine Finset.mem_filter.mpr ?_
        exact And.symm ⟨ha₄, ha₃⟩
      · intro a _ b _ h₃
        lia
      · intro b hb₀
        use ((b - 1) / 2)
        grind
      · exact fun a _ => rfl
    exact h₀₁
  have h₁: ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x)) * k ^ (2 * x) =
    ∑ x ∈ fs₁, ↑((2 * n + 1).choose (x)) * k ^ (x) := by
    have h₁₁: ∑ x ∈ fs₃, f (2 * x) = ∑ x ∈ (fs₁), f x := by
      refine Finset.sum_bij ?_ ?_ ?_ ?_ ?_
      · intro a _
        exact (2 * a)
      · intro a ha₀
        have ha₁: a < n + 1 := List.mem_range.mp ha₀
        have ha₂: 2 * a < 2 * n + 2 := by lia
        refine Finset.mem_filter.mpr ?_
        constructor
        · exact Finset.mem_range.mpr ha₂
        · exact even_two_mul a
      · intro a _ b _ h₃
        exact Nat.eq_of_mul_eq_mul_left (by norm_num) h₃
      · intro b hb₀
        use (b/2)
        refine exists_prop.mpr ?_
        have hb₁: b ∈ fs₂ ∧ Even b := Finset.mem_filter.mp hb₀
        constructor
        · have hb₂: b < 2 * n + 2 := by exact List.mem_range.mp hb₁.1
          have hb₃: (b / 2) < n + 1 := by exact Nat.div_lt_of_lt_mul hb₂
          exact Finset.mem_range.mpr hb₃
        · exact Nat.two_mul_div_two_of_even hb₁.2
      · exact fun a _ => rfl
    exact h₁₁
  have h₂: ∑ x ∈ Finset.range (2 * n + 1 + 1), k ^ x * ↑((2 * n + 1).choose x) =
    ∑ x ∈ fs₂, ↑((2 * n + 1).choose x) * k ^ x := by
    refine Finset.sum_congr (rfl) ?_
    intro x _
    rw [mul_comm]
  rw [h₀, h₁, h₂]
  have h₃: fs₂ = fs₀ ∪ fs₁ := by
    refine Finset.ext_iff.mpr ?_
    intro a
    constructor
    · intro ha₀
      refine Finset.mem_union.mpr ?mp.a
      have ha₁: Odd a ∨ Even a := Or.symm (Nat.even_or_odd a)
      obtain ha₂ | ha₃ := ha₁
      · left
        exact Finset.mem_filter.mpr ⟨ha₀, ha₂⟩
      · right
        exact Finset.mem_filter.mpr ⟨ha₀, ha₃⟩
    · intro ha₀
      apply Finset.mem_union.mp at ha₀
      obtain ha₁ | ha₂ := ha₀
      · exact Finset.mem_of_mem_filter a ha₁
      · exact Finset.mem_of_mem_filter a ha₂
  have h₄: Disjoint fs₀ fs₁ := by
    refine Finset.disjoint_filter.mpr ?_
    intro x _ hx₁
    exact Nat.not_even_iff_odd.mpr hx₁
  nth_rw 2 [add_comm]
  rw [h₃, Finset.sum_union h₄]


lemma aux_5
  (n b a : ℕ)
  (k : ℝ)
  (hb₁ : ↑b = 1 / k * ∑ x ∈ Finset.range (n + 1),
                        ↑((2 * n + 1).choose (2 * x + 1)) * k ^ (2 * x + 1))
  (ha₁ : ↑a = ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x)) * k ^ (2 * x))
  (hk₀ : k * k⁻¹ = 1) :
  (1 - k) ^ (2 * n + 1) = ↑a - ↑b * k := by
  rw [mul_comm _ k, hb₁, ← mul_assoc]
  rw [← inv_eq_one_div, hk₀, one_mul, ha₁, sub_eq_add_neg]
  rw [add_comm 1 _, add_pow (-k) 1 (2 * n + 1)]
  simp
  clear hb₁ ha₁ b a hk₀
  let f₀ : ℕ → ℝ := fun i => ↑((2 * n + 1).choose (i)) * k ^ i
  let f₁ : ℕ → ℝ := fun i => ↑((2 * n + 1).choose (i)) * (-k) ^ i
  let fs₂ := Finset.range (2 * n + 2)
  let fs₀ : Finset ℕ := fs₂.filter (fun x => Odd x)
  let fs₁ : Finset ℕ := fs₂.filter (fun x => Even x)
  let fs₃ : Finset ℕ := Finset.range (n + 1)
  have h₀: ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x + 1)) * k ^ (2 * x + 1) =
    - ∑ x ∈ fs₀, ↑((2 * n + 1).choose (x)) * (-k) ^ (x) := by
    rw [neg_eq_neg_one_mul, Finset.mul_sum]
    have h₀₁: ∑ x ∈ fs₃, f₀ (2 * x + 1) = ∑ x ∈ (fs₀), -1 * f₁ x := by
      refine Finset.sum_bij ?i ?_ ?i_inj ?i_surj ?h
      · intro a _
        exact (2 * a + 1)
      · intro a ha₀
        have ha₁: a ≤ n := Finset.mem_range_succ_iff.mp ha₀
        have ha₂: 2 * a + 1 ≤ 2 * n + 1 := by lia
        have ha₃: (2 * a + 1) ∈ fs₂ := Finset.mem_range_succ_iff.mpr ha₂
        have ha₄: Odd (2 * a + 1) := odd_two_mul_add_one a
        exact Finset.mem_filter.mpr ⟨ha₃, ha₄⟩
      · intro a _ b _ h₃
        lia
      · intro b hb₀
        use ((b - 1) / 2)
        grind
      · intro b hb₀
        have hb₁: (-1:ℝ) ^ (b * 2) = 1 := by
          refine (neg_one_pow_eq_one_iff_even (by norm_num)).mpr ?_
          rw [mul_comm]
          exact even_two_mul b
        simp only [f₀, f₁]
        ring_nf
        rw [hb₁, mul_one]
    exact h₀₁
  have h₁: ∑ x ∈ Finset.range (n + 1), ↑((2 * n + 1).choose (2 * x)) * k ^ (2 * x) =
    ∑ x ∈ fs₁, ↑((2 * n + 1).choose (x)) * (-k) ^ (x) := by
    have h₁₁: ∑ x ∈ fs₃, f₀ (2 * x) = ∑ x ∈ (fs₁), f₁ x := by
      refine Finset.sum_bij ?_ ?_ ?_ ?_ ?_
      · intro a _
        exact (2 * a)
      · intro a ha₀
        have ha₁: a < n + 1 := List.mem_range.mp ha₀
        have ha₂: 2 * a < 2 * n + 2 := by lia
        refine Finset.mem_filter.mpr ?_
        constructor
        · exact Finset.mem_range.mpr ha₂
        · exact even_two_mul a
      · intro a _ b _ h₃
        exact Nat.eq_of_mul_eq_mul_left (by norm_num) h₃
      · intro b hb₀
        use (b/2)
        refine exists_prop.mpr ?_
        have hb₁: b ∈ fs₂ ∧ Even b := Finset.mem_filter.mp hb₀
        constructor
        · have hb₂: b < 2 * n + 2 := List.mem_range.mp hb₁.1
          have hb₃: b / 2 < n + 1 := Nat.div_lt_of_lt_mul hb₂
          exact Finset.mem_range.mpr hb₃
        · exact Nat.two_mul_div_two_of_even hb₁.2
      · intro b hb₀
        have hb₁: (-1:ℝ) ^ (b * 2) = 1 := by
          refine (neg_one_pow_eq_one_iff_even (by norm_num)).mpr ?_
          rw [mul_comm]
          exact even_two_mul b
        simp only [f₀, f₁]
        ring_nf
        rw [hb₁, mul_one]
    exact h₁₁
  have h₂: ∑ x ∈ Finset.range (2 * n + 1 + 1), (-k) ^ x * ↑((2 * n + 1).choose x) =
    ∑ x ∈ fs₂, ↑((2 * n + 1).choose x) * (-k) ^ x := by
    refine Finset.sum_congr (rfl) ?_
    intro x _
    rw [mul_comm]
  rw [h₀, h₁, h₂, sub_neg_eq_add]
  have h₃: fs₂ = fs₀ ∪ fs₁ := by
    refine Finset.ext_iff.mpr ?_
    intro a
    constructor
    · intro ha₀
      refine Finset.mem_union.mpr ?mp.a
      have ha₁: Odd a ∨ Even a := by exact Or.symm (Nat.even_or_odd a)
      obtain ha₂ | ha₃ := ha₁
      · left
        exact Finset.mem_filter.mpr ⟨ha₀, ha₂⟩
      · right
        exact Finset.mem_filter.mpr ⟨ha₀, ha₃⟩
    · intro ha₀
      apply Finset.mem_union.mp at ha₀
      obtain ha₁ | ha₂ := ha₀
      · exact Finset.mem_of_mem_filter a ha₁
      · exact Finset.mem_of_mem_filter a ha₂
  have h₄: Disjoint fs₀ fs₁ := by
    refine Finset.disjoint_filter.mpr ?_
    intro x _ hx₁
    exact Nat.not_even_iff_odd.mpr hx₁
  nth_rw 2 [add_comm]
  rw [h₃, Finset.sum_union h₄]



theorem imo1974_p3
    (n : ℕ) :
    ¬ 5 ∣ ∑ k ∈ Finset.range (n + 1),
            (Nat.choose (2 * n + 1) (2 * k + 1)) * (2^(3 * k)) := by
  let k:ℝ := Real.sqrt (8:ℝ)
  have hk: k = Real.sqrt (8:ℝ) := by rfl
  let b:ℕ := ∑ k ∈ Finset.range (n + 1), (Nat.choose (2 * n + 1) (2 * k + 1)) * (2^(3 * k))
  have hb : b = ∑ k ∈ Finset.range (n + 1),
                  (Nat.choose (2 * n + 1) (2 * k + 1)) * (2^(3 * k)) := by rfl
  rw [← hb]
  let a := ∑ k ∈ Finset.range (n + 1), (Nat.choose (2 * n + 1) (2 * k) * (2 ^ (3 * k)))
  have ha : a = ∑ k ∈ Finset.range (n + 1),
                  (Nat.choose (2 * n + 1) (2 * k) * (2 ^ (3 * k))) := by rfl
  have hb₁: b = (1 / k) *
    ∑ x ∈ Finset.range (n + 1), (Nat.choose (2 * n + 1) (2 * x + 1)) * (k ^ (2 * x + 1)) := by
    rw [hb, hk]
    simp
    rw [Finset.mul_sum]
    refine Finset.sum_congr (rfl) ?_
    intro x _
    rw [mul_comm ((√8)⁻¹), mul_assoc]
    refine mul_eq_mul_left_iff.mpr ?_
    left
    rw [pow_succ, pow_mul, pow_mul, Real.sq_sqrt (by norm_num)]
    norm_num
  have ha₁: a = ∑ x ∈ Finset.range (n + 1), (Nat.choose (2 * n + 1) (2 * x) * (k ^ (2 * x))) := by
    rw [ha, hk]
    simp
    refine Finset.sum_congr (rfl) ?_
    intro x _
    refine mul_eq_mul_left_iff.mpr ?_
    left
    rw [pow_mul, pow_mul, Real.sq_sqrt (by norm_num)]
    norm_num
  have hk₀: k * k⁻¹ = 1 := by
    refine (mul_inv_eq_one₀ ?_).mpr (rfl)
    rw [hk]
    norm_num
  have h₀: (1 + k) ^ (2 * n + 1) = a + b * k := by
    exact aux_4 n b a k hb₁ ha₁ hk₀
  have h₁: (1 - k) ^ (2 * n + 1) = a - b * k := by
    exact aux_5 n b a k hb₁ ha₁ hk₀
  have h₂: ((1 + k) * (1 - k)) ^ (2 * n + 1) = (a + b * k) * (a - b * k) := by
    rw [mul_pow, h₀, h₁]
  rw [← sq_sub_sq 1 k] at h₂
  rw [← sq_sub_sq (↑a) ((↑b:ℝ) * k)] at h₂
  rw [mul_pow, hk] at h₂
  norm_num at h₂
  have h₃: (7:ℕ) ^ (2 * n + 1) = b ^ 2 * 8 - a ^ 2 := by
    have h₃₀: Odd (2 * n + 1) := by exact odd_two_mul_add_one n
    have h₃₁: (-7:ℝ) = (-1:ℝ) * (7:ℕ) := by norm_num
    have h₃₂: (-1:ℝ) ^ (2 * n + 1) = -1 := by exact Odd.neg_one_pow h₃₀
    have h₃₃: ↑a ^ 2 - ↑b ^ 2 * 8 = (-1:ℝ) * (↑b ^ 2 * 8 - ↑a ^ 2) := by
      linarith
    rw [h₃₁, mul_pow, h₃₂, h₃₃] at h₂
    simp at h₂
    have h₃₄: (7:ℝ) ^ (2 * n + 1) = ↑b ^ 2 * 8 - ↑a ^ 2 := by
      linarith
    norm_cast at h₃₄
    rw [Int.subNatNat_eq_coe] at h₃₄
    rw [← Int.toNat_sub, ← h₃₄]
    exact rfl
  have h₄: 7 ^ (2 * n + 1) ≡ 2 [MOD 5] ∨ 7 ^ (2 * n + 1) ≡ 3 [MOD 5] := by
    refine aux_3 n
  by_contra! hc₀
  have hc₁: b^2 * 8 ≡ 0^2 * 8 [MOD 5] := by
    refine Nat.ModEq.mul ?_ rfl
    refine Nat.ModEq.pow 2 ?_
    exact Nat.modEq_zero_iff_dvd.mpr hc₀
  simp at hc₁
  have h₅: a ^ 2 < b ^ 2 * 8 := by
    have h₅₀: 0 < 7 ^ (2 * n + 1) := by
      exact Nat.pow_pos (by norm_num)
    rw [h₃] at h₅₀
    exact Nat.lt_of_sub_pos h₅₀
  obtain h₄₀ | h₄₁ := h₄
  · rw [h₃] at h₄₀
    have hc₂: b ^ 2 * 8 - a ^ 2 + a ^ 2 ≡ 2 + a ^ 2 [MOD 5] := by
      exact Nat.ModEq.add_right (a ^ 2) h₄₀
    rw [Nat.sub_add_cancel (le_of_lt h₅)] at hc₂
    have hc₃: 3 + (2 + a ^ 2) ≡ 3 [MOD 5] := by
      apply Nat.ModEq.trans hc₂.symm at hc₁
      exact Nat.ModEq.add_left 3 hc₁
    have hc₄: a ^ 2 ≡ 3 [MOD 5] := by
      rw [← add_assoc, ← zero_add 3] at hc₃
      norm_num at hc₃
      exact hc₃
    have hc₅: ¬ a ^ 2 ≡ 3 [MOD 5] := by exact aux_2 a
    exact hc₅ hc₄
  · rw [h₃] at h₄₁
    have hc₂: b ^ 2 * 8 - a ^ 2 + a ^ 2 ≡ 3 + a ^ 2 [MOD 5] := by
      exact Nat.ModEq.add_right (a ^ 2) h₄₁
    rw [Nat.sub_add_cancel (le_of_lt h₅)] at hc₂
    apply Nat.ModEq.trans hc₂.symm at hc₁
    have hc₃: a ^ 2 ≡ 2 [MOD 5] := Nat.ModEq.add_left_cancel' 3 hc₁
    exact aux_1 a hc₃

end Imo1974P3

-- ═══ Imo1975P1 ═══

/-
Copyright (c) 2022 Mantas Bakšys. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mantas Bakšys
-/




/-!
# International Mathematical Olympiad 1975, Problem 1

Let `x₁, x₂, ... , xₙ` and `y₁, y₂, ... , yₙ` be two sequences of real numbers, such that
`x₁ ≥ x₂ ≥ ... ≥ xₙ` and `y₁ ≥ y₂ ≥ ... ≥ yₙ`. Prove that if `z₁, z₂, ... , zₙ` is any permutation
of `y₁, y₂, ... , yₙ`, then `∑ (xᵢ - yᵢ)^2 ≤ ∑ (xᵢ - zᵢ)^2`
-/

namespace Imo1975P1

/- Let `n` be a natural number, `x` and `y` be as in the problem statement and `σ` be the
permutation of natural numbers such that `z = y ∘ σ` -/
variable (n : ℕ) (σ : Equiv.Perm ℕ) (x y : ℕ → ℝ)

theorem imo1975_p1
    (hx : AntitoneOn x (Finset.Icc 1 n)) (hy : AntitoneOn y (Finset.Icc 1 n))
    (hσ : {x | σ x ≠ x} ⊆ Finset.Icc 1 n) :
    ∑ i ∈ Finset.Icc 1 n, (x i - y i) ^ 2 ≤ ∑ i ∈ Finset.Icc 1 n, (x i - y (σ i)) ^ 2 := by
  /-
  Firstly, we expand the squares within both sums and distribute into separate finite sums. Then,
  noting that `∑ yᵢ ^ 2 = ∑ zᵢ ^ 2`, it remains to prove that `∑ xᵢ * zᵢ ≤ ∑ xᵢ * yᵢ`, which is true
  by the Rearrangement Inequality
  -/

  simp only [sub_sq, Finset.sum_add_distrib, Finset.sum_sub_distrib]
  -- a finite sum is invariant if we permute the order of summation
  have hσy : ∑ i ∈ Finset.Icc 1 n, y i ^ 2 = ∑ i ∈ Finset.Icc 1 n, y (σ i) ^ 2 := by
    rw [← Equiv.Perm.sum_comp σ (Finset.Icc 1 n) _ hσ]
  -- let's cancel terms appearing on both sides
  rw [hσy, add_le_add_iff_right, sub_le_sub_iff_left]
  simp only [mul_assoc, ← Finset.mul_sum, zero_lt_two, mul_le_mul_iff_right₀]
  -- what's left to prove is a version of the rearrangement inequality
  apply MonovaryOn.sum_mul_comp_perm_le_sum_mul _ hσ
  -- finally we need to show that `x` and `y` 'vary' together on `[1, n]` and this is due to both of
  -- them being `decreasing`
  exact AntitoneOn.monovaryOn hx hy


end Imo1975P1

-- ═══ Imo1975P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1, Shahar Blumentzvaig
-/






/-!
# International Mathematical Olympiad 1975, Problem 2

Let a1 < a2 < a3 < ... be positive integers.
Prove that for every i >= 1,
there are infinitely many a_n that can be written in the form a_n = ra_i + sa_j,
with r, s positive integers and j > i.
-/

namespace Imo1975P2

theorem imo1975_p2 (a : ℕ → ℤ)
    (apos : ∀ i : ℕ, 0 < a i)
    (ha : ∀ i : ℕ, a i < a (i + 1))
    : ∀ i n0 : ℕ,
      ∃ n, n0 ≤ n ∧
      ∃ r s : ℕ,
      ∃ j : ℕ,
        a n = r * a i + s * a j ∧
        i < j ∧
        0 < r ∧
        0 < s := by
  let b : ℕ → ℕ := fun n => (a n).natAbs
  intro i
  have hn0 : ∀ j, a j ≠ (0 : ℤ) := fun j ↦ (Int.ne_of_lt (apos j)).symm
  intro n0
  have h1 : ∃t:ℕ , ∀ n1:ℕ , ∃ n:ℕ , n > n1 ∧ a i ∣ (a n-t) := by
    by_contra h2
    push_neg at h2

    choose f hf using h2
    let m := Nat.succ (Finset.sup ((List.range (b i)).toFinset) f)
    have h3 : ∀ n>m , ∀ t:ℕ , t < b i → ¬ (a i ∣ a n - t) := by
      intro n1 g t1 r
      have h4 : m > f t1 := by
        have h4' : (Finset.sup (List.range (b i)).toFinset f) >= f t1 := by
          apply Finset.le_sup
          rw[List.mem_toFinset]
          exact List.mem_range.2 r
        exact Nat.lt_add_one_of_le h4'
      have h6 : n1 > f t1 := Nat.lt_trans h4 g
      apply hf t1 n1 h6
    have h4 := h3 (m+1) (Nat.lt_add_one m)
    let t_int := a (m+1) - (a i)*((a (m+1))/(a i))
    let t := t_int.natAbs
    have g : (a i)∣ a (m+1) - (a (m+1) - (a i)*((a (m+1))/(a i))) := by
      simp
    have h5 := h4 t
    have h6 : (a i ∣ a (m + 1) - ↑t) → (t ≥ b i) := by
      contrapose
      intro r
      apply lt_of_not_ge at r
      exact h5 r
    dsimp [t] at h6
    dsimp [t_int] at h6
    have g : (a (m + 1) - a i * (a (m + 1) / a i))≥0 := by
        have r : (a i)*(a (m + 1) / a i) ≤ a (m+1) := Int.mul_ediv_self_le (hn0 i)
        lia
    have h7 : ↑(a (m + 1) - a i * (a (m + 1) / a i)).natAbs = (a (m + 1) - a i * (a (m + 1) / a i)) := Int.natAbs_of_nonneg g
    rw [h7] at h6
    simp only [sub_sub_cancel, dvd_mul_right, ge_iff_le, forall_const] at h6
    unfold b at h6
    have h8 : a (m + 1) - a i * (a (m + 1) / a i) < (a i):= by
      have h8' : a i * (a (m + 1) / a i) + (a i) > a (m + 1) :=  Int.lt_mul_ediv_self_add (apos i)
      lia
    lia
  obtain ⟨t,ht⟩ := h1
  have g := ht (n0+i)
  obtain ⟨k,hk⟩ := g
  rcases hk.right with ⟨x, hx⟩
  have g' := ht k
  obtain ⟨m,hm⟩ := g'
  rcases hm.right with ⟨y, hy⟩
  have g : a m = (y-x)*(a i) + (a k) := by
    calc
          a m   = (a m - t) - (a k - t)+(a k) := by ring
          _   = a i * y - a i * x +(a k)     := by rw [hy, hx]
          _   = (y - x) * a i +(a k)        := by ring
  have rm : n0 ≤ m ∧ ∃ r s j : ℕ, a m = ↑r * a i + ↑s * a j ∧ i < j ∧ 0 < r ∧ 0 < s := by
    have r1 : m ≥ n0 := by lia
    have r2 : ∃ r s j : ℕ, a m = r * a i + s * a j ∧ i < j ∧ 0 < r ∧ 0 < s := by
      have s3 : 0<y-x := by
        have t1 : a k < a m := strictMono_nat_of_lt_succ ha hm.left
        have t2 : a m - t > a k - t :=  add_lt_add_left t1 (-t)
        rw [hy] at t2
        rw [hx] at t2
        have t3 := (mul_lt_mul_iff_right₀ (apos i)).mp t2
        exact sub_pos.mpr t3
      have s : a m = (y-x) * a i + 1 * a k ∧ i < k ∧ 0 < (y - x).natAbs ∧ (0 : ℕ)<(1 : ℕ) := by
        lia
      use (y-x).natAbs, 1, k
      have abs_eq : ↑((y - x).natAbs) = y - x := by
        rw [Int.natAbs_of_nonneg (Int.le_of_lt s3)]
      rw [abs_eq]
      exact s
    exact And.intro r1 r2
  use m

end Imo1975P2

-- ═══ Imo1976P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 1976, Problem 4

Determine, with proof, the largest number which is the product
of positive integers whose sum is 1976.
-/

namespace Imo1976P4



def IsMaxProd (n₀ : ℕ) :=
  fun m ↦ IsGreatest
      { n | ∃ s : Multiset ℕ, s.sum = n₀ ∧ s.prod = n }
      m

def IsMaxProdSet (s : Multiset ℕ) :=
  IsMaxProd (s.sum) (s.prod)

def result : ℕ → ℕ
  | 0 => 1
  | 1 => 1
  | 2 => 2
  | 3 => 3
  | 4 => 4
  | n + 3 => 3 * (result n)

lemma prod_le_sum_pow_sum (s : Multiset ℕ) : s.prod ≤ s.sum ^ s.sum := by
  induction' s using Multiset.induction with i s' hs'
  · simp
  · rw [Multiset.sum_cons, Multiset.prod_cons]
    by_cases hi : i = 0
    · rw [hi, zero_mul]
      apply Nat.zero_le
    · push_neg at hi
      rw [← Nat.one_le_iff_ne_zero] at hi
      calc i * s'.prod
          ≤ i * s'.sum ^ s'.sum := mul_le_mul_right hs' i
        _ ≤ (i + s'.sum) * s'.sum ^ s'.sum := mul_le_mul_left (Nat.le_add_right _ _) _
        _ ≤ (i + s'.sum) * (i + s'.sum) ^ s'.sum :=
            mul_le_mul_right (pow_le_pow_left' (Nat.le_add_left _ _) _) _
        _ = (i + s'.sum) ^ (s'.sum + 1) := by exact Nat.pow_add_one'.symm
        _ ≤ (i + s'.sum) ^ (i + s'.sum) := by
          apply pow_le_pow_right'
          · exact Nat.le_add_right_of_le hi
          · rw [add_comm]
            exact Nat.add_le_add_right hi s'.sum

lemma exists_mem_of_sum_lt_zero (s : Multiset ℕ) (hs: 0 < s.sum) :
  ∃ x: ℕ, x ∈ s := by
  have hs' : s ≠ 0 := by
    contrapose! hs
    rw [hs, Multiset.sum_zero]
  exact Multiset.exists_mem_of_ne_zero hs'

lemma prod_with_given_sum_bddAbove (n₀ : ℕ) :
  BddAbove {n | ∃ s : Multiset ℕ, s.sum = n₀ ∧ s.prod = n} := by
    use n₀ ^ n₀
    intro m hm
    rcases hm with ⟨s, ⟨hs_sum, hs_prod⟩⟩
    rw [← hs_sum, ← hs_prod]
    exact prod_le_sum_pow_sum s

lemma exists_max_prod (n : ℕ) :
  ∃ m : ℕ, IsMaxProd n m := by
  apply BddAbove.exists_isGreatest_of_nonempty
  · exact prod_with_given_sum_bddAbove n
  · use n
    use {n}
    constructor
    · rw [Multiset.sum_singleton]
    · rw [Multiset.prod_singleton]

lemma exists_max_prod_set {n m : ℕ} (hnm: IsMaxProd n m):
  ∃ s : Multiset ℕ, s.sum = n ∧ IsMaxProdSet s := by
  rcases hnm.left with ⟨s, ⟨hs_sum, hs_prod⟩⟩
  use s
  constructor
  · exact hs_sum
  · rw [IsMaxProdSet, hs_prod, hs_sum]
    exact hnm

lemma prod_le_max_prod {n m : ℕ} (hnm: IsMaxProd n m)
  {s : Multiset ℕ} (hs : s.sum = n) : s.prod ≤ m := by
  have h := hnm.right
  simp [upperBounds] at h
  exact h s hs

lemma not_max_prod_set_of_prod_lt_prod {s t: Multiset ℕ}
  (hst' : s.sum = t.sum) (hst : s.prod < t.prod) : ¬IsMaxProdSet s := by
  contrapose! hst
  have h' := hst.right
  simp [upperBounds] at h'
  exact h' t hst'.symm

lemma exists_cons_le_of_le_of_sum_lt_sum {s t : Multiset ℕ}
  (hst' : s ≤ t) (hst : s.sum < t.sum) : ∃ n : ℕ, s.cons n ≤ t := by
  have ht_sub_s : t - s ≠ 0 := by
    contrapose! hst
    apply le_of_eq
    calc t.sum
        = (t - s + s).sum := by rw [Multiset.sub_add_cancel hst']
      _ = (t - s).sum + s.sum := by rw [Multiset.sum_add]
      _ = 0 + s.sum := by rw [hst, Multiset.sum_zero]
      _ = s.sum := by rw [zero_add]
  rcases Multiset.exists_mem_of_ne_zero ht_sub_s with ⟨m, hm⟩
  use m
  rw [← Multiset.singleton_add, ← Multiset.sub_add_cancel hst']
  rw [Multiset.add_le_add_iff_right, Multiset.singleton_le]
  exact hm

lemma exists_le_of_mem_of_lt_sum {n : ℕ} {s : Multiset ℕ}
  (hns' : n ∈ s) (hns : n < s.sum) : ∃ m : ℕ, {n, m} ≤ s := by
  rcases Multiset.exists_cons_of_mem hns' with ⟨t, ht⟩
  have ht' : t ≠ 0 := by
    contrapose! hns
    rw [ht, hns, Multiset.sum_cons, Multiset.sum_zero, add_zero]
  rcases Multiset.exists_mem_of_ne_zero ht' with ⟨m, hm⟩
  use m
  rw [ht, Multiset.insert_eq_cons]
  exact Multiset.cons_le_cons n (Multiset.singleton_le.mpr hm)

lemma zero_not_in_max_prod_set {s : Multiset ℕ}
  (hs: IsMaxProdSet s) : 0 ∉ s := by
  contrapose! hs
  have ha : s.sum = (Multiset.replicate s.sum 1).sum := by
    rw [Multiset.sum_replicate, Nat.nsmul_eq_mul, mul_one]
  apply not_max_prod_set_of_prod_lt_prod ha
  rw [Multiset.prod_replicate, one_pow, Multiset.prod_eq_zero hs]
  norm_num

lemma max_prod_set_of_subset_of_max_prod_set {s t : Multiset ℕ}
  (hst : s ≤ t) (ht: IsMaxProdSet t) : IsMaxProdSet s := by
  constructor
  · use s
  · intro n hn
    rcases hn with ⟨s', ⟨hs'_sum, hs'_prod⟩⟩
    have ht_sub_s : (t - s).prod > 0 := by
      apply Nat.zero_lt_of_ne_zero
      apply Multiset.prod_ne_zero
      intro h'
      apply zero_not_in_max_prod_set ht
      rw [Multiset.mem_sub] at h'
      rw [← Multiset.count_pos]
      exact Nat.zero_lt_of_lt h'
    apply Nat.le_of_mul_le_mul_left _ ht_sub_s
    rw [← hs'_prod, ← Multiset.prod_add, ← Multiset.prod_add]
    rw [Multiset.sub_add_cancel hst]
    have h' := ht.right
    simp [upperBounds] at h'
    apply h' (t - s + s')
    calc (t - s + s').sum
        = (t - s).sum + s'.sum := by rw [Multiset.sum_add]
      _ = (t - s).sum + s.sum := by rw [hs'_sum]
      _ = (t - s + s).sum := by rw [Multiset.sum_add]
      _ = t.sum := by rw [Multiset.sub_add_cancel hst]

lemma one_not_in_max_prod_set_of_one_lt_sum {s : Multiset ℕ}
  (hs' : 1 < s.sum) (hs: IsMaxProdSet s) : 1 ∉ s := by
  intro h1s
  rcases exists_le_of_mem_of_lt_sum h1s hs' with ⟨n, hn⟩
  have h1n := max_prod_set_of_subset_of_max_prod_set hn hs
  contrapose! h1n
  have h1n' : ({1, n} : Multiset ℕ).sum = ({1 + n} : Multiset ℕ).sum := by
    rw [Multiset.sum_singleton, Multiset.insert_eq_cons, Multiset.sum_cons, Multiset.sum_singleton]
  apply not_max_prod_set_of_prod_lt_prod h1n'
  rw [Multiset.prod_singleton, Multiset.insert_eq_cons, Multiset.prod_cons, Multiset.prod_singleton]
  lia

lemma not_in_max_prod_set_of_five_le {s : Multiset ℕ} {n : ℕ}
  (hn : 4 < n) (hs: IsMaxProdSet s) : n ∉ s := by
  intro hn'
  have hn'' := max_prod_set_of_subset_of_max_prod_set (Multiset.singleton_le.mpr hn') hs
  contrapose! hn''
  have hn_sub_2 : ({n} : Multiset ℕ).sum = ({n - 2, 2} : Multiset ℕ).sum := by
    rw [Multiset.sum_singleton, Multiset.insert_eq_cons, Multiset.sum_cons, Multiset.sum_singleton]
    symm
    apply Nat.sub_add_cancel
    lia
  apply not_max_prod_set_of_prod_lt_prod hn_sub_2
  rw [Multiset.prod_singleton, Multiset.insert_eq_cons, Multiset.prod_cons, Multiset.prod_singleton]
  lia

lemma lt_and_gt_of_in_max_prod_set_of_four_lt_sum {s : Multiset ℕ} {n : ℕ}
  (hn : n ∈ s) (hs' : 4 < s.sum) (hs: IsMaxProdSet s) : 1 < n ∧  n < 5 := by
  have hn_ne_0 : n ≠ 0 := by
      contrapose! hn
      rw [hn]
      exact zero_not_in_max_prod_set hs
  have hn_ne_1 : n ≠ 1 := by
    contrapose! hn
    rw [hn]
    apply one_not_in_max_prod_set_of_one_lt_sum _ hs
    lia
  have hn_le_4 : n ≤ 4 := by
      contrapose! hn
      exact not_in_max_prod_set_of_five_le hn hs
  lia

lemma three_in_max_prod_set_of_four_lt_sum {s : Multiset ℕ}
  (hs' : 4 < s.sum) (hs: IsMaxProdSet s) : 3 ∈ s := by
  rw [← Multiset.count_ne_zero, Nat.ne_zero_iff_zero_lt]
  have h₁ : s.toFinset ⊆ {2, 3, 4} := by
    intro x hx
    rw [Multiset.mem_toFinset] at hx
    have hx' := lt_and_gt_of_in_max_prod_set_of_four_lt_sum hx hs' hs
    have hx'l := hx'.left
    have hx'r := hx'.right
    interval_cases x <;> simp
  simp [Finset.sum_multiset_count_of_subset _ _ h₁] at hs'
  have h₂ : Multiset.count 2 s < 3 := by
    by_contra! h2
    have h222 : ({2, 2, 2} : Multiset ℕ) ≤ s := by
      rw [Multiset.le_iff_count]
      intro n
      by_cases hn2 : n = 2
      · simp [hn2]
        exact h2
      · have hn' : n ∉ ({2, 2, 2} : Multiset ℕ) := by
          simp [← Multiset.mem_toFinset]
          exact hn2
        rw [Multiset.count_eq_zero_of_notMem hn']
        apply Nat.zero_le
    have h222' := max_prod_set_of_subset_of_max_prod_set h222 hs
    contrapose! h222'
    have h : ({2, 2, 2} : Multiset ℕ).sum = ({3, 3} : Multiset ℕ).sum := by
      simp [Multiset.sum_singleton, Multiset.insert_eq_cons, Multiset.sum_cons]
    apply not_max_prod_set_of_prod_lt_prod h
    simp [Multiset.prod_singleton, Multiset.insert_eq_cons, Multiset.prod_cons]
  have h₃ : Multiset.count 4 s < 2 := by
    by_contra! h4
    have h44 : ({4, 4} : Multiset ℕ) ≤ s := by
      rw [Multiset.le_iff_count]
      intro n
      by_cases hn4 : n = 4
      · simp [hn4]
        exact h4
      · have hn' : n ∉ ({4, 4} : Multiset ℕ) := by
          simp [← Multiset.mem_toFinset]
          exact hn4
        rw [Multiset.count_eq_zero_of_notMem hn']
        apply Nat.zero_le
    have h44' := max_prod_set_of_subset_of_max_prod_set h44 hs
    contrapose! h44'
    have h : ({4, 4} : Multiset ℕ).sum = ({3, 3, 2} : Multiset ℕ).sum := by
      simp [Multiset.sum_singleton, Multiset.insert_eq_cons, Multiset.sum_cons]
    apply not_max_prod_set_of_prod_lt_prod h
    simp [Multiset.prod_singleton, Multiset.insert_eq_cons, Multiset.prod_cons]
  have h₄ : Multiset.count 4 s < 1 ∨ Multiset.count 2 s < 1 := by
    by_contra! h'
    have h24 : ({2, 4} : Multiset ℕ) ≤ s := by
      rw [Multiset.le_iff_count]
      intro n
      by_cases hn4 : n = 4
      · simp [hn4]
        exact h'.left
      · by_cases hn2 : n = 2
        · simp [hn2]
          exact h'.right
        · have hn' : n ∉ ({2, 4} : Multiset ℕ) := by
            simp [← Multiset.mem_toFinset]
            exact ⟨hn2, hn4⟩
          rw [Multiset.count_eq_zero_of_notMem hn']
          apply Nat.zero_le
    have h24' := max_prod_set_of_subset_of_max_prod_set h24 hs
    contrapose! h24'
    have h : ({2, 4} : Multiset ℕ).sum = ({3, 3} : Multiset ℕ).sum := by
      simp [Multiset.sum_singleton, Multiset.insert_eq_cons, Multiset.sum_cons]
    apply not_max_prod_set_of_prod_lt_prod h
    simp [Multiset.prod_singleton, Multiset.insert_eq_cons, Multiset.prod_cons]
  lia

lemma max_prod_zero : IsMaxProd 0 1 := by
  constructor
  · use 0
    constructor <;> rfl
  · intro n hn
    rcases hn with ⟨s, ⟨s_sum, s_prod⟩⟩
    by_cases hs : s = 0
    · rw [← s_prod, hs, Multiset.prod_zero]
    · rcases Multiset.exists_mem_of_ne_zero hs with ⟨m, hm⟩
      have hm' := Multiset.le_sum_of_mem hm
      rw [s_sum] at hm'
      rw [Nat.eq_zero_of_le_zero hm'] at hm
      rw [← s_prod, Multiset.prod_eq_zero hm]
      lia

lemma max_prod_one : IsMaxProd 1 1 := by
  constructor
  · use {1}
    constructor <;> rfl
  · intro n hn
    rcases hn with ⟨s, ⟨s_sum, s_prod⟩⟩
    rcases exists_mem_of_sum_lt_zero s (by lia:_) with ⟨m, hm⟩
    have hm' : m ≤ 1 := by
      rw [← s_sum]
      exact Multiset.le_sum_of_mem hm
    rcases Multiset.exists_cons_of_mem hm with ⟨t, ht⟩
    have ht' : t.sum = 1 - m := by
      rw [← s_sum, ht, Multiset.sum_cons, add_comm, Nat.add_sub_cancel_right]
    rw [← s_prod, ht, Multiset.prod_cons]
    interval_cases m
    · rw [zero_mul]
      norm_num
    · have h := prod_le_max_prod max_prod_zero ht'
      lia

lemma max_prod_two : IsMaxProd 2 2 := by
  constructor
  · use {2}
    constructor <;> rfl
  · intro n hn
    rcases hn with ⟨s, ⟨s_sum, s_prod⟩⟩
    rcases exists_mem_of_sum_lt_zero s (by lia:_) with ⟨m, hm⟩
    have hm' : m ≤ 2 := by
      rw [← s_sum]
      exact Multiset.le_sum_of_mem hm
    rcases Multiset.exists_cons_of_mem hm with ⟨t, ht⟩
    have ht' : t.sum = 2 - m := by
      rw [← s_sum, ht, Multiset.sum_cons, add_comm, Nat.add_sub_cancel_right]
    rw [← s_prod, ht, Multiset.prod_cons]
    interval_cases m
    · rw [zero_mul]
      norm_num
    · have h := prod_le_max_prod max_prod_one ht'
      lia
    · have h := prod_le_max_prod max_prod_zero ht'
      lia

lemma max_prod_three : IsMaxProd 3 3 := by
  constructor
  · use {3}
    constructor <;> rfl
  · intro n hn
    rcases hn with ⟨s, ⟨s_sum, s_prod⟩⟩
    rcases exists_mem_of_sum_lt_zero s (by lia:_) with ⟨m, hm⟩
    have hm' : m ≤ 3 := by
      rw [← s_sum]
      exact Multiset.le_sum_of_mem hm
    rcases Multiset.exists_cons_of_mem hm with ⟨t, ht⟩
    have ht' : t.sum = 3 - m := by
      rw [← s_sum, ht, Multiset.sum_cons, add_comm, Nat.add_sub_cancel_right]
    rw [← s_prod, ht, Multiset.prod_cons]
    interval_cases m
    · rw [zero_mul]
      norm_num
    · have h := prod_le_max_prod max_prod_two ht'
      lia
    · have h := prod_le_max_prod max_prod_one ht'
      lia
    · have h := prod_le_max_prod max_prod_zero ht'
      lia

lemma max_prod_four : IsMaxProd 4 4 := by
  constructor
  · use {4}
    constructor <;> rfl
  · intro n hn
    rcases hn with ⟨s, ⟨s_sum, s_prod⟩⟩
    rcases exists_mem_of_sum_lt_zero s (by lia:_) with ⟨m, hm⟩
    have hm' : m ≤ 4 := by
      rw [← s_sum]
      exact Multiset.le_sum_of_mem hm
    rcases Multiset.exists_cons_of_mem hm with ⟨t, ht⟩
    have ht' : t.sum = 4 - m := by
      rw [← s_sum, ht, Multiset.sum_cons, add_comm, Nat.add_sub_cancel_right]
    rw [← s_prod, ht, Multiset.prod_cons]
    interval_cases m
    · rw [zero_mul]
      norm_num
    · have h := prod_le_max_prod max_prod_three ht'
      lia
    · have h := prod_le_max_prod max_prod_two ht'
      lia
    · have h := prod_le_max_prod max_prod_one ht'
      lia
    · have h := prod_le_max_prod max_prod_zero ht'
      lia

theorem generalized (n : ℕ) :
  IsMaxProd n (result n) := by
  fun_induction result with
  | case1 => exact max_prod_zero
  | case2 => exact max_prod_one
  | case3 => exact max_prod_two
  | case4 => exact max_prod_three
  | case5 => exact max_prod_four
  | case6 n n_ne_zero n_ne_one ih =>
    rw [imp_false, ← ne_eq] at *
    rcases exists_max_prod (n + 3) with ⟨m, hm⟩
    rcases exists_max_prod_set hm with ⟨s, ⟨hs_sum, hs⟩⟩
    have hs_sum' : 4 < s.sum := by
      rw [hs_sum]
      lia
    have hs3 := three_in_max_prod_set_of_four_lt_sum hs_sum' hs
    have hs3' := Multiset.singleton_le.mpr hs3
    have hs_without_3 : s - {3} ≤ s := Multiset.sub_le_self _ _
    have hs_without_3' := max_prod_set_of_subset_of_max_prod_set hs_without_3 hs
    have hs_without_3_sum : (s - {3}).sum = n := by
      calc (s - {3}).sum
          = (s - {3}).sum + ({3} : Multiset _).sum - ({3} : Multiset _).sum := by rfl
        _ = (s - {3} + {3}).sum - ({3} : Multiset _).sum := by rw [Multiset.sum_add]
        _ = s.sum - ({3} : Multiset _).sum := by rw [Multiset.sub_add_cancel hs3']
        _ = n + 3 - 3 := by rw [hs_sum, Multiset.sum_singleton]
        _ = n := by rfl
    rw [IsMaxProdSet, hs_without_3_sum] at hs_without_3'
    have hs_without_3_prod := IsGreatest.unique hs_without_3' ih
    have hs_prod : s.prod = (3 * result n) := by
      calc s.prod
          = (s - {3} + {3}).prod := by rw [Multiset.sub_add_cancel hs3']
        _ = (s - {3}).prod * ({3} : Multiset _).prod := by rw [Multiset.prod_add]
        _ = result n * 3 := by rw [hs_without_3_prod, Multiset.prod_singleton]
        _ = 3 * result n := by apply mul_comm
    rw [IsMaxProdSet, hs_prod, hs_sum] at hs
    exact hs



noncomputable def solution : ℕ := result 1976

theorem imo1976_p4 :
    IsGreatest
      { n | ∃ s : Multiset ℕ, s.sum = 1976 ∧ s.prod = n }
      solution := by
  exact generalized 1976


end Imo1976P4

-- ═══ Imo1976P6 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1, Aristotle-Harmonic, David Renshaw
-/





/-!
# International Mathematical Olympiad 1976, Problem 6

The sequence u_0, u_1, u_2, ... is defined by:
u_0 = 2, u_1 = 5/2, u_{n+1} = u_n(u_{n-1}^2 - 2) - u_1 for n = 1, 2, ... .
Prove that ⌊u_n⌋ = 2^(2^n - (-1)^n)/3 for all positive n,
where ⌊x⌋ denotes the greatest integer less than or equal to x.
-/

namespace Imo1976P6

theorem imo1976_p6 (u : ℕ → ℝ)
    (h₀ : u 0 = 2)
    (h₁ : u 1 = 5 / 2)
    (h₂ : ∀ n, u (n + 2) = u (n + 1) * ((u n) ^ 2 - 2) - u 1) :
      ∀ n > 0, ⌊u n⌋  = (2 : ℝ) ^ ((2^n - (-1 : ℝ) ^ n) / 3) := by
  have h_ind : ∀ n, u n = 2 ^ ((2 ^ n - (-1) ^ n) / 3 : ℝ) +
                          2 ^ ((-2 ^ n + (-1) ^ n) / 3 : ℝ) := by
    intro n
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | n ) <;> norm_num
    · exact h₀
    · exact h₁
    simp_all only [lt_add_iff_pos_left, add_pos_iff, Nat.ofNat_pos, or_true, pow_zero,
                   sub_self, zero_div, Real.rpow_zero, neg_add_cancel,
                   zero_lt_one, pow_one, sub_neg_eq_add, lt_add_iff_pos_right]
    ring_nf at * ; norm_num at *;
    rw [ih n (by lia)] ; ring_nf; norm_num [ sq, ← Real.rpow_add ] ; ring_nf;
    obtain h | h := Nat.even_or_odd n <;> norm_num [h.neg_one_pow] <;> ring_nf
  intro n hn_pos
  have h_int : ∃ k : ℤ, (2 : ℝ) ^ ((2 ^ n - (-1) ^ n) / 3 : ℝ) = k := by
    -- We need to show that $(2^n - (-1)^n) / 3$ is an integer.
    have h_int : ∃ k : ℤ, (2^n - (-1)^n) = 3 * k := sub_dvd_pow_sub_pow _ _ _
    simp_all only [pow_zero, sub_self, zero_div, Real.rpow_zero, neg_add_cancel,
                   pow_one, sub_neg_eq_add, gt_iff_lt, Int.reduceNeg]
    obtain ⟨w, h⟩ := h_int
    use 2 ^ w.natAbs
    obtain a | a := w <;> norm_num [ Real.rpow_def_of_pos ] at *
    · simp_all only [Int.reduceNeg]
      norm_num [ ← h, Real.exp_mul, Real.exp_log ];
      norm_num [ show ( 2 ^ n - ( -1 ) ^ n : ℝ ) = 3 * a by exact_mod_cast h ];
    · obtain ⟨w, h_1⟩ := Nat.even_or_odd' n
      simp_all only [Int.reduceNeg]
      cases h_1 with
      | inl h_2 =>
        subst h_2
        simp_all only [Nat.ofNat_pos, mul_pos_iff_of_pos_left, Int.reduceNeg, even_two,
                       Even.mul_right, Even.neg_pow, one_pow]
        lia
      | inr h_3 =>
        subst h_3
        simp_all only [lt_add_iff_pos_left, add_pos_iff, Nat.ofNat_pos, mul_pos_iff_of_pos_left,
                       zero_lt_one, or_true, Int.reduceNeg]
        norm_num [Int.negSucc_eq] at h
        lia
  simp_all only [pow_zero, sub_self, zero_div, Real.rpow_zero, neg_add_cancel,
                 pow_one, sub_neg_eq_add, gt_iff_lt]
  obtain ⟨w, h⟩ := h_int
  simp_all only [Int.floor_intCast_add, Int.cast_add, add_eq_left, Int.cast_eq_zero,
                 Int.floor_eq_zero_iff, Set.mem_Ico]
  apply And.intro
  · positivity
  · rw [ Real.rpow_lt_one_iff ] <;> norm_num
    rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] at *;
    · linarith [ pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 4 ) hn_pos ];
    · linarith [ pow_pos ( by norm_num : ( 0 : ℝ ) < 4 ) k ]

end Imo1976P6

-- ═══ Imo1977P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1, Goedel-Prover-V2
-/





/-!
# International Mathematical Olympiad 1977, Problem 4

Define f(x) = 1 - a cos x - b sin x - A cos 2x - B sin 2x,
where a, b, A, B are real constants.
Suppose that f(x) ≥ 0 for all real x.
Prove that a^2 + b^2 ≤ 2 and A^2 + B^2 ≤ 1.
-/

namespace Imo1977P4

theorem imo1977_p4 (f : ℝ → ℝ) (a b A B : ℝ)
    (h₀ : ∀ x, f x = 1 - a * Real.cos x - b * Real.sin x -
                     A * Real.cos (2 * x) - B * Real.sin (2 * x))
    (h₁ : ∀ x, f x ≥ 0) :
    a ^ 2 + b ^ 2 ≤ 2 ∧ A ^ 2 + B ^ 2 ≤ 1 := by
  have h₂ : A ^ 2 + B ^ 2 ≤ 1 := by
    by_contra! h
    have h₅ : 0 < A ^ 2 + B ^ 2 := by positivity

    set R : ℝ := Real.sqrt (A ^ 2 + B ^ 2) with hR_def
    have hR_pos : 0 < R := Real.sqrt_pos.mpr h₅
    have hR_sq : R ^ 2 = A ^ 2 + B ^ 2 := Real.sq_sqrt (by positivity)

    set p : ℝ := A / R with hp_def
    set q : ℝ := B / R with hq_def
    have hpq_sq : p ^ 2 + q ^ 2 = 1 := by
      calc
        p ^ 2 + q ^ 2 = (A / R) ^ 2 + (B / R) ^ 2 := by rw [hp_def, hq_def]
        _ = (A ^ 2 + B ^ 2) / R ^ 2 := by
          field_simp [hR_pos.ne']
        _ = 1 := by
          rw [hR_sq]
          field_simp [hR_pos.ne']

    have hpn1 : -1 ≤ p := by nlinarith only [hpq_sq]
    have hp1 : p ≤ 1 := by nlinarith only [hpq_sq]
    have hθ : ∃ (θ : ℝ), Real.cos θ = p ∧ Real.sin θ = q := by
      by_cases hq_nonneg : q ≥ 0
      · use Real.arccos p
        have h₈ : Real.sin (Real.arccos p) = Real.sqrt (1 - p ^ 2) := by
          rw [Real.sin_arccos]
        have h₉ : Real.sqrt (1 - p ^ 2) = q := by
          have h₁₁ : q ^ 2 = 1 - p ^ 2 := (sub_eq_of_eq_add' hpq_sq.symm).symm
          have h₁₂ : Real.sqrt (1 - p ^ 2) = q := by
            rw [Real.sqrt_eq_iff_eq_sq _ hq_nonneg] <;> nlinarith only [h₁₁]
          exact h₁₂
        exact ⟨Real.cos_arccos hpn1 hp1, by linarith only [h₈, h₉]⟩
      · use -Real.arccos p
        have h₇ : Real.cos (-Real.arccos p) = p := by
          rw [Real.cos_neg, Real.cos_arccos hpn1 hp1]
        have h₈ : Real.sin (-Real.arccos p) = -Real.sqrt (1 - p ^ 2) := by
          rw [Real.sin_neg, Real.sin_arccos]
        have h₉ : -Real.sqrt (1 - p ^ 2) = q := by
          have h₁₀ : q < 0 := lt_of_not_ge hq_nonneg
          have h₁₁ : q ^ 2 = 1 - p ^ 2 := (sub_eq_of_eq_add' hpq_sq.symm).symm
          have h₁₂ : Real.sqrt (1 - p ^ 2) = -q := by
            rw [Real.sqrt_eq_iff_eq_sq] <;> nlinarith only [h₁₀, h₁₁]
          exact neg_eq_iff_eq_neg.mpr h₁₂
        exact ⟨h₇, by linarith only [h₈, h₉]⟩
    obtain ⟨θ, hθ_cos, hθ_sin⟩ := hθ

    have h₁₀ : A * Real.cos θ + B * Real.sin θ = R := by
      calc
        A * Real.cos θ + B * Real.sin θ = R * p * Real.cos θ + R * q * Real.sin θ := by
          rw [hp_def, hq_def]
          field_simp [hR_pos.ne']
        _ = R * (p * Real.cos θ + q * Real.sin θ) := by ring
        _ = R * (p * p + q * q) := by
          rw [hθ_cos, hθ_sin]
        _ = R * 1 := by
          have h₁₂ : p * p + q * q = 1 := by simp only [←sq, hpq_sq]
          rw [h₁₂]
        _ = R := by ring

    have h₁₁ : A * Real.cos θ + B * Real.sin θ > 1 := by
      have h₁₂ : R > 1 := by
        rw [hR_def, gt_iff_lt, ←one_lt_sq_iff₀ (a := √(A^2 + B^2)) (by positivity)]
        rw [Real.sq_sqrt (by positivity)]
        exact h
      linarith only [h₁₀, h₁₂]

    have h₁₂ : A * Real.cos (2 * (θ / 2)) + B * Real.sin (2 * (θ / 2)) > 1 := by
      have h₁₃ : Real.cos (2 * (θ / 2)) = Real.cos θ := by ring_nf
      have h₁₄ : Real.sin (2 * (θ / 2)) = Real.sin θ := by ring_nf
      lia
    have h₁₃ : A * Real.cos (2 * (θ / 2)) + B * Real.sin (2 * (θ / 2)) ≤ 1 := by
      have h₁₄ : f (θ / 2) + f (θ / 2 + Real.pi) ≥ 0 := by
        have h₁₅ : f (θ / 2) ≥ 0 := h₁ (θ / 2)
        have h₁₆ : f (θ / 2 + Real.pi) ≥ 0 := h₁ (θ / 2 + Real.pi)
        positivity
      have h₁₅ : f (θ / 2) + f (θ / 2 + Real.pi) = 2 - 2 * (A * Real.cos (2 * (θ / 2)) + B * Real.sin (2 * (θ / 2))) := by
        have h₁₆ : f (θ / 2) = 1 - a * Real.cos (θ / 2) - b * Real.sin (θ / 2) - A * Real.cos (2 * (θ / 2)) - B * Real.sin (2 * (θ / 2)) := by
          rw [h₀]
        have h₁₇ : f (θ / 2 + Real.pi) = 1 - a * Real.cos (θ / 2 + Real.pi) - b * Real.sin (θ / 2 + Real.pi) - A * Real.cos (2 * (θ / 2 + Real.pi)) - B * Real.sin (2 * (θ / 2 + Real.pi)) := by
          rw [h₀]
        rw [h₁₆, h₁₇]
        have h₁₈ : Real.cos (θ / 2 + Real.pi) = -Real.cos (θ / 2) := by
          rw [Real.cos_add]
          simp [Real.cos_pi, Real.sin_pi]
        have h₁₉ : Real.sin (θ / 2 + Real.pi) = -Real.sin (θ / 2) := by
          rw [Real.sin_add]
          simp [Real.cos_pi, Real.sin_pi]
        have h₂₀ : Real.cos (2 * (θ / 2 + Real.pi)) = Real.cos (2 * (θ / 2)) := by
          have h₂₁ : 2 * (θ / 2 + Real.pi) = 2 * (θ / 2) + 2 * Real.pi := by ring_nf
          rw [h₂₁]
          exact Real.cos_add_two_pi (2 * (θ / 2))
        have h₂₁ : Real.sin (2 * (θ / 2 + Real.pi)) = Real.sin (2 * (θ / 2)) := by
          have h₂₂ : 2 * (θ / 2 + Real.pi) = 2 * (θ / 2) + 2 * Real.pi := by ring_nf
          rw [h₂₂]
          exact Real.sin_add_two_pi (2 * (θ / 2))
        rw [h₁₈, h₁₉, h₂₀, h₂₁]
        ring_nf
      rw [h₁₅] at h₁₄
      linarith only [h₁₄]
    exact not_lt_of_ge h₁₃ h₁₂

  have h₃ : a ^ 2 + b ^ 2 ≤ 2 := by
    by_contra! h

    set C : ℝ := a + b with hC_def
    set D : ℝ := a - b with hD_def
    have hC_sq_add_D_sq : C ^ 2 + D ^ 2 = 2 * (a ^ 2 + b ^ 2) := by
      calc
        C ^ 2 + D ^ 2 = (a + b) ^ 2 + (a - b) ^ 2 := by rw [hC_def, hD_def]
        _ = 2 * (a ^ 2 + b ^ 2) := by ring
    have hC_sq_add_D_sq_gt_4 : C ^ 2 + D ^ 2 > 4 := by
      linarith only [h, hC_sq_add_D_sq]

    set R : ℝ := Real.sqrt (C ^ 2 + D ^ 2) with hR_def
    have hR_pos : 0 < R := by positivity
    have hR_sq : R ^ 2 = C ^ 2 + D ^ 2 := Real.sq_sqrt (by positivity)

    set p : ℝ := C / R with hp_def
    set q : ℝ := D / R with hq_def
    have hpq_sq : p ^ 2 + q ^ 2 = 1 := by
      calc
        p ^ 2 + q ^ 2 = (C / R) ^ 2 + (D / R) ^ 2 := by rw [hp_def, hq_def]
        _ = (C ^ 2 + D ^ 2) / R ^ 2 := by
          field_simp [hR_pos.ne']
        _ = 1 := by
          rw [hR_sq]
          field_simp [hR_pos.ne']

    have hpn1 : -1 ≤ p := by nlinarith only [hpq_sq]
    have hp1 : p ≤ 1 := by nlinarith only [hpq_sq]
    have hθ : ∃ (θ : ℝ), Real.cos θ = p ∧ Real.sin θ = -q := by
      by_cases hq_nonneg : q ≥ 0
      · use -Real.arccos p
        have h₅ : Real.cos (-Real.arccos p) = p := by
          rw [Real.cos_neg, Real.cos_arccos hpn1 hp1]
        have h₆ : Real.sin (-Real.arccos p) = -Real.sqrt (1 - p ^ 2) := by
          rw [Real.sin_neg, Real.sin_arccos]
        have h₇ : -Real.sqrt (1 - p ^ 2) = -q := by
          have h₈ : q ≥ 0 := hq_nonneg
          have h₉ : q ^ 2 = 1 - p ^ 2 := (sub_eq_of_eq_add' hpq_sq.symm).symm
          congr 1
          rw [Real.sqrt_eq_iff_eq_sq] <;> nlinarith only [h₈, h₉]
        exact ⟨h₅, h₆.trans h₇⟩
      · use Real.arccos p
        have h₆ : Real.sin (Real.arccos p) = Real.sqrt (1 - p ^ 2) := by
          rw [Real.sin_arccos]
        have h₇ : Real.sqrt (1 - p ^ 2) = -q := by
          have h₈ : q < 0 := lt_of_not_ge hq_nonneg
          have h₉ : q ^ 2 = 1 - p ^ 2 := (sub_eq_of_eq_add' hpq_sq.symm).symm
          rw [Real.sqrt_eq_iff_eq_sq] <;> nlinarith only [h₈, h₉]
        exact ⟨Real.cos_arccos hpn1 hp1, by rw [h₆, h₇]⟩
    obtain ⟨θ, hθ_cos, hθ_sin⟩ := hθ

    have h₅ : C * Real.cos θ - D * Real.sin θ = R := by
      calc
        C * Real.cos θ - D * Real.sin θ = R * p * Real.cos θ - R * q * Real.sin θ := by
          rw [hp_def, hq_def]
          ring_nf
          field_simp [hR_pos.ne']
        _ = R * (p * Real.cos θ - q * Real.sin θ) := by ring
        _ = R * (p * p + q * q) := by
          rw [hθ_cos, hθ_sin]
          ring_nf
        _ = R * 1 := by
          have h₆ : p ^ 2 + q ^ 2 = 1 := hpq_sq
          have h₇ : p * p + q * q = 1 := by simp only [←sq, h₆]
          rw [h₇]
        _ = R := by ring

    have h₆ : C * Real.cos θ - D * Real.sin θ > 2 := by
      have h₇ : R > 2 := by
        have h₉ : C ^ 2 + D ^ 2 > 4 := hC_sq_add_D_sq_gt_4
        rw [←hR_sq, show 4 = (2:ℝ)^2 by norm_num] at h₉
        exact (sq_lt_sq₀ (by positivity) (by positivity)).mp h₉
      lia

    have h₇ : C * Real.cos θ - D * Real.sin θ ≤ 2 := by
      have h₈ : f θ + f (θ + Real.pi / 2) ≥ 0 := by
        exact Left.add_nonneg (h₁ θ) (h₁ (θ + Real.pi / 2))
      have h₉ : f θ + f (θ + Real.pi / 2) = 2 - (C * Real.cos θ - D * Real.sin θ) := by
        have h₁₀ : f θ = 1 - a * Real.cos θ - b * Real.sin θ - A * Real.cos (2 * θ) - B * Real.sin (2 * θ) := by
          rw [h₀]
        have h₁₁ : f (θ + Real.pi / 2) = 1 - a * Real.cos (θ + Real.pi / 2) - b * Real.sin (θ + Real.pi / 2) - A * Real.cos (2 * (θ + Real.pi / 2)) - B * Real.sin (2 * (θ + Real.pi / 2)) := by
          rw [h₀]
        rw [h₁₀, h₁₁]
        have h₁₂ : Real.cos (θ + Real.pi / 2) = -Real.sin θ := by
          rw [Real.cos_add]
          simp [Real.cos_pi_div_two, Real.sin_pi_div_two]
        have h₁₃ : Real.sin (θ + Real.pi / 2) = Real.cos θ := by
          rw [Real.sin_add]
          simp [Real.cos_pi_div_two, Real.sin_pi_div_two]
        have h₁₄ : Real.cos (2 * (θ + Real.pi / 2)) = -Real.cos (2 * θ) := by
          have h₁₅ : 2 * (θ + Real.pi / 2) = 2 * θ + Real.pi := by ring_nf
          rw [h₁₅]
          exact Real.cos_add_pi _
        have h₁₅ : Real.sin (2 * (θ + Real.pi / 2)) = -Real.sin (2 * θ) := by
          have h₁₆ : 2 * (θ + Real.pi / 2) = 2 * θ + Real.pi := by ring_nf
          rw [h₁₆]
          exact Real.sin_add_pi _
        rw [h₁₂, h₁₃, h₁₄, h₁₅]
        have h₁₆ : C = a + b := by rw [hC_def]
        have h₁₇ : D = a - b := by rw [hD_def]
        simp only [h₁₆, h₁₇] at *
        ring_nf at *
      rw [h₉] at h₈
      linarith only [h₈]
    exact not_lt_of_ge h₇ h₆

  exact ⟨h₃, h₂⟩


end Imo1977P4

-- ═══ Imo1977P6 ═══

/-
Copyright (c) 2021 Tian Chen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tian Chen
-/




/-!
# International Mathematical Olympiad 1977, Problem 6

Suppose `f : ℕ+ → ℕ+` satisfies `f(f(n)) < f(n + 1)` for all `n`.
Prove that `f(n) = n` for all `n`.
-/

namespace Imo1977P6



/-
We first prove the problem statement for `f : ℕ → ℕ`
then we use it to prove the statement for positive naturals.
-/

theorem imo1977_p6_nat (f : ℕ → ℕ) (h : ∀ n, f (f n) < f (n + 1)) : ∀ n, f n = n := by
  have h' : ∀ k n : ℕ, k ≤ n → k ≤ f n := by
    intro k
    induction k with
    | zero => intros; exact Nat.zero_le _
    | succ k h_ind =>
      intro n hk
      apply Nat.succ_le_of_lt
      calc
        k ≤ f (f (n - 1)) := h_ind _ (h_ind (n - 1) (le_tsub_of_add_le_right hk))
        _ < f n := tsub_add_cancel_of_le (le_trans (Nat.succ_le_succ (Nat.zero_le _)) hk) ▸ h _
  have hf : ∀ n, n ≤ f n := fun n => h' n n rfl.le
  have hf_mono : StrictMono f := strictMono_nat_of_lt_succ fun _ => lt_of_le_of_lt (hf _) (h _)
  intro
  exact Nat.eq_of_le_of_lt_succ (hf _) (hf_mono.lt_iff_lt.mp (h _))



theorem imo1977_p6 (f : ℕ+ → ℕ+) (h : ∀ n, f (f n) < f (n + 1)) : ∀ n, f n = n := by
  intro n
  have := by
    refine imo1977_p6_nat (fun m => if 0 < m then f m.toPNat' else 0) ?_ n
    intro x; cases x
    · simp
    · simpa using h _
  simpa


end Imo1977P6

-- ═══ Imo1978P5 ═══

/-
Copyright (c) 2025 Roozbeh Yousefzadeh. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/






/-!
# International Mathematical Olympiad 1978, Problem 5

Let a_k be a sequence of distinct positive integers for k = 1,2,3, ...

Prove that for all natural numbers n, we have:

sum_{k=1}^{n} a(k)/(k^2) >= sum_{k=1}^{n} (1/k).
-/

open Finset

namespace Imo1978P5



lemma aux₁
    {n : ℕ}
    (f : ℕ → ℕ)
    (h₀ : ∀ (m : ℕ), 0 < m → 0 < f m)
    (h₁ : ∀ (p q : ℕ), 0 < p → 0 < q → p ≠ q → f p ≠ f q)
    (h₂ : 0 < n) :
    ∑ k ∈ Finset.Icc 1 n, ((k):ℝ) / (k) ^ 2 ≤ ∑ k ∈ Finset.Icc 1 n, ((f k):ℝ) / (k) ^ 2 := by
  let s := Finset.Icc 1 n
  let f₀ : ℕ → ℝ := fun k => 1 / (k:ℝ) ^ 2
  let f₁ : ℕ → ℝ := fun k => (k:ℝ)
  let f₂ : ℕ → ℝ := fun k => ((f k):ℝ)
  have h₃: ∑ k ∈ Icc 1 n, (k : ℝ) / k ^ 2 = ∑ k ∈ Icc 1 n, f₁ k • f₀ k := by
    refine Finset.sum_congr rfl ?_
    intro x _
    rw [div_eq_mul_one_div, smul_eq_mul]
  have h₄: ∑ k ∈ Icc 1 n, ((f k):ℝ) / (k) ^ 2 = ∑ k ∈ Icc 1 n, f₂ k • f₀ k := by
    refine Finset.sum_congr rfl ?_
    intro x _
    rw [div_eq_mul_one_div, smul_eq_mul]
  let sf : Finset ℝ := Finset.image f₂ (Finset.Icc 1 n)
  set sf_sorted : List ℝ := sf.sort (fun (x₁ x₂) => x₁ ≤ x₂) with hf₁
  let f₃: ℕ → ℝ := fun k => sf_sorted.getD (k - 1) 0
  have hf₀: ∀ k, f₃ k = sf_sorted.getD (k - 1) 0 := by exact fun k => rfl
  have hf₂: sf = Finset.image f₂ s := by rfl
  have hf₃: f₂ = fun k => ((f k):ℝ) := by rfl
  have hl₁: s.card = n := by
    have g₀: s = Icc 1 n := by rfl
    rw [g₀]
    refine Nat.le_induction ?_ ?_ n h₂
    · simp
    · simp
  have hf₄: sf_sorted.length = n ∧ (sort (image f s) (fun x₁ x₂ => x₁ ≤ x₂) ).length = n := by
    have hl₂: sf.card = n := by
      rw [← hl₁]
      refine Finset.card_image_of_injOn ?_
      intro p hp₀ q hq₀ hpq
      have hf₅: f₂ = fun k => ((f k):ℝ) := by rfl
      contrapose! hpq
      rw [hf₅]
      simp only [ne_eq, Nat.cast_inj]
      refine h₁ p q ?_ ?_ hpq
      · norm_cast at hp₀
        apply Finset.mem_Icc.mp at hp₀
        exact hp₀.1
      · norm_cast at hq₀
        apply Finset.mem_Icc.mp at hq₀
        exact hq₀.1
    have hl₃: (image f s).card = n := by
      rw [← hl₁]
      refine Finset.card_image_of_injOn ?_
      intro p hp₀ q hq₀ hpq
      contrapose! hpq
      refine h₁ p q ?_ ?_ hpq
      · norm_cast at hp₀
        apply Finset.mem_Icc.mp at hp₀
        exact hp₀.1
      · norm_cast at hq₀
        apply Finset.mem_Icc.mp at hq₀
        exact hq₀.1
    constructor
    · rw [← hl₂]
      exact length_sort fun x₁ x₂ => x₁ ≤ x₂
    · rw [← hl₃]
      exact length_sort fun x₁ x₂ => x₁ ≤ x₂
  have hf₅: ∀ a ∈ s, a - 1 < sf_sorted.length := by
    intro a ha₀
    rw [hf₄.1]
    apply Finset.mem_Icc.mp at ha₀
    lia
  have hf₆: ∀ k ∈ s, 1 ≤ f₃ k := by
    have hs₂: ∀ k ∈ sf_sorted, 1 ≤ k := by
      rw [hf₁, hf₂, hf₃]
      simp only [mem_sort, mem_image, forall_exists_index, and_imp,
                 forall_apply_eq_imp_iff₂, Nat.one_le_cast]
      intro k hk₀
      apply Finset.mem_Icc.mp at hk₀
      exact h₀ k hk₀.1
    have hs₃: ∀ k ∈ s, f₃ k ∈ sf_sorted := by
      intro k hk₀
      rw [hf₀]
      have hk₁: k - 1 < sf_sorted.length := by exact hf₅ k hk₀
      rw [List.getD_eq_getElem sf_sorted 0 hk₁]
      exact List.getElem_mem hk₁
    intro k hk₀
    exact hs₂ (f₃ k) (hs₃ k hk₀)
  have hf₇: ∀ a : ℕ, a ∈ Icc 1 n → ∀ b : ℕ, b ∈ Icc 1 n → a < b → f₃ a + 1 ≤ f₃ b := by
    intro a ha₀ b hb₀ hab
    rw [hf₀, hf₀]
    have ha₁: a - 1 < sf_sorted.length := by exact hf₅ a ha₀
    have hb₁: b - 1 < sf_sorted.length := by exact hf₅ b hb₀
    rw [hf₁, hf₂]
    let sfo : Finset ℕ := image f s
    have hso₂: ∀ k ∈ s, ((image f₂ s).sort (fun x₁ x₂ => x₁ ≤ x₂)).getD (k - 1) 0
      = ((image f s).sort (fun x₁ x₂ => x₁ ≤ x₂)).getD (k - 1) 0 := by
      intro k hk₀
      have hk₃: Function.Injective f₁ := CharZero.cast_injective
      let fe : ℕ ↪ ℝ := {toFun := f₁ , inj' := hk₃}
      have hk₅: ((image f₂ s).sort (fun x₁ x₂ => x₁ ≤ x₂)) =
        List.map f₁ ((image f s).sort (fun x₁ x₂ => x₁ ≤ x₂)) := by
        have hh₀: fe = {toFun := f₁ , inj' := hk₃} := by rfl
        have hh₁: (image f₂ s) = Finset.map fe (image f s) := by
          rw [hf₃, hh₀]
          refine Finset.induction_on_min s ?_ ?_
          · simp
          · intro z sz _ hz₁
            simp only [image_insert, map_insert, Function.Embedding.coeFn_mk]
            exact congrArg (insert ↑(f z)) hz₁
        rw [hh₁]
        refine Finset.induction_on_min (image f s) ?_ ?_
        · simp
        · intro z sz hz₀ hz₁
          have hz₂: z ∉ sz := by
            contrapose! hz₀
            use z
          simp only [map_insert]
          have hz₃: fe z = (z:ℝ) := by exact rfl
          rw [hz₃]
          have hz₄: ∀ b ∈ sz, (fun x₁ x₂ => x₁ ≤ x₂) z b := by
            intro b a
            exact Nat.le_of_succ_le (hz₀ b a)
          have hz₅: ∀ b ∈ map fe sz, (fun x₁ x₂ => x₁ ≤ x₂) (↑z:ℝ) b := by
            intro y hy₀
            have hy₁: ∃ d:ℕ, d ∈ sz ∧ (d:ℝ) = y := by exact Multiset.mem_map.mp hy₀
            obtain ⟨d, hd₀, hd₁⟩ := hy₁
            refine le_of_lt ?_
            rw [← hd₁]
            exact Nat.cast_lt.mpr (hz₀ d hd₀)
          have hz₆: (↑z:ℝ) ∉ map fe sz := by
            simp only [mem_map, not_exists, not_and]
            intro x hx₀
            rw [hh₀]
            simp only [Function.Embedding.coeFn_mk]
            have hx₁: ∀ x:ℕ, f₁ x = (x:ℝ) := by exact fun x => rfl
            rw [hx₁]
            norm_cast
            exact Nat.ne_of_lt' (hz₀ x hx₀)
          rw [Finset.sort_insert (fun x₁ x₂ => x₁ ≤ x₂) hz₄ hz₂]
          rw [Finset.sort_insert (fun x₁ x₂ => x₁ ≤ x₂) hz₅ hz₆]
          simp only [List.map_cons, List.cons.injEq]
          exact List.cons_eq_cons.mp (congrArg (List.cons ↑z) hz₁)
      have hk₁: k - 1 < (List.map f₁ (sfo.sort (fun x₁ x₂ => x₁ ≤ x₂))).length := by
        rw [← hk₅]
        exact hf₅ k hk₀
      have hk₂: k - 1 < (sfo.sort (fun x₁ x₂ => x₁ ≤ x₂)).length := by
        rw [hf₄.2, ← hf₄.1]
        exact hf₅ k hk₀
      rw [hk₅, List.getD_eq_getElem _ 0 hk₁, List.getD_eq_getElem _ 0 hk₂]
      exact List.getElem_map f₁
    rw [hso₂ a ha₀, hso₂ b hb₀]
    norm_cast
    refine Nat.succ_le_of_lt ?_
    have ha₂: a - 1 < ((image f s).sort (fun x₁ x₂ => x₁ ≤ x₂)).length := by
      rw [hf₄.2, ← hf₄.1]
      exact ha₁
    have hb₂: b - 1 < ((image f s).sort (fun x₁ x₂ => x₁ ≤ x₂)).length := by
      rw [hf₄.2, ← hf₄.1]
      exact hb₁
    rw [List.getD_eq_getElem _ 0 ha₂, List.getD_eq_getElem _ 0 hb₂]
    refine List.Pairwise.rel_get_of_lt ?_ ?_
    · have := Finset.sortedLT_sort (image f s)
      rw [List.sortedLT_iff_pairwise] at this
      exact this
    simp only [Fin.mk_lt_mk]
    apply Finset.mem_Icc.mp at ha₀
    apply Finset.mem_Icc.mp at hb₀
    lia
  have hρ: ∃ ρ: Equiv.Perm ℕ, (∀ a ∈ Icc 1 n, f₂ a = f₃ (ρ a)) ∧ ∀ a ∉ Icc 1 n, ρ a = a := by
    let so : Finset ℕ := image f (Icc 1 n)
    let lo_sorted : List ℕ := so.sort (fun x₁ x₂ => x₁ ≤ x₂)
    let sl := List.range' 1 n 1
    have hs₀: sl = List.range' 1 n 1 := by rfl
    let lo : List ℕ := List.map f sl
    let f₄ : ℕ → ℕ := fun k => lo_sorted.getD (k - 1) 0
    let f₅ : ℕ → ℕ := fun k => (List.findIdx (fun x => x = f k) lo_sorted) + 1
    let f₆ : ℕ → ℕ := fun k => ite (k ∈ s) (f₅ k) (k)
    let f₈ : ℕ → ℕ := fun k => (List.findIdx (fun x => x = f₄ k) lo) + 1
    let f₉ : ℕ → ℕ := fun k => ite (k ∈ s) (f₈ k) (k)
    have gg₀: f₄ = fun k => lo_sorted.getD (k - 1) 0 := by rfl
    have gg₁: f₅ = fun k => List.findIdx (fun x => decide (x = f k)) lo_sorted + 1 := by rfl
    have gg₂: f₆ = fun k => if k ∈ s then f₅ k else k := by rfl
    have gg₃: f₈ = fun k => (List.findIdx (fun x => x = f₄ k) lo) + 1 := by rfl
    have gg₄: f₉ = fun k => ite (k ∈ s) (f₈ k) (k) := by rfl
    have gg₅: ∀ k ∈ s, f₆ k = f₅ k := by
      intro k hk₀
      rw [gg₂]
      simp only [ite_eq_left_iff]
      intro hk₁
      exact False.elim (hk₁ hk₀)
    have gg₆: ∀ k ∈ s, f₉ k = f₈ k := by grind
    have gg₇: ∀ k ∉ s, f₆ k = k := by grind
    have gg₈: ∀ k ∉ s, f₉ k = k := by grind
    have gg₉: lo_sorted.length = n := by grind
    have gg₁₀: ∀ k ∈ s, f₅ k ∈ s := by
      intro k hk₀
      refine Finset.mem_Icc.mpr ?_
      constructor
      · exact Nat.le_add_left 1 (List.findIdx (fun y => decide (y = f k)) lo_sorted)
      · have hk₁: List.findIdx (fun x => decide (x = f k)) lo_sorted < lo_sorted.length := by
          refine List.findIdx_lt_length.mpr ?_
          use (f k)
          constructor
          · refine (mem_sort fun x₁ x₂ => x₁ ≤ x₂).mpr ?_
            exact mem_image_of_mem f hk₀
          · exact of_decide_eq_self_eq_true (f k)
        rw [gg₉] at hk₁
        refine Nat.le_of_lt_succ ?_
        exact Nat.add_lt_of_lt_sub hk₁
    have gg₁₁: lo.length = n := by
      have g₀: lo = List.map f sl := by rfl
      rw [g₀, hs₀]
      simp
    have gg₁₂: ∀ k ∈ s, f₈ k ∈ s := by
      intro k hk₀
      refine Finset.mem_Icc.mpr ?_
      constructor
      · exact Nat.le_add_left 1 (List.findIdx (fun x => decide (x = f₄ k)) lo)
      · have hk₁: List.findIdx (fun x => decide (x = f₄ k)) lo < lo.length := by
          refine List.findIdx_lt_length.mpr ?_
          use (f₄ k)
          constructor
          · have hk₁: k - 1 < lo.length := by
              rw [gg₁₁]
              apply Finset.mem_Icc.mp at hk₀
              exact Nat.sub_one_lt_of_le hk₀.1 hk₀.2
            have hk₂: lo_sorted = so.sort (fun x₁ x₂ => x₁ ≤ x₂) := by rfl
            have hk₃: lo = List.map f sl := by rfl
            rw [gg₀, hk₂, hk₃]
            ring_nf
            have hk₄: so = image f (Icc 1 n) := by rfl
            rw [gg₁₁, ← gg₉, hk₂, hk₄] at hk₁
            rw [List.getD_eq_getElem _ 0 hk₁]
            let j : ℕ := ((image f (Icc 1 n)).sort (fun x₁ x₂ => x₁ ≤ x₂))[k - 1]
            have hj₀: j = ((image f (Icc 1 n)).sort (fun x₁ x₂ => x₁ ≤ x₂))[k - 1] := by rfl
            have hj₁: j ∈ ((image f (Icc 1 n)).sort (fun x₁ x₂ => x₁ ≤ x₂)) := List.getElem_mem hk₁
            have hj₂: j ∈ image f s := by exact (mem_sort fun x₁ x₂ => x₁ ≤ x₂).mp hj₁
            rw [← hj₀]
            exact List.mem_dedup.mp hj₂
          · exact of_decide_eq_self_eq_true (f₄ k)
        rw [gg₁₁] at hk₁
        refine Nat.le_of_lt_succ ?_
        exact Nat.add_lt_of_lt_sub hk₁
    have gg₁₃: sf_sorted = List.map f₁ lo_sorted := by
      have g₀: Function.Injective f₁ := by exact CharZero.cast_injective
      let fe : ℕ ↪ ℝ := {toFun := f₁ , inj' := g₀}
      have hh₀: fe = {toFun := f₁ , inj' := g₀} := by rfl
      have hh₁: (image f₂ s) = Finset.map fe (image f s) := by
        rw [hf₃, hh₀]
        refine Finset.induction_on_min s ?_ ?_
        · simp
        · intro z sz _ hz₁
          simp only [image_insert, map_insert, Function.Embedding.coeFn_mk]
          exact congrArg (insert ↑(f z)) hz₁
      have g₁: lo_sorted = so.sort (fun x₁ x₂ => x₁ ≤ x₂) := by rfl
      have g₂: so = image f s := by rfl
      rw [hf₁, hf₂, g₁, g₂, hh₁]
      refine Finset.induction_on_min (image f s) ?_ ?_
      · simp
      · intro z sz hz₀ hz₁
        have hz₂: z ∉ sz := by
          contrapose! hz₀
          use z
        simp only [map_insert]
        have hz₃ : fe z = (z:ℝ) := rfl
        rw [hz₃]
        have hz₄: ∀ b ∈ sz, (fun x₁ x₂ => x₁ ≤ x₂) z b := by
          simp only
          exact fun b a => Nat.le_of_succ_le (hz₀ b a)
        have hz₅: ∀ b ∈ map fe sz, (fun x₁ x₂ => x₁ ≤ x₂) (↑z:ℝ) b := by
          intro y hy₀
          have hy₁: ∃ d:ℕ, d ∈ sz ∧ (d:ℝ) = y := by exact Multiset.mem_map.mp hy₀
          obtain ⟨d, hd₀, hd₁⟩ := hy₁
          refine le_of_lt ?_
          rw [← hd₁]
          exact Nat.cast_lt.mpr (hz₀ d hd₀)
        have hz₆: (↑z:ℝ) ∉ map fe sz := by
          simp only [mem_map, not_exists, not_and]
          intro x hx₀
          rw [hh₀]
          simp only [Function.Embedding.coeFn_mk]
          have hx₁: ∀ x:ℕ, f₁ x = (x:ℝ) := by exact fun x => rfl
          rw [hx₁]
          norm_cast
          exact Nat.ne_of_lt' (hz₀ x hx₀)
        rw [Finset.sort_insert (fun x₁ x₂ => x₁ ≤ x₂) hz₄ hz₂]
        rw [Finset.sort_insert (fun x₁ x₂ => x₁ ≤ x₂) hz₅ hz₆]
        simp only [List.map_cons, List.cons.injEq]
        exact List.cons_eq_cons.mp (congrArg (List.cons ↑z) hz₁)
    have gg₁₄: ∀ x y, x ∈ s → y ∈ s → f₄ x = f₄ y → x = y := by
      intro x y hx₀ hy₀ hx₁
      have hx₂: List.Nodup lo_sorted := by exact sort_nodup so (fun x₁ x₂ => x₁ ≤ x₂)
      rw [gg₀] at hx₁
      ring_nf at hx₁
      have hx₃: x - 1 < lo_sorted.length := by
        rw [gg₉]
        apply Finset.mem_Icc.mp at hx₀
        exact Nat.sub_one_lt_of_le hx₀.1 hx₀.2
      have hy₁: y - 1 < lo_sorted.length := by
        rw [gg₉]
        apply Finset.mem_Icc.mp at hy₀
        exact Nat.sub_one_lt_of_le hy₀.1 hy₀.2
      rw [List.getD_eq_getElem _ 0 hx₃, List.getD_eq_getElem _ 0 hy₁] at hx₁
      have hj₉: x - 1 = y - 1 := by
        exact (List.Nodup.getElem_inj_iff hx₂).mp hx₁
      apply Finset.mem_Icc.mp at hy₀
      apply Finset.mem_Icc.mp at hx₀
      rw [← Nat.sub_add_cancel hy₀.1, ← Nat.sub_add_cancel hx₀.1]
      exact congr(HAdd.hAdd $hj₉ 1)
    have hh₀: ∀ k ∈ s, f₄ (f₆ k) = f k := by
      intro k hk₀
      have g₀: f₆ k = f₅ k := gg₅ k hk₀
      rw [g₀, gg₁]
      simp only
      let j := List.findIdx (fun x => decide (x = f k)) lo_sorted
      have hj₀: j + 1 = List.findIdx (fun x => decide (x = f k)) lo_sorted + 1 := by rfl
      have hj₁: List.findIdx (fun x => decide (x = f k)) lo_sorted < lo_sorted.length := by
        refine List.findIdx_lt_length.mpr ?_
        simp only [decide_eq_true_eq, exists_eq_right]
        refine (mem_sort fun x₁ x₂ => x₁ ≤ x₂).mpr ?_
        exact mem_image_of_mem f hk₀
      have hj₂: f₄ (j + 1) = f k := by
        let p := (fun (x) => decide (x = f k))
        have hp₀: p = (fun (x) => decide (x = f k)) := by rfl
        rw [gg₀, hj₀]
        ring_nf
        rw [add_comm 1, Nat.add_sub_cancel]
        rw [← hp₀]
        rw [← hp₀] at hj₁
        rw [List.getD_eq_getElem _ 0 hj₁]
        have g₁: p lo_sorted[List.findIdx p lo_sorted] = true := by
          exact List.findIdx_getElem
        refine decide_eq_true_iff.mp g₁
      rw [← hj₀, hj₂]
    have gg₁₅: ∀ x y, x ∈ s → y ∈ s → (f₄ x = f y ↔ f₈ x = y) := by
      intro x y hx₀ hy₀
      have hy₁: y - 1 < lo.length := by
        rw [gg₁₁]
        apply Finset.mem_Icc.mp at hy₀
        exact Nat.sub_one_lt_of_le hy₀.1 hy₀.2
      have hy₃: y - 1 < (List.range' 1 n 1).length := by
        rw [List.length_range', ← gg₁₁]
        exact hy₁
      have hy₄: y - 1 < sl.length := by
        rw [hs₀]
        exact hy₃
      have gg₁₆: lo = List.map f sl := by rfl
      constructor
      · intro hx₁
        have hx₂: f₄ (f₆ y) = f y := by exact hh₀ y hy₀
        have hx₃: x = f₅ y := by
          rw [← hx₁, gg₅ y hy₀] at hx₂
          exact gg₁₄ x (f₅ y) hx₀ (gg₁₀ y hy₀) (id (Eq.symm hx₂))
        rw [hx₃]
        apply Finset.mem_Icc.mp at hx₀
        apply Finset.mem_Icc.mp at hy₀
        have hx₄: x - 1 < lo_sorted.length := by
          rw [gg₉]
          exact Nat.sub_one_lt_of_le hx₀.1 hx₀.2
        have hx₅: List.findIdx (fun x => decide (x = f y)) lo_sorted = x - 1 :=
          Nat.eq_sub_of_add_eq hx₃.symm
        apply (List.findIdx_eq hx₄).mp at hx₅
        obtain ⟨hx₅, hx₆⟩ := hx₅
        simp at hx₅ hx₆
        rw [gg₃]
        simp only
        rw [← Nat.sub_add_cancel hy₀.1]
        refine add_right_cancel_iff.mpr ?_
        refine (List.findIdx_eq hy₁).mpr ?_
        simp only [decide_eq_true_eq, decide_eq_false_iff_not]
        constructor
        · rw [Nat.sub_add_cancel hy₀.1]
          apply Finset.mem_Icc.mpr at hy₀
          rw [← gg₅ y hy₀, hh₀ y hy₀]
          rw [← List.getD_eq_getElem lo 0 hy₁, gg₁₆]
          rw [List.getD_eq_getElem (List.map f sl) 0 hy₁]
          simp only [List.getElem_map]
          refine congr rfl ?_
          have g₀: sl = List.range' 1 n 1 := by rfl
          rw [← List.getD_eq_getElem sl 0 hy₄, g₀]
          rw [List.getD_eq_getElem (List.range' 1 n 1) 0 hy₃]
          rw [List.getElem_range' hy₃]
          lia
        · intro j hj₀
          rw [Nat.sub_add_cancel hy₀.1]
          apply Finset.mem_Icc.mpr at hy₀
          rw [← gg₅ y hy₀, hh₀ y hy₀]
          have hj₁: j < lo.length := by exact Nat.lt_trans hj₀ hy₁
          have hj₂: j < (List.map f sl).length := by exact Nat.lt_trans hj₀ hy₁
          have hj₃: j < sl.length := by exact Nat.lt_trans hj₀ hy₃
          have hj₄: j < (List.range' 1 n 1).length := by exact Nat.lt_trans hj₀ hy₃
          rw [← List.getD_eq_getElem lo 0 hj₁, gg₁₆]
          rw [List.getD_eq_getElem (List.map f sl) 0 hj₂]
          simp only [List.getElem_map, ne_eq]
          refine h₁ sl[j] y ?_ ?_ ?_
          · have ht: ∀ t ∈ sl, 1 ≤ t := by
              intro t ht₀
              apply List.mem_range'.mp at ht₀
              lia
            refine ht sl[j] ?_
            exact List.getElem_mem hj₄
          · lia
          · rw [List.getElem_range' hj₃]
            lia
      · intro hx₁
        have hx₃: f (f₈ x) = f₄ x := by
          rw [hx₁]
          rw [gg₃] at hx₁
          simp only at hx₁
          have hy₅: List.findIdx (fun x_1 => decide (x_1 = f₄ x)) lo = y - 1 :=
            Nat.eq_sub_of_add_eq hx₁
          apply (List.findIdx_eq hy₁).mp at hy₅
          obtain ⟨hy₅, hy₆⟩ := hy₅
          simp only [decide_eq_true_eq, decide_eq_false_iff_not] at hy₅ hy₆
          rw [← hy₅]
          have hy₇: lo[y - 1] = (List.map f sl)[y - 1] := by
            rw [← List.getD_eq_getElem (List.map f sl) 0 hy₁, ← gg₁₆]
          rw [hy₇]
          apply Finset.mem_Icc.mp at hy₀
          simp only [List.getElem_map]
          refine congr rfl ?_
          have g₀: sl = List.range' 1 n 1 := by rfl
          rw [← List.getD_eq_getElem sl 0 hy₄, g₀]
          rw [List.getD_eq_getElem (List.range' 1 n 1) 0 hy₃]
          rw [List.getElem_range' hy₃]
          rw [one_mul, add_comm 1, Nat.sub_add_cancel hy₀.1]
        rw [← hx₃]
        exact congrArg f hx₁
    have hh₁: ∀ x, (f₉ ∘ f₆) x = x := by
      intro x
      rw [Function.comp_def]
      simp only
      by_cases hx₀: x ∈ s
      · have g₀: f₅ x ∈ s := by exact gg₁₀ x hx₀
        rw [gg₅ x hx₀, gg₆ (f₅ x) g₀,]
        let j := f₅ x
        have hj₀: j = f₅ x := by rfl
        have hj₁: f₄ j = f x := by
          rw [hj₀, ← gg₅ x hx₀]
          exact hh₀ x hx₀
        exact (gg₁₅ j x (gg₁₀ x hx₀) hx₀).mp hj₁
      · have g₀: f₆ x = x := by exact gg₇ x hx₀
        have g₁: f₉ x = x := by exact gg₈ x hx₀
        rw [g₀, g₁]
    have hh₂: Function.LeftInverse f₉ f₆ := by
      refine Function.leftInverse_iff_comp.mpr ?_
      exact Function.RightInverse.id hh₁
    have hh₃: Function.RightInverse f₉ f₆ := by
      refine Function.rightInverse_iff_comp.mpr ?_
      have hh₄: ∀ x, (f₆ ∘ f₉) x = x := by
        intro x
        rw [Function.comp_def]
        simp only
        by_cases hx₀: x ∈ s
        · have g₀: f₈ x ∈ s := by exact gg₁₂ x hx₀
          rw [gg₆ x hx₀, gg₅ (f₈ x) g₀,]
          let j := f₈ x
          have hj₀: j = f₈ x := by rfl
          have hj₁: f₄ x = f j := by exact (gg₁₅ x j hx₀ (gg₁₂ x hx₀)).mpr hj₀.symm
          rw [← hj₀]
          have hj₂: j ∈ s := gg₁₂ x hx₀
          have hj₃: f₄ (f₅ j) = f j := by
            rw [← gg₅ j hj₂]
            exact hh₀ j hj₂
          rw [← hj₁] at hj₃
          exact gg₁₄ (f₅ j) x (gg₁₀ j g₀) hx₀ hj₃
        · have g₀: f₉ x = x := gg₈ x hx₀
          have g₁: f₆ x = x := gg₇ x hx₀
          rw [g₀, g₁]
      exact Function.RightInverse.id hh₄
    set ρ : Equiv.Perm ℕ := { toFun := f₆, invFun := f₉, left_inv := hh₂, right_inv := hh₃ }
    have hh₅: ∀ k ∈ s, ρ k ∈ s := by
      intro k hk₀
      have hk₁: f₆ k ∈ s := by
        rw [gg₅ k hk₀]
        exact gg₁₀ k hk₀
      exact hk₁
    use ρ
    constructor
    · intro a ha₀
      have ha₁: f₂ a = ((f a):ℝ) := by rfl
      have ha₂: f₃ (ρ a) = ((f₄ (ρ a)):ℝ) := by
        have ha₂: f₃ (ρ a) = sf_sorted.getD (ρ a - 1) 0 := by rfl
        have ha₃: f₄ (ρ a) = lo_sorted.getD (ρ a - 1) 0 := by rfl
        have ha₄: ρ a ∈ s := by exact hh₅ a ha₀
        have ha₅: ρ a - 1 < sf_sorted.length := by
          exact hf₅ (ρ a) (hh₅ a ha₀)
        have ha₆: ρ a - 1 < lo_sorted.length := by
          refine Nat.lt_of_succ_le ?_
          apply Finset.mem_Icc.mp at ha₄
          rw [gg₉, Nat.succ_eq_add_one, Nat.sub_add_cancel ha₄.1]
          exact ha₄.2
        rw [ha₂, ha₃]
        rw [gg₁₃]
        rw [gg₁₃] at ha₅
        rw [List.getD_eq_getElem _ 0 ha₅, List.getD_eq_getElem _ 0 ha₆]
        exact List.getElem_map f₁
      rw [ha₁, ha₂,]
      norm_cast
      rw [← hh₀ a ha₀]
      exact rfl
    · intro a ha₀
      exact gg₇ a ha₀
  obtain ⟨ρ, hρ₀, hρ₁⟩ := hρ
  have h₆: ∑ k ∈ Icc 1 n, f₃ k • f₀ k ≤ ∑ k ∈ Icc 1 n, f₂ k • f₀ k := by
    have h₆₀: ∑ k ∈ Icc 1 n, f₂ k • f₀ k = ∑ k ∈ Icc 1 n, f₃ (ρ k) • f₀ k := by
      refine Finset.sum_congr rfl ?_
      intro x hx₀
      rw [hρ₀ x hx₀]
    rw [h₆₀]
    refine AntivaryOn.sum_smul_le_sum_comp_perm_smul ?hfg ?hσ
    · refine MonotoneOn.antivaryOn ?hfg.hf ?hfg.hg
      · refine monotoneOn_iff_forall_lt.mpr ?hfg.hf.a
        norm_cast
        intro a ha₀ b hb₀ ha₁
        have ha₂: f₃ a + 1 ≤ f₃ b := by exact hf₇ a ha₀ b hb₀ ha₁
        refine le_trans ?_ ha₂
        refine le_of_lt ?_
        exact lt_add_one (f₃ a)
      · refine antitoneOn_iff_forall_lt.mpr ?hfg.hg.a
        norm_cast
        intro a ha₀ b hb₀ ha₁
        refine (one_div_le_one_div ?_ ?_).mpr ?_
        · apply Finset.mem_Icc.mp at hb₀
          norm_cast
          exact Nat.pow_pos hb₀.1
        · apply Finset.mem_Icc.mp at ha₀
          norm_cast
          exact Nat.pow_pos ha₀.1
        · norm_cast
          exact Nat.pow_le_pow_left (le_of_lt ha₁) 2
    · intro x hx₀
      contrapose! hx₀
      exact fun a => a (hρ₁ x hx₀)
  have h₇: ∑ k ∈ Icc 1 n, f₁ k • f₀ k ≤ ∑ k ∈ Icc 1 n, f₃ k • f₀ k := by
    refine Finset.sum_le_sum ?_
    intro x hx₀
    have hx₁: 1 ≤ x := by
      apply Finset.mem_Icc.mp at hx₀
      exact hx₀.1
    have hx₂: 0 < f₀ x := by
      ring_nf
      refine div_pos zero_lt_one ?_
      norm_cast
      exact Nat.pow_pos hx₁
    refine (smul_le_smul_iff_of_pos_right hx₂).mpr ?_
    have hh₀: f₁ = fun (k:ℕ) => (↑k:ℝ) := by rfl
    rw [hh₀]
    dsimp only
    have hi: x ≤ n → (↑x:ℝ) ≤ f₃ x := by
      refine Nat.le_induction ?_ ?_ x hx₁
      · intro _
        norm_cast
        refine hf₆ 1 ?_
        exact left_mem_Icc.mpr h₂
      · intro y hy₀ hy₁ hy₂
        have hy₃: y ≤ n := Nat.le_of_succ_le hy₂
        have hy₄: f₃ y + 1 ≤ f₃ (y + 1) := by
          refine hf₇ y ?_ (y + 1) ?_ (by lia)
          · exact Finset.mem_Icc.mpr ⟨hy₀, hy₃⟩
          · refine Finset.mem_Icc.mpr ⟨Nat.le_add_right_of_le hy₀, hy₂⟩
        refine le_trans ?_ hy₄
        simp only [Nat.cast_add, Nat.cast_one, add_le_add_iff_right]
        exact hy₁ hy₃
    refine hi ?_
    apply Finset.mem_Icc.mp at hx₀
    exact hx₀.2
  rw [h₃, h₄]
  refine le_trans h₇ h₆



theorem imo_1978_p5
    (n : ℕ)
    (f : ℕ → ℕ)
    (h₀ : ∀ (m : ℕ), 0 < m → 0 < f m)
    (h₁ : ∀ (p q : ℕ), 0 < p → 0 < q → p ≠ q → f p ≠ f q)
    (h₂ : 0 < n) :
    ∑ k ∈ Finset.Icc 1 n, (1 : ℝ) / k ≤ ∑ k ∈ Finset.Icc 1 n, ((f k):ℝ) / k ^ 2 := by
  have h₃ : ∑ k ∈ Icc 1 n, (k : ℝ) / k ^ 2 ≤ ∑ k ∈ Icc 1 n, ((f k):ℝ) / (k) ^ 2 :=
    aux₁ f h₀ h₁ h₂
  refine le_trans ?_ h₃
  refine Finset.sum_le_sum ?_
  intro x hx₀
  rw [pow_two, ← div_div, div_self]
  rw [Finset.mem_Icc] at hx₀
  norm_cast
  lia

end Imo1978P5

-- ═══ Imo1979P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1979, Problem 1

Suppose that p and q are positive integers such that

  p / q = 1 - 1/2 + 1/3 - 1/4 + ... - 1/1318 + 1/1319.

Prove that p is divisible by 1979.
-/

namespace Imo1979P1



lemma lemma3 : ∑ i ∈ Finset.range 1319, (-(1:ℚ))^i / (i + 1) =
      ∑ i ∈ Finset.range 1319, (1:ℚ) / (i + 1) -
         2 * ∑ i ∈ Finset.range 659, (1:ℚ) / (2 * (i + 1)) := by
  have h2 := Finset.sum_filter_add_sum_filter_not
           (Finset.range 1319) (Even ·) (λ i ↦ (1:ℚ) / (i + 1))
  rw [←h2]
  let g : ℕ ↪ ℕ :=
    ⟨fun x ↦ 2 * x + 1, by intro a b hab; lia⟩

  have h4 : (Finset.range 659).map g =
        (Finset.range 1319).filter (fun x ↦ ¬Even x) := by
    ext a
    unfold g
    rw [Finset.mem_map, Function.Embedding.coeFn_mk,
        Finset.mem_filter, Finset.mem_range]
    constructor
    · intro ha
      obtain ⟨b, hb1, hb2⟩ := ha
      rw [Finset.mem_range] at hb1
      rw [←hb2]
      constructor
      · lia
      · exact Nat.not_even_iff_odd.mpr ⟨b, rfl⟩
    · rintro ⟨ha1, ha2⟩
      have h5 : Odd a := Nat.not_even_iff_odd.mp ha2
      obtain ⟨r, hr⟩ := h5
      use r
      constructor
      · rw [Finset.mem_range]; lia
      · exact hr.symm
  have h5 : ∑ i ∈ Finset.range 659, 1 / (2 * ((i:ℚ) + 1))
       = ∑ i ∈ Finset.range 659, (1 / (((g i):ℚ) + 1)) := by
    apply Finset.sum_congr rfl
    intro x _
    field_simp
    simp only [Function.Embedding.coeFn_mk, Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat,
      Nat.cast_one, g]
    linarith
  have h6 := Finset.sum_map (Finset.range 659) g (fun j ↦ 1 / ((j:ℚ) + 1))

  have h3 :
    ∑ x ∈ Finset.filter (fun x ↦ ¬Even x) (Finset.range 1319),
     1 / ((x:ℚ) + 1) =
      ∑ i ∈ Finset.range 659, 1 / (2 * ((i:ℚ) + 1)) := by
    rw [h5]
    rw [←h6, h4]
  rw [h3, two_mul, add_sub_add_right_eq_sub]
  rw [←h3, ←h4, h6, ←h5, ←h3]
  have h7 :
   ∑ i ∈ Finset.filter (fun x ↦ Even x) (Finset.range 1319), 1 / ((i:ℚ) + 1) =
    ∑ i ∈ Finset.filter (fun x ↦ Even x) (Finset.range 1319),
      (-1 : ℚ)^i / ((i:ℚ) + 1) := by
    apply Finset.sum_congr rfl
    intro x hx
    rw [Finset.mem_filter] at hx
    have h9: (-1 : ℚ)^x = 1 := Even.neg_one_pow hx.2
    rw [h9]
  rw [h7]; clear h7
  rw [Rat.sub_eq_add_neg, ←Finset.sum_neg_distrib]
  have h10 : ∑ x ∈ Finset.filter (fun x ↦ ¬Even x) (Finset.range 1319),
               -(1 / ((x:ℚ) + 1)) =
              ∑ x ∈ Finset.filter (fun x ↦ ¬Even x) (Finset.range 1319),
               (-1 : ℚ)^x / ((x:ℚ) + 1) := by
    apply Finset.sum_congr rfl
    intro x hx
    rw [Finset.mem_filter] at hx
    have h9: (-1 : ℚ)^x = -1 := Odd.neg_one_pow (Nat.not_even_iff_odd.mp hx.2)
    rw [h9]
    field_simp
  rw [h10, Finset.sum_filter_add_sum_filter_not]

lemma lemma4 (n m : ℕ) (f : ℕ → ℚ) :
    ∑ i ∈ Finset.Ico n (n + 2 * m), f i =
    ∑ i ∈ Finset.range m, (f (n + i) + f (n + (2 * m - 1 - i))) := by
  rw [Finset.sum_Ico_eq_sum_range, add_tsub_cancel_left]
  rw [two_mul, Finset.sum_range_add, Finset.sum_add_distrib]
  congr 1
  rw [←Finset.sum_range_reflect (fun x ↦ f (n + (m + x)))]
  refine Finset.sum_congr rfl fun x hx => ?_
  rw [Finset.mem_range] at hx
  lia

lemma lemma9' (i : ℕ) (hi : i ∈ Finset.range 330) :
     (((∏ j ∈ Finset.range 330,
         (660 + j) * (1319 - j)):ℕ):ℚ) / ((660 + (i:ℚ)) * (1319 - (i:ℚ)))
       = ∏ j ∈ (Finset.range 330).erase i, (660 + j) * (1319 - j) := by
  rw [←Finset.prod_erase_mul _ _ hi]
  rw [Finset.mem_range] at hi
  push_cast
  have h1 : (((1319 - i):ℕ):ℚ) = 1319 - (i:ℚ) := by
    have : i ≤ 1319 := by lia
    simp_all only [Nat.cast_sub, Nat.cast_ofNat]
  rw [h1, mul_div_assoc]
  have h2 : ((660 + (i:ℚ)) * (1319 - (i:ℚ))) /
              ((660 + (i:ℚ)) * (1319 - (i:ℚ))) = 1 := by
    have h3 : (660 + (i:ℚ)) * (1319 - (i:ℚ)) ≠ 0 := by
      have h5 : (i: ℚ) < 330 := by norm_cast
      nlinarith
    exact div_self h3
  rw [h2, mul_one]

lemma lemma9 :
    (∑ i ∈ Finset.range 330, 1 / ((660 + (i:ℚ)) * (1319 - (i:ℚ)))) *
      (((∏ j ∈ Finset.range 330, (660 + j) * (1319 - j)):ℕ):ℚ) =
    (∑ i ∈ Finset.range 330, ∏ j ∈ (Finset.range 330).erase i,
         (660 + j) * (1319 - j)) := by
  simp_rw [Finset.sum_mul, div_mul_eq_mul_div, one_mul]
  rw [Finset.sum_congr rfl lemma9']
  push_cast
  rfl



theorem imo1979_p1 (p q : ℤ) (hp : 0 < p) (hq : 0 < q)
    (h : (p : ℚ) / q = ∑ i ∈ Finset.range 1319, (-1 : ℚ)^i / (i + 1)) :
    1979 ∣ p := by
  -- we follow the solution from
  -- https://artofproblemsolving.com/wiki/index.php/1979_IMO_Problems/Problem_1

  rw [lemma3] at h
  have h1 : 2 * ∑ i ∈ Finset.range 659, 1 / (2 * ((i:ℚ) + 1)) =
              ∑ i ∈ Finset.range 659, 1 / ((i:ℚ) + 1) := by
    rw [Finset.mul_sum, Finset.sum_congr rfl]
    intro x _
    field_simp
  rw [h1] at h; clear h1
  have h2 : Disjoint (Finset.range 659) (Finset.Ico 659 1319) := by
    rw [Finset.disjoint_left]
    intro a ha ha1
    rw [Finset.mem_range] at ha
    rw [Finset.mem_Ico] at ha1
    lia
  have h3 : Finset.range 1319 =
      Finset.disjUnion (Finset.range 659) (Finset.Ico 659 1319) h2 := by
    ext a
    rw [Finset.mem_range, Finset.disjUnion_eq_union, Finset.mem_union,
        Finset.mem_range, Finset.mem_Ico]
    lia
  rw [h3] at h; clear h3
  rw [Finset.sum_disjUnion, add_sub_cancel_left] at h; clear h2
  rw [lemma4 659 330] at h
  have h4 :
    ∀ i ∈ Finset.range 330,
      1 / ((((659 + i):ℕ):ℚ) + 1) + 1 / ((((659 + (2 * 330 - 1 - i)):ℕ):ℚ) + 1) =
      1979 / ((660 + (i:ℚ)) * (1319 - (i:ℚ))) := by
    intro i hi
    rw [Finset.mem_range] at hi
    have h5 : (((659 + i) : ℕ) : ℚ) + 1 = 660 + (i : ℚ) := by grind
    have h6 : (((659 + (2 * 330 - 1 - i)):ℕ):ℚ) + 1 = 1319 - (i:ℚ) := by
      rw [show 2 * 330 - 1 - i = 659 - i by lia]
      rw [show 659 + (659 - i) = 1318 - i by lia]
      have h10 : (((1318 - i):ℕ):ℚ) = 1318 - ↑i := by
        have : i ≤ 1318 := by lia
        rw [Nat.cast_sub this]
        rfl
      rw [h10]
      ring
    rw [h5, h6]; clear h5 h6
    have : (1319 : ℚ) - i ≠ 0 := by
      have h8 : 1319 ≠ i := by lia
      intro H
      have h9 : 1319 = (i : ℚ) := by linarith
      norm_cast at h9
    field_simp; norm_num

  rw [Finset.sum_congr rfl h4] at h; clear h4
  rw [show (1979 : ℚ) = 1979 * 1 by simp +arith] at h
  simp_rw [mul_div_assoc] at h
  rw [←Finset.mul_sum] at h
  let s : ℕ := ∏ i ∈ Finset.range 330, (660 + i) * (1319 - i)
  let sq := (s : ℚ)
  have hpp : Nat.Prime 1979 := by norm_num1

  have hsqp : ¬ 1979 ∣ s := by
    have h30 : ∀ i ∈ Finset.range 330, ¬ 1979 ∣ (660 + i) * (1319 - i) := fun i hi ↦ by
      rw [Finset.mem_range] at hi
      intro H
      have := (Nat.Prime.dvd_mul hpp).mp H
      lia
    exact Prime.not_dvd_finset_prod (Nat.prime_iff.mp hpp) h30
  obtain ⟨p', rfl⟩ := Int.eq_ofNat_of_zero_le (le_of_lt hp)
  obtain ⟨q', rfl⟩ := Int.eq_ofNat_of_zero_le (le_of_lt hq)
  simp only [Int.cast_natCast] at h
  suffices H : 1979 ∣ p' from Int.ofNat_dvd.mpr H
  have hqq0 : (q':ℚ) ≠ 0 :=
    Nat.cast_ne_zero.mpr (Nat.pos_iff_ne_zero.mp (Int.natCast_pos.mp hq))
  rw [div_eq_iff hqq0] at h
  apply_fun (· * sq) at h
  have h41 :
     (1979 * ∑ i ∈ Finset.range 330, 1 / ((660 + (i:ℚ)) * (1319 - (i:ℚ)))) * (q':ℚ) * sq
     = 1979 * (q':ℚ) *
        ((∑ i ∈ Finset.range 330, 1 / ((660 + (i:ℚ)) * (1319 - (i:ℚ)))) * sq) := by
   ring
  rw [h41] at h; clear h41
  rw [lemma9] at h
  rw [← Nat.cast_mul, show (1979:ℚ) = ((1979:ℕ):ℚ) by rfl,
      ← Nat.cast_mul, ← Nat.cast_mul] at h
  replace h := Nat.cast_inj.mp h
  rw [Nat.mul_assoc] at h
  have h20 : 1979 ∣ p' * s :=
    ⟨(q' * ∑ i ∈ Finset.range 330,
       ∏ j ∈ Finset.erase (Finset.range 330) i, (660 + j) * (1319 - j)),
     h⟩
  have : Nat.Coprime 1979 s := (Nat.Prime.coprime_iff_not_dvd hpp).mpr hsqp
  exact (Nat.Coprime.dvd_mul_right this).mp h20


end Imo1979P1

-- ═══ Imo1981P6 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1981, Problem 6

Suppose that f : ℕ × ℕ → ℕ satisfies

 1) f (0, y) = y + 1
 2) f (x + 1, 0) = f (x, 1),
 3) f (x + 1, y + 1) = f (x, f (x + 1, y))

for all x y ∈ ℕ.

Determine f (4, 1981).
-/

namespace Imo1981P6



/--
Wrapper to prevent the Lean kernel from eagerly trying to normalize
the solution value, which happens to be way too large to normalize.
-/
def no_eval (x : ℕ) : ℕ := x



noncomputable def solution_value : ℕ := no_eval ((2^·)^[1984] 1 - 3)

theorem imo1981_p6 (f : ℕ → ℕ → ℕ)
    (h1 : ∀ y, f 0 y = y + 1)
    (h2 : ∀ x, f (x + 1) 0 = f x 1)
    (h3 : ∀ x y, f (x + 1) (y + 1) = f x (f (x + 1) y)) :
    f 4 1981 = solution_value := by
  have h4 : ∀ y, f 1 y = y + 2 := by
    intro y
    induction y using Nat.strongRecOn with | ind y ih =>
    cases y with
    | zero => simp [h1, h2]
    | succ y =>
      rw [h3 0 y, ih y (Nat.lt_add_one y)]
      rw [h1 (y + 2)]
  have h20 : ∀ y, f 2 y = 2 * y + 3 := by
    intro y;
    induction y with
    | zero => simp [h1, h2, h3]
    | succ y ih =>
      rw [h3, ih, h3, h3, h3, h4, h1, h1, h1]
      ring
  have h21 : ∀ y, f 3 y + 3 = 2^(y + 3) := by
    intro y
    induction y with
    | zero => simp (config := {decide := true}) [h1, h2, h3]
    | succ y ih =>
      rw [h3, h20]
      rw [show 2 * f (2 + 1) y + 3 + 3 = 2 * (f 3 y + 3) by ring]
      rw [ih, ←Nat.pow_succ']
  have h6 : ∀ y, f 4 (y + 1) + 3 = 2^(f 4 y + 3) := by
    intro y
    induction y with
    | zero => rw [h3 3 0, h2 3, h21]
    | succ y ih => rw [h3, ih, h21, ih]
  have h7' : ∀ y, f 4 y + 3 = (2^·)^[y + 3] 1 := by
    intro y
    induction y with
    | zero => simp (config := {decide := true}) [h1, h2, h3]
    | succ y ih =>
      rw [show Nat.succ y + 3 = Nat.succ (y + 3) by rfl]
      rw [Function.iterate_succ']
      rw [h6 y, ih]
      rfl
  have h7 : ∀ y, f 4 y = no_eval ((2^·)^[y + 3] 1 - 3) := by
    intro y
    exact eq_tsub_of_add_eq (h7' y)
  have h8 := h7 1981
  rw [show 1981 + 3 = 1984 by rfl] at h8
  exact h8


end Imo1981P6

-- ═══ Imo1982P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1982, Problem 1

Let f be a function from positive integers to nonnegative integers such that
 1) f(2) = 0
 2) f(3) > 0
 3) f(9999) = 3333
 4) for all m,n > 0, f (m + n) - f (m) - f(n) = 1 or 0

Determine the value of f(1982).
-/

namespace Imo1982P1

noncomputable def solution_value : ℕ := 660

theorem imo1982_p1 (f : ℕ → ℕ)
    (h2 : f 2 = 0)
    (h3 : 0 < f 3)
    (h9999 : f 9999 = 3333)
    (hf : ∀ m n, 0 < m → 0 < n → f (m + n) = f m + f n ∨ f (m + n) = f m + f n + 1) :
    f 1982 = solution_value := by
  -- Follows Solution 1 by sayantanchakraborty at
  -- https://artofproblemsolving.com/wiki/index.php/1982_IMO_Problems/Problem_1
  have h4 : f 1 = 0 := by
    have h5 := hf 1 1 Nat.one_pos Nat.one_pos
    rw [h2] at h5
    lia
  have h5 : f 3 = 1 := by
    have := hf 1 2 Nat.one_pos two_pos
    aesop
  have h7 : ∀ m n, 0 < m → 0 < n → f m + f n ≤ f (m + n) := by
    intro m n hm hn
    obtain h8 | h8 := hf m n hm hn
    · exact Nat.le_of_eq h8.symm
    · exact Nat.le.intro h8.symm
  have h6 : ∀ k, 0 < k → f (3 * k) < f (3 * k + 3) := fun k hk ↦ by
    calc _ < f (3 * k) + f 3 := Nat.lt_add_of_pos_right h3
         _ ≤ _ := h7 _ _ (Nat.succ_mul_pos 2 hk) three_pos
  have h9 : ∀ k l, 0 < k → f (3 * k) + l ≤ f (3 * (k + l)) := by
    intro k l hk
    induction' l with l ih
    · simp
    · have h10 := h6 (k + l) (Nat.add_pos_left hk l)
      have h11 : 3 * (k + l) + 3 = 3 * (k + Nat.succ l) := by lia
      have h12 : f (3 * k) + Nat.succ l = f (3 * k) + l + 1 := by lia
      rw [←h11, h12]
      lia
  have h8 : ∀ k, 0 < k → k ≤ 3333 → f (3 * k) = k := by
     intro k hk0 hk1
     by_contra! H
     have h11 := h9 1 (k - 1) zero_lt_one
     have h12 : 1 + (k - 1) = k := Nat.add_sub_of_le hk0
     rw [mul_one, h5, h12] at h11
     have h13 : k < f (3 * k) := Nat.lt_of_le_of_ne h11 H.symm
     have h14 := h9 k (3333 - k) hk0
     have h15 : k + (3333 - k) = 3333 := Nat.add_sub_of_le hk1
     rw [h15, h9999] at h14
     lia
  have h20 : ∀ k, 0 < k → f k ≤ f (k + 1) := by grind
  have h30 : ∀ k l, 0 < k → l ≤ f k → l + l ≤ f (k + k) := by grind
  have h10 : ∀ k, 0 < k → 12 * k + 9 ≤ 9999 → f (3 * k + 2) = k := by
    intro k hk hk1
    obtain h11 | h11 :=  hf (3*k) 2 (Nat.succ_mul_pos 2 hk) two_pos
    · rw [h11, h2, add_zero]
      exact h8 k hk (by lia)
    · rw [h2, add_zero, h8 k hk (by lia)] at h11
      exfalso
      have h12 : 2 * k + 2 ≤ f (6 * k + 4) := by
        have h14 : 3 * k + 2 + (3 * k + 2) = 6 * k + 4 := by ring
        have h15 : k + 1 + (k + 1) = 2 * k + 2 := by ring
        rw [←h14, ←h15]
        exact h30 _ _ (Nat.succ_pos _) (Nat.le_of_eq h11.symm)
      have h13 : 4 * k + 4 ≤ f (12 * k + 8) := by
        have h14 : 6 * k + 4 + (6 * k + 4) = 12 * k + 8 := by ring
        have h15 : 2 * k + 2 + (2 * k + 2) = 4 * k + 4 := by ring
        rw [←h14, ←h15]
        exact h30 _ _ (Nat.succ_pos _) h12
      have h14 : f (12 * k + 8) ≤ f (12 * k + 9) := by
        have h15 : 12 * k + 8 + 1 = 12 * k + 9 := by ring
        rw [←h15]
        exact h20 _ (Nat.succ_pos _)
      have h15 : f (12 * k + 9) = 4 * k + 3 := by
         have h16 : 3 * (4 * k + 3) = 12 * k + 9 := by ring
         have h17 := h8 (4 * k + 3) (Nat.succ_pos _) (by lia)
         rw [h16] at h17
         exact h17
      rw [h15] at h14
      exact Nat.lt_le_asymm h13 h14
  exact h10 660 (Nat.succ_pos _) (by norm_num)


end Imo1982P1

-- ═══ Imo1983P6 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh, David Renshaw
-/





/-!
# International Mathematical Olympiad 1983, Problem 6

Suppose that a,b,c are the side lengths of a triangle. Prove that

   a²b(a - b) + b²c(b - c) + c²a(c - a) ≥ 0.

Determine when equality occurs.
-/

namespace Imo1983P6



/-- Equality in Cauchy-Schwarz implies linear dependence. -/
lemma cauchy_schwarz_equals {ι: Type*} (s : Finset ι)
    (f g : ι → ℝ) (hf : ∃ i ∈ s, f i ≠ 0) :
    (∑ i ∈ s, f i * g i) ^ 2 = (∑ i ∈ s, f i ^ 2) * ∑ i ∈ s, g i ^ 2 →
    ∃ r, ∀ i ∈ s, r * f i = g i := by
  intro h0
  let q t := ∑ i ∈ s, (t * f i - g i) * (t * f i - g i)
  have h1 : ∀ t, q t =
      (∑ i ∈ s, f i^2) * (t * t) + ((- 2) * ∑ i ∈ s, f i * g i) * t + ∑ i ∈ s, g i^2 := by
    intro t
    unfold q
    simp only [Finset.mul_sum, Finset.sum_mul, ←Finset.sum_add_distrib]
    apply Finset.sum_congr rfl
    intro i hi
    ring
  have h2 : discrim (∑ i ∈ s, f i^2) ((- 2) * ∑ i ∈ s, f i * g i) (∑ i ∈ s, g i^2) = 0 := by
    unfold discrim
    linarith
  have h3 : ∑ i ∈ s, f i^2 ≠ 0 := by
    obtain ⟨ii, hii, hiif⟩ := hf
    have h6 : ∀ i ∈ s, f i ^ 2 = f i * f i := by
      intro h hi
      exact pow_two (f h)
    rw [Finset.sum_congr rfl h6]
    intro H
    rw [Finset.sum_mul_self_eq_zero_iff] at H
    specialize H ii hii
    contradiction
  obtain ⟨t0, ht0, -⟩ := (discrim_eq_zero_iff h3).mp h2
  rw [←h1] at ht0
  unfold q at ht0
  use t0
  rw [Finset.sum_mul_self_eq_zero_iff] at ht0
  intro i hi
  specialize ht0 i hi
  linarith

theorem lemma1 {x y z : ℝ} (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)
    (hxyz : x * y * z * (z + x + y) = x * y ^ 3 + y * z ^ 3 + z * x ^ 3) :
    x = y ∧ x = z := by
  let f : Fin 3 → ℝ := ![√x * √(y^3), √y * √(z^3), √z * √(x^3)]
  let g : Fin 3 → ℝ := ![√z, √x, √y]
  suffices H : ∃ r : ℝ, ∀ i ∈ Finset.univ, r * f i = g i by
    obtain ⟨r, hr⟩ := H
    dsimp [f, g] at hr
    simp only [Finset.mem_univ, forall_const] at hr
    have hr0 := hr 0
    have hr1 := hr 1
    have hr2 := hr 2
    clear hr
    apply_fun (·)^2 at hr0 hr1 hr2
    dsimp at hr0 hr1 hr2
    simp only [mul_pow] at hr0 hr1 hr2
    rw [Real.sq_sqrt hx.le, Real.sq_sqrt hy.le] at hr1
    rw [Real.sq_sqrt hz.le, Real.sq_sqrt hx.le] at hr0
    rw [Real.sq_sqrt hy.le, Real.sq_sqrt hz.le] at hr2
    rw [Real.sq_sqrt (by positivity)] at hr0 hr1 hr2
    have h0 : x * y^3 ≠ 0 := by positivity
    have h1 : y * z^3 ≠ 0 := by positivity
    have h2 : z * x^3 ≠ 0 := by positivity
    replace hr0 : r^2 = z / (x * y^3) := (div_eq_of_eq_mul h0 hr0.symm).symm
    replace hr1 : r^2 = x / (y * z^3) := (div_eq_of_eq_mul h1 hr1.symm).symm
    replace hr2 : r^2 = y / (z * x^3) := (div_eq_of_eq_mul h2 hr2.symm).symm
    clear hxyz f g
    constructor
    · rw [hr0] at hr1 hr2
      have h3 : z^4 = x^2 * y^2 := by
        field_simp at hr1 ⊢
        exact hr1
      have h3' : z^2 = x * y := by
        rw [show z ^ 4 = (z^2)^2 by ring, show x ^ 2 * y ^ 2 = (x * y)^2 by ring] at h3
        exact (pow_left_inj₀ (by positivity) (by positivity) (by positivity)).mp h3
      have h4 : z^2 = y^4 / x^2 := by
        field_simp at hr2 ⊢
        exact hr2
      rw [h3'] at h4
      have h5 : x^3 = y ^ 3 := by
        field_simp at h4
        exact h4
      exact (pow_left_inj₀ (by positivity) (by positivity) (by positivity)).mp h5
    · rw [hr2] at hr0 hr1
      have h3 : y^4 = x^2 * z^2 := by
        field_simp at hr0 ⊢
        exact hr0
      have h3' : y^2 = x * z := by
        rw [show y ^ 4 = (y^2)^2 by ring, show x ^ 2 * z ^ 2 = (x * z)^2 by ring] at h3
        exact (pow_left_inj₀ (by positivity) (by positivity) (by positivity)).mp h3
      have h4 : y^2 = x^4 / z^2 := by
        field_simp at hr1 ⊢
        exact hr1
      rw [h3'] at h4
      have h5 : z^3 = x ^ 3 := by
        field_simp at h4
        exact h4
      symm
      exact (pow_left_inj₀ (by positivity) (by positivity) (by positivity)).mp h5
  refine cauchy_schwarz_equals _ f g ?_ ?_
  · use 0
    simp [f]
    change _ ≠ 0 ∧ _ ≠ 0
    constructor
    · positivity
    · positivity
  simp only [Fin.sum_univ_three, f, g]
  dsimp
  rw [show x^3 = x^2 * x from rfl, show y^3 = y^2 * y from rfl,
      show z^3 = z^2 * z from rfl]
  rw [Real.sqrt_mul (by positivity), Real.sqrt_mul (by positivity),
      Real.sqrt_mul (by positivity)]
  rw [Real.sqrt_sq hx.le, Real.sqrt_sq hy.le, Real.sqrt_sq hz.le]
  grind



noncomputable def EqualityCondition (a b c : ℝ) : Prop := a = b ∧ a = c

theorem imo1983_p6 (T : Affine.Triangle ℝ (EuclideanSpace ℝ (Fin 2))) :
    let a := dist (T.points 1) (T.points 2)
    let b := dist (T.points 0) (T.points 2)
    let c := dist (T.points 0) (T.points 1)
    0 ≤ a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ∧
    (0 = a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ↔
     EqualityCondition a b c) := by
  intro a b c
  have h₁ : c < a + b := by
    have := AffineIndependent.not_wbtw_of_injective (0 : Fin 3) 2 1 (by decide) T.independent
    rw [←dist_lt_dist_add_dist_iff, dist_comm (T.points 2)] at this
    linarith

  have h₂ : b < a + c := by
    have := AffineIndependent.not_wbtw_of_injective (0 : Fin 3) 1 2 (by decide) T.independent
    rw [←dist_lt_dist_add_dist_iff] at this
    linarith

  have h₃ : a < b + c := by
    have := AffineIndependent.not_wbtw_of_injective (1 : Fin 3) 0 2 (by decide) T.independent
    rw [←dist_lt_dist_add_dist_iff, dist_comm (T.points 1) (T.points 0)] at this
    linarith

  -- https://prase.cz/kalva/imo/isoln/isoln836.html
  set x := (-a + b + c) / 2
  set y := (a - b + c) / 2
  set z := (a + b - c) / 2
  have hx : 0 < x := by unfold x; linarith
  have hy : 0 < y := by unfold y; linarith
  have hz : 0 < z := by unfold z; linarith

  constructor
  · suffices H : x * y * z * (z + x + y) ≤ x * y ^3 + y * z^3 + z * x ^3 by
      unfold x y z at H
      nlinarith
    let f : Fin 3 → ℝ := ![√x * √(y^3), √y * √(z^3), √z * √(x^3)]
    let g : Fin 3 → ℝ := ![√z, √x, √y]
    have hsum := Finset.sum_mul_sq_le_sq_mul_sq (Finset.univ) f g
    simp only [Fin.sum_univ_three, f, g] at hsum
    dsimp at hsum
    rw [show x^3 = x^2 * x from rfl, show y^3 = y^2 * y from rfl,
        show z^3 = z^2 * z from rfl] at hsum
    rw [Real.sqrt_mul (by positivity), Real.sqrt_mul (by positivity),
        Real.sqrt_mul (by positivity)] at hsum
    rw [Real.sqrt_sq hx.le, Real.sqrt_sq hy.le, Real.sqrt_sq hz.le] at hsum
    have h1 : √x * (y * √y) * √z + √y * (z * √z) * √x + √z * (x * √x) * √y =
              (√x * √y * √z) * (z + x + y) := by ring
    rw [h1] at hsum; clear h1
    simp only [mul_pow] at hsum
    simp only [Real.sq_sqrt hx.le, Real.sq_sqrt hy.le, Real.sq_sqrt hz.le] at hsum
    rw [pow_two (z + x + y), ←mul_assoc] at hsum
    have h2 : 0 < z + x + y := by positivity
    rw [show x^2 * x = x^3 from rfl, show y^2 * y = y^3 from rfl,
        show z^2 * z = z^3 from rfl] at hsum
    exact le_of_mul_le_mul_right hsum h2
  constructor
  · intro h
    have hxyz : x * y * z * (z + x + y) = x * y ^3 + y * z^3 + z * x ^3 := by
      unfold x y z
      linarith
    clear h h₁ h₂ h₃
    unfold EqualityCondition
    suffices H : x = y ∧ x = z by
      unfold x y z at H
      obtain ⟨H1, H2⟩ := H
      constructor
      · linarith
      · linarith
    exact lemma1 hx hy hz hxyz
  · rintro ⟨h1, h2⟩
    simp [←h1, ←h2]

end Imo1983P6

-- ═══ Imo1984P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: InternLM-MATH LEAN Formalizer v0.1, Hongyu Ouyang
-/





/-!
# International Mathematical Olympiad 1984, Problem 1

Let $x$, $y$, $z$ be nonnegative real numbers with $x + y + z = 1$.
Show that $0 \leq xy+yz+zx-2xyz \leq \frac{7}{27}$
-/

namespace Imo1984P1



lemma geom_mean_le_arith_mean_3 {a b c : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) :
    a * b * c ≤ ((a + b + c) / 3) ^ (3 : ℝ) := by
  have abc_pos : 0 ≤ a * b * c := by positivity
  rw [show a * b * c = ((a * b * c) ^ ((1:ℝ) / 3)) ^ (3 : ℝ) by
        rw [←(Real.rpow_mul abc_pos ((1 : ℝ)/3) 3)]; simp]
  apply Real.rpow_le_rpow; rotate_right
  · norm_num
  · apply Real.rpow_nonneg abc_pos
  · let w := (1 : ℝ) / 3
    change (a * b * c) ^ w ≤ (a + b + c) / 3
    trans w * a + w * b + w * c; rotate_left
    · unfold w
      field_simp
      exact Std.IsPreorder.le_refl (a + b + c)
    rw [Real.mul_rpow (by positivity) hc]
    rw [Real.mul_rpow ha hb]
    apply Real.geom_mean_le_arith_mean3_weighted; all_goals try norm_num; try positivity



theorem imo1984_p1  (x y z : ℝ)
  (h₀ : 0 ≤ x ∧ 0 ≤ y ∧ 0 ≤ z)
  (h₁ : x + y + z = 1) :
    0 ≤ x * y + y * z + z * x - 2 * x * y * z ∧ x * y + y * z + z * x - 2 * x * y * z ≤
      (7:ℝ) / 27 := by
  rw [calc x * y + y * z + z * x - 2 * x * y * z
           = (1 : ℝ) / 4 * (4 * (y * z + z * x + x * y) - 8 * x * y * z) := by ring_nf
         _ = (1 : ℝ) / 4 * (4 * (y * z + z * x + x * y) -
             8 * x * y * z + 1 - 2 * (x + y + z) + 1) :=
             by rw [h₁]; ring_nf
         _ = (1 : ℝ) / 4 * ((1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z) + 1) := by ring_nf]
  have hx0 : 0 ≤ x := h₀.1
  have hy0 : 0 ≤ y := h₀.2.1
  have hz0 : 0 ≤ z := h₀.2.2

  -- TODO: smarter wlog needed.
  wlog hxy : x ≤ y generalizing x y z
  · rw [show (1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z) = (1 - 2 * y) * (1 - 2 * x) * (1 - 2 * z)
        by linarith]
    exact this y x z ⟨hy0, hx0, hz0⟩ (by rw [←h₁]; linarith) hy0 hx0 hz0 (by linarith)
  · wlog hxz : x ≤ z generalizing x y z
    · rw [show (1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z) = (1 - 2 * z) * (1 - 2 * x) * (1 - 2 * y)
          by linarith]
      exact this z x y ⟨hz0, hx0, hy0⟩
            (by rw [←h₁]; linarith) hz0 hx0 hy0 (by linarith) ((le_of_not_ge hxz).trans hxy)
    · wlog hyz : y ≤ z generalizing x y z
      · rw [show (1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z) = (1 - 2 * x) * (1 - 2 * z) * (1 - 2 * y)
            by linarith]
        exact this x z y ⟨hx0, hz0, hy0⟩ (by rw [←h₁]; linarith) hx0 hz0 hy0 hxz hxy (by linarith)
      · constructor
        · suffices habs : abs ((1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z)) ≤ 1 by
            have ⟨i, _⟩ := abs_le.mp habs; linarith only [i]
          rw [abs_mul, abs_mul]
          refine mul_le_one₀ (mul_le_one₀ ?_ (by positivity) ?_) (by positivity) ?_ <;>
          (rw [abs_le]; constructor) <;> linarith
        · suffices habs : ((1 - 2 * x) * (1 - 2 * y) * (1 - 2 * z)) ≤ (1 : ℝ) / 27 by linarith [habs]
          conv => lhs; rw [← h₁]
          have h1 : 0 ≤ (x + y + z - 2 * x) := by linarith
          have h2 : 0 ≤ (x + y + z - 2 * y) := by linarith
          by_cases h3 : 0 ≤ (x + y + z - 2 * z); rotate_left
          · trans 0; rotate_left
            · norm_num
            apply nonpos_of_neg_nonneg
            rw [←mul_neg]
            apply mul_nonneg
            · positivity
            · linarith
          · apply le_trans (geom_mean_le_arith_mean_3 h1 h2 h3)
            rw [show (x + y + z - 2 * x + (x + y + z - 2 * y) + (x + y + z - 2 * z)) = 1
                by rw [←h₁]; ring_nf]
            norm_num

end Imo1984P1

-- ═══ Imo1984P2 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1984, Problem 2

Find a pair of positive integers a and b such that

 (i) ab(a + b) is not divisible by 7.
 (ii) (a + b)⁷ - a⁷ - b⁷ is divisible by 7⁷.
-/

namespace Imo1984P2

noncomputable def a : ℤ := 18
noncomputable def b : ℤ := 1

theorem imo1984_p2 :
    (0 < a) ∧ (0 < b) ∧
    (¬ 7 ∣ a * b * (a + b)) ∧
    7^7 ∣ (a + b)^7 - a^7 - b^7 := by
  decide


end Imo1984P2

-- ═══ Imo1984P6 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/





/-!
# International Mathematical Olympiad 1984, Problem 6

Let a, b, c, and d be odd integers such that 0 < a < b < c < d and ad = bc.
Prove that if a + d = 2ᵏ and b + c = 2ᵐ for some integers k and m, then
a = 1.
-/

namespace Imo1984P6



lemma mylemma_sub_sq
    (a b : ℕ)
    (h₀: b < a) :
    ((a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b) := by
  have h₁: b^2 ≤ a * b := by
    rw [pow_two]
    refine Nat.mul_le_mul_right _ ?_
    exact Nat.le_of_lt h₀
  have h₂: a * b ≤ a ^ 2 := by
    rw [pow_two]
    refine Nat.mul_le_mul_left _ ?_
    exact Nat.le_of_lt h₀
  repeat rw [pow_two]
  repeat rw [Nat.mul_sub_left_distrib]
  repeat rw [Nat.mul_sub_right_distrib a b a]
  rw [Nat.sub_right_comm]
  repeat rw [Nat.mul_sub_right_distrib a b b]
  ring_nf
  lia

lemma mylemma_k_le_m_alt
    (a b c d k m : ℕ)
    (h₂ : a < b ∧ b < c ∧ c < d)
    (h₃ : a * d = b * c)
    (h₄ : a + d = 2 ^ k)
    (h₅ : b + c = 2 ^ m)
    (hkm : k ≤ m) :
    False := by
  have h₆: (a + d) ^ 2 ≤ (b + c) ^ 2 := by
    refine Nat.pow_le_pow_left ?_ 2
    rw [h₄,h₅]
    exact pow_le_pow_right₀ (by norm_num) hkm
  rw [add_sq, add_sq, mul_assoc, h₃, mul_assoc] at h₆
  have h₇: (d - a) ^ 2 ≤ (c - b) ^ 2 := by
    have hda: a < d := by
      refine lt_trans h₂.1 ?_
      exact lt_trans h₂.2.1 h₂.2.2
    rw [mylemma_sub_sq d a hda]
    rw [mylemma_sub_sq c b h₂.2.1]
    rw [mul_assoc, mul_assoc]
    rw [mul_comm d a, mul_comm c b]
    rw [h₃]
    refine Nat.sub_le_sub_right ?_ (2 * (b * c))
    linarith
  have h₈: (c - b) ^ 2 < (d - a) ^ 2 := by
    refine Nat.pow_lt_pow_left ?_ (by norm_num)
    have h₈₀: c - a < d - a := by
      have g₀: c - a + a < d - a + a := by
        rw [Nat.sub_add_cancel ?_]
        · rw [Nat.sub_add_cancel ?_]
          · exact h₂.2.2
          · linarith
        · linarith
      exact Nat.lt_of_add_lt_add_right g₀
    refine lt_trans ?_ h₈₀
    refine Nat.sub_lt_sub_left ?_ h₂.1
    exact lt_trans h₂.1 h₂.2.1
  lia

lemma mylemma_h8
  (a b c d k m : ℕ)
  (h₀ : 0 < a ∧ 0 < b ∧ 0 < c ∧ 0 < d)
  (h₁ : Odd a ∧ Odd b ∧ Odd c ∧ Odd d)
  (h₂ : a < b ∧ b < c ∧ c < d)
  (h₅ : b + c = 2 ^ m)
  (hkm : m < k)
  (h₆ : b * 2 ^ m - a * 2 ^ k = (b - a) * (b + a))
  (h₇ : 2 ^ m ∣ (b - a) * (b + a)) :
  (b + a = 2 ^ (m - 1)) := by
  have h₇₁: ∃ y z, y ∣ b - a ∧ z ∣ b + a ∧ y * z = 2 ^ m := by
    exact Nat.dvd_mul.mp h₇
  let ⟨p, q, hpd, hqd, hpq⟩ := h₇₁
  have hm1: 1 ≤ m := by
    by_contra! hc
    interval_cases m
    lia
  have h₈₀: b - a < 2 ^ (m - 1) := by
    have g₀: b < (b + c) / 2 := by
      refine (Nat.lt_div_iff_mul_lt' ?_ b).mpr ?_
      · refine even_iff_two_dvd.mp ?_
        exact Odd.add_odd h₁.2.1 h₁.2.2.1
      · lia
    have g₁: (b + c) / 2 = 2 ^ (m-1) := by
      rw [h₅]
      rw [← Nat.pow_sub_mul_pow 2 hm1]
      simp
    rw [← g₁]
    exact tsub_lt_of_lt g₀
  have hp: p = 2 := by
    have hp₀: 2 * b < 2 ^ m := by
      rw [← h₅, two_mul]
      exact Nat.add_lt_add_left h₂.2.1 b
    have hp₁: b + a < 2 ^ (m) := by
      have g₀: b + a < b + b := by
        exact Nat.add_lt_add_left h₂.1 b
      refine Nat.lt_trans g₀ ?_
      rw [← two_mul]
      exact hp₀
    have hp₂: q < 2 ^ m := by
      refine Nat.lt_of_le_of_lt (Nat.le_of_dvd ?_ hqd) hp₁
      exact Nat.add_pos_right b h₀.1
    have hp₃: 1 < p := by
      rw [← hpq] at hp₂
      exact one_lt_of_lt_mul_left hp₂
    have h2prime: Nat.Prime 2 := Nat.prime_two
    have hp₅: ∀ i j:ℕ , 2 ^ i ∣ (b - a) ∧ 2 ^ j ∣ (b + a) → (i < 2 ∨ j < 2) := by
      by_contra! hc
      let ⟨i, j, hi⟩ := hc
      have hti: 2 ^ 2 ∣ 2 ^ i := by exact Nat.pow_dvd_pow 2 hi.2.1
      have htj: 2 ^ 2 ∣ 2 ^ j := by exact Nat.pow_dvd_pow 2 hi.2.2
      norm_num at hti htj
      have hi₄: 4 ∣ b - a := by exact Nat.dvd_trans hti hi.1.1
      have hi₅: 4 ∣ b + a := by exact Nat.dvd_trans htj hi.1.2
      have hi₆: 4 ∣ (b - a) + (b + a) := by exact Nat.dvd_add hi₄ hi₅
      have hi₇: 2 ∣ b := by
        have g₀: 0 < 2 := by norm_num
        refine Nat.dvd_of_mul_dvd_mul_left g₀ ?_
        rw [← Nat.add_sub_cancel (2 * b) a, Nat.two_mul b]
        rw [add_assoc, Nat.sub_add_comm (le_of_lt h₂.1)]
        exact hi₆
      have hi₈: Even b := by
        exact even_iff_two_dvd.mpr hi₇
      apply Nat.not_odd_iff_even.mpr hi₈
      exact h₁.2.1
    have hp₆: ∀ i j:ℕ , i + j = m ∧ 2 ^ i ∣ (b - a) ∧ 2 ^ j ∣ (b + a) → (¬ j < 2) := by
      by_contra! hc
      let ⟨i, j, hi⟩ := hc
      have hi₀: m - 1 ≤ i := by
        rw [← hi.1.1]
        simp
        exact Nat.le_pred_of_lt hi.2
      have hi₁: 2 ^ (m - 1) ≤ 2 ^ i := by exact Nat.pow_le_pow_right (by norm_num) hi₀
      have hi₂: 2 ^ i < 2 ^ (m - 1) := by
        refine lt_of_le_of_lt ?_ h₈₀
        refine Nat.le_of_dvd ?_ hi.1.2.1
        exact Nat.sub_pos_of_lt h₂.1
      linarith [hi₁, hi₂]
    have hi₀: ∃ i ≤ m, p = 2 ^ i := by
      have g₀: p ∣ 2 ^ m := Dvd.intro q hpq
      exact (Nat.dvd_prime_pow h2prime).mp g₀
    let ⟨i, him, hp⟩ := hi₀
    let j:ℕ := m - i
    have hj₀: j = m - i := by linarith
    have hj₁: i + j = m := by
      rw [add_comm, ← Nat.sub_add_cancel him]
    have hq: q = 2 ^ j := by
      rw [hp] at hpq
      rw [hj₀, ← Nat.pow_div him (by norm_num)]
      refine Nat.eq_div_of_mul_eq_right ?_ hpq
      refine Nat.ne_of_gt ?_
      rw [← hp]
      linarith [hp₃]
    rw [hp] at hpd
    rw [hq] at hqd
    have hj₃: ¬ j < 2 := by
      exact hp₆ i j {left:= hj₁ , right:= { left := hpd , right:= hqd} }
    have hi₂: i < 2 := by
      have g₀: i < 2 ∨ j < 2 := by
        exact hp₅ i j { left := hpd , right:= hqd }
      lia
    have hi₃: 0 < i := by
      rw [hp] at hp₃
      refine Nat.zero_lt_of_ne_zero ?_
      exact (Nat.one_lt_two_pow_iff).mp hp₃
    have hi₄: i = 1 := by
      interval_cases i
      rfl
    rw [hi₄] at hp
    exact hp
  have hq: q = 2 ^ (m - 1) := by
    rw [hp, ← Nat.pow_sub_mul_pow 2 hm1, pow_one, mul_comm] at hpq
    exact Nat.mul_right_cancel (by norm_num) hpq
  rw [hq] at hqd
  have h₈₂: ∃ c, (b + a) = c * 2 ^ (m - 1) := by
    exact exists_eq_mul_left_of_dvd hqd
  let ⟨f, hf⟩ := h₈₂
  have hfeq1: f = 1 := by
    have hf₀: f * 2 ^ (m - 1) < 2 * 2 ^ (m - 1) := by
      rw [← hf, ← Nat.pow_succ', ← Nat.succ_sub hm1]
      rw [Nat.succ_sub_one, ← h₅]
      refine Nat.add_lt_add_left ?_ b
      exact lt_trans h₂.1 h₂.2.1
    have hf₁: f < 2 := by
      exact Nat.lt_of_mul_lt_mul_right hf₀
    interval_cases f
    · lia
    · rfl
  rw [hfeq1, one_mul] at hf
  exact hf



theorem imo_1984_p6
    (a b c d k m : ℕ)
    (h₀ : 0 < a ∧ 0 < b ∧ 0 < c ∧ 0 < d)
    (h₁ : Odd a ∧ Odd b ∧ Odd c ∧ Odd d)
    (h₂ : a < b ∧ b < c ∧ c < d)
    (h₃ : a * d = b * c)
    (h₄ : a + d = 2^k)
    (h₅ : b + c = 2^m) :
    a = 1 := by
  by_cases hkm: k ≤ m
  · exfalso
    exact mylemma_k_le_m_alt a b c d k m h₂ h₃ h₄ h₅ hkm
  · push_neg at hkm
    have h₆: b * 2 ^ m - a * 2 ^ k = (b - a) * (b + a) := by
      have h₆₀: c = 2 ^ m - b := by exact (tsub_eq_of_eq_add_rev (id h₅.symm)).symm
      have h₆₁: d = 2 ^ k - a := by exact (tsub_eq_of_eq_add_rev (id h₄.symm)).symm
      rw [h₆₀, h₆₁] at h₃
      repeat rw [Nat.mul_sub_left_distrib, ← pow_two] at h₃
      have h₆₂: b * 2 ^ m - a * 2 ^ k =  b ^ 2 - a ^ 2 := by
        symm at h₃
        refine Nat.sub_eq_of_eq_add ?_
        rw [add_comm, ← Nat.add_sub_assoc]
        · rw [Nat.sub_add_comm]
          · refine Nat.eq_add_of_sub_eq ?_ h₃
            rw [pow_two]
            refine le_of_lt ?_
            refine mul_lt_mul' (by lia) ?_ (le_of_lt h₀.2.1) h₀.2.1
            lia
          · rw [pow_two]
            refine le_of_lt ?_
            refine mul_lt_mul' (by lia) ?_ (le_of_lt h₀.1) h₀.1
            lia
        · refine le_of_lt ?_
          rw [pow_two, pow_two]
          exact mul_lt_mul h₂.1 (le_of_lt h₂.1) h₀.1 (le_of_lt h₀.2.1)
      rw [Nat.sq_sub_sq b a] at h₆₂
      linarith
    have h₇: 2 ^ m ∣ (b - a) * (b + a) := by
      have h₇₀: k = (k - m) + m := by exact (Nat.sub_add_cancel (le_of_lt hkm)).symm
      rw [h₇₀, pow_add] at h₆
      have h₇₁: (b - a * 2 ^ (k - m)) * (2 ^ m) = (b - a) * (b + a) := by
        rw [Nat.mul_sub_right_distrib]
        rw [mul_assoc a _ _]
        exact h₆
      exact Dvd.intro_left (b - a * 2 ^ (k - m)) h₇₁
    have h₈: b + a = 2 ^ (m - 1) := by
      exact mylemma_h8 a b c d k m h₀ h₁ h₂ h₅ hkm h₆ h₇
    have h₉: a = 2 ^ (2 * m - 2) / 2 ^ k := by
      have ga: 1 ≤ a := Nat.succ_le_of_lt h₀.1
      have gb: 3 ≤ b := by
        by_contra! hc
        interval_cases b
        · lia
        · lia
        · have g₀: ¬ Odd 2 := by decide
          exact g₀ h₁.2.1
      have gm: 3 ≤ m := by
        have gm₀: 2 ^ 2 ≤ 2 ^ (m - 1) := by
          norm_num
          rw [← h₈]
          lia
        have gm₁: 2 ≤ m - 1 := by
          exact (Nat.pow_le_pow_iff_right (by norm_num)).mp gm₀
        lia
      have g₀: a < 2 ^ (m - 2) := by
        have g₀₀: a + a < b + a := by simp [h₂.1]
        rw [h₈, ← mul_two a] at g₀₀
        have g₀₁: m - 1 = Nat.succ (m - 2) := by
          rw [← Nat.succ_sub ?_]
          · rw [Nat.succ_eq_add_one]
            lia
          · lia
        rw [g₀₁, Nat.pow_succ 2 _] at g₀₀
        exact Nat.lt_of_mul_lt_mul_right g₀₀
      have h₉₀: b = 2 ^ (m - 1) - a := by
        symm
        exact Nat.sub_eq_of_eq_add h₈.symm
      rw [h₈, h₉₀] at h₆
      repeat rw [Nat.mul_sub_right_distrib] at h₆
      repeat rw [← Nat.pow_add] at h₆
      have hm1: 1 ≤ m := by lia
      repeat rw [← Nat.sub_add_comm hm1] at h₆
      repeat rw [← Nat.add_sub_assoc hm1] at h₆
      ring_nf at h₆
      rw [← Nat.sub_add_eq _ 1 1] at h₆
      norm_num at h₆
      rw [← Nat.sub_add_eq _ (a * 2 ^ (m - 1)) (a * 2 ^ (m - 1))] at h₆
      rw [← two_mul (a * 2 ^ (m - 1))] at h₆
      rw [mul_comm 2 _] at h₆
      rw [mul_assoc a (2 ^ (m - 1)) 2] at h₆
      rw [← Nat.pow_succ, Nat.succ_eq_add_one] at h₆
      rw [Nat.sub_add_cancel hm1] at h₆
      rw [← Nat.sub_add_eq ] at h₆
      have h₉₁: 2 ^ (m * 2 - 1) = 2 ^ (m * 2 - 2) - a * 2 ^ m + (a * 2 ^ m + a * 2 ^ k) := by
        refine Nat.eq_add_of_sub_eq ?_ h₆
        by_contra! hc
        have g₁: 2 ^ (m * 2 - 1) - (a * 2 ^ m + a * 2 ^ k) = 0 := by
          exact Nat.sub_eq_zero_of_le (le_of_lt hc)
        rw [g₁] at h₆
        have g₂: 2 ^ (m * 2 - 2) ≤ a * 2 ^ m := by exact Nat.le_of_sub_eq_zero h₆.symm
        have g₃: 2 ^ (m - 2) ≤ a := by
          rw [mul_two, Nat.add_sub_assoc (by lia) m] at g₂
          rw [Nat.pow_add, mul_comm] at g₂
          refine Nat.le_of_mul_le_mul_right g₂ ?_
          exact Nat.two_pow_pos m
        linarith [g₀, g₃]
      rw [← Nat.add_assoc] at h₉₁
      have h₉₂: a * 2 ^ k = 2 * 2 ^ (2 * m - 2) - 2 ^ (2 * m - 2) := by
        rw [Nat.sub_add_cancel ?_] at h₉₁
        · rw [add_comm] at h₉₁
          symm
          rw [← Nat.pow_succ', Nat.succ_eq_add_one]
          lia
        · refine le_of_lt ?_
          rw [mul_two, Nat.add_sub_assoc, Nat.pow_add, mul_comm (2 ^ m) _]
          · refine (Nat.mul_lt_mul_right (by lia)).mpr g₀
          lia
      nth_rewrite 2 [← Nat.one_mul (2 ^ (2 * m - 2))] at h₉₂
      rw [← Nat.mul_sub_right_distrib 2 1 (2 ^ (2 * m - 2))] at h₉₂
      norm_num at h₉₂
      refine Nat.eq_div_of_mul_eq_left ?_ h₉₂
      exact Ne.symm (NeZero.ne' (2 ^ k))
    by_cases hk2m: k ≤ 2 * m - 2
    · rw [Nat.pow_div hk2m (by norm_num)] at h₉
      rw [Nat.sub_right_comm (2*m) 2 k] at h₉
      by_contra! hc
      obtain hc₀ | hc₁ := lt_or_gt_of_ne hc
      · interval_cases a
        lia
      · have hc₂: ¬ Odd a := by
          refine (Nat.not_odd_iff_even).mpr ?_
          have hc₃: 1 ≤ 2 * m - k - 2 := by
            by_contra! hc₄
            interval_cases (2 * m - k - 2)
            rw [pow_zero] at h₉
            exact hc h₉
          have hc₄: 2 * m - k - 2 = Nat.succ (2 * m - k - 3) := by
            rw [Nat.succ_eq_add_one]
            exact Nat.eq_add_of_sub_eq hc₃ rfl
          rw [h₉, hc₄, Nat.pow_succ']
          exact even_two_mul (2 ^ (2 * m - k - 3))
        exact hc₂ h₁.1
    · push_neg at hk2m
      exfalso
      have ha: a = 0 := by
        rw [h₉]
        refine (Nat.div_eq_zero_iff).mpr ?_
        right
        exact Nat.pow_lt_pow_right (by norm_num) hk2m
      lia

end Imo1984P6

-- ═══ Imo1985P2 ═══

/-
Copyright (c) 2025 Jeremy Tan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan
-/




/-!
# International Mathematical Olympiad 1985, Problem 2

Fix a natural number $n ≥ 3$ and define $N=\{1, 2, 3, \dots, n-1\}$.
Fix another natural number $j ∈ N$ coprime to $n$. Each number in
$N$ is now colored with one of two colors, say red or black, so that:

1. $i$ and $n-i$ always receive the same color, and
2. $i$ and $|j-i|$ receive the same color for all $i ∈ N, i ≠ j$.

Prove that all numbers in $N$ must receive the same color.
-/

namespace Imo1985P2

/-- The conditions on the problem's coloring `C`.
Although its domain is all of `ℕ`, we only care about its values in `Set.Ico 1 n`. -/
def Condition (n j : ℕ) (C : ℕ → Fin 2) : Prop :=
  (∀ i ∈ Set.Ico 1 n, C i = C (n - i)) ∧
  ∀ i ∈ Set.Ico 1 n, i ≠ j → C i = C (j - i : ℤ).natAbs


/-
# Solution
Let $a \sim b$ denote that $a$ and $b$ have the same color.
Because $j$ is coprime to $n$, every number in $N$ is of the form $kj\bmod n$ for a unique
$1 ≤ k < n$, so it suffices to show that $kj\bmod n \sim (k-1)j\bmod n$ for $1 < k < n$.
In this range of $k$, $kj\bmod n ≠ j$, so
* if $kj\bmod n > j$, $kj\bmod n \sim kj\bmod n - j = (k-1)j\bmod n$ using rule 2;
* if $kj\bmod n < j$, $kj\bmod n \sim j - kj\bmod n \sim n - j + kj\bmod n = (k-1)j\bmod n$
using rule 2 then rule 1.
-/

/-- For `1 ≤ k < n`, `k * j % n` has the same color as `j`. -/
lemma C_mul_mod {n j : ℕ} (hn : 3 ≤ n) (hj : j ∈ Set.Ico 1 n) (cpj : Nat.Coprime n j)
    {C : ℕ → Fin 2} (hC : Condition n j C) {k : ℕ} (hk : k ∈ Set.Ico 1 n) :
    C (k * j % n) = C j := by
  induction k, hk.1 using Nat.le_induction with
  | base => rw [one_mul, Nat.mod_eq_of_lt hj.2]
  | succ k hk₁ ih =>
    have nej : (k + 1) * j % n ≠ j := by
      by_contra! h; nth_rw 2 [← Nat.mod_eq_of_lt hj.2, ← one_mul j] at h
      replace h : (k + 1) % n = 1 % n := Nat.ModEq.cancel_right_of_coprime cpj h
      rw [Nat.mod_eq_of_lt hk.2, Nat.mod_eq_of_lt (by lia)] at h
      lia
    have b₁ : (k + 1) * j % n ∈ Set.Ico 1 n := by
      refine ⟨?_, Nat.mod_lt _ (by lia)⟩
      by_contra! h; rw [Nat.lt_one_iff, ← Nat.dvd_iff_mod_eq_zero] at h
      have ek := Nat.eq_zero_of_dvd_of_lt (cpj.dvd_of_dvd_mul_right h) hk.2
      lia
    rw [← ih ⟨hk₁, Nat.lt_of_succ_lt hk.2⟩, hC.2 _ b₁ nej]
    rcases nej.lt_or_gt with h | h
    · rw [Int.natAbs_natCast_sub_natCast_of_ge h.le]
      have b₂ : j - (k + 1) * j % n ∈ Set.Ico 1 n :=
        ⟨Nat.sub_pos_iff_lt.mpr h, (Nat.sub_le ..).trans_lt hj.2⟩
      have q : n - (j - (k + 1) * j % n) = (k + 1) * j % n + (n - j) % n := by
        rw [tsub_tsub_eq_add_tsub_of_le h.le, add_comm, Nat.add_sub_assoc hj.2.le,
          Nat.mod_eq_of_lt (show n - j < n by lia)]
      rw [hC.1 _ b₂, q, ← Nat.add_mod_of_add_mod_lt (by lia), ← Nat.add_sub_assoc hj.2.le, add_comm,
        Nat.add_sub_assoc (Nat.le_mul_of_pos_left _ hk.1), ← tsub_one_mul,
        Nat.add_mod_left, add_tsub_cancel_right]
    · rw [Int.natAbs_natCast_sub_natCast_of_le h.le, Nat.mod_sub_of_le h.le]
      rw [add_mul, one_mul, add_tsub_cancel_right]



theorem imo1985_p2 {n j : ℕ} (hn : 3 ≤ n) (hj : j ∈ Set.Ico 1 n)
    (cpj : Nat.Coprime n j) {C : ℕ → Fin 2} (hC : Condition n j C)
    {i : ℕ} (hi : i ∈ Set.Ico 1 n) :
    C i = C j := by
  obtain ⟨v, hv⟩ := Nat.exists_mul_mod_eq_one_of_coprime cpj.symm (by lia)
  have hvi : i = (v * i % n) * j % n := by
    rw [Nat.mod_mul_mod, ← mul_rotate, ← Nat.mod_mul_mod, hv.2, one_mul, Nat.mod_eq_of_lt hi.2]
  have vib : v * i % n ∈ Set.Ico 1 n := by
    refine ⟨(?_ : 0 < _), Nat.mod_lt _ (by lia)⟩
    by_contra! h; rw [Nat.le_zero, ← Nat.dvd_iff_mod_eq_zero] at h
    rw [mul_comm, ← Nat.mod_eq_of_lt (show 1 < n by lia)] at hv
    have i0 := Nat.eq_zero_of_dvd_of_lt
      ((Nat.coprime_of_mul_modEq_one _ hv.2).symm.dvd_of_dvd_mul_left h) hi.2
    subst i; simp at hi
  rw [hvi, C_mul_mod hn hj cpj hC vib]

end Imo1985P2

-- ═══ Imo1985P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 1985, Problem 4

Given a set M of 1985 distinct positive integers, none of which has a prime
divisor greater than 23, prove that M contains a subset of 4 elements
whose product is the 4th power of an integer.
-/

namespace Imo1985P4



universe u v w

lemma extended_pigeonhole {α : Type u} {β : Type v} [DecidableEq α] [DecidableEq β]
    {s : Finset α} {f: α → β} {s' : Finset β} (hf : ∀ n ∈ s, f n ∈ s')
    (n : ℕ) (hn : 2 * n + s'.card - 1 ≤ s.card)
    : ∃ t : Finset (Finset α), t.card = n
      ∧ (∀ t' : Finset α, t' ∈ t → t' ⊆ s)
      ∧ (∀ t' : Finset α, t' ∈ t → t'.card = 2)
      ∧ ((t : Set (Finset α)).PairwiseDisjoint id)
      ∧ (∀ t' : Finset α, t' ∈ t → ∃ p : β, ∀ n : α, n ∈ t' → f n = p) := by
  induction' n with n' hn'
  · use ∅; simp
  · have h'n' : 2 * n' + s'.card - 1 ≤ s.card := by lia
    rcases hn' h'n' with ⟨tn', ⟨htn'₁, htn'₂, htn'₃, htn'₄, htn'₅⟩⟩
    let s'' := s \ (Finset.disjiUnion tn' id htn'₄)
    have hs'' : s''.card = s.card - 2 * n' := by
      calc s''.card
          = s.card - (Finset.disjiUnion tn' id htn'₄).card := by
            apply Finset.card_sdiff_of_subset
            intro x hx
            simp at hx
            rcases hx with ⟨t', ⟨ht'₁, ht'₂⟩⟩
            exact (htn'₂ t' ht'₁) ht'₂
        _ = s.card - ∑ x ∈ tn', x.card := by
          rw [Finset.card_disjiUnion]
          simp
        _ = s.card - ∑ x ∈ tn', 2 := by rw [Finset.sum_congr rfl htn'₃]
        _ = s.card - 2 * n' := by
          rw [Finset.sum_const]
          simp
          lia
    have hf' : Set.MapsTo f s'' s' := by
      intro x hxs''
      rw [Finset.mem_coe] at *
      exact hf x (Finset.mem_sdiff.mp hxs'').left
    have h's'' : s'.card < s''.card := by lia
    rcases Finset.exists_ne_map_eq_of_card_lt_of_maps_to h's'' hf' with ⟨p, hp, q, hq, hpq₁, hpq₂⟩
    use insert {p, q} tn'
    have hpqs'' : {p, q} ⊆ s'' := Finset.insert_subset hp (Finset.singleton_subset_iff.mpr hq)
    constructorm* _ ∧ _
    · rw [← htn'₁]
      apply Finset.card_insert_of_notMem
      rw [Finset.subset_sdiff] at hpqs''
      have h' := hpqs''.right
      contrapose! h'
      simp
      intro htn'
      use {p, q}
      constructor
      · exact h'
      · simp
    · intro t' ht'
      rw [Finset.mem_insert] at ht'
      rcases ht' with (ht'pq|ht'tn')
      · rw [ht'pq]
        exact subset_trans hpqs'' Finset.sdiff_subset
      · exact htn'₂ t' ht'tn'
    · intro t' ht'
      rw [Finset.mem_insert] at ht'
      rcases ht' with (ht'pq|ht'tn')
      · rw [ht'pq]
        exact Finset.card_pair hpq₁
      · exact htn'₃ t' ht'tn'
    · rw [Finset.coe_insert, Set.pairwiseDisjoint_insert]
      constructor
      · exact htn'₄
      · intro j hj hpqj
        simp only [id_eq, Finset.disjoint_iff_ne]
        intro a ha b hb
        have has'' := hpqs'' ha
        rw [Finset.mem_sdiff] at has''
        have hatn' := has''.right
        contrapose! hatn'
        rw [hatn']
        simp
        use j
        exact ⟨hj, hb⟩
    · intro t' ht'
      rw [Finset.mem_insert] at ht'
      rcases ht' with (ht'pq|ht'tn')
      · use (f p)
        intro m hm
        rw [ht'pq, Finset.mem_insert, Finset.mem_singleton] at hm
        lia
      · exact htn'₅ t' ht'tn'

lemma double_pigeonhole {α : Type u} {β : Type v} {γ : Type w} [DecidableEq α] [DecidableEq β] [DecidableEq γ]
    {s : Finset α} {f₁: α → β} {f₂: (Finset α) → γ} {s₁ : Finset β} {s₂ : Finset γ}
    (hf₁ : ∀ n ∈ s, f₁ n ∈ s₁) (hf₂ : ∀ s' ⊆ s, f₂ s' ∈ s₂)
    (hs: 2 * s₂.card + s₁.card + 1 ≤ s.card)
    : ∃ t₁ t₂ : (Finset α), t₁.card = 2 ∧ t₂.card = 2
      ∧ t₁ ⊆ s ∧ t₂ ⊆ s ∧ Disjoint t₁ t₂
      ∧ (∃ p : β, ∀ n : α, n ∈ t₁ → f₁ n = p)
      ∧ (∃ p : β, ∀ n : α, n ∈ t₂ → f₁ n = p)
      ∧ (f₂ t₁ = f₂ t₂) := by
  have h's : 2 * (s₂.card + 1) + s₁.card - 1 ≤ s.card := by lia
  rcases extended_pigeonhole hf₁ (s₂.card + 1) h's with ⟨t, ⟨ht₁, ht₂, ht₃, ht₄, ht₅⟩⟩
  have h't : s₂.card < t.card := by lia
  have h'f₂ : Set.MapsTo f₂ t s₂ := by
    intro x hxt
    rw [Finset.mem_coe] at *
    exact hf₂ x (ht₂ x hxt)
  rcases Finset.exists_ne_map_eq_of_card_lt_of_maps_to h't h'f₂ with ⟨p, hp, q, hq, hpq₁, hpq₂⟩
  use p, q
  constructorm* _ ∧ _
  · exact ht₃ p hp
  · exact ht₃ q hq
  · exact ht₂ p hp
  · exact ht₂ q hq
  · exact ht₄ hp hq hpq₁
  · exact ht₅ p hp
  · exact ht₅ q hq
  · exact hpq₂

noncomputable def pow_of_kth_prime_mod_two (k : ℕ) (n : ℕ) : ℕ :=
  (padicValNat (Nat.nth Nat.Prime k) n) % 2

def two_pow_k_finset (k : ℕ) := Finset.pi (Finset.range k) (fun _ ↦ Finset.range 2)

noncomputable def pow_of_first_k_prime_mod_two (k : ℕ) (n : ℕ) :=
  fun (k' : ℕ) ↦ fun (_ : k' ∈ Finset.range k) ↦ pow_of_kth_prime_mod_two k' n

lemma pow_of_first_k_prime_mod_two_mem_two_pow_k_finset (k : ℕ) (n : ℕ) :
    pow_of_first_k_prime_mod_two k n ∈ two_pow_k_finset k := by
  rw [two_pow_k_finset, Finset.mem_pi]
  intro a ha
  simp [pow_of_first_k_prime_mod_two, pow_of_kth_prime_mod_two]
  apply Nat.mod_lt
  norm_num

lemma square_of_pow_of_pow_of_kth_prime_mod_two_eq {m n : ℕ}
    (hm₀ : m ≠ 0) (hn₀ : n ≠ 0)
    (hmn : ∀ k , pow_of_kth_prime_mod_two k m = pow_of_kth_prime_mod_two k n) :
  ∃ k, m * n = k ^ 2 := by
  let k := ∏ p ∈ Finset.range (m * n + 1) with Nat.Prime p, p ^ ((padicValNat p m + padicValNat p n) / 2)
  use k
  have hmn₀ : m * n ≠ 0 := Nat.mul_ne_zero hm₀ hn₀
  rw [← Nat.prod_pow_prime_padicValNat (m * n) hmn₀ (m * n + 1) (by lia:_)]
  rw [← Finset.prod_pow]
  apply Finset.prod_congr rfl
  intro p hp
  simp at hp
  have hp' := hp.right
  rw [← pow_mul]
  congr
  have : Fact (Nat.Prime p) := { out := hp' }
  rw [padicValNat.mul hm₀ hn₀]
  symm
  apply Nat.div_mul_cancel
  apply Nat.dvd_of_mod_eq_zero
  have hmn':= hmn (Nat.primeCounting' p)
  simp [pow_of_kth_prime_mod_two, Nat.primeCounting'] at hmn'
  rw [Nat.nth_count hp'] at hmn'
  lia

lemma padicValNat_eq_zero_of_divisors {k m k': ℕ} (hm₀ : m ≠ 0)
    (hm : ∀ p, p.Prime ∧ p ∣ m → p ≤ Nat.nth Nat.Prime k) (hk' : k < k'):
    padicValNat (Nat.nth Nat.Prime k') m = 0 := by
  by_contra! hdiv
  have : Fact (Nat.Prime (Nat.nth Nat.Prime k')) := Fact.mk (Nat.prime_nth_prime k')
  rw [← dvd_iff_padicValNat_ne_zero hm₀] at hdiv
  have hdiv' := hm (Nat.nth Nat.Prime k') ⟨Nat.prime_nth_prime k', hdiv⟩
  rw [Nat.nth_le_nth Nat.infinite_setOf_prime] at hdiv'
  lia

lemma square_of_pow_of_first_k_prime_mod_two_eq {k m n : ℕ}
    (hm₀ : m ≠ 0) (hn₀ : n ≠ 0)
    (hmn : pow_of_first_k_prime_mod_two (k + 1) m = pow_of_first_k_prime_mod_two (k + 1) n)
    (hm : ∀ p, p.Prime ∧ p ∣ m → p ≤ Nat.nth Nat.Prime k)
    (hn : ∀ p, p.Prime ∧ p ∣ n → p ≤ Nat.nth Nat.Prime k) :
    ∃ k, m * n = k ^ 2 := by
  have hmn' : ∀ k' , pow_of_kth_prime_mod_two k' m = pow_of_kth_prime_mod_two k' n := by
    intro k'
    by_cases hk' : k' ≤ k
    · rw [funext_iff] at hmn
      have hmn'' := hmn k'
      rw [funext_iff] at hmn''
      have h'k' : k' ∈ Finset.range (k + 1) := by exact Finset.mem_range_succ_iff.mpr hk'
      have hmn''' := hmn'' h'k'
      simp only [pow_of_first_k_prime_mod_two] at hmn'''
      exact hmn'''
    · push_neg at hk'
      simp only [pow_of_kth_prime_mod_two]
      rw [padicValNat_eq_zero_of_divisors hm₀ hm hk']
      rw [padicValNat_eq_zero_of_divisors hn₀ hn hk']
  exact square_of_pow_of_pow_of_kth_prime_mod_two_eq hm₀ hn₀ hmn'

lemma prod_square_of_pow_of_first_k_prime_mod_two_eq {M : Finset ℕ} {k : ℕ}
    (Mdivisors : ∀ m ∈ M, ∀ n, n.Prime ∧ n ∣ m → n ≤ Nat.nth Nat.Prime k)
    (Mpos : ∀ m ∈ M, 0 < m) {s : Finset ℕ} (hs₁ : s.card = 2) (hs₂ : s ⊆ M)
    (hs₃ : ∃ f, ∀ n ∈ s, pow_of_first_k_prime_mod_two (k+1) n = f) :
    ∃ k, s.prod id = k ^ 2 := by
  rw [Finset.card_eq_two] at hs₁
  rcases hs₁ with ⟨m, n, hmn₁, hmn₂⟩
  rw [hmn₂, Finset.prod_insert (Finset.notMem_singleton.mpr hmn₁), Finset.prod_singleton, id_eq, id_eq]
  have hm' : m ∈ M := by
    apply hs₂
    simp [hmn₂]
  have hn' : n ∈ M := by
    apply hs₂
    simp [hmn₂]
  have hm₀ : m ≠ 0 := Nat.ne_zero_iff_zero_lt.mpr (Mpos m hm')
  have hn₀ : n ≠ 0 := Nat.ne_zero_iff_zero_lt.mpr (Mpos n hn')
  have hmn : pow_of_first_k_prime_mod_two (k + 1) m = pow_of_first_k_prime_mod_two (k + 1) n := by
    rcases hs₃ with ⟨f, hf⟩
    rw [hf m (by simp [hmn₂]:_), hf n (by simp [hmn₂]:_)]
  have hm : ∀ p, p.Prime ∧ p ∣ m → p ≤ Nat.nth Nat.Prime k := Mdivisors m hm'
  have hn : ∀ p, p.Prime ∧ p ∣ n → p ≤ Nat.nth Nat.Prime k := Mdivisors n hn'
  exact square_of_pow_of_first_k_prime_mod_two_eq hm₀ hn₀ hmn hm hn

lemma sqrt_prod_subset_ne_zero {M s : Finset ℕ} {k : ℕ}
    (Mpos : ∀ m ∈ M, 0 < m) (hs: s ⊆ M) (hk : s.prod id = k ^ 2) :
    k ≠ 0 := by
  contrapose! hk
  rw [hk]
  simp
  rw [Finset.prod_eq_zero_iff]
  push_neg
  intro n hn
  exact Nat.ne_zero_iff_zero_lt.mpr (Mpos n (hs hn))

lemma sqrt_divisors_subset {M s : Finset ℕ} {k k₁: ℕ}
    (Mdivisors : ∀ m ∈ M, ∀ n, n.Prime ∧ n ∣ m → n ≤ Nat.nth Nat.Prime k)
    (hs: s ⊆ M) (hk₁ : s.prod id = k₁ ^ 2) : ∀ p, p.Prime ∧ p ∣ k₁ → p ≤ Nat.nth Nat.Prime k := by
  rintro p' ⟨hp', h'p'⟩
  rw [← Prime.dvd_pow_iff_dvd (Nat.Prime.prime hp') (by norm_num:2 ≠ 0)] at h'p'
  rw [← hk₁] at h'p'
  apply Prime.exists_mem_finset_dvd (Nat.Prime.prime hp') at h'p'
  rcases h'p' with ⟨n, hn, hn'⟩
  exact Mdivisors n (hs hn) p' ⟨hp', hn'⟩

theorem generalized (M : Finset ℕ) (k : ℕ)
    (Mcard : 3 * 2 ^ (k + 1) + 1 ≤ M.card) (Mpos : ∀ m ∈ M, 0 < m)
    (Mdivisors : ∀ m ∈ M, ∀ n, n.Prime ∧ n ∣ m → n ≤ Nat.nth Nat.Prime k) :
    ∃ M' : Finset ℕ, M' ⊆ M ∧ M'.card = 4 ∧ ∃ k, M'.prod id = k^4 := by
  let f₁ := fun (n : ℕ) ↦ pow_of_first_k_prime_mod_two (k+1) n
  have hf₁ : ∀ n ∈ M, f₁ n ∈ two_pow_k_finset (k + 1) := by
    intro m hm
    simp [f₁]
    apply pow_of_first_k_prime_mod_two_mem_two_pow_k_finset
  let f₂ := fun (n : Finset ℕ) ↦ pow_of_first_k_prime_mod_two (k+1) (Nat.sqrt (∏ x ∈ n, x))
  have hf₂ : ∀ n ⊆ M, f₂ n ∈ two_pow_k_finset (k + 1) := by
    intro m hm
    simp [f₂]
    apply pow_of_first_k_prime_mod_two_mem_two_pow_k_finset
  have hs : 2 * (two_pow_k_finset (k + 1)).card + (two_pow_k_finset (k + 1)).card + 1 ≤ M.card := by
    rw [two_pow_k_finset, Finset.card_pi, Finset.card_range, Finset.prod_const, Finset.card_range]
    lia
  rcases double_pigeonhole hf₁ hf₂ hs with ⟨p, q, hp₁, hq₁, hp₂, hq₂, hpq₁, hp₃, hq₃, hpq₂⟩
  use p ∪ q
  constructorm* _ ∧ _
  · exact Finset.union_subset hp₂ hq₂
  · rw [← Finset.card_union_eq_card_add_card] at hpq₁
    lia
  · rw [Finset.prod_union hpq₁]
    rcases prod_square_of_pow_of_first_k_prime_mod_two_eq Mdivisors Mpos hp₁ hp₂ hp₃ with ⟨k₁, hk₁⟩
    rcases prod_square_of_pow_of_first_k_prime_mod_two_eq Mdivisors Mpos hq₁ hq₂ hq₃ with ⟨k₂, hk₂⟩
    rw [hk₁, hk₂]
    have h₀k₁ : k₁ ≠ 0 := sqrt_prod_subset_ne_zero Mpos hp₂ hk₁
    have h₀k₂ : k₂ ≠ 0 := sqrt_prod_subset_ne_zero Mpos hq₂ hk₂
    have hk₁k₂ : pow_of_first_k_prime_mod_two (k + 1) k₁ = pow_of_first_k_prime_mod_two (k + 1) k₂ := by
      simp [f₂] at hpq₂
      simp at hk₁ hk₂
      rw [hk₁, hk₂, Nat.sqrt_eq' k₁, Nat.sqrt_eq' k₂] at hpq₂
      exact hpq₂
    have h'k₁ : ∀ p, p.Prime ∧ p ∣ k₁ → p ≤ Nat.nth Nat.Prime k :=
      sqrt_divisors_subset Mdivisors hp₂ hk₁
    have h'k₂ : ∀ p, p.Prime ∧ p ∣ k₂ → p ≤ Nat.nth Nat.Prime k :=
      sqrt_divisors_subset Mdivisors hq₂ hk₂
    rcases square_of_pow_of_first_k_prime_mod_two_eq h₀k₁ h₀k₂ hk₁k₂ h'k₁ h'k₂ with ⟨k, hk⟩
    use k
    rw [← mul_pow, hk, ← pow_mul]



theorem imo1985_p4 (M : Finset ℕ) (Mcard : M.card = 1985) (Mpos : ∀ m ∈ M, 0 < m)
    (Mdivisors : ∀ m ∈ M, ∀ n, n ∈ m.primeFactors → n ≤ 23)
    : ∃ M' : Finset ℕ, M' ⊆ M ∧ M'.card = 4 ∧ ∃ k, M'.prod id = k^4 := by
  replace Mdivisors : ∀ m ∈ M, ∀ n, n.Prime ∧ n ∣ m → n ≤ 23 := fun m hm n ↦ by
    rw [←Nat.mem_primeFactors_of_ne_zero (Mpos m hm).ne.symm]
    grind
  let k := 8
  have h₁ : Nat.nth Nat.Prime k = 23 := by
    have h' : Nat.count Nat.Prime 23 = k := by decide
    rw [← h']
    apply Nat.nth_count
    decide
  rw [← h₁] at Mdivisors
  have h₂ : 3 * 2 ^ (k + 1) + 1 ≤ M.card := by norm_num [Mcard]
  exact generalized M k h₂ Mpos Mdivisors


end Imo1985P4

-- ═══ Imo1985P6 ═══

/-
Copyright (c) 2025 Roozbeh Yousefzadeh. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh
-/





/-!
# International Mathematical Olympiad 1985, Problem 6

For every real number x_1, construct the sequence {x_1,x_2, ...}
by setting x_{n+1} = x_n * (x_n + 1 / n) for each n >= 1.


Prove that there exists exactly one value of x_1 for which
0 < x_n , x_n < x_{n+1}, and x_{n+1} < 1 for every n.
-/

namespace Imo1985P6



lemma aux_1
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ x, f 1 x = x)
  (h₁ : ∀ n x, 0 < n → f (n + 1) x = f n x * (f n x + 1 / n)) :
  ∀ n x, 0 < n ∧ 0 < x → 0 < f n x := by
  rintro n x ⟨hn, hx⟩
  induction n, hn using Nat.le_induction with
  | base =>
      rw [h₀]
      exact hx
  | succ m hm ih =>
      rw [h₁ m x (Nat.zero_lt_of_lt hm)]
      positivity

lemma aux_2
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ x, f 1 x = x)
  (h₁ : ∀ n x, 0 < n → f (n + 1) x = f n x * (f n x + 1 / n))
  (h₃ : ∀ n x, 0 < n → 0 ≤ f n x) :
  ∀ n x y, 0 < n → x < y → f n x < f n y := by
  intro n x y hn hxy
  induction n using Nat.strong_induction_on with
  | h n ih =>
    cases n with
    | zero => exact absurd hn (Nat.lt_irrefl _)
    | succ n =>
      cases n with
      | zero => simpa [h₀] using hxy
      | succ n =>
        have pos_n : 0 < n.succ := Nat.succ_pos _
        have IH := ih n.succ (Nat.lt_succ_self _) pos_n
        rw [h₁ n.succ x pos_n, h₁ n.succ y pos_n]
        refine mul_lt_mul IH ?_ ?_ ?_
        · apply add_le_add (le_of_lt IH) le_rfl
        · exact add_pos_of_nonneg_of_pos (h₃ _ _ pos_n) (by positivity)
        · exact h₃ _ _ pos_n

lemma aux_3
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (h₄ : ∀ (n : ℕ) (x y : NNReal), 0 < n → x < y → f n x < f n y) :
  ∀ (n : ℕ) (x : NNReal), 1 < n ∧ 1 ≤ x → 1 < f n x := by
  intro n x hx₀
  obtain ⟨hn₀, hx₁⟩ := hx₀
  have g₂₀: f n 1 ≤ f n x := by
    obtain hx_gt | hx_eq := lt_or_eq_of_le hx₁
    · exact le_of_lt (h₄ n 1 x (Nat.zero_lt_of_lt hn₀) hx_gt)
    · rw [hx_eq]
  have g₂₁: f 1 1 < f n 1 := by
    rw [h₀]
    refine Nat.le_induction ?_ ?_ n hn₀
    · rw [h₁ 1 1 (by norm_num), h₀]
      norm_num
    · intro m hm₀ hm₁
      rw [h₁ m 1 (by lia)]
      refine one_lt_mul_of_lt_of_le hm₁ ?_
      nth_rw 1 [← add_zero 1]
      refine add_le_add ?_ ?_
      · exact le_of_lt hm₁
      · exact Nat.one_div_cast_nonneg m
  refine lt_of_lt_of_le ?_ g₂₀
  exact (lt_iff_lt_of_cmp_eq_cmp (congrFun (congrArg cmp (h₀ 1)) (f n 1))).mp g₂₁


lemma aux_4
    (f : ℕ → NNReal → ℝ)
    (h₃ : ∀ (n : ℕ) (x : NNReal), 0 < n → 0 ≤ f n x)
    (h₄ : ∀ (n : ℕ) (x y : NNReal), 0 < n → x < y → f n x < f n y)
    (f₀ : ℕ → NNReal → NNReal)
    (hf₀ : f₀ = fun n x => (f n x).toNNReal) :
    ∀ (n : ℕ), 0 < n → StrictMono (f₀ n) := by
  intro n hn x y hxy
  rw [hf₀]
  simp only [Real.toNNReal_lt_toNNReal_iff']
  constructor
  · exact h₄ n x y hn hxy
  · exact lt_of_lt_of_le' (h₄ n x y hn hxy) (h₃ n x hn)

lemma aux_5
    (f : ℕ → NNReal → ℝ)
    (hmo₁ : ∀ (n : ℕ), 0 < n → Function.Injective (f n))
    (f₀ : ℕ → NNReal → NNReal)
    (hmo₂ : ∀ (n : ℕ), 0 < n → StrictMono (f₀ n))
    (fi : ℕ → NNReal → NNReal)
    (hfi : fi = fun n => Function.invFun (f₀ n)) :
    ∀ (n : ℕ) (x y : NNReal), 0 < n → f₀ n x = y → fi n y = x := by
  intro n x y hn₀ hn₁
  have hf₃: ∀ n y, fi n y = Function.invFun (f₀ n) y := by
    exact fun n y => congrFun (congrFun hfi n) y
  rw [← hn₁, hf₃]
  have hmo₃: ∀ n, 0 < n → Function.Injective (f₀ n) := by
    exact fun n a => StrictMono.injective (hmo₂ n a)
  have hn₂: (Function.invFun (f₀ n)) ∘ (f₀ n) = id := by exact Function.invFun_comp (hmo₃ n hn₀)
  rw [Function.comp_def (Function.invFun (f₀ n)) (f₀ n)] at hn₂
  have hn₃ : (fun x => Function.invFun (f₀ n) (f₀ n x)) x = id x :=
    (NNReal.eq (congrArg NNReal.toReal (congrFun hn₂.symm x))).symm
  exact hmo₁ n hn₀ (congrArg (f n) hn₃)

lemma aux_6
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (f₀ : ℕ → NNReal → NNReal)
  (hf₀ : f₀ = fun n x => (f n x).toNNReal) :
  ∀ (n : ℕ), 0 < n → Continuous (f₀ n) := by
  intro n hn₀
  rw [hf₀]
  apply Continuous.comp continuous_real_toNNReal
  induction n, hn₀ using Nat.le_induction with
  | base =>
      have : f 1 = fun x => ↑x := funext h₀
      rw [this]
      exact NNReal.continuous_coe
  | succ d hd_pos hd_cont =>
      have : f (d + 1) = fun x => f d x * (f d x + 1 / d) := funext (h₁ d · hd_pos)
      rw [this]
      fun_prop

lemma aux_7
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (h₃ : ∀ (n : ℕ) (x : NNReal), 0 < n → 0 ≤ f n x)
  (h₅ : ∀ (n : ℕ) (x : NNReal), 1 < n ∧ 1 ≤ x → 1 < f n x)
  (f₀ : ℕ → NNReal → NNReal)
  (hf₂ : ∀ (n : ℕ) (x : NNReal), 0 < n → f₀ n x = (f n x).toNNReal)
  (hmo₂ : ∀ (n : ℕ), 0 < n → StrictMono (f₀ n))
  (hmo₄ : ∀ (n : ℕ), 0 < n → Continuous (f₀ n)) :
  ∀ (n : ℕ), 0 < n → Function.Surjective (f₀ n) := by
  intro n hn₀
  refine Continuous.surjective (hmo₄ n hn₀) ?_ ?_
  · refine Monotone.tendsto_atTop_atTop ?_ ?_
    · exact StrictMono.monotone (hmo₂ n hn₀)
    · intro b
      use (b + 1)
      refine Nat.le_induction ?_ ?_ n hn₀
      · rw [hf₂ 1 (b + 1) (by lia), h₀]
        simp
      · intro d hd₀ hd₁
        rw [hf₂ (d + 1) (b + 1) (by lia), h₁ d (b + 1) (by lia)]
        have hd₂: b ≤ f d (b + 1) := by
          rw [hf₂ d (b + 1) (by lia)] at hd₁
          exact (Real.le_toNNReal_iff_coe_le (h₃ d (b + 1) hd₀)).mp hd₁
        have hd₃: 1 < (f d (b + 1) + 1 / ↑d) := by
          by_cases hd₄: 1 < d
          · refine lt_add_of_lt_of_pos ?_ ?_
            · exact h₅ d (b + 1) ⟨hd₄, le_add_self⟩
            · positivity
          · have hd₅: d = 1 := by lia
            rw [hd₅, h₀]
            simp
            positivity
        refine NNReal.le_toNNReal_of_coe_le ?_
        nth_rw 1 [← mul_one (↑b:ℝ)]
        refine mul_le_mul hd₂ (le_of_lt hd₃) zero_le_one ?_
        exact h₃ d (b + 1) hd₀
  · refine Filter.tendsto_atBot_atBot.mpr ?_
    intro b
    use 0
    intro a ha₀
    have ha₁: a = 0 := nonpos_iff_eq_zero.mp ha₀
    have ha₂: f₀ n 0 = 0 := by
      refine Nat.le_induction ?_ ?_ n hn₀
      · rw [hf₂ 1 0 (by lia), h₀]
        exact Real.toNNReal_coe
      · intro d hd₀ hd₁
        rw [hf₂ (d + 1) 0 (by lia), h₁ d 0 (by lia)]
        have hd₂: 0 ≤ f d 0 := by exact h₃ d 0 hd₀
        have hd₃: f d 0 = 0 := by
          rw [hf₂ d 0 (by lia)] at hd₁
          apply Real.toNNReal_eq_zero.mp at hd₁
          exact eq_of_le_of_ge hd₁ hd₂
        rw [hd₃, zero_mul]
        exact Real.toNNReal_zero
    rw [ha₁, ha₂]
    exact _root_.zero_le b


lemma aux_8
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (hmo₀ : ∀ (n : ℕ), 0 < n → StrictMono (f n))
  (hmo₁ : ∀ (n : ℕ), 0 < n → Function.Injective (f n))
  (f₀ : ℕ → NNReal → NNReal)
  (hf₂ : ∀ (n : ℕ) (x : NNReal), 0 < n → f₀ n x = (f n x).toNNReal)
  (sn : Set ℕ)
  (fb : ↑sn → NNReal)
  (hsn₁ : ∀ (n : ↑sn), ↑n ∈ sn ∧ 0 < n.1)
  (hfb₁ : ∀ (n : ↑sn), f₀ (↑n) (fb n) = 1 - 1 / ↑↑n) :
  ∀ (n : ↑sn), fb n < 1 := by
  intro n
  have hn₀: 0 < (n:ℕ) := by exact (hsn₁ n).2
  let z := fb n
  have hz₀: z = fb n := by rfl
  rw [← hz₀]
  by_contra! hc₀
  have hc₁: 1 ≤ f n z := by
    by_cases hn₁: 1 < (n:ℕ)
    · refine le_of_lt ?_
      refine aux_3 f h₀ h₁ ?_ (↑n) z ?_
      · exact fun n x y a a_1 => hmo₀ n a a_1
      · exact ⟨hn₁, hc₀⟩
    · have hn₂: (n:ℕ) = 1 := by lia
      rw [hn₂, h₀]
      exact hc₀
  have hz₁: f₀ n z = 1 - 1 / n := by
    exact hfb₁ n
  have hz₃: f n z = 1 - 1 / n := by
    rw [hf₂ n z hn₀] at hz₁
    by_cases hn₁: 1 < (n:ℕ)
    · have hz₂: 1 - 1 / (n:NNReal) ≠ 0 := by
        have g₀: (n:NNReal) ≠ 0 := by
          norm_cast
          lia
        nth_rw 1 [← div_self g₀, ← NNReal.sub_div]
        refine div_ne_zero ?_ g₀
        norm_cast
        exact Nat.sub_ne_zero_iff_lt.mpr hn₁
      apply (Real.toNNReal_eq_iff_eq_coe hz₂).mp at hz₁
      rw [hz₁]
      exact ((fun {r} {p:NNReal} hp =>
              (Real.toNNReal_eq_iff_eq_coe hp).mp) hz₂ (hmo₁ n hn₀ rfl)).symm
    · have hn₂: (n:ℕ) = 1 := by lia
      rw [hn₂, h₀] at hz₁
      simp at hz₁
      rw [hn₂, h₀, hz₁]
      simp
  rw [hz₃] at hc₁
  have hz₄: 0 < 1 / (n:ℝ) := by
    refine div_pos zero_lt_one ?_
    exact Nat.cast_pos'.mpr hn₀
  linarith


lemma aux_9
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (f₀ : ℕ → NNReal → NNReal)
  (hf₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f n x = ↑(f₀ n x))
  (hf₂ : ∀ (n : ℕ) (x : NNReal), 0 < n → f₀ n x = (f n x).toNNReal)
  (hmo₂ : ∀ (n : ℕ), 0 < n → StrictMono (f₀ n))
  (fi : ℕ → NNReal → NNReal)
  (hf₅ : ∀ (x : NNReal), fi 1 x = x)
  (hmo₇ : ∀ (n : ℕ), 0 < n → Function.RightInverse (fi n) (f₀ n))
  (hf₇ : ∀ (n : ℕ) (x y : NNReal), 0 < n → (f₀ n x = y ↔ fi n y = x))
  (fb : ℕ → NNReal)
  (hfb₀ : fb = fun n => fi n (1 - 1 / ↑n))
  (sn : Set ℕ)
  (hsn : sn = Set.Ici 1) :
  StrictMonoOn fb sn := by
  rw [hsn]
  refine strictMonoOn_Ici_of_pred_lt ?hψ
  intro m hm₀
  rw [hfb₀]
  refine Nat.le_induction ?_ ?_ m hm₀
  · have g₁: fi 1 0 = 0 := by exact hf₅ 0
    have g₂: (2:NNReal).HolderConjugate (2:NNReal) := by
      refine (NNReal.holderConjugate_iff_eq_conjExponent ?_).mpr ?_
      · exact one_lt_two
      · norm_cast
        simp
    simp
    norm_cast
    rw [g₁, NNReal.HolderConjugate.one_sub_inv g₂]
    let x := fi 2 2⁻¹
    have hx₀: x = fi 2 2⁻¹ := by rfl
    have hx₁: f₀ 2 x = 2⁻¹ := by
      rw [hx₀]
      have g₃: Function.RightInverse (fi 2) (f₀ 2) := by exact hmo₇ 2 (by lia)
      exact g₃ 2⁻¹
    rw [← hx₀]
    contrapose! hx₁
    have hc₁: x = 0 := by exact nonpos_iff_eq_zero.mp hx₁
    have hc₃: f₀ 2 x = 0 := by
      rw [hc₁, hf₂ 2 0 (by lia), h₁ 1 0 (by lia), h₀ 0]
      norm_cast
      rw [zero_mul]
      exact Real.toNNReal_zero
    rw [hc₃]
    exact Ne.symm (NNReal.HolderTriple.inv_ne_zero g₂)
  · simp
    intro n hn₀ _
    let i := fi n (1 - (↑n)⁻¹)
    let j := fi (n + 1) (1 - ((↑n:NNReal) + 1)⁻¹)
    have hi₀: i = fi n (1 - (↑n)⁻¹) := by rfl
    have hj₀: j = fi (n + 1) (1 - ((↑n:NNReal) + 1)⁻¹) := by rfl
    have hi₁: f₀ n i = (1 - (↑n)⁻¹) := (hf₇ n i (1 - (↑n:NNReal)⁻¹) (by lia)).mpr hi₀.symm
    have hj₁: f₀ (n + 1) j = (1 - ((↑n:NNReal) + 1)⁻¹) := by
      exact (hf₇ (n + 1) j _ (by lia)).mpr hj₀.symm
    have hj₂: (1 - ((↑n:NNReal) + 1)⁻¹) = (1 - ((n:ℝ) + 1)⁻¹).toNNReal := by
      exact rfl
    have hn₂: f₀ (n + 1) i < f₀ (n + 1) j := by
      rw [hj₁, hj₂, hf₂ (n + 1) _ (by lia), h₁ n i (by lia)]
      rw [hf₁ n i (by lia), hi₁]
      refine (Real.toNNReal_lt_toNNReal_iff ?_).mpr ?_
      · refine sub_pos.mpr ?_
        refine inv_lt_one_of_one_lt₀ ?_
        norm_cast
        exact Nat.lt_add_right 1 hn₀
      · have g₀: (↑n:NNReal)⁻¹ ≤ 1 := by exact Nat.cast_inv_le_one n
        rw [NNReal.coe_sub g₀, NNReal.coe_inv]
        simp
        refine inv_strictAnti₀ ?_ ?_
        · positivity
        · norm_cast
          exact lt_add_one n
    refine (StrictMono.lt_iff_lt ?_).mp hn₂
    exact hmo₂ (n + 1) (by lia)


lemma aux_10
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ (x : NNReal), f 1 x = ↑x)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (f₀ : ℕ → NNReal → NNReal)
  (hf₂ : ∀ (n : ℕ) (x : NNReal), 0 < n → f₀ n x = (f n x).toNNReal)
  (fi : ℕ → NNReal → NNReal)
  (hmo₇ : ∀ (n : ℕ), 0 < n → Function.RightInverse (fi n) (f₀ n))
  (sn : Set ℕ)
  (sb : Set NNReal)
  (fb : ↑sn → NNReal)
  (hsn₀ : sn = Set.Ici 1)
  (hfb₀ : fb = fun n:↑sn => fi (↑n) (1 - 1 / ↑↑n))
  (hsb₀ : sb = Set.range fb)
  (fr : NNReal → ℝ)
  (hfr: fr = fun x => ↑x)
  (sbr : Set ℝ)
  (hsbr: sbr = fr '' sb)
  (br: ℝ)
  (hbr₀ : IsLUB sbr br) :
  0 < br := by
  have hnb₀: 2 ∈ sn := by
    rw [hsn₀]
    decide
  let nb : ↑sn := ⟨2, hnb₀⟩
  have g₀: 0 < fb nb := by
    have g₁: (2:NNReal).HolderConjugate (2:NNReal) := by
      refine (NNReal.holderConjugate_iff_eq_conjExponent ?_).mpr ?_
      · exact one_lt_two
      · norm_cast
        simp
    rw [hfb₀]
    simp
    have hnb₁: nb.val = 2 := by exact rfl
    rw [hnb₁]
    norm_cast
    rw [NNReal.HolderConjugate.one_sub_inv g₁]
    let x := fi 2 2⁻¹
    have hx₀: x = fi 2 2⁻¹ := by rfl
    have hx₁: f₀ 2 x = 2⁻¹ := by
      rw [hx₀]
      have g₃: Function.RightInverse (fi 2) (f₀ 2) := by exact hmo₇ 2 (by lia)
      exact g₃ 2⁻¹
    rw [← hx₀]
    contrapose! hx₁
    have hc₁: x = 0 := by exact nonpos_iff_eq_zero.mp hx₁
    have hc₃: f₀ 2 x = 0 := by
      rw [hc₁, hf₂ 2 0 (by lia), h₁ 1 0 (by lia), h₀ 0]
      norm_cast
      rw [zero_mul]
      exact Real.toNNReal_zero
    rw [hc₃]
    exact Ne.symm (NNReal.HolderTriple.inv_ne_zero g₁)
  have g₁: ∃ x, 0 < x ∧ x ∈ sbr := by
    use (fb nb).toReal
    constructor
    · exact g₀
    · rw [hsbr]
      simp
      use fb ↑nb
      constructor
      · rw [hsb₀]
        exact Set.mem_range_self nb
      · exact congrFun hfr (fb ↑nb)
  obtain ⟨x, hx₀, hx₁⟩ := g₁
  have hx₂: br ∈ upperBounds sbr := by
    refine (isLUB_le_iff hbr₀).mp ?_
    exact Preorder.le_refl br
  exact lt_of_le_of_lt' (hx₂ hx₁) hx₀


lemma aux_11
  (sn : Set ℕ)
  (fb fc : ↑sn → NNReal)
  (hfc₂ : ∀ (n : ↑sn), fb n < fc n)
  (hfb₃ : StrictMono fb)
  (hfc₃ : StrictAnti fc)
  (sb sc : Set NNReal)
  (hsb₀ : sb = Set.range fb)
  (hsc₀ : sc = Set.range fc)
  (fr : NNReal → ℝ)
  (hfr : fr = fun x ↦ ↑x)
  (sbr scr : Set ℝ)
  (hsbr : sbr = fr '' sb)
  (hscr : scr = fr '' sc)
  (br cr : ℝ)
  (hbr₀ : IsLUB sbr br)
  (hcr₀ : IsGLB scr cr) :
  br ≤ cr := by
  have hfc₄: ∀ nb nc, fb nb < fc nc := by
    intro nb nc
    obtain hn₀ | hn₀ := lt_or_ge nb nc
    · exact lt_trans (hfb₃ hn₀) (hfc₂ nc)
    obtain hn₁ | hn₁ := lt_or_eq_of_le hn₀
    · refine lt_trans (hfc₂ nb) ?_
      exact hfc₃ hn₁
    · rw [hn₁]
      exact hfc₂ nb
  by_contra! hc₀
  have hc₁: ∃ x ∈ sbr, cr < x ∧ x ≤ br := by exact IsLUB.exists_between hbr₀ hc₀
  let ⟨x, hx₀, hx₁, _⟩ := hc₁
  have hc₂: ∃ y ∈ scr, cr ≤ y ∧ y < x := by exact IsGLB.exists_between hcr₀ hx₁
  let ⟨y, hy₀, _, hy₂⟩ := hc₂
  have hc₃: x < y := by
    have hx₃: x.toNNReal ∈ sb := by
      rw [hsbr] at hx₀
      apply (Set.mem_image fr sb x).mp at hx₀
      obtain ⟨z, hz₀, hz₁⟩ := hx₀
      rw [← hz₁, hfr, Real.toNNReal_coe]
      exact hz₀
    have hy₃: y.toNNReal ∈ sc := by
      rw [hscr] at hy₀
      apply (Set.mem_image fr sc y).mp at hy₀
      obtain ⟨z, hz₀, hz₁⟩ := hy₀
      rw [← hz₁, hfr, Real.toNNReal_coe]
      exact hz₀
    rw [hsb₀] at hx₃
    rw [hsc₀] at hy₃
    apply Set.mem_range.mp at hx₃
    apply Set.mem_range.mp at hy₃
    let ⟨nx, hnx₀⟩ := hx₃
    let ⟨ny, hny₀⟩ := hy₃
    have hy₄: 0 < y := by
      contrapose! hy₃
      have hy₅: y.toNNReal = 0 := by exact Real.toNNReal_of_nonpos hy₃
      intro z
      rw [hy₅]
      exact ne_zero_of_lt (hfc₂ z)
    refine (Real.toNNReal_lt_toNNReal_iff hy₄).mp ?_
    rw [← hnx₀, ← hny₀]
    exact hfc₄ nx ny
  refine (lt_self_iff_false x).mp ?_
  exact lt_trans hc₃ hy₂


lemma aux_exists
  (f : ℕ → NNReal → ℝ)
  (h₂ : ∀ (n : ℕ) (x : NNReal), 0 < n ∧ 0 < x → 0 < f n x)
  (hmo₀ : ∀ (n : ℕ), 0 < n → StrictMono (f n))
  (f₀ : ℕ → NNReal → NNReal)
  (hf₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f n x = ↑(f₀ n x))
  (sn : Set ℕ)
  (hsn₀ : sn = Set.Ici 1)
  (fb fc : ↑sn → NNReal)
  (hfb₁ : ∀ (n : ↑sn), f₀ (↑n) (fb n) = 1 - 1 / ↑↑n)
  (hfc₁ : ∀ (n : ↑sn), f₀ (↑n) (fc n) = 1)
  (hfb₃ : StrictMono fb)
  (hfc₃ : StrictAnti fc)
  (sb sc : Set NNReal)
  (hsb₀ : sb = Set.range fb)
  (hsc₀ : sc = Set.range fc)
  (fr : NNReal → ℝ)
  (hfr : fr = fun x => ↑x)
  (sbr scr : Set ℝ)
  (hsbr : sbr = fr '' sb)
  (hscr : scr = fr '' sc)
  (br cr : ℝ)
  (h₈ : ∀ (n : ℕ) (x : NNReal), 0 < n → 0 < x → 1 - 1 / ↑n < f n x → f n x < f (n + 1) x)
  (hbr₁ : 0 < br)
  (hu₅ : br ≤ cr)
  (hbr₃ : ∀ x ∈ sbr, x ≤ br)
  (hcr₃ : ∀ x ∈ scr, cr ≤ x) :
  ∃ x, ∀ (n : ℕ), 0 < n → 0 < f n x ∧ f n x < f (n + 1) x ∧ f (n + 1) x < 1 := by
  obtain hu₆ | hu₆ := lt_or_eq_of_le hu₅
  · apply exists_between at hu₆
    let ⟨a, ha₀, ha₁⟩ := hu₆
    have ha₂: 0 < a := by exact gt_trans ha₀ hbr₁
    have ha₃: 0 < a.toNNReal := by exact Real.toNNReal_pos.mpr ha₂
    use a.toNNReal
    intro n hn₀
    have hn₁: n ∈ sn := by
      rw [hsn₀]
      exact hn₀
    constructor
    · exact h₂ n a.toNNReal ⟨hn₀, ha₃⟩
    constructor
    · refine h₈ n a.toNNReal hn₀ ?_ ?_
      · exact Real.toNNReal_pos.mpr ha₂
      · let nn : ↑sn := ⟨n, hn₁⟩
        have hn₂: f n (fb nn) = 1 - 1 / n := by
          rw [hf₁ n _ hn₀, hfb₁ nn]
          refine NNReal.coe_sub ?_
          refine div_le_self ?_ ?_
          · exact zero_le_one' NNReal
          · exact Nat.one_le_cast.mpr hn₀
        rw [← hn₂]
        refine hmo₀ n hn₀ ?_
        refine Real.lt_toNNReal_iff_coe_lt.mpr ?_
        refine lt_of_le_of_lt ?_ ha₀
        refine hbr₃ _ ?_
        rw [hsbr]
        refine (Set.mem_image fr sb _).mpr ?_
        use (fb nn)
        rw [hfr, hsb₀]
        refine ⟨?_, rfl⟩
        exact Set.mem_range_self nn
    · have hn₂: n + 1 ∈ sn := by
        rw [hsn₀]
        exact Set.mem_Ici.mpr (by lia)
      let nn : ↑sn := ⟨n + 1, hn₂⟩
      have hn₃: f (n + 1) (fc (nn)) = 1 := by
        rw [hf₁ (n + 1) _ (by lia), hfc₁ nn]
        exact rfl
      rw [← hn₃]
      refine hmo₀ (n + 1) (by lia) ?_
      refine (Real.toNNReal_lt_iff_lt_coe (le_of_lt ha₂)).mpr ?_
      refine lt_of_lt_of_le ha₁ ?_
      refine hcr₃ _ ?_
      rw [hscr]
      refine (Set.mem_image fr sc _).mpr ?_
      use (fc nn)
      rw [hfr, hsc₀]
      refine ⟨?_, rfl⟩
      exact Set.mem_range_self nn
  · use br.toNNReal
    intro n hn₀
    have hn₁: n ∈ sn := by
      rw [hsn₀]
      exact hn₀
    constructor
    · refine h₂ n br.toNNReal ⟨hn₀, ?_⟩
      exact Real.toNNReal_pos.mpr hbr₁
    constructor
    · refine h₈ n br.toNNReal hn₀ ?_ ?_
      · exact Real.toNNReal_pos.mpr hbr₁
      · let nn : ↑sn := ⟨n, hn₁⟩
        have hn₂: fb nn < br := by
          by_contra! hc₀
          have hbr₅: (fb nn) = br := by
            refine eq_of_le_of_ge ?_ hc₀
            refine hbr₃ _ ?_
            rw [hsbr]
            refine (Set.mem_image fr sb _).mpr ?_
            use (fb nn)
            rw [hfr, hsb₀]
            exact ⟨Set.mem_range_self nn, rfl⟩
          have hn₂: n + 1 ∈ sn := by
            rw [hsn₀]
            refine Set.mem_Ici.mpr ?_
            exact Nat.le_add_right_of_le hn₀
          let ns : ↑sn := ⟨n + 1, hn₂⟩
          have hc₁: fb nn < fb ns := by
            refine hfb₃ ?_
            refine Subtype.mk_lt_mk.mpr ?_
            exact lt_add_one n
          have hbr₆: fb ns ≤ fb nn := by
            refine NNReal.coe_le_coe.mp ?_
            rw [hbr₅]
            refine hbr₃ _ ?_
            rw [hsbr]
            refine (Set.mem_image fr sb _).mpr ?_
            use (fb ns)
            rw [hfr, hsb₀]
            refine ⟨?_, rfl⟩
            exact Set.mem_range_self ns
          refine (lt_self_iff_false (fb nn)).mp ?_
          exact lt_of_lt_of_le hc₁ hbr₆
        have hn₃: f n (fb nn) = 1 - 1 / n := by
          rw [hf₁ n _ hn₀, hfb₁ nn]
          refine NNReal.coe_sub ?_
          refine div_le_self ?_ ?_
          · exact zero_le_one' NNReal
          · exact Nat.one_le_cast.mpr hn₀
        rw [← hn₃]
        refine hmo₀ n hn₀ ?_
        exact Real.lt_toNNReal_iff_coe_lt.mpr hn₂
    · have hn₂: n + 1 ∈ sn := by
        rw [hsn₀]
        exact Set.mem_Ici.mpr (by lia)
      let nn : ↑sn := ⟨n + 1, hn₂⟩
      have hcr₁: 0 < cr := lt_of_le_of_lt' hu₅ hbr₁
      have hn₃: f (n + 1) (fc (nn)) = 1 := by
        rw [hf₁ (n + 1) _ (by lia), hfc₁ nn]
        exact rfl
      rw [← hn₃, hu₆]
      refine hmo₀ (n + 1) (by lia) ?_
      refine (Real.toNNReal_lt_iff_lt_coe (le_of_lt hcr₁)).mpr ?_
      by_contra! hc₀
      have hc₁: fc nn = cr := by
        refine eq_of_le_of_ge hc₀ ?_
        refine hcr₃ _ ?_
        rw [hscr]
        refine (Set.mem_image fr sc _).mpr ?_
        use (fc nn)
        rw [hfr, hsc₀]
        refine ⟨?_, rfl⟩
        exact Set.mem_range_self nn
      have hn₄: n + 2 ∈ sn := by
        rw [hsn₀]
        refine Set.mem_Ici.mpr ?_
        exact Nat.le_add_right_of_le hn₀
      let ns : ↑sn := ⟨n + 2, hn₄⟩
      have hn₅: fc ns < fc nn := by
        refine hfc₃ ?_
        refine Subtype.mk_lt_mk.mpr ?_
        exact Nat.lt_add_one (n + 1)
      have hc₂: fc nn ≤ fc ns := by
        refine NNReal.coe_le_coe.mp ?_
        rw [hc₁]
        refine hcr₃ _ ?_
        rw [hscr]
        refine (Set.mem_image fr sc _).mpr ?_
        use (fc ns)
        rw [hfr, hsc₀]
        refine ⟨?_, rfl⟩
        exact Set.mem_range_self ns
      refine (lt_self_iff_false (fc ns)).mp ?_
      exact lt_of_lt_of_le hn₅ hc₂


lemma aux_unique_top_ind
  (f : ℕ → NNReal → ℝ)
  (sd : Set ℕ)
  (hsd : sd = Set.Ici 2)
  (fd : NNReal → NNReal → ↑sd → ℝ)
  (hfd₁ : ∀ (y₁ y₂ : NNReal) (n : ↑sd), fd y₁ y₂ n = f (↑n) y₂ - f (↑n) y₁)
  (hd₁ : ∀ (n : ↑sd) (a b : NNReal), a < b → 0 < fd a b n)
  (a b : NNReal)
  (ha₀ : a < b)
  (hd₃ : ∀ (nd : ↑sd), nd.1 + (1 : ℕ) ∈ sd)
  (hd₂ : ∀ (nd : ↑sd), fd a b nd * (2 - 1 / ↑↑nd) ≤ fd a b ⟨nd.1 + 1, hd₃ nd⟩)
  (hi₀ : 2 ∈ sd)
  (i : ↑sd)
  (hi₁ : i = ⟨2, hi₀⟩) :
  ∀ (nd : ↑sd), fd a b i * (3 / 2) ^ (nd.1 - 2) ≤ fd a b nd := by
  intro nd
  rw [hfd₁ a b nd]
  have hnd₀: 2 ≤ nd.1 := by
    refine Set.mem_Ici.mp ?_
    rw [← hsd]
    exact nd.2
  refine Nat.le_induction ?_ ?_ nd.1 hnd₀
  · have hi₂: i.val = (2:ℕ) := by
      simp_all only [Subtype.forall]
    rw [hfd₁ a b i, hi₂]
    simp
  · simp
    intro n hn₀ hn₁
    have hn₂: n - 1 = n - 2 + 1 := by lia
    have hn₃: n ∈ sd := by
      rw [hsd]
      exact hn₀
    let nn : ↑sd := ⟨n, hn₃⟩
    have hn₄: nn.1 + 1 ∈ sd := hd₃ nn
    have hn₅: fd a b nn * (2 - 1 / ↑n) ≤ fd a b ⟨nn.1 + 1, hn₄⟩ := by exact hd₂ nn
    rw [hfd₁ a b ⟨nn.1 + 1, hn₄⟩] at hn₅
    have hn₆: f (↑nn + 1) b - f (↑nn + 1) a = f (n + 1) b - f (n + 1) a := by exact rfl
    rw [hn₆] at hn₅
    refine le_trans ?_ hn₅
    rw [hn₂, pow_succ (3/2) (n - 2), ← mul_assoc (fd a b i)]
    refine mul_le_mul ?_ ?_ (by norm_num1) ?_
    · refine le_of_le_of_eq hn₁ ?_
      rw [hfd₁]
    · refine (div_le_iff₀ (two_pos)).mpr ?_
      rw [sub_mul, one_div_mul_eq_div _ 2]
      refine le_sub_iff_add_le.mpr ?_
      refine le_sub_iff_add_le'.mp ?_
      refine (div_le_iff₀ ?_).mpr ?_
      · positivity
      · ring_nf
        exact Nat.ofNat_le_cast.mpr hn₀
    · exact le_of_lt (hd₁ nn a b ha₀)

lemma aux_unique_top
  (f : ℕ → NNReal → ℝ)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (h₇ : ∀ (n : ℕ) (x : NNReal), 0 < n → f n x < f (n + 1) x → 1 - 1 / ↑n < f n x)
  (sd : Set ℕ)
  (hsd : sd = Set.Ici 2)
  (fd : NNReal → NNReal → ↑sd → ℝ)
  (hfd₁ : ∀ (y₁ y₂ : NNReal) (n : ↑sd), fd y₁ y₂ n = f (↑n) y₂ - f (↑n) y₁)
  (hd₁ : ∀ (n : ↑sd) (a b : NNReal), a < b → 0 < fd a b n) :
  ∀ (a b : NNReal),
    a < b →
      (∀ (n : ↑sd), f (↑n) a < f (↑n + 1) a ∧ f (↑n) b < f (↑n + 1) b)
      → Filter.Tendsto (fd a b) Filter.atTop Filter.atTop := by
  intro a b ha₀ ha₁
  have hd₀: ∀ (nd:↑sd), (nd.1 + 1) ∈ sd := by
    intro nd
    let t : ℕ := nd.1
    have ht: t = nd.1 := by rfl
    rw [← ht, hsd]
    refine Set.mem_Ici.mpr ?_
    refine Nat.le_add_right_of_le ?_
    refine Set.mem_Ici.mp ?_
    rw [ht, ← hsd]
    exact nd.2
  have hd₂: ∀ nd, fd a b nd  * (2 - 1 / nd.1) ≤ fd a b ⟨nd.1 + 1, hd₀ nd⟩ := by
    intro nd
    have hnd₀: 0 < nd.1 := by
      have g₀: 2 ≤ nd.1 := by
        refine Set.mem_Ici.mp ?_
        rw [← hsd]
        exact nd.2
      exact Nat.zero_lt_of_lt g₀
    rw [hfd₁, hfd₁, h₁ nd.1 _ hnd₀, h₁ nd.1 _ hnd₀]
    have hnd₁: f (↑nd) b * (f (↑nd) b + 1 / ↑↑nd) - f (↑nd) a * (f (↑nd) a + 1 / ↑↑nd) =
      (f (↑nd) b - f (↑nd) a) * (f (↑nd) b + f (↑nd) a + 1 / nd.1) := by
      ring_nf
    rw [hnd₁]
    refine (mul_le_mul_iff_right₀ ?_).mpr ?_
    · rw [← hfd₁]
      exact hd₁ nd a b ha₀
    · refine le_sub_iff_add_le.mp ?_
      rw [sub_neg_eq_add]
      have hnd₂: 1 - 1 / nd.1 < f (↑nd) b := by
        exact h₇ nd.1 b hnd₀ (ha₁ nd).2
      have hnd₃: 1 - 1 / nd.1 < f (↑nd) a := by
        exact h₇ nd.1 a hnd₀ (ha₁ nd).1
      linarith
  have hi: 2 ∈ sd := by
    rw [hsd]
    decide
  let i : ↑sd := ⟨(2:ℕ), hi⟩
  have hd₃: ∀ nd, fd a b i * (3 / 2) ^ (nd.1 - 2) ≤ fd a b nd := by
    intro nd
    exact aux_unique_top_ind f sd hsd fd hfd₁ hd₁ a b ha₀ hd₀ hd₂ hi i rfl nd
  have hsd₁: Nonempty ↑sd := Nonempty.intro i
  refine Filter.tendsto_atTop_atTop.mpr ?_
  intro z
  by_cases hz₀: z ≤ fd a b i
  · use i
    intro j _
    refine le_trans hz₀ ?_
    refine le_trans ?_ (hd₃ j)
    refine le_mul_of_one_le_right ?_ ?_
    · refine le_of_lt ?_
      exact hd₁ i a b ha₀
    · refine one_le_pow₀ ?_
      norm_num
  · push_neg at hz₀
    have hz₁: 0 < fd a b i := by exact hd₁ i a b ha₀
    have hz₂: 0 < Real.log (z / fd a b i) := by
      refine Real.log_pos ?_
      exact (one_lt_div hz₁).mpr hz₀
    let j : ℕ := Nat.ceil (2 + Real.log (z / fd a b i) / Real.log (3 / 2))
    have hj₀: 2 < j := by
      refine Nat.lt_ceil.mpr ?_
      norm_cast
      refine lt_add_of_pos_right 2 ?_
      refine div_pos ?_ ?_
      · exact hz₂
      · positivity
    have hj₁: j ∈ sd := by
      rw [hsd]
      exact Set.mem_Ici_of_Ioi hj₀
    use ⟨j, hj₁⟩
    intro k hk₀
    have hk₁: fd a b i * (3 / 2) ^ (k.1 - 2) ≤ fd a b k := by
      exact hd₃ k
    have hk₂: i < k := lt_of_lt_of_le hj₀ hk₀
    refine le_trans ?_ hk₁
    refine (div_le_iff₀' ?_).mp ?_
    · exact hz₁
    · refine Real.le_pow_of_log_le (by norm_num1) ?_
      refine (div_le_iff₀ ?_).mp ?_
      · positivity
      · rw [Nat.cast_sub ?_]
        · rw [Nat.cast_two]
          refine le_sub_iff_add_le'.mpr ?_
          exact Nat.le_of_ceil_le hk₀
        · exact Nat.le_of_succ_le hk₂


lemma aux_unique_nhds
  (f : ℕ → NNReal → ℝ)
  (sd : Set ℕ)
  (hsd : sd = Set.Ici 2)
  (fd : NNReal → NNReal → ↑sd → ℝ)
  (hfd₁ : ∀ (y₁ y₂ : NNReal) (n : ↑sd), fd y₁ y₂ n = f (↑n) y₂ - f (↑n) y₁)
  (hd₁ : ∀ (n : ↑sd) (a b : NNReal), a < b → 0 < fd a b n) :
  ∀ (a b : NNReal),
    a < b →
      (∀ (n : ↑sd),
        (1 - 1 / ↑↑n < f (↑n) a ∧ 1 - 1 / ↑↑n < f (↑n) b) ∧ f (↑n) a < 1 ∧ f (↑n) b < 1) →
          Filter.Tendsto (fd a b) Filter.atTop (nhds 0) := by
  intro a b ha₀ ha₁
  have hsd₁: Nonempty ↑sd := by
    rw [hsd]
    exact Set.nonempty_Ici_subtype
  refine tendsto_atTop_nhds.mpr ?_
  intro U hU₀ hU₁
  have hU₂: U ∈ nhds 0 := by exact IsOpen.mem_nhds hU₁ hU₀
  apply mem_nhds_iff_exists_Ioo_subset.mp at hU₂
  obtain ⟨l, u, hl₀, hl₁⟩ := hU₂
  have hl₂: 0 < u := by exact (Set.mem_Ioo.mpr hl₀).2
  let nd := 2 + Nat.ceil (1/u)
  have hnd₀: nd ∈ sd := by
    rw [hsd]
    refine Set.mem_Ici.mpr ?_
    exact Nat.le_add_right 2 ⌈1 / u⌉₊
  use ⟨nd, hnd₀⟩
  intro n hn₀
  refine (IsOpen.mem_nhds_iff hU₁).mp ?_
  refine mem_nhds_iff.mpr ?_
  use Set.Ioo l u
  refine ⟨hl₁, isOpen_Ioo, Set.mem_Ioo.mpr ?_⟩
  constructor
  · refine lt_trans ?_ (hd₁ n a b ha₀)
    exact (Set.mem_Ioo.mp hl₀).1
  · have hn₁: fd a b n < 1 / n := by
      rw [hfd₁]
      have ha₂: 1 - 1 / n < f n a := by exact (ha₁ n).1.1
      have hb₁: f n b < 1 := by exact (ha₁ n).2.2
      refine sub_lt_iff_lt_add.mpr ?_
      refine lt_trans hb₁ ?_
      exact sub_lt_iff_lt_add'.mp ha₂
    have hn₂: (1:ℝ) / n ≤ 1 / nd := by
      refine one_div_le_one_div_of_le ?_ ?_
      · positivity
      · exact Nat.cast_le.mpr hn₀
    refine lt_of_lt_of_le hn₁ ?_
    refine le_trans hn₂ ?_
    refine div_le_of_le_mul₀ ?_ ?_ ?_
    · exact Nat.cast_nonneg' nd
    · exact le_of_lt hl₂
    · have hl₃: u * (2 + 1 / u) ≤ u * ↑((2:ℕ) + ⌈(1:ℝ) / u⌉₊) := by
        refine (mul_le_mul_iff_right₀ hl₂).mpr ?_
        rw [Nat.cast_add 2 _, Nat.cast_two]
        refine add_le_add_right ?_ 2
        exact Nat.le_ceil (1 / u)
      refine le_trans ?_ hl₃
      rw [mul_add, mul_one_div u u, div_self (ne_of_gt hl₂)]
      refine le_of_lt ?_
      refine sub_lt_iff_lt_add.mp ?_
      rw [sub_self 1]
      exact mul_pos hl₂ two_pos

lemma aux_unique
  (f : ℕ → NNReal → ℝ)
  (h₁ : ∀ (n : ℕ) (x : NNReal), 0 < n → f (n + 1) x = f n x * (f n x + 1 / ↑n))
  (hmo₀ : ∀ (n : ℕ), 0 < n → StrictMono (f n))
  (h₇ : ∀ (n : ℕ) (x : NNReal), 0 < n → f n x < f (n + 1) x → 1 - 1 / ↑n < f n x) :
  ∀ (y₁ y₂ : NNReal),
    (∀ (n : ℕ), 0 < n → 0 < f n y₁ ∧ f n y₁ < f (n + 1) y₁ ∧ f (n + 1) y₁ < 1) →
      (∀ (n : ℕ), 0 < n → 0 < f n y₂ ∧ f n y₂ < f (n + 1) y₂ ∧ f (n + 1) y₂ < 1) → y₁ = y₂ := by
  intro x y hx₀ hy₀
  let sd : Set ℕ := Set.Ici 2
  let fd : NNReal → NNReal → ↑sd → ℝ := fun y₁ y₂ n => (f n.1 y₂ - f n.1 y₁)
  have hfd₁: ∀ y₁ y₂ n, fd y₁ y₂ n = f n.1 y₂ - f n.1 y₁ := by exact fun y₁ y₂ n => rfl
  have hd₁: ∀ n a b, a < b → 0 < fd a b n := by
    intro nd a b hnd₀
    rw [hfd₁]
    refine sub_pos.mpr ?_
    refine hmo₀ nd.1 ?_ hnd₀
    exact lt_of_lt_of_le (Nat.zero_lt_two) nd.2
  have hfd₂: ∀ a b, a < b → (∀ n:↑sd, f n.1 a < f (n.1 + 1) a ∧ f n.1 b < f (n.1 + 1) b)
      → Filter.Tendsto (fd a b) Filter.atTop Filter.atTop := by
    intro a b ha₀ ha₁
    exact aux_unique_top f h₁ h₇ sd rfl fd hfd₁ hd₁ a b ha₀ ha₁
  have hfd₃: ∀ a b, a < b →
    (∀ (n:↑sd), (1 - 1 / n.1 < f n.1 a ∧ 1 - 1 / n.1 < f n.1 b) ∧ (f n.1 a < 1 ∧ f n.1 b < 1))
        → Filter.Tendsto (fd a b) Filter.atTop (nhds 0) := by
    intro a b ha₀ ha₁
    exact aux_unique_nhds f sd rfl fd hfd₁ hd₁ a b ha₀ ha₁
  by_contra! hc₀
  by_cases hy₁: x < y
  · have hy₂: Filter.Tendsto (fd x y) Filter.atTop Filter.atTop := by
      refine hfd₂ x y hy₁ ?_
      intro nd
      have hnd₀: 0 < nd.1 := by exact lt_of_lt_of_le (two_pos) nd.2
      constructor
      · exact (hx₀ nd.1 hnd₀).2.1
      · exact (hy₀ nd.1 hnd₀).2.1
    have hy₃: Filter.Tendsto (fd x y) Filter.atTop (nhds 0) := by
      refine hfd₃ x y hy₁ ?_
      intro nd
      have hnd₀: 0 < nd.1 := by
        refine lt_of_lt_of_le ?_ nd.2
        exact Nat.zero_lt_two
      have hnd₁: nd.1 - 1 + 1 = nd.1 := by exact Nat.sub_add_cancel hnd₀
      have hnd₂: 0 < nd.1 - 1 := by
        refine Nat.sub_pos_of_lt ?_
        refine lt_of_lt_of_le ?_ nd.2
        exact Nat.one_lt_two
      constructor
      · constructor
        · refine h₇ nd.1 x hnd₀ ?_
          exact (hx₀ (nd.1) hnd₀).2.1
        · refine h₇ nd.1 y hnd₀ ?_
          exact (hy₀ (nd.1) hnd₀).2.1
      · constructor
        · rw [← hnd₁]
          exact (hx₀ (nd.1 - 1) hnd₂).2.2
        · rw [← hnd₁]
          exact (hy₀ (nd.1 - 1) hnd₂).2.2
    apply Filter.tendsto_atTop_atTop.mp at hy₂
    apply tendsto_atTop_nhds.mp at hy₃
    contrapose! hy₃
    clear hy₃
    let sx : Set ℝ := Set.Ioo (-1) 1
    use sx
    constructor
    · refine Set.mem_Ioo.mpr ?_
      simp
    constructor
    · exact isOpen_Ioo
    · intro N
      have hy₅: ∃ i, ∀ (a : ↑sd), i ≤ a → N + 3 ≤ fd x y a := by exact hy₂ (N + 3)
      obtain ⟨i, hi₀⟩ := hy₅
      have hi₁: (N.1 + i.1) ∈ sd := by
        refine Set.mem_Ici.mpr ?_
        rw [← add_zero 2]
        exact Nat.add_le_add N.2 (Nat.zero_le ↑i)
      let a : ↑sd := ⟨N + i, hi₁⟩
      use a
      constructor
      · refine Subtype.mk_le_mk.mpr ?_
        exact Nat.le_add_right ↑N ↑i
      · refine Set.notMem_Ioo_of_ge ?_
        have hi₂: ↑↑N + 3 ≤ fd x y a := by
          refine hi₀ a ?_
          refine Subtype.mk_le_mk.mpr ?_
          exact Nat.le_add_left ↑i ↑N
        refine le_trans ?_ hi₂
        norm_cast
        exact Nat.le_add_left 1 (↑N + 2)
  · have hy₂: y < x := by
      push_neg at hy₁
      exact lt_of_le_of_ne hy₁ hc₀.symm
    have hy₃: Filter.Tendsto (fd y x) Filter.atTop Filter.atTop := by
      refine hfd₂ y x hy₂ ?_
      intro nd
      have hnd₀: 0 < nd.1 := by exact lt_of_lt_of_le (two_pos) nd.2
      constructor
      · exact (hy₀ nd.1 hnd₀).2.1
      · exact (hx₀ nd.1 hnd₀).2.1
    have hy₄: Filter.Tendsto (fd y x) Filter.atTop (nhds 0) := by
      refine hfd₃ y x hy₂ ?_
      intro nd
      have hnd₀: 0 < nd.1 := by exact lt_of_lt_of_le (Nat.zero_lt_two) nd.2
      have hnd₁: nd.1 - 1 + 1 = nd.1 := by exact Nat.sub_add_cancel hnd₀
      have hnd₂: 0 < nd.1 - 1 := by
        refine Nat.sub_pos_of_lt ?_
        exact lt_of_lt_of_le (Nat.one_lt_two) nd.2
      constructor
      · constructor
        · refine h₇ nd.1 y hnd₀ ?_
          exact (hy₀ (nd.1) hnd₀).2.1
        · refine h₇ nd.1 x hnd₀ ?_
          exact (hx₀ (nd.1) hnd₀).2.1
      · constructor
        · rw [← hnd₁]
          exact (hy₀ (nd.1 - 1) hnd₂).2.2
        · rw [← hnd₁]
          exact (hx₀ (nd.1 - 1) hnd₂).2.2
    apply Filter.tendsto_atTop_atTop.mp at hy₃
    apply tendsto_atTop_nhds.mp at hy₄
    contrapose! hy₄
    clear hy₄
    let sx : Set ℝ := Set.Ioo (-1) 1
    use sx
    constructor
    · refine Set.mem_Ioo.mpr ?_
      simp
    constructor
    · exact isOpen_Ioo
    · intro N
      have hy₅: ∃ i, ∀ (a : ↑sd), i ≤ a → N + 3 ≤ fd y x a := by exact hy₃ (N + 3)
      obtain ⟨i, hi₀⟩ := hy₅
      have hi₁: (N.1 + i.1) ∈ sd := by
        refine Set.mem_Ici.mpr ?_
        rw [← add_zero 2]
        exact Nat.add_le_add N.2 (Nat.zero_le ↑i)
      let a : ↑sd := ⟨N + i, hi₁⟩
      use a
      constructor
      · refine Subtype.mk_le_mk.mpr ?_
        exact Nat.le_add_right ↑N ↑i
      · refine Set.notMem_Ioo_of_ge ?_
        have hi₂: ↑↑N + 3 ≤ fd y x a := by
          refine hi₀ a ?_
          refine Subtype.mk_le_mk.mpr ?_
          exact Nat.le_add_left ↑i ↑N
        refine le_trans ?_ hi₂
        norm_cast
        exact Nat.le_add_left 1 (↑N + 2)


lemma imo_1985_p6_nnreal
  (f : ℕ → NNReal → ℝ)
  (h₀ : ∀ x, f 1 x = x)
  (h₁ : ∀ n x, 0 < n → f (n + 1) x = f n x * (f n x + 1 / n)) :
  ∃! a, ∀ n, 0 < n → 0 < f n a ∧ f n a < f (n + 1) a ∧ f (n + 1) a < 1 := by
  have h₂: ∀ n x, 0 < n ∧ 0 < x → 0 < f n x := by
    exact fun n x a => aux_1 f h₀ h₁ n x a
  have h₃: ∀ n x, 0 < n → 0 ≤ f n x := by
    intro n x hn
    refine Nat.le_induction ?_ ?_ n hn
    · rw [h₀ x]
      exact NNReal.zero_le_coe
    · intro d hd₀ hd₁
      rw [h₁ d x hd₀]
      positivity
  have hmo₀: ∀ n, 0 < n → StrictMono (f n) := by
    intro n hn₀
    refine Monotone.strictMono_of_injective ?h₁ ?h₂
    · refine monotone_iff_forall_lt.mpr ?h₁.a
      intro a b hab
      refine le_of_lt ?_
      exact aux_2 f h₀ h₁ h₃ n a b hn₀ hab
    · intro p q hpq
      contrapose! hpq
      apply lt_or_gt_of_ne at hpq
      obtain hpq | hpq := hpq
      · refine ne_of_lt ?_
        exact aux_2 f h₀ h₁ h₃ n p q hn₀ hpq
      · symm
        refine ne_of_lt ?_
        exact aux_2 f h₀ h₁ h₃ n q p hn₀ hpq
  have hmo₁: ∀ n, 0 < n → Function.Injective (f n) := fun n a => StrictMono.injective (hmo₀ n a)
  let f₀: ℕ → NNReal → NNReal := fun n x => (f n x).toNNReal
  have hf₀: f₀ = fun n x => (f n x).toNNReal := by rfl
  have hf₁: ∀ n x, 0 < n → f n x = f₀ n x := by
    intro n x hn₀
    rw [hf₀]
    simp
    exact h₃ n x hn₀
  have hf₂: ∀ n x, 0 < n → f₀ n x = (f n x).toNNReal := by
    intro n x _
    rw [hf₀]
  have hmo₂: ∀ n, 0 < n → StrictMono (f₀ n) := by
    intro n hn₀
    refine aux_4 f h₃ ?_ f₀ hf₀ n hn₀
    exact fun n x y a a_1 => hmo₀ n a a_1
  let fi : ℕ → NNReal → NNReal := fun n => Function.invFun (f₀ n)
  have hmo₇: ∀ n, 0 < n → Function.RightInverse (fi n) (f₀ n) := by
    intro n hn₀
    refine Function.rightInverse_invFun ?_
    have h₄: ∀ n x y, 0 < n → x < y → f n x < f n y := by
      exact fun n x y a a_1 => aux_2 f h₀ h₁ h₃ n x y a a_1
    refine aux_7 f h₀ h₁ h₃ ?_ f₀ hf₂ hmo₂ ?_ n hn₀
    · exact fun n x a => aux_3 f h₀ h₁ h₄ n x a
    · intro m hm₀
      exact aux_6 f h₀ h₁ f₀ hf₀ m hm₀
  have hf₇: ∀ n x y, 0 < n → (f₀ n x = y ↔ fi n y = x) := by
    intro n x y hn₀
    constructor
    · intro hn₁
      rw [← hn₁, hf₀]
      exact aux_5 f hmo₁ f₀ hmo₂ fi rfl n x ((fun n x => (f n x).toNNReal) n x) hn₀ (hf₂ n x hn₀)
    · intro hn₁
      rw [← hn₁]
      exact hmo₁ n hn₀ (congrArg (f n) (hmo₇ n hn₀ y))
  let sn : Set ℕ := Set.Ici 1
  let fb : ↑sn → NNReal := sn.restrict (fun (n:ℕ) => fi n (1 - 1 / (n:NNReal)))
  let fc : ↑sn → NNReal := sn.restrict (fun (n:ℕ) => fi n 1)
  have hsn₁: ∀ n:↑sn, ↑n ∈ sn ∧ 0 < (↑n:ℕ) := by
    intro n
    have hn₀: ↑n ∈ sn := by exact Subtype.coe_prop n
    constructor
    · exact Subtype.coe_prop n
    · exact hn₀
  have hfb₀: fb = fun (n:↑sn) => fi n (1 - 1 / (n:NNReal)) := by rfl
  have hfc₀: fc = fun (n:↑sn) => fi n 1 := by rfl
  have hfb₁: ∀ n:↑sn, f₀ n (fb n) = 1 - 1 / (n:NNReal) := by
    intro n
    have hn₀: 0 < (n:ℕ) := by exact (hsn₁ n).2
    rw [hfb₀]
    exact hmo₁ n hn₀ (congrArg (f n) (hmo₇ n hn₀ (1 - 1 / (n:NNReal))))
  have hfc₁: ∀ n:↑sn, f₀ n (fc n) = 1 := by
    intro n
    have hn₀: 0 < (n:ℕ) := by exact (hsn₁ n).2
    rw [hfc₀]
    exact hmo₁ n hn₀ (congrArg (f n) (hmo₇ n hn₀ 1))
  have hu₁: ∀ n:↑sn, fb n < 1 := by
    exact aux_8 f h₀ h₁ hmo₀ hmo₁ f₀ hf₂ sn fb hsn₁ hfb₁
  have hfc₂: ∀ n:↑sn, fb n < fc n := by
    intro n
    have hn₀: 0 < (n:ℕ) := by exact (hsn₁ n).2
    have g₀: f₀ n (fb n) < f₀ n (fc n) := by
      rw [hfb₁ n, hfc₁ n]
      simp
      exact (hsn₁ n).2
    exact (StrictMono.lt_iff_lt (hmo₂ n hn₀)).mp g₀
  have hfb₃: StrictMono fb := by
    refine StrictMonoOn.restrict ?_
    refine aux_9 f h₀ h₁ f₀ hf₁ hf₂ hmo₂ fi ?_ hmo₇ hf₇ _ (by rfl) sn (by rfl)
    intro x
    refine (hf₇ 1 x x (by lia)).mp ?_
    rw [hf₂ 1 x (by lia), h₀]
    exact Real.toNNReal_coe
  have hfc₃: StrictAnti fc := by
    have g₀: StrictAntiOn (fun n => fi n 1) sn := by
      refine strictAntiOn_Ici_of_lt_pred ?_
      intro m hm₀
      have hm₁: 0 < m - 1 := by exact Nat.zero_lt_sub_of_lt hm₀
      have hm₂: m = m - 1 + 1 := by rw [Nat.sub_add_cancel (le_of_lt hm₀)]
      have hm₃: 0 < m := by exact Nat.zero_lt_of_lt hm₀
      simp
      let x := fi m 1
      let y := fi (m - 1) 1
      have hx₀: x = fi m 1 := by rfl
      have hy₀: y = fi (m - 1) 1 := by rfl
      have hx₁: f₀ m x = 1 := by exact (hf₇ m x 1 (by lia)).mpr hx₀.symm
      have hy₁: f₀ (m - 1) y = 1 := by
        exact (hf₇ (m - 1) y 1 hm₁).mpr hy₀.symm
      have hy₂: f (m - 1) y = 1 := by
        rw [hf₁ (m - 1) y hm₁, hy₁]
        exact rfl
      have hf: StrictMono (f m) := by exact hmo₀ m hm₃
      refine (StrictMono.lt_iff_lt hf).mp ?_
      rw [← hx₀, ← hy₀]
      rw [hf₁ m x hm₃, hf₁ m y hm₃]
      refine NNReal.coe_lt_coe.mpr ?_
      rw [hx₁, hf₂ m y hm₃, hm₂, h₁ (m - 1) y hm₁, hy₂]
      simp
      exact hm₀
    intro m n hmn
    rw [hfc₀]
    simp
    let mn : ℕ := ↑m
    let nn : ℕ := ↑n
    have hm₀: mn ∈ sn := by exact Subtype.coe_prop m
    have hn₀: nn ∈ sn := by exact Subtype.coe_prop n
    exact g₀ hm₀ hn₀ hmn
  let sb := Set.range fb
  let sc := Set.range fc
  have hsb₀: sb = Set.range fb := by rfl
  have hsc₀: sc = Set.range fc := by rfl
  let fr : NNReal → ℝ := fun x => x.toReal
  let sbr := Set.image fr sb
  let scr := Set.image fr sc
  have hu₃: ∃ br, IsLUB sbr br := by
    refine Real.exists_isLUB ?_ ?_
    · exact Set.Nonempty.of_subtype
    · refine NNReal.bddAbove_coe.mpr ?_
      refine (bddAbove_iff_exists_ge 1).mpr ?_
      use 1
      constructor
      · exact Preorder.le_refl 1
      · intro y hy₀
        apply Set.mem_range.mp at hy₀
        obtain ⟨na, hna₀⟩ := hy₀
        refine le_of_lt ?_
        rw [← hna₀]
        exact hu₁ na
  have hu₄: ∃ cr, IsGLB scr cr := by
    refine Real.exists_isGLB ?_ ?_
    · exact Set.Nonempty.of_subtype
    · exact NNReal.bddBelow_coe sc
  obtain ⟨br, hbr₀⟩ := hu₃
  obtain ⟨cr, hcr₀⟩ := hu₄
  have h₇: ∀ n x, 0 < n → (f n x < f (n + 1) x → 1 - 1 / n < f n x) := by
    intro n x hn₀ hn₁
    rw [h₁ n x hn₀] at hn₁
    nth_rw 1 [← mul_one (f n x)] at hn₁
    suffices g₀: 1 < f n x + 1 / ↑n
    · exact sub_right_lt_of_lt_add g₀
    · refine lt_of_mul_lt_mul_left hn₁ ?_
      exact h₃ n x hn₀
  have h₈: ∀ n x, 0 < n → 0 < x → 1 - 1 / n < f n x → f n x < f (n + 1) x := by
    intro n x hn₀ hx₀ hn₁
    rw [h₁ n x hn₀]
    suffices g₀: 1 < f n x + 1 / ↑n
    · nth_rw 1 [← mul_one (f n x)]
      refine mul_lt_mul' ?_ g₀ ?_ ?_
      · exact Preorder.le_refl (f n x)
      · exact zero_le_one' ℝ
      · exact lt_of_lt_of_le' (hmo₀ n hn₀ hx₀) (h₃ n 0 hn₀)
    · exact lt_add_of_tsub_lt_right hn₁
  have hbr₁: 0 < br := by
    exact aux_10 f h₀ h₁ f₀ hf₂ fi hmo₇ sn sb fb (by rfl) hfb₀ hsb₀ fr (by rfl) sbr (by rfl) br hbr₀
  have hu₅: br ≤ cr := by
    exact aux_11 sn fb fc hfc₂ hfb₃ hfc₃ sb sc hsb₀ hsc₀ fr
            (by rfl) sbr scr (by rfl) (by rfl) br cr hbr₀ hcr₀
  have hbr₃: ∀ x ∈ sbr, x ≤ br := by
    refine mem_upperBounds.mp ?_
    refine (isLUB_le_iff hbr₀).mp ?_
    exact Preorder.le_refl br
  have hcr₃: ∀ x ∈ scr, cr ≤ x := by
      refine mem_lowerBounds.mp ?_
      refine (le_isGLB_iff hcr₀).mp ?_
      exact Preorder.le_refl cr
  refine existsUnique_of_exists_of_unique ?_ ?_
  · exact aux_exists f h₂ hmo₀ f₀ hf₁ sn (by rfl)
           fb fc hfb₁ hfc₁ hfb₃ hfc₃ sb sc hsb₀ hsc₀
           fr (by rfl) sbr scr (by rfl) (by rfl) br cr h₈ hbr₁ hu₅ hbr₃ hcr₃
  · intro x y hx₀ hy₀
    exact aux_unique f h₁ hmo₀ h₇ x y hx₀ hy₀



theorem imo_1985_p6
  (f : ℕ → ℝ → ℝ)
  (h₀ : ∀ x, f 1 x = x)
  (h₁ : ∀ n x, 0 < n → f (n + 1) x = f n x * (f n x + 1 / n)) :
  ∃! a, ∀ n, 0 < n → 0 < f n a ∧ f n a < f (n + 1) a ∧ f (n + 1) a < 1 := by
  let fn : ℕ → NNReal → ℝ := fun n x => f n x
  have hfn₁: ∀ n x, 0 < n → 0 ≤ x → fn n x = f n x := by
    exact fun n x a a ↦ rfl
  have h₂: ∃! a, ∀ (n : ℕ), 0 < n → 0 < fn n a ∧ fn n a < fn (n + 1) a ∧ fn (n + 1) a < 1 := by
    exact imo_1985_p6_nnreal fn (fun x ↦ h₀ ↑x) fun n x ↦ h₁ n ↑x
  obtain ⟨a, ha₀, ha₁⟩ := h₂
  refine ⟨a, ha₀, fun y hy₀ ↦ ?_⟩
  have hy₁: 0 ≤ y.toNNReal := by exact zero_le y.toNNReal
  by_cases hy₂: 0 ≤ y
  · refine (Real.toNNReal_eq_toNNReal_iff hy₂ ?_).mp ?_
    · exact NNReal.zero_le_coe
    · rw [Real.toNNReal_coe]
      refine ha₁ y.toNNReal ?_
      intro n hn₀
      rw [hfn₁ n _ hn₀ hy₁, hfn₁ (n + 1) _ (by lia) hy₁]
      rw [Real.coe_toNNReal y hy₂]
      exact hy₀ n hn₀
  · exfalso
    push_neg at hy₂
    have hy₃: f 1 y < 0 := by
      rw [h₀]
      exact hy₂
    have hy₄: 0 < f 1 y := by
      exact (hy₀ 1 (by decide)).1
    order

end Imo1985P6

-- ═══ Imo1986P1 ═══

/-
Copyright (c) 2023 Moritz Firsching. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Firsching
-/




/-!
# International Mathematical Olympiad 1986, Problem 1

Let d be any positive integer not equal to 2, 5 or 13.
Show that one can find distinct a, b in the set {2, 5, 13, d} such that ab - 1
is not a perfect square.
-/

namespace Imo1986P1



/-
We prove a slightly stronger statement, namely:
Let d be any integer, then 2 * d - 1, 5 * d - 1 and 13 * d - 1 can't all be perfect squares.
We follow "Solution 2" on https://artofproblemsolving.com/wiki/index.php/1986_IMO_Problems/Problem_1
by showing a contradiction: we show d is odd and d is even.
First we assume that there are p, q and r such that:
2 * d - 1 = p^2
5 * d - 1 = q^2 and
13 * d - 1 = r^2

The fact that d is odd follows from the fact that p is odd.
The fact that d is even follows from examining the difference 13 * d - 5 * d.
-/

theorem imo1986_p1' (d : ℤ):
    ¬ ((IsSquare (2 * d - 1)) ∧ (IsSquare (5 * d - 1)) ∧ (IsSquare (d * 13 - 1))) := by
  rintro ⟨⟨p, hp⟩, ⟨q, hq⟩, ⟨r, hr⟩⟩
  rw [← pow_two] at hp hq hr
  have hpodd : Odd p := (Int.odd_pow' two_ne_zero).mp (by use d - 1; rw [← hp]; ring)
  obtain ⟨k, hk⟩ := hpodd
  have hp := hp.symm
  have hdp : d  = 2*(k + k^2) + 1 := by
    rw [hk, ←(add_left_inj 1), sub_add_cancel _] at hp
    ring_nf at hp
    have h422 : (4 : ℤ) = 2 * 2 := by norm_num
    simp only [h422,  ← mul_assoc] at hp
    nth_rw 1 [← one_mul 2] at hp
    rw [← add_mul, ← add_mul, mul_left_inj' two_ne_zero] at hp
    rw [← hp]
    ring
  have hdodd : Odd d := by use k + k ^ 2
  have hd_sub_one : Even (d - 1) := by use (k + k ^ 2); rw [hdp]; ring
  have hqeven : Even q := by
    refine (Int.even_pow' two_ne_zero).mp ?_
    have heq : 5 * d - 1 = 5 * (d - 1) + 4 := by ring_nf
    rw [← hq, heq]
    exact Even.add (Even.mul_left hd_sub_one 5) (by use 2; rfl)
  have hreven : Even (r : ℤ) := by
    refine (Int.even_pow' two_ne_zero).mp ?_
    have heq : d * 13 - 1 = 13*(d - 1) + 12 := by
      rw [mul_comm]
      ring_nf
    rw [← hr, heq]
    exact Even.add (Even.mul_left hd_sub_one 13) (by use 6; rfl)
  obtain ⟨n, hqeven'⟩ := hqeven
  obtain ⟨m, hreven'⟩ := hreven
  have h8d : d * 8 = 4*m^2 - 4*n^2 := by
    calc d * 8 = (d * 13 - 1) - (5 * d - 1) := by ring
          _ = r^2 - q^2 := by rw [hr, hq]
          _ = (m + m)^2 - (n + n)^2 := by rw [hqeven', hreven']
          _ = 4*m^2 - 4*n^2 := by ring
  have h4d : 4 * (2 * d) = 4 * (m^2 - n^2) := by ring_nf; rw [h8d]; ring_nf
  have hnm' : 2*d = (m + n)*(m - n):= by
    rw [← pow_two_sub_pow_two]
    refine (mul_right_inj' ?_).mp h4d
    decide
  have h2d : Even ((m + n) * (m - n)) := by use d; rw [← two_mul, hnm']
  have hnm_parity : (Even m ↔ Even n) := by grind
  have hnm_sub : Even (m - n) := Int.even_sub.mpr hnm_parity
  have hnm_add : Even (m + n) := Int.even_add.mpr hnm_parity

  have hdeven : Even d := by
    obtain ⟨v, hnm_sub⟩ := hnm_sub
    obtain ⟨w, hnm_add⟩ := hnm_add
    simp only [hnm_sub, hnm_add, ← two_mul] at hnm'
    rw [mul_assoc,  mul_right_inj' two_ne_zero, ← mul_assoc, mul_comm w, mul_assoc, two_mul] at hnm'
    exact ⟨w * v, hnm'⟩
  exact Int.not_odd_iff_even.mpr hdeven hdodd



theorem imo1986_p1 (d : ℤ) (_hdpos : 1 ≤ d) (h2 : d ≠ 2) (h5 : d ≠ 5) (h13 : d ≠ 13) :
    ∃ a b :({2, 5, 13, d} : Finset ℤ), (a ≠ b) ∧ ¬ ∃ z, z^2 = (a * (b : ℤ) - 1) := by
  by_contra h
  simp only [ne_eq, Subtype.exists, Finset.mem_singleton, Finset.mem_insert,
  exists_and_right, Subtype.mk.injEq, exists_prop, exists_eq_or_imp, exists_eq_left, not_or,
  not_exists, not_and, not_forall, not_not, and_imp, forall_eq_or_imp, IsEmpty.forall_iff,
  forall_eq, true_and, not_true, and_true] at h
  have ⟨p, hp⟩ := h.1.2.2 h2.symm
  have ⟨q, hq⟩ := h.2.1.2.2 h5.symm
  have ⟨r, hr⟩ := h.2.2.2.2.2 h13
  have : IsSquare (2 * d - 1) ∧ IsSquare (5 * d - 1) ∧ IsSquare (d * 13 - 1) := by
    refine ⟨?_, ?_, ?_⟩
    · use p; rw [← pow_two]; exact hp.symm
    · use q; rw [← pow_two]; exact hq.symm
    · use r; rw [← pow_two]; exact hr.symm
  exact imo1986_p1' d this


end Imo1986P1

-- ═══ Imo1986P5 ═══

/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/




/-!
# International Mathematical Olympiad 1986, Problem 5

Find all functions `f`, defined on the non-negative real numbers and taking nonnegative real values,
such that:

- $f(xf(y))f(y) = f(x + y)$ for all $x, y \ge 0$,
- $f(2) = 0$,
- $f(x) \ne 0$ for $0 \le x < 2$.
-/

open scoped NNReal

namespace Imo1986P5

structure IsGood (f : ℝ≥0 → ℝ≥0) : Prop where
  map_add_rev x y : f (x * f y) * f y = f (x + y)
  map_two : f 2 = 0
  map_ne_zero : ∀ x < 2, f x ≠ 0


namespace IsGood

/-
Note that this formalization relies on the fact that Mathlib uses 0 as the "garbage value",
namely for `2 ≤ x` we have `2 - x = 0` and `2 / (2 - x) = 0`.

Formalization is based on
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1986_IMO_Problems/Problem_5)
with minor modifications.
-/

variable {f : ℝ≥0 → ℝ≥0} (hf : IsGood f) {x y : ℝ≥0}
include hf

theorem map_add (x y : ℝ≥0) : f (x + y) = f (x * f y) * f y :=
  (hf.map_add_rev x y).symm

theorem map_eq_zero : f x = 0 ↔ 2 ≤ x := by
  refine ⟨fun hx₀ ↦ not_lt.1 fun hlt ↦ hf.map_ne_zero x hlt hx₀, fun hle ↦ ?_⟩
  rcases exists_add_of_le hle with ⟨x, rfl⟩
  rw [add_comm, hf.map_add, hf.map_two, mul_zero]

theorem map_ne_zero_iff : f x ≠ 0 ↔ x < 2 := by simp [hf.map_eq_zero]

theorem map_of_lt_two (hx : x < 2) : f x = 2 / (2 - x) := by
  have hx' : 0 < 2 - x := tsub_pos_of_lt hx
  have hfx : f x ≠ 0 := hf.map_ne_zero_iff.2 hx
  apply le_antisymm
  · rw [le_div_iff₀ hx', ← le_div_iff₀' hfx.bot_lt,
        tsub_le_iff_right, ← hf.map_eq_zero,
        hf.map_add, div_mul_cancel₀ _ hfx, hf.map_two, zero_mul]
  · rw [div_le_iff₀' hx', ← hf.map_eq_zero]
    refine (mul_eq_zero.1 ?_).resolve_right hfx
    rw [hf.map_add_rev, hf.map_eq_zero, tsub_add_cancel_of_le hx.le]

theorem map_eq (x : ℝ≥0) : f x = 2 / (2 - x) :=
  match lt_or_ge x 2 with
  | .inl hx => hf.map_of_lt_two hx
  | .inr hx => by rwa [tsub_eq_zero_of_le hx, div_zero, hf.map_eq_zero]

end IsGood


noncomputable def SolutionSet : Set (ℝ≥0 → ℝ≥0) := { fun x ↦ 2 / (2 - x) }

theorem imo1986_p5 {f : ℝ≥0 → ℝ≥0} : IsGood f ↔ f ∈ SolutionSet := by
  refine ⟨fun hf ↦ funext hf.map_eq, ?_⟩
  rintro rfl
  constructor
  case map_two => simp [tsub_self]
  case map_ne_zero => intro x hx; simpa [tsub_eq_zero_iff_le]
  case map_add_rev =>
    intro x y
    cases lt_or_ge y 2 with
    | inl hy =>
      have hy' : 2 - y ≠ 0 := (tsub_pos_of_lt hy).ne'
      rw [div_mul_div_comm, tsub_mul, mul_assoc, div_mul_cancel₀ _ hy', mul_comm x,
        ← mul_tsub, tsub_add_eq_tsub_tsub_swap, mul_div_mul_left _ _ two_ne_zero]
    | inr hy =>
      have : 2 ≤ x + y := le_add_left hy
      simp [tsub_eq_zero_of_le, *]


end Imo1986P5

-- ═══ Imo1987P1 ═══

/-
Copyright (c) 2021 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/




/-!
# International Mathematical Olympiad 1987, Problem 1

Let $p_{n, k}$ be the number of permutations of a set of cardinality `n ≥ 1`
that fix exactly `k` elements. Prove that $∑_{k=0}^n k p_{n,k}=n!$.
-/

namespace Imo1987P1

/-- Given `α : Type*` and `k : ℕ`, `fiber α k` is the set of permutations of
    `α` with exactly `k` fixed points. -/
def fiber (α : Type*) [Fintype α] [DecidableEq α] (k : ℕ) : Set (Equiv.Perm α) :=
  {σ : Equiv.Perm α | Fintype.card (Function.fixedPoints σ) = k}

instance {k : ℕ} (α : Type*) [Fintype α] [DecidableEq α] :
  Fintype (fiber α k) := by unfold fiber; infer_instance

/-- `p α k` is the number of permutations of `α` with exactly `k` fixed points. -/
def p (α : Type*) [Fintype α] [DecidableEq α] (k : ℕ) : ℕ := Fintype.card (fiber α k)

open scoped Nat


section generalization

/-
To prove this identity, we show that both sides are equal to the cardinality of the set
`{(x : α, σ : Perm α) | σ x = x}`, regrouping by `card (fixedPoints σ)` for the left hand side and
by `x` for the right hand side.
-/

/-
The original problem assumes `n ≥ 1`. It turns out that a version with `n * (n - 1)!` in the RHS
holds true for `n = 0` as well, so we first prove it, then deduce the original version in the case
`n ≥ 1`. -/

variable (α : Type*) [Fintype α] [DecidableEq α]

open Equiv Fintype Function

open Finset (sum_const)

open Set (Iic)

/-- The set of pairs `(x : α, σ : Perm α)` such that `σ x = x` is equivalent to the set of pairs
`(x : α, σ : Perm {x}ᶜ)`. -/
def fixedPointsEquiv : { σx : α × Perm α // σx.2 σx.1 = σx.1 } ≃ Σ x : α, Perm ({x}ᶜ : Set α) :=
  calc
    { σx : α × Perm α // σx.2 σx.1 = σx.1 } ≃ Σ x : α, { σ : Perm α // σ x = x } :=
      setProdEquivSigma _
    _ ≃ Σ x : α, { σ : Perm α // ∀ y : ({x} : Set α), σ y = Equiv.refl (↥({x} : Set α)) y } :=
      (sigmaCongrRight fun x => Equiv.setCongr <| by simp only [SetCoe.forall]; dsimp; simp)
    _ ≃ Σ x : α, Perm ({x}ᶜ : Set α) := sigmaCongrRight fun x => by apply Equiv.Set.compl

theorem card_fixed_points :
    card { σx : α × Perm α // σx.2 σx.1 = σx.1 } = card α * (card α - 1)! := by
  simp only [card_congr (fixedPointsEquiv α), card_sigma, card_perm]
  have (x : _) : ({x}ᶜ : Set α) = Finset.filter (· ≠ x) Finset.univ := by
    ext; simp
  simp [this]

@[simp]
theorem mem_fiber {σ : Perm α} {k : ℕ} : σ ∈ fiber α k ↔ card (fixedPoints σ) = k :=
  Iff.rfl

/-- The set of triples `(k ≤ card α, σ ∈ fiber α k, x ∈ fixedPoints σ)` is equivalent
to the set of pairs `(x : α, σ : Perm α)` such that `σ x = x`. The equivalence sends
`(k, σ, x)` to `(x, σ)` and `(x, σ)` to `(card (fixedPoints σ), σ, x)`.

It is easy to see that the cardinality of the LHS is given by
`∑ k : Fin (card α + 1), k * p α k`. -/
def fixedPointsEquiv' :
    (Σ (k : Fin (card α + 1)) (σ : fiber α k), fixedPoints σ.1) ≃
      { σx : α × Perm α // σx.2 σx.1 = σx.1 } where
  toFun p := ⟨⟨p.2.2, p.2.1⟩, p.2.2.2⟩
  invFun p :=
    ⟨⟨card (fixedPoints p.1.2), (card_subtype_le _).trans_lt (Nat.lt_succ_self _)⟩, ⟨p.1.2, rfl⟩,
      ⟨p.1.1, p.2⟩⟩
  left_inv := fun ⟨⟨k, hk⟩, ⟨σ, hσ⟩, ⟨x, hx⟩⟩ => by
    simp only [mem_fiber] at hσ
    subst k; rfl
  right_inv := fun ⟨⟨x, σ⟩, h⟩ => rfl

/-- Main statement for any `(α : Type*) [Fintype α]`. -/
theorem main_fintype :
    ∑ k ∈ Finset.range (card α + 1), k * p α k = card α * (card α - 1)! := by
  have A : ∀ (k) (σ : fiber α k), card (fixedPoints (↑σ : Perm α)) = k := fun k σ => σ.2
  simpa [A, ← Fin.sum_univ_eq_sum_range, -card_ofFinset, Finset.card_univ, card_fixed_points,
    mul_comm] using card_congr (fixedPointsEquiv' α)

/-- Main statement for permutations of `Fin n`, a version that works for `n = 0`. -/
theorem main₀ (n : ℕ) : ∑ k ∈ Finset.range (n + 1), k * p (Fin n) k = n * (n - 1)! := by
  simpa using main_fintype (Fin n)

end generalization


theorem imo1987_p1 {n : ℕ} (hn : 1 ≤ n) :
    ∑ k ∈ Finset.range (n + 1), k * p (Fin n) k = n ! := by
  rw [main₀, Nat.mul_factorial_pred (Nat.one_le_iff_ne_zero.mp hn)]

end Imo1987P1

-- ═══ Imo1987P4 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1987, Problem 4

Prove that there is no function f : ℕ → ℕ such that f(f(n)) = n + 1987
for every n.
-/

namespace Imo1987P4

theorem imo1987_p4 : ¬∃ f : ℕ → ℕ, ∀ n, f (f n) = n + 1987 := by
  -- Informal solution by Sawa Pavlov, listed at
  -- https://artofproblemsolving.com/wiki/index.php/1987_IMO_Problems/Problem_4

  -- We will prove a more general statement.
  suffices generalized : ∀ m : ℕ, ¬∃ f : ℕ → ℕ, ∀ n, f (f n) = n + (2 * m + 1) from
    generalized 993

  rintro m ⟨f, hf⟩

  -- Note that f is injective, because if f(x) = f(y),
  -- then f(f(x)) = f(f(y)), so x = y.
  have f_injective : f.Injective := by
    intro x y hxy
    have hfx := hf x
    rw [hxy, hf y] at hfx
    exact Nat.add_right_cancel hfx.symm

  -- Let A := ℕ - f(ℕ) and B := f(A).
  let A : Set ℕ := Set.univ \ (f '' Set.univ)
  let B : Set ℕ := f '' A

  -- A and B have union ℕ - f(f(ℕ)).
  have ab_union : A ∪ B = Set.univ \ (f '' (f '' Set.univ)) := by
    -- Note that B = f(ℕ) - f(f(ℕ)).
    simp only [A, B, Set.image_diff f_injective]
    exact Set.diff_union_diff_cancel
      (Set.subset_univ _) (Set.image_mono (Set.subset_univ _))

  -- ... which is {0, 1, ... , 2 * m}.
  have ab_range : A ∪ B = {n | n < 2 * m + 1} := by
    rw [ab_union]
    ext x
    rw [Set.mem_setOf_eq, ←not_iff_not, ←Set.compl_eq_univ_diff]
    rw [Set.notMem_compl_iff, not_lt]
    simp only [Set.mem_image, Set.mem_univ, true_and, exists_exists_eq_and, hf]
    rw [le_iff_exists_add']
    simp_rw [eq_comm]

  -- A and B are disjoint.
  have ab_disjoint : Disjoint A B := by
    intro C hca hcb c hc
    exact Set.notMem_of_mem_diff (hca hc) (Set.image_mono sdiff_le (hcb hc))

  -- But since f is injective, A and B have the
  -- same number of elements, which is impossible since {0, 1, ... , 2 * m}
  -- has an odd number of elements.

  have ab_card : Set.ncard (A ∪ B) = 2 * m + 1 := by
    rw [ab_range, Set.Iio_def, ←Finset.coe_range, Set.ncard_coe_finset]
    exact Finset.card_range (2 * m + 1)

  have ab_finite : (A ∪ B).Finite := by
    rw [ab_range]; exact Set.finite_lt_nat _
  obtain ⟨a_finite, b_finite⟩ := Set.finite_union.mp ab_finite

  rw [Set.ncard_union_eq ab_disjoint a_finite b_finite] at ab_card
  rw [Set.ncard_image_of_injective _ f_injective] at ab_card
  lia


end Imo1987P4

-- ═══ Imo1987P6 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jia-Jun Ma
-/




/-!
# International Mathematical Olympiad 1987, Problem 6

Let $n$ be an integer greater than or equal to 2. Prove that
if $k^2 + k + n$ is prime for all integers $k$ such that
$0 <= k <= \sqrt{n/3}$, then $k^2 + k + n$ is prime for all
integers $k$ such that $0 <= k <= n - 2$.
-/

namespace Imo1987P6
open Nat



lemma minFac_le_sq {n : ℕ} (hnezero : n ≠ 0) (hn : minFac n ≠ n) : (minFac n)^2 ≤ n := by
  match n with
  | 0 => contradiction
  | 1 => simp
  | n+2 =>
    obtain ⟨r,hr⟩ := Nat.minFac_dvd (n+2)
    match r with
    | 0 => lia
    | 1 => nth_rw 2 [hr] at hn; simp at hn
    | r+2 =>
      have hh : (r+2) ∣ (n+2) := ⟨minFac (n+2), (by nth_rw 1 [hr,mul_comm])⟩
      have hr' : minFac (n+2) ≤ (r+2) := Nat.minFac_le_of_dvd (by lia) hh
      calc
      _ =  (minFac (n+2)) * minFac (n+2) := by ring_nf
      _ ≤ minFac (n+2) * (r+2) := Nat.mul_le_mul_left _ hr'
      _ = _ := hr.symm

lemma prime_of_coprime' (n : ℕ) (h1 : 1 < n)
    (h2 : ∀ m:ℕ, m^2  ≤  n → m ≠ 0 → n.Coprime m) : Nat.Prime n := by
  rw [Nat.prime_def_minFac]
  by_contra H; push_neg at H
  replace H := H (by lia)
  let m := minFac n
  have nneone : n ≠ 1 := by lia
  have mpos := Nat.minFac_pos n
  replace h2 := h2 (m) (minFac_le_sq (by lia) H) (by lia)
  apply Nat.Prime.not_coprime_iff_dvd.2 ?_ h2
  use (minFac n)
  simp [Nat.minFac_prime nneone,Nat.minFac_dvd,m]

lemma dyadic {k b : ℕ} (h1 : 1 ≤ k) (h2 : k ≤ b) : ∃ i, b < 2^i * k ∧ 2^i *k ≤ 2* b := by
  have hbk :  b/k ≠ 0 := by
    apply (Nat.div_ne_zero_iff (a:=b) (b:=k)).2
    lia
  use Nat.log2 (b/k) + 1
  constructor
  · have h2bk: (b/k).log2 < (b/k).log2 + 1 := Nat.lt_succ_self _
    replace h2bk := (Nat.log2_lt hbk).1 h2bk
    replace h2bk := succ_le_of_lt h2bk
    calc
    _ < b/k * k + k := lt_div_mul_add (by lia)
    _ = (b/k+1) *k := by ring
    _ ≤  2 ^((b/k).log2 +1) * k := Nat.mul_le_mul_right k h2bk
  · have h2 : 2 ^((b/k).log2 +1)  = 2 * 2^( (b/k).log2 ):=
      by rw [pow_succ _ _,mul_comm]
    rw [h2]
    have h3 : 2^((b/k).log2) ≤ b/k := Nat.log2_self_le hbk
    rw [mul_assoc]
    apply Nat.mul_le_mul_left 2
    exact (Nat.le_div_iff_mul_le h1).mp h3

lemma key_lemma {m b: ℕ}
    (h: ∀ k, b < k → k ≤ 2*b → Coprime m k) :
     ∀ k, 1 < k →  k ≤ 2 * b → Coprime m k := by
   intro k hk1 hk2
   by_cases hk0 : b < k
   · exact h k hk0 hk2
   · push_neg at hk0
     obtain ⟨i, hi1, hi2⟩  :=  dyadic (le_of_lt hk1) hk0
     exact Coprime.coprime_mul_left_right (h (2 ^ i * k) hi1 hi2)

lemma key_lemma'  {m b: ℕ } (h1 : 1 < m)
    (h: ∀ k,  b < k → k ≤ 2*b → Coprime m k) (h2 : m < (2*b+1)^2) :
     Nat.Prime m := by
  replace h := key_lemma h
  apply prime_of_coprime' m h1
  intro k hk1 hk2
  by_cases hk0 : k=1
  · simp [hk0]
  push_neg at hk0
  refine h k ?_ ?_
  · lia
  · replace h2 := lt_of_le_of_lt hk1 h2
    rw [pow_two,pow_two] at h2
    replace h2 := Nat.mul_self_lt_mul_self_iff.1 h2
    lia

lemma dvd_lemma (a b c : ℕ ) (h : c ≠ 0) : a ≤ b → b ∣ c → c < 2 * a → b = c := by
  intro h1 ⟨k, hk⟩ h3
  match k with
  | 0 => simp at hk; exfalso; exact h hk
  | 1 => simp [hk]
  | k + 2 => lia

lemma zero_of_le_sub_pos {a b : ℕ} : b ≠ 0 → a ≤ a - b → a = 0 := by lia

lemma sub_le_lemma {a b : ℕ} : b ≤ a → b ≠ 0 → a - b < a := by lia



theorem imo1987_p6
    (p : ℕ)
    (h₁ : ∀ k : ℕ, k ≤ Nat.floor (Real.sqrt ((p:ℝ) / 3)) → Nat.Prime (k^2 + k + p)) :
    ∀ i ≤ p - 2, Nat.Prime (i^2 + i + p) := by
  let f x := x^2 + x + p
  let r := Nat.floor (Real.sqrt (p/3))
  intro k
  apply Nat.case_strong_induction_on k
  · intro; exact h₁ 0 (Nat.zero_le _)
  intro k IH hk
  by_cases h : k+1 ≤ r
  · exact h₁ (k+1) h
  · push_neg at h
    let kk := k+1
    let s := kk - r
    let N := f kk
    have hksr : kk =  s + r := Nat.eq_add_of_sub_eq (le_of_lt h) (by rfl)

    /- Show that N < ... -/
    have hs : 1 ≤ s := by
      simp_rw [s, kk]
      exact Nat.le_sub_of_add_le' h
    have ieq3 : 3*r ≤ 6*r*s  := by nlinarith only [hs]
    have ieq4 : p ≤ 3*r^2 + 6*r + 2 := by
      have ieq5: √ (p/3) < r+1 := Nat.lt_floor_add_one _
      replace ieq5 := Real.lt_sq_of_sqrt_lt ieq5 |> (div_lt_iff₀ (by norm_num)).1
      replace ieq5: (p) < (3*r^2 + 6*r +3) := cast_lt.1 <| by
        have casteq: ((r:ℝ)+1)^2 * 3 = ((3*r^2+6*r+3:ℕ):ℝ) := by simp;ring_nf
        rw [←casteq]
        exact ieq5
      lia
    have hN0 : N = kk^2+kk+p := rfl
    have hN1 : N < (2 * (s + r) +1)^2  := by
      calc
      _ = _:= hN0
      _ ≤  3*r^2 + 6*r + 2 + (r+s)*(r+s+1) := by nlinarith only [hN0, ieq4, hs, hksr]
      _ = 4*r^2 + 2* r*s + s^2 + 7*r+s+2 := by ring_nf
      _ < 4*r^2 +4*s^2 +8*r*s+4*r+4*s+1 := by lia
      _ = _ := by ring
    rw [←hksr] at hN1

    have hP : ∀ i , kk < i → i ≤ 2*(kk) → Coprime N i := by
      by_contra H
      push_neg at H
      obtain ⟨j, hj1,hj2,hj3⟩ := H
      have hj1' : s+r +1 ≤ j := by rw [←hksr]; apply succ_le_of_lt hj1
      let  ss :=  j-(s+r+1)
      have hss0 : j =  ss + (s+r+1) := Nat.eq_add_of_sub_eq hj1' (by rfl)


      have hp: 2 ≤ p :=  Nat.lt_of_sub_ne_zero (by lia: p-2 ≠ 0) |> le_of_lt

      have hss1 : ss ≤ k := by
        apply Nat.le_of_add_le_add_right (b :=s+r+1)
        rw [←hss0,←hksr]
        calc
        _ ≤ _ := hj2
        _ = _ := by lia
      replace hss1 : Nat.Prime (f ss) := IH ss hss1 (by lia)
      have hfss: N = f ss + (2*kk - j+1) *j := by
        unfold f
        rw [hN0]
        zify
        rw [Int.natCast_sub hj2,hss0,←hksr]
        push_cast
        ring_nf
      change ¬N.gcd j = 1 at hj3
      rw [hfss, ←Nat.coprime_iff_gcd_eq_one, Nat.coprime_add_mul_right_left] at hj3
      have hss2 : f ss ∣ j := Nat.Prime.dvd_iff_not_coprime hss1 |>.2 hj3
      have hfss1: p ≤ f ss := Nat.le_add_left p (ss ^ 2 + ss)
      have hp1 : p - 2 < p := sub_le_lemma hp (by lia)
      have hfss2: j < 2*p := by lia
      have hj : j ≠ 0 := by lia
      have hfss3:  f ss = j := dvd_lemma _ _ _ hj hfss1 hss2  hfss2
      unfold f at hfss3
      rw [hss0,add_comm _ ss,add_assoc] at hfss3
      replace hfss3 := add_left_cancel hfss3
      have hc1 : p ≤ k + 2 := by
        calc
          p ≤ ss^2 + p := Nat.le_add_left _ _
          _ = _ := hfss3
          _ = _ := by rw [←hksr]
      have hc2: p ≤ p-1 := by
        calc
        _ ≤ _ := hc1
        _ = (k+1) + 1 := by ring_nf
        _ ≤ (p-2)+1 := by lia
        _ = p - 1 := by lia
      have : p = 0 := zero_of_le_sub_pos (by simp) hc2
      lia
    have hfk : 1 < f kk := by
      unfold f
      rw [hksr]
      calc
      _ < 1 + 1 := by decide
      _ ≤ s^2 + s  := by nlinarith only [hs]
      _ ≤ s^2 + 2 * r *s + r^2 + s + r + p := by lia
      _ = _ := by ring
    exact key_lemma' (hfk) hP hN1

end Imo1987P6

-- ═══ Imo1988P6 ═══

/-
Copyright (c) 2019 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/





/-!
# International Mathematical Olympiad 1988, Problem 6

If a and b are two natural numbers such that a*b+1 divides a^2 + b^2,
show that their quotient is a perfect square.
-/

namespace Imo1988P6



/-
Question 6 of IMO1988 is somewhat (in)famous. Several expert problem solvers
could not tackle the question within the given time limit.
The problem lead to the introduction of a new proof technique,
so called “Vieta jumping”.

In this file we formalise constant descent Vieta jumping,
and apply this to prove P6 of IMO1988.
To illustrate the technique, we also prove a similar result.
-/

/-- Constant descent Vieta jumping.

This proof technique allows one to prove an arbitrary proposition `claim`,
by running a descent argument on a hyperbola `H` in the first quadrant of the plane,
under the following conditions:

* `h₀`     : There exists an integral point `(x,y)` on the hyperbola `H`.
* `H_symm` : The hyperbola has a symmetry along the diagonal in the plane.
* `H_zero` : If an integral point `(x,0)` lies on the hyperbola `H`, then `claim` is true.
* `H_diag` : If an integral point `(x,x)` lies on the hyperbola `H`, then `claim` is true.
* `H_desc` : If `(x,y)` is an integral point on the hyperbola `H`,
with `x < y` then there exists a “smaller” point on `H`: a point `(x',y')` with `x' < y' ≤ x`.

For reasons of usability, the hyperbola `H` is implemented as an arbitrary predicate.
(In question 6 of IMO1988, where this proof technique was first developped,
the predicate `claim` would be `∃ (d : ℕ), d ^ 2 = k` for some natural number `k`,
and the predicate `H` would be `fun a b ↦ a * a + b * b = (a * b + 1) * k`.)

To ensure that the predicate `H` actually describes a hyperbola,
the user must provide arguments `B` and `C` that are used as coefficients for a quadratic equation.
Finally, `H_quad` is the proof obligation that the quadratic equation
  `(y:ℤ) * y - B x * y + C x = 0`
describes the same hyperbola as the predicate `H`.

For extra flexibility, one must provide a predicate `base` on the integral points in the plane.
In the descent step `H_desc` this will give the user the additional assumption that
the point `(x,y)` does not lie in this base locus.
The user must provide a proof that the proposition `claim` is true
if there exists an integral point `(x,y)` on the hyperbola `H` that lies in the base locus.
If such a base locus is not necessary, once can simply let it be `fun x y ↦ False`.
-/
theorem constant_descent_vieta_jumping (x y : ℕ) {claim : Prop} {H : ℕ → ℕ → Prop} (h₀ : H x y)
    (B : ℕ → ℤ) (C : ℕ → ℤ) (base : ℕ → ℕ → Prop)
    (H_quad : ∀ {x y}, H x y ↔ (y : ℤ) * y - B x * y + C x = 0) (H_symm : ∀ {x y}, H x y ↔ H y x)
    (H_zero : ∀ {x}, H x 0 → claim) (H_diag : ∀ {x}, H x x → claim)
    (H_desc : ∀ {x y}, 0 < x → x < y → ¬base x y → H x y →
      ∀ y', y' * y' - B x * y' + C x = 0 → y' = B x - y → y' * y = C x → 0 ≤ y' ∧ y' ≤ x)
    (H_base : ∀ {x y}, H x y → base x y → claim) : claim := by
  -- First of all, we may assume that x ≤ y.
  -- We justify this using H_symm.
  wlog hxy : x ≤ y
  · rw [H_symm] at h₀; apply this y x h₀ B C base _ _ _ _ _ _ (le_of_not_ge hxy); assumption'
  -- In fact, we can easily deal with the case x = y.
  by_cases x_eq_y : x = y
  · subst x_eq_y; exact H_diag h₀
  -- Hence we may assume that x < y.
  replace hxy : x < y := lt_of_le_of_ne hxy x_eq_y
  clear x_eq_y
  -- Consider the upper branch of the hyperbola defined by H.
  let upper_branch : Set (ℕ × ℕ) := {p | H p.1 p.2 ∧ p.1 < p.2}
  -- Note that the point p = (x,y) lies on the upper branch.
  let p : ℕ × ℕ := ⟨x, y⟩
  have hp : p ∈ upper_branch := ⟨h₀, hxy⟩
  -- We also consider the exceptional set of solutions (a,b) that satisfy
  -- a = 0 or a = b or B a = b or B a = b + a or that lie in the base locus.
  let exceptional : Set (ℕ × ℕ) :=
    {p | H p.1 p.2 ∧ (base p.1 p.2 ∨ p.1 = 0 ∨ p.1 = p.2 ∨ B p.1 = p.2 ∨ B p.1 = p.2 + p.1)}
  -- Let S be the projection of the upper branch on to the y-axis
  -- after removing the exceptional locus.
  let S : Set ℕ := Prod.snd '' (upper_branch \ exceptional)
  -- The strategy is to show that the exceptional locus in nonempty
  -- by running a descent argument that starts with the given point p = (x,y).
  -- Our assumptions ensure that we can then prove the claim.
  suffices exc : exceptional.Nonempty by
    -- Suppose that there exists an element in the exceptional locus.
    simp only [Set.Nonempty, Prod.exists, Set.mem_setOf_eq, exceptional] at exc
    -- Let (a,b) be such an element, and consider all the possible cases.
    rcases exc with ⟨a, b, hH, hb⟩
    rcases hb with (_ | rfl | rfl | hB | hB)
    -- The first three cases are rather easy to solve.
    · solve_by_elim
    · rw [H_symm] at hH; solve_by_elim
    · solve_by_elim
    -- The final two cases are very similar.
    all_goals
      -- Consider the quadratic equation that (a,b) satisfies.
      rw [H_quad] at hH
      -- We find the other root of the equation, and Vieta's formulas.
      rcases vieta_formula_quadratic hH with ⟨c, h_root, hV₁, hV₂⟩
      -- By substitutions we find that b = 0 or b = a.
      simp only [hB, add_eq_left, add_right_inj] at hV₁
      subst hV₁
      rw [← Int.ofNat_zero] at *
      rw [← H_quad] at h_root
      -- And hence we are done by H_zero and H_diag.
      solve_by_elim
  -- To finish the main proof, we need to show that the exceptional locus is nonempty.
  -- So we assume that the exceptional locus is empty, and work towards deriving a contradiction.
  rw [Set.nonempty_iff_ne_empty]
  intro exceptional_empty
  -- Observe that S is nonempty.
  have S_nonempty : S.Nonempty := by
    -- It contains the image of p.
    use p.2
    apply Set.mem_image_of_mem
    -- After all, we assumed that the exceptional locus is empty.
    rwa [exceptional_empty, Set.diff_empty]
  -- We are now set for an infinite descent argument.
  -- Let m be the smallest element of the nonempty set S.
  let m : ℕ := WellFounded.min Nat.lt_wfRel.wf S S_nonempty
  have m_mem : m ∈ S := WellFounded.min_mem Nat.lt_wfRel.wf S S_nonempty
  have m_min : ∀ k ∈ S, ¬k < m := fun k hk => WellFounded.not_lt_min Nat.lt_wfRel.wf S S_nonempty hk
  -- It suffices to show that there is point (a,b) with b ∈ S and b < m.
  rsuffices ⟨p', p'_mem, p'_small⟩ : ∃ p' : ℕ × ℕ, p'.2 ∈ S ∧ p'.2 < m
  · solve_by_elim
  -- Let (m_x, m_y) be a point on the upper branch that projects to m ∈ S
  -- and that does not lie in the exceptional locus.
  rcases m_mem with ⟨⟨mx, my⟩, ⟨⟨hHm, mx_lt_my⟩, h_base⟩, m_eq⟩
  -- This means that m_y = m,
  -- and the conditions H(m_x, m_y) and m_x < m_y are satisfied.
  simp only at mx_lt_my hHm m_eq
  simp only [exceptional, hHm, Set.mem_setOf_eq, true_and] at h_base
  push_neg at h_base
  -- Finally, it also means that (m_x, m_y) does not lie in the base locus,
  -- that m_x ≠ 0, m_x ≠ m_y, B(m_x) ≠ m_y, and B(m_x) ≠ m_x + m_y.
  rcases h_base with ⟨h_base, hmx, hm_diag, hm_B₁, hm_B₂⟩
  replace hmx : 0 < mx := pos_iff_ne_zero.mpr hmx
  -- Consider the quadratic equation that (m_x, m_y) satisfies.
  have h_quad := hHm
  rw [H_quad] at h_quad
  -- We find the other root of the equation, and Vieta's formulas.
  rcases vieta_formula_quadratic h_quad with ⟨c, h_root, hV₁, hV₂⟩
  -- Now we rewrite Vietas formulas a bit, and apply the descent step.
  replace hV₁ : c = B mx - my := eq_sub_of_add_eq' hV₁
  rw [mul_comm] at hV₂
  have Hc := H_desc hmx mx_lt_my h_base hHm c h_root hV₁ hV₂
  -- This means that we may assume that c ≥ 0 and c ≤ m_x.
  obtain ⟨c_nonneg, c_lt⟩ := Hc
  -- In other words, c is a natural number.
  lift c to ℕ using c_nonneg
  -- Recall that we are trying find a point (a,b) such that b ∈ S and b < m.
  -- We claim that p' = (c, m_x) does the job.
  let p' : ℕ × ℕ := ⟨c, mx⟩
  use p'
  -- The second condition is rather easy to check, so we do that first.
  constructor; swap
  · rwa [m_eq] at mx_lt_my
  -- Now we need to show that p' projects onto S. In other words, that c ∈ S.
  -- We do that, by showing that it lies in the upper branch
  -- (which is sufficient, because we assumed that the exceptional locus is empty).
  apply Set.mem_image_of_mem
  rw [exceptional_empty, Set.diff_empty]
  -- Now we are ready to prove that p' = (c, m_x) lies on the upper branch.
  -- We need to check two conditions: H(c, m_x) and c < m_x.
  constructor <;> dsimp only
  · -- The first condition is not so hard. After all, c is the other root of the quadratic equation.
    rw [H_symm, H_quad]
    simpa using h_root
  · -- For the second condition, we note that it suffices to check that c ≠ m_x.
    lia



theorem imo1988_p6 {a b : ℕ} (h : a * b + 1 ∣ a ^ 2 + b ^ 2) :
    ∃ d, d ^ 2 = (a ^ 2 + b ^ 2) / (a * b + 1) := by
  rcases h with ⟨k, hk⟩
  rw [hk, Nat.mul_div_cancel_left _ (Nat.succ_pos (a * b))]
  simp only [sq] at hk
  apply constant_descent_vieta_jumping a b (H := fun a b => a * a + b * b = (a * b + 1) * k)
      hk (fun x => k * x) (fun x => x * x - k) fun _ _ => False <;>
    clear hk a b
  · -- We will now show that the fibers of the solution set are described by a quadratic equation.
    lia
  · -- Show that the solution set is symmetric in a and b.
    intro x y
    simp [add_comm (x * x), mul_comm x]
  · -- Show that the claim is true if b = 0.
    suffices ∀ a, a * a = k → ∃ d, d * d = k by simpa [sq]
    rintro x rfl; use x
  · -- Show that the claim is true if a = b.
    intro x hx
    suffices k ≤ 1 by
      rw [Nat.le_add_one_iff, Nat.le_zero] at this
      rcases this with (rfl | rfl)
      · use 0; simp
      · use 1; simp
    contrapose! hx with k_lt_one
    apply ne_of_lt
    calc
      x * x + x * x = x * x * 2 := by rw [mul_two]
      _ ≤ x * x * k := (Nat.mul_le_mul_left (x * x) k_lt_one)
      _ < (x * x + 1) * k := by linarith
  · -- Show the descent step.
    intro x y hx x_lt_y _ _ z h_root _ hV₀
    constructor
    · have hpos : z * z + x * x > 0 := by
        apply add_pos_of_nonneg_of_pos
        · apply mul_self_nonneg
        · positivity
      have hzx : z * z + x * x = (z * x + 1) * k := by
        rw [← sub_eq_zero, ← h_root]
        ring
      rw [hzx] at hpos
      replace hpos : z * x + 1 > 0 := pos_of_mul_pos_left hpos (Int.natCast_nonneg k)
      replace hpos : z * x ≥ 0 := Int.le_of_lt_add_one hpos
      apply nonneg_of_mul_nonneg_left hpos (mod_cast hx)
    · contrapose! hV₀ with x_lt_z
      apply ne_of_gt
      calc
        z * y > x * x := by apply mul_lt_mul' <;> lia
        _ ≥ x * x - k := sub_le_self _ (Int.natCast_nonneg k)
  · -- There is no base case in this application of Vieta jumping.
    simp




/-
The following example illustrates the use of constant descent Vieta jumping
in the presence of a non-trivial base case.
-/
example {a b : ℕ} (h : a * b ∣ a ^ 2 + b ^ 2 + 1) : 3 * a * b = a ^ 2 + b ^ 2 + 1 := by
  rcases h with ⟨k, hk⟩
  suffices k = 3 by simp_all; ring
  simp only [sq] at hk
  apply constant_descent_vieta_jumping a b (H := fun a b => a * a + b * b + 1 = a * b * k)
      hk (fun x => k * x) (fun x => x * x + 1) fun x _ => x ≤ 1 <;>
    clear hk a b
  · lia
  · -- Show that the solution set is symmetric in a and b.
    intro x y; ring_nf -- Porting note: Originally, `cc` solved the entire goal
  · -- Show that the claim is true if b = 0.
    simp
  · -- Show that the claim is true if a = b.
    intro x hx
    have x_sq_dvd : x * x ∣ x * x * k := dvd_mul_right (x * x) k
    rw [← hx] at x_sq_dvd
    obtain ⟨y, hy⟩ : x * x ∣ 1 := by simpa only [Nat.dvd_add_self_left, add_assoc] using x_sq_dvd
    obtain ⟨rfl, rfl⟩ : x = 1 ∧ y = 1 := by simpa [mul_eq_one] using hy.symm
    simpa using hx.symm
  · -- Show the descent step.
    intro x y _ hx h_base _ z _ _ hV₀
    constructor
    · have zy_pos : z * y ≥ 0 := by rw [hV₀]; exact mod_cast Nat.zero_le _
      apply nonneg_of_mul_nonneg_left zy_pos
      lia
    · contrapose! hV₀ with x_lt_z
      apply ne_of_gt
      push_neg at h_base
      calc
        z * y > x * y := by apply mul_lt_mul_of_pos_right <;> lia
        _ ≥ x * (x + 1) := by apply mul_le_mul <;> lia
        _ > x * x + 1 := by
          rw [mul_add, mul_one]
          apply add_lt_add_right
          assumption_mod_cast
  · -- Show the base case.
    intro x y h h_base
    obtain rfl | rfl : x = 0 ∨ x = 1 := by rwa [Nat.le_add_one_iff, Nat.le_zero] at h_base
    · simp at h
    · rw [mul_one, one_mul, add_right_comm] at h
      have y_dvd : y ∣ y * k := dvd_mul_right y k
      rw [← h, Nat.dvd_add_left (dvd_mul_left y y)] at y_dvd
      obtain rfl | rfl := (Nat.dvd_prime Nat.prime_two).mp y_dvd <;> apply mul_left_cancel₀
      exacts [one_ne_zero, h.symm, two_ne_zero, h.symm]



end Imo1988P6

-- ═══ Imo1989P5 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 1989, Problem 5

Prove that for each positive integer n there exist n consecutive positive
integers, none of which is an integral power of a prime number.
-/

namespace Imo1989P5



structure ChinesePair where
  modulus : ℕ
  remainder : ℕ

lemma general_chinese_remainder (xs : List ChinesePair)
    (x_coprime : xs.Pairwise (fun x y ↦ Nat.Coprime x.modulus y.modulus)) :
    ∃ m : ℕ, ∀ x ∈ xs, m ≡ x.remainder [MOD x.modulus] := by
  induction xs with
  | nil => use 0; decide
  | cons x xs ih =>
    obtain ⟨b, hb⟩ := ih x_coprime.tail
    clear ih
    -- then we use Nat.chineseRemainder on x and ⟨List.prod(xs.map modulus), b⟩
    rw [List.pairwise_cons] at x_coprime
    -- need that `Nat.Coprime x.modulus y`
    have h1 := (Nat.coprime_list_prod_right_iff
                   (k := x.modulus) (l := xs.map (·.modulus))).mpr
                   (by intro z hz; aesop)
    obtain ⟨k, hk1, hk2⟩ := Nat.chineseRemainder h1 x.remainder b
    use k
    intro z hz
    cases hz with
    | head => exact hk1
    | tail w hw =>
      have h2 := hb z hw
      have h4 := Nat.ModEq.of_dvd (List.dvd_prod (List.mem_map_of_mem hw)) hk2
      exact h4.trans h2

lemma list_upper_bound (l : List ℕ) : ∃ m : ℕ, ∀ x ∈ l, x ≤ m := by
  use List.foldr max ⊥ l
  intro a ha
  exact List.le_max_of_le ha (le_refl _)

theorem get_primes (n m : ℕ) :
    ∃ lst : List ℕ, lst.length = n ∧ lst.Nodup ∧
               ∀ x ∈ lst, x.Prime ∧ m ≤ x := by
  induction n with
  | zero => use ∅; simp
  | succ n ih =>
    obtain ⟨l', hl', hlnd, hlp⟩ := ih
    obtain ⟨mx, hmx⟩ := list_upper_bound l'
    obtain ⟨p, hpm, hp⟩ := Nat.exists_infinite_primes (max m (mx + 1))
    use p :: l'
    constructor
    · exact Iff.mpr Nat.succ_inj hl'
    · constructor
      · rw [List.nodup_cons]
        constructor
        · intro hpl
          exact Iff.mpr Nat.not_le (le_of_max_le_right hpm) (hmx p hpl)
        · exact hlnd
      · aesop

lemma not_prime_power_of_two_factors
     {n p q : ℕ}
     (hp : Nat.Prime p) (hq : Nat.Prime q)
     (hpq : p ≠ q)
     (hpn : p ∣ n) (hqn : q ∣ n) : ¬IsPrimePow n := by
   intro hpp
   have h0 : n ≠ 0 := IsPrimePow.ne_zero hpp
   obtain ⟨r, k, hr, hk, hrk⟩ := hpp
   rw [← Nat.prime_iff] at hr
   rw [← hrk] at hqn hpn h0; clear hrk
   have h1 := (Nat.mem_primeFactorsList h0).mpr ⟨hp, hpn⟩
   rw [Nat.Prime.primeFactorsList_pow hr] at h1
   have h3 := (List.mem_replicate.mp h1).2
   have h2 := (Nat.mem_primeFactorsList h0).mpr ⟨hq, hqn⟩
   rw [Nat.Prime.primeFactorsList_pow hr] at h2
   have h4 := (List.mem_replicate.mp h2).2
   rw [h3, h4] at hpq
   exact hpq rfl

lemma lemma1 {p1 p2 q : ℕ}
    (hp1 : Nat.Prime p1)
    (hp2 : Nat.Prime p2)
    (hq : Nat.Prime q)
    (hp1q : p1 ≠ q)
    (hp2q : p2 ≠ q) :
    Nat.Coprime (p1 * p2) q := by
  have h1 : Nat.Coprime p1 q := Iff.mpr (Nat.coprime_primes hp1 hq) hp1q
  have h2 : Nat.Coprime p2 q := Iff.mpr (Nat.coprime_primes hp2 hq) hp2q
  exact Nat.Coprime.mul_left h1 h2

lemma lemma2 {p1 q1 p2 q2 : ℕ}
    (hp1 : Nat.Prime p1)
    (hq1 : Nat.Prime q1)
    (hp2 : Nat.Prime p2)
    (hq2 : Nat.Prime q2)
    (hp1q1 : p1 ≠ q1)
    (hp1q2 : p1 ≠ q2)
    (hp2q1 : p2 ≠ q1)
    (hp2q2 : p2 ≠ q2) :
    Nat.Coprime (p1 * p2) (q1 * q2) := by
  have h1 := lemma1 hp1 hp2 hq1 hp1q1 hp2q1
  have h2 := lemma1 hp1 hp2 hq2 hp1q2 hp2q2
  exact Nat.Coprime.mul_right h1 h2

lemma lemma3 {α : Type} (l : List α)
    (hl : List.Nodup l)
    {i j : Fin l.length}
    (hij : i ≠ j)
    : l.get i ≠ l.get j := by
  intro hij'
  --TODO why do neither aesop nor library_search succeed here?
  exact hij (List.nodup_iff_injective_get.mp hl hij')

lemma lemma4 {a b : ℕ} (h : a ≡ b [MOD b]) : a ≡ 0 [MOD b] := by
  have h1 : a % b = b % b := h
  have h2 : b % b = 0 := Nat.mod_self b
  rw [h2] at h1
  exact h1



theorem imo1989_p5 (n : ℕ) : ∃ m, ∀ j < n, ¬IsPrimePow (m + j) := by
  -- (informal solution from https://artofproblemsolving.com)
  -- Let p₁,p₂,...pₙ,q₁,q₂,...,qₙ be distinct primes.
  obtain ⟨l, hll, hld, hl⟩ := get_primes (2 * n) n
  let ci : List ChinesePair :=
    List.ofFn (fun x : Fin n ↦ have hx0: ↑x < List.length l := by lia
                               have hx1: ↑x + n < List.length l := by lia
                               let p := l.get ⟨x.1, hx0⟩
                               let q := l.get ⟨x.1 + n, hx1⟩
                               ⟨p * q, p * q - x.1⟩)

  have lcp : ci.Pairwise (fun x y => Nat.Coprime x.modulus y.modulus) := by
     rw [List.pairwise_ofFn]
     intro i j hij
     apply lemma2
           (hl _ (List.get_mem _ _)).1
           (hl _ (List.get_mem _ _)).1
           (hl _ (List.get_mem _ _)).1
           (hl _ (List.get_mem _ _)).1
     · exact lemma3 l hld (LT.lt.ne hij)
     · have hijn : i < j + n := Nat.lt_add_right n hij
       exact lemma3 l hld (Fin.ne_of_val_ne (LT.lt.ne hijn))
     · have hijn' := calc j < n := j.prop
                          _ ≤ i + n := Nat.le_add_left _ _
       have hijn : i + n ≠ j := Nat.ne_of_gt hijn'
       exact lemma3 l hld (Fin.ne_of_val_ne hijn)
     · have hijn : i + n < j + n := Nat.add_lt_add_right hij n
       exact lemma3 l hld (Fin.ne_of_val_ne (LT.lt.ne hijn))

  -- By the Chinese Remainder theorem, there exists x such that
  --   x ≡ 0 mod p₁q₁
  --   x ≡ -1 mod p₂q₂
  --   ...
  --   x ≡ -(n - 1) mod pₙqₙ

  obtain ⟨m, hm⟩ := general_chinese_remainder ci lcp

  -- The n consecutive numbers x, x, ..., x+n-1 each have at least
  -- two prime factors, so none of them can be expressed as an integral
  -- power of a prime.
  use m
  intro j hj
  have hcil : ci.length = n := by unfold ci; aesop
  have hj1 : j < ci.length := by rwa [hcil]
  have hj2 : j < l.length := by rw [hll, Nat.two_mul]
                                exact Nat.lt_add_right n hj
  have hj3 : j + n < l.length := by rw [hll, Nat.two_mul]
                                    exact Nat.add_lt_add_right hj n
  have h1 := hm (ci.get ⟨j, hj1⟩) (List.get_mem _ _)
  obtain ⟨h2, h3⟩ := hl (l.get ⟨j, hj2⟩) (List.get_mem _ _)
  obtain ⟨h4, _⟩ := hl (l.get ⟨j + n, hj3⟩) (List.get_mem _ _)
  simp only [List.get_ofFn, Fin.cast_mk, ci] at h1
  have h6 := Nat.ModEq.add_right j h1
  have h7 : j ≤ l.get ⟨j, hj2⟩ * l.get ⟨j + n, hj3⟩ := by
      apply Nat.le_of_lt
      calc
        j < n := hj
        _ ≤ l.get ⟨j, hj2⟩ := h3
        _ ≤ l.get ⟨j, hj2⟩ * l.get ⟨j + n, hj3⟩ := Nat.le_mul_of_pos_right _ (Nat.Prime.pos h4)

  rw [Nat.sub_add_cancel h7] at h6
  clear h1 h7
  have h8 := lemma4 h6
  replace h8 := Nat.dvd_of_mod_eq_zero h8
  have h9 := dvd_of_mul_right_dvd h8
  have h10 := dvd_of_mul_left_dvd h8
  have h11 : l.get ⟨j, hj2⟩ ≠ l.get ⟨j + n, hj3⟩ := by
    intro h12
    have h13 := (List.Nodup.get_inj_iff hld).mp h12
    simp only [Fin.mk.injEq, left_eq_add] at h13
    simp only [h13, not_lt_zero'] at hj
  exact not_prime_power_of_two_factors h2 h4 h11 h9 h10


end Imo1989P5

-- ═══ Imo1989P6 ═══

/-
Copyright (c) 2026 Constantin Seebach. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Constantin Seebach
-/





/-!
# International Mathematical Olympiad 1989, Problem 6

A permutation $\{x_1, \ldots, x_{2n}\}$ of the set $\{1,2, \ldots, 2n\}$ where $n$ is a positive integer,
is said to have property $T$ if $|x_i - x_{i + 1}| = n$ for at least one $i \in \{1,2, \ldots, 2n - 1\}$.
Show that, for each $n$, there are more permutations with property $T$ than without.
-/

namespace Imo1989P6

open Equiv

variable (n : ℕ)

def T (x : Perm (Finset.Icc 1 (2*n))) :=
  ∃ i, ∃ _ : i ∈ Finset.Icc 1 (2*n-1),
    (x ⟨i, by grind⟩ : ℕ).dist (x ⟨i+1, by grind⟩) = n



/-!
We implement Solution 3 from https://artofproblemsolving.com/wiki/index.php/1989_IMO_Problems/Problem_6 ,
trying to incorporate as much Perm(utation) machinery from Mathlib as possible.
-/

instance instOne [NeZero n] : OfNat ↥(Finset.Icc 1 (2 * n)) 1 := ⟨⟨1, by simpa using NeZero.one_le⟩⟩

noncomputable def A :=
  {x | ¬ T n x}

noncomputable def B :=
  {⟨x, k⟩ : Perm (Finset.Icc 1 (2*n)) × Finset.Icc 2 (2*n-1) | ∀ j : Finset.Icc 1 (2*n-1), k.val=j.val ↔ (x ⟨j, by grind⟩ : ℕ).dist (x ⟨j+1, by grind⟩) = n}


theorem unique_ndiff (i j : Finset.Icc 1 (2*n)) : (i : ℕ).dist j = n ↔ j = (if i ≤ n then i+n else i-n) := by
  simp only [Nat.dist_eq_max_sub_min]
  grind

def fin_equiv : Finset.Icc 1 (2*n) ≃ Fin (2*n) where
  toFun x := ⟨x.val-1, by grind⟩
  invFun x := ⟨x.val+1, by grind⟩
  left_inv x := by grind
  right_inv x := by grind

def perm_fin_equiv : Perm (Finset.Icc 1 (2*n)) ≃ Perm (Fin (2*n)) := equivCongr (fin_equiv n) (fin_equiv n)


@[simp]
theorem one_le_val (k : Finset.Icc 1 (2 * n)) : 1 ≤ k.val := by grind

@[simp]
theorem val_le_2n (k : Finset.Icc 1 (2 * n)) : k.val ≤ 2*n := by grind


def partial_cycle (k : Finset.Icc 1 (2 * n)) : Perm $ Perm $ Finset.Icc 1 (2 * n) where
  toFun x := (perm_fin_equiv n).symm ((perm_fin_equiv n) x * Fin.cycleRange (fin_equiv n k))
  invFun x := (perm_fin_equiv n).symm ((perm_fin_equiv n) x * (Fin.cycleRange (fin_equiv n k)).symm)
  left_inv x := by simp [mul_assoc]
  right_inv x := by simp [mul_assoc]

theorem partial_cycle.apply_of_eq [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h : i = k)
    : (partial_cycle n k x) i = x 1 := by
  unfold partial_cycle perm_fin_equiv instOne
  simp only [equivCongr_symm, coe_fn_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply]
  rw [<-h, Fin.cycleRange_self]
  unfold fin_equiv
  simp

theorem partial_cycle.apply_of_gt [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h : k < i)
    : (partial_cycle n k x) i = x i := by
  unfold partial_cycle perm_fin_equiv
  simp only [equivCongr_symm, coe_fn_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply]
  rw [Fin.cycleRange_of_gt]
  · simp
  · unfold fin_equiv
    apply Nat.sub_lt_sub_right _ h
    apply one_le_val

theorem partial_cycle.apply_of_lt [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h : i < k)
    : (partial_cycle n k x) i = ⟨x ⟨i + 1, by rw [<-Subtype.coe_lt_coe] at h; grind⟩, by simp⟩ := by
  unfold partial_cycle perm_fin_equiv
  simp only [equivCongr_symm, coe_fn_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply]
  rw [Fin.cycleRange_of_lt]
  · unfold fin_equiv
    simp only [coe_fn_mk, coe_fn_symm_mk, Subtype.coe_eta, EmbeddingLike.apply_eq_iff_eq,
      Subtype.mk.injEq, Nat.add_right_cancel_iff]
    rw [Fin.val_add_one_of_lt']
    · simp
    · simp only [one_le_val, Nat.sub_add_cancel]
      rw [<-Subtype.coe_lt_coe] at h
      apply lt_of_lt_of_le h
      exact val_le_2n n k
  · unfold fin_equiv
    apply Nat.sub_lt_sub_right _ h
    apply one_le_val


theorem partial_cycle.symm.apply_of_eq [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h : i = 1)
    : ((partial_cycle n k).symm x) i = x k := by
  unfold partial_cycle perm_fin_equiv
  simp only [equivCongr_symm, coe_fn_symm_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply, EmbeddingLike.apply_eq_iff_eq]
  suffices (fin_equiv n) i = (((fin_equiv n) k).cycleRange) ((fin_equiv n) k) by grind
  rw [Fin.cycleRange_of_eq]
  · subst i
    unfold fin_equiv instOne
    simp
  · rfl

theorem partial_cycle.symm.apply_of_gt [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h : k < i)
    : ((partial_cycle n k).symm x) i = x i := by
  unfold partial_cycle perm_fin_equiv
  simp only [equivCongr_symm, coe_fn_symm_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply, EmbeddingLike.apply_eq_iff_eq]
  suffices (fin_equiv n) i = (((fin_equiv n) k).cycleRange) ((fin_equiv n) i) by grind
  rw [Fin.cycleRange_of_gt]
  unfold fin_equiv
  apply Nat.sub_lt_sub_right _ h
  apply one_le_val

theorem partial_cycle.symm.apply_of_le [NeZero n] (x : Perm $ Finset.Icc 1 (2 * n)) (k i : Finset.Icc 1 (2 * n)) (h1 : i ≤ k) (h2 : 1 < i)
    : ((partial_cycle n k).symm x) i = ⟨x ⟨i - 1, by rw [instOne, <-Subtype.coe_lt_coe] at h2; grind⟩, by simp⟩ := by
  unfold partial_cycle perm_fin_equiv
  simp only [equivCongr_symm, coe_fn_symm_mk, equivCongr_apply_apply, symm_symm, Perm.coe_mul,
    Function.comp_apply, symm_apply_apply]
  suffices (fin_equiv n) i = (((fin_equiv n) k).cycleRange) ((fin_equiv n) ⟨i - 1, by rw [instOne, <-Subtype.coe_lt_coe] at h2; grind⟩) by grind
  simp_rw [<-Subtype.coe_lt_coe] at h1 h2
  rw [Fin.cycleRange_of_lt]
  · unfold fin_equiv
    simp only [coe_fn_mk]
    apply Fin.val_injective
    rw [Fin.val_add_one_of_lt'] <;> grind
  · unfold fin_equiv
    simp only [coe_fn_mk, Fin.mk_lt_mk]
    apply Nat.sub_lt_sub_right
    · grind
    · apply Nat.lt_of_le_sub_one
      · grind
      · apply Nat.sub_le_sub_right
        exact h1


def transform_A_to_B [NeZero n] : (A n) → (B n) := fun x ↦ by
  let x_1 := x.val 1
  let x_k : Finset.Icc 1 (2*n) := ⟨if x_1 ≤ n then x_1+n else x_1-n, by grind⟩
  have ndiff : (x_1 : ℕ).dist x_k = n := by rw [unique_ndiff]
  let k := x.val.symm x_k
  let k_sub_1 : Finset.Icc 2 (2*n-1) := ⟨k-1, by {
    suffices k.val ≠ 1 ∧ k.val ≠ 2 by
      let := one_le_val _ k
      grind
    and_intros
    · contrapose! ndiff
      replace ndiff : k = 1 := by exact SetLike.coe_eq_coe.mp ndiff
      rw [show x_1 = (x.val 1) by rfl]
      rw [show x_k = (x.val 1) by rw [<-ndiff]; unfold k; simp]
      simp
      grind only [= Finset.mem_Icc]
    · unfold A T at x
      let := (not_exists.mp $ Set.mem_setOf_eq.mp x.prop) 1
      simp only [Set.mem_setOf_eq, Nat.reduceAdd, Finset.mem_Icc, le_refl, true_and,
        not_exists] at this
      contrapose! this
      use (by grind)
      rw [show (x.val ⟨1, _⟩) = x_1 by rfl]
      rw [show (x.val ⟨2, _⟩) = x_k by unfold k at this; simp_rw [<-this]; simp]
      exact ndiff
  }⟩
  use ⟨(partial_cycle n ⟨k-1, by grind⟩) x, k_sub_1⟩
  intro j
  constructor
  · intro jeq
    simp_rw [<-jeq]
    nth_rw 1 [partial_cycle.apply_of_eq _ _ _ _ (by unfold k_sub_1; simp)]
    nth_rw 1 [partial_cycle.apply_of_gt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; grind)]
    unfold k_sub_1
    simp only [one_le_val, Nat.sub_add_cancel, Subtype.coe_eta]
    rw [show (x.val 1) = x_1 by rfl]
    rw [show (x.val k) = x_k by unfold k; simp]
    exact ndiff
  · intro e
    contrapose e
    unfold k_sub_1 at e
    simp only at e
    have : j.val = k.val-2 ∨ j.val < k.val-2 ∨ j.val ≥ k.val := by lia
    apply this.elim3
    · intro jeq
      simp_rw [jeq]
      nth_rw 1 [partial_cycle.apply_of_lt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; lia)]
      nth_rw 1 [partial_cycle.apply_of_eq _ _ _ _ (by lia)]
      unfold x_1 at ndiff
      rw [Nat.dist_comm]
      rw [unique_ndiff] at ⊢ ndiff
      rw [<-ndiff]
      simp
      rw [show x_k = (x.val k) by unfold k; simp]
      have : ⟨k-2+1, by grind⟩ ≠ k := by rw [<-Subtype.coe_ne_coe]; grind
      contrapose! this
      apply x.val.injective this
    · intro jlt
      nth_rw 1 [partial_cycle.apply_of_lt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; simp; lia)]
      nth_rw 1 [partial_cycle.apply_of_lt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; simp; lia)]
      apply not_exists.mp $ (not_exists.mp $ Set.mem_setOf_eq.mp x.prop) _
      grind only [= Finset.mem_Icc]
    · intro jgt
      nth_rw 1 [partial_cycle.apply_of_gt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; simp; lia)]
      nth_rw 1 [partial_cycle.apply_of_gt _ _ _ _ (by rw [<-Subtype.coe_lt_coe]; simp; lia)]
      apply not_exists.mp $ (not_exists.mp $ Set.mem_setOf_eq.mp x.prop) _
      grind only [= Finset.mem_Icc]


def transform_B_to_A [NeZero n] : (B n) → (A n) := fun ⟨⟨x, k⟩, h⟩ ↦ by
  let x_k := x ⟨k, by grind⟩
  let x_k_1 := x ⟨k+1, by grind⟩
  have ndiff : (x_k : ℕ).dist x_k_1 = n := by
    unfold B at h
    simp only [Subtype.forall, Set.mem_setOf_eq] at h
    apply (h _ _).mp
    · rfl
    · grind only [= Finset.mem_Icc]
  use (partial_cycle n ⟨k, by grind⟩).symm x
  unfold A T
  simp only [Finset.mem_Icc, not_exists, forall_and_index, Set.mem_setOf_eq]
  intro i ib1 ib2
  by_cases c1 : i = 1
  · subst c1
    nth_rw 1 [partial_cycle.symm.apply_of_eq _ _ _ _ (by rfl)]
    nth_rw 1 [partial_cycle.symm.apply_of_le _ _ _ _ (by simp; grind) (by rw [<-Subtype.coe_lt_coe]; exact Nat.lt_add_one _)]
    simp only [Nat.reduceAdd, Nat.add_one_sub_one]
    rw [unique_ndiff] at ⊢ ndiff
    rw [<-ndiff]
    unfold x_k_1
    simp only [SetLike.coe_eq_coe]
    by_contra
    simp only [EmbeddingLike.apply_eq_iff_eq, Subtype.mk.injEq, Nat.right_eq_add] at this
    grind only [= Finset.mem_Icc]
  have igt : 1 < i := by grind
  by_cases cik : i = k
  · subst cik
    nth_rw 1 [partial_cycle.symm.apply_of_le _ _ _ _ (by rfl) (by simpa using igt)]
    nth_rw 1 [partial_cycle.symm.apply_of_gt _ _ _ _ (by simp)]
    simp only [ne_eq]
    rw [Nat.dist_comm] at ⊢ ndiff
    rw [unique_ndiff] at ⊢ ndiff
    rw [<-ndiff]
    unfold x_k
    simp
    rw [Nat.sub_one_eq_self]
    exact Nat.ne_zero_of_lt ib1
  by_cases c2 : i < k
  · nth_rw 1 [partial_cycle.symm.apply_of_le _ _ _ _ (by simp; grind) (by simpa using igt)]
    nth_rw 1 [partial_cycle.symm.apply_of_le _ _ _ _ (by simpa using c2) (by rw [<-Subtype.coe_lt_coe]; exact Nat.lt_add_of_pos_left ib1)]
    simp only [add_tsub_cancel_right]
    unfold B at h
    simp only [Subtype.forall, Set.mem_setOf_eq] at h
    have : ∀ h, (⟨i, h⟩ : Finset.Icc 1 (2 * n)) = ⟨i-1+1, by grind⟩ := by lia
    simp_rw [this]
    apply (h _ _).not.mp
    · grind only
    · grind only [= Finset.mem_Icc]
  · have c2 : k < i := by grind
    nth_rw 1 [partial_cycle.symm.apply_of_gt _ _ _ _ (by simpa using c2)]
    nth_rw 1 [partial_cycle.symm.apply_of_gt _ _ _ _ (by simp; lia)]
    unfold B at h
    simp only [Subtype.forall, Set.mem_setOf_eq] at h
    apply (h _ _).not.mp
    · exact Nat.ne_of_lt c2
    · grind only [= Finset.mem_Icc]


def A_equiv_B [NeZero n] : Equiv (A n) (B n) := {
  toFun := transform_A_to_B n
  invFun := transform_B_to_A n
  left_inv x := by
    unfold transform_A_to_B transform_B_to_A
    refine SetCoe.ext ?_
    simp only
    rw [<-Perm.mul_apply, Perm.mul_def, trans_eq_refl_iff_eq_symm.mpr] <;> simp
  right_inv := fun ⟨⟨x, k⟩, h⟩ ↦ by
    unfold transform_A_to_B transform_B_to_A
    simp only [Subtype.mk.injEq, Prod.mk.injEq]
    and_intros
    · rw [<-Perm.mul_apply, Perm.mul_def, trans_eq_refl_iff_eq_symm.mpr]
      · simp
      · congr
        simp_rw [partial_cycle.symm.apply_of_eq n _ _ 1 rfl]
        unfold B at h
        simp only [Subtype.forall, Set.mem_setOf_eq] at h
        replace h := (h k (by grind)).mp rfl
        rw [unique_ndiff] at h
        simp_rw [<-h]
        simp only [Subtype.coe_eta]
        refine (Nat.eq_sub_of_add_eq ?_)
        let k_add_1 : Finset.Icc 1 (2*n) := ⟨k+1, by grind⟩
        simp_rw [show ↑k + 1 = k_add_1.val by grind]
        simp only [Subtype.coe_eta, SetLike.coe_eq_coe]
        rw [Eq.comm, apply_eq_iff_eq_symm_apply, symm_symm]
        rw [partial_cycle.symm.apply_of_gt n _ _ _ (by unfold k_add_1; simp)]
    · simp_rw [partial_cycle.symm.apply_of_eq n _ _ 1 rfl]
      unfold B at h
      simp only [Subtype.forall, Set.mem_setOf_eq] at h
      replace h := (h k (by grind)).mp rfl
      rw [unique_ndiff] at h
      simp_rw [<-h]
      simp only [Subtype.coe_eta]
      rw [<-Subtype.val_inj]
      refine Eq.symm (Nat.eq_sub_of_add_eq ?_)
      let k_add_1 : Finset.Icc 1 (2*n) := ⟨k+1, by grind⟩
      simp_rw [show ↑k + 1 = k_add_1.val by grind]
      simp only [Subtype.coe_eta, SetLike.coe_eq_coe]
      rw [Eq.comm, apply_eq_iff_eq_symm_apply, symm_symm]
      rw [partial_cycle.symm.apply_of_gt n _ _ _ (by unfold k_add_1; simp)]
}

def embed_B : (B n) ↪ {x | T n x} := {
  toFun b := by
    let ⟨⟨x, k⟩, h⟩ := b
    use x
    unfold T
    use k, ?_
    · unfold B at h
      simp only [Subtype.forall, Set.mem_setOf_eq] at h
      apply (h _ _).mp rfl
      grind
    · grind
  inj' x1 x2 e := by
    simp at e
    have eq_perm : x1.val.1 = x2.val.1 := by exact Equiv.coe_inj.mp (congrArg DFunLike.coe e)
    apply Subtype.ext
    apply Prod.ext
    · exact eq_perm
    · let p1 := x1.prop
      let p2 := x2.prop
      unfold B at p1 p2
      simp only [Subtype.forall, Set.mem_setOf_eq] at p1 p2
      let := (p1 x2.val.2 (by grind))
      simp only [SetLike.coe_eq_coe] at this
      rw [this]
      let := (p1 x1.val.2 (by grind)).mp rfl
      rw [eq_perm]
      apply (p2 x2.val.2 (by grind)).mp
      rfl
}

theorem embed_B.not_Surjective [NeZero n] : ¬ Function.Surjective (embed_B n) := by
  have npos := Nat.pos_of_neZero n
  rw [Function.Surjective, not_forall]
  let swap2 (i : Finset.Icc 1 (2*n)) : Finset.Icc 1 (2*n) :=
    if i.val = 2 then
      ⟨1+n, by grind⟩
    else if i.val = 1+n then
      ⟨2, by grind⟩
    else
      i
  let x : Perm (Finset.Icc 1 (2*n)) := {
    toFun := swap2
    invFun := swap2
    left_inv i := by
      unfold swap2
      split_ifs <;> grind
    right_inv i := by
      unfold swap2
      split_ifs <;> grind
  }
  have Tx1 : (x ⟨1, by grind⟩ : ℕ).dist (x ⟨1+1, by grind⟩) = n := by
    unfold x swap2
    simp only [coe_fn_mk, OfNat.one_ne_ofNat, ↓reduceIte, Nat.left_eq_add, Nat.reduceAdd]
    rw [ite_eq_right_iff.mpr (by grind)]
    simp [Nat.dist_eq_sub_of_le]
  use ⟨x, by unfold T; exists 1, (by grind)⟩
  by_contra ⟨⟨⟨y, k⟩, h⟩, h'⟩
  unfold embed_B at h'
  simp at h'
  subst y
  unfold B at h
  simp only [Subtype.forall, Set.mem_setOf_eq] at h
  let := (h k (by grind)).mp rfl
  unfold x swap2 at this
  simp only [coe_fn_mk, Nat.reduceEqDiff] at this
  split_ifs at this <;> grind

theorem embed_B.card [NeZero n] : (B n).ncard < {x | T n x}.ncard := by
  rw [<-Set.ncard_coe, <-Set.ncard_image_of_injective Set.univ (embed_B n).injective]
  apply Set.ncard_lt_card
  simp only [Set.coe_setOf, Set.image_univ, ne_eq]
  rw [Set.range_eq_univ]
  apply embed_B.not_Surjective




theorem imo1989_p6 (npos : 0 < n) : {x | T n x}.ncard > {x | ¬ T n x}.ncard := by
  have : NeZero n := NeZero.of_pos npos
  calc
    _ > (B n).ncard := by
      exact embed_B.card n
    _ = (A n).ncard := by
      rw [Set.ncard_congr']
      exact (A_equiv_B n).symm
    _ = _ := by rw [A]


end Imo1989P6

-- ═══ Imo1991P2 ═══

/-
Copyright (c) 2025 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 1991, Problem 2

Let n > 6 be an integer and a₁, a₂, ..., aₖ be all the
natural numbers less than n and relatively prime to n.
If

  a₂ - a₁ = a₃ - a₂ = ... = aₖ - aₖ₋₁ > 0,

prove that n must either be a prime number of a power
of 2.
-/

namespace Imo1991P2



lemma exists_powerOfTwo_mul_odd (n : ℕ) (hn : 0 < n) :
  ∃ t l : ℕ, n = 2 ^ t * l ∧ ¬2 ∣ l := by
  induction' n using Nat.case_strong_induction_on with n' hn'
  · lia
  · by_cases! hn'' : 2 ∣ n' + 1
    · rcases exists_eq_mul_left_of_dvd hn'' with ⟨m, hm⟩
      rcases hn' m (by lia : _) (by lia : _) with ⟨t', l', ht'l', hl'⟩
      use t' + 1, l'
      constructor
      · rw [hm, ht'l']
        ring
      · exact hl'
    · use 0, n' + 1
      lia

lemma aux {l n s t: ℕ} (hl : ¬2 ∣ l) (hs : s ≠ 0) (hn : n = 2 ^ t * l) :
  Nat.Coprime (l + 2 ^ s) n := by
  by_contra h'
  rw [Nat.Prime.not_coprime_iff_dvd] at h'
  rcases h' with ⟨p, hp, hp', hp''⟩
  rw [hn] at hp''
  have hp2 := dvd_mul_of_dvd_right hp' (2 ^ t)
  rw [mul_add, ← Nat.dvd_add_iff_right hp'', ← pow_add] at hp2
  apply Nat.prime_eq_prime_of_dvd_pow hp Nat.prime_two at hp2
  have h2s := dvd_pow_self 2 hs
  rw [hp2, ← Nat.dvd_add_iff_left h2s] at hp'
  contrapose! hl
  exact hp'



theorem imo1991_p2 (n : ℕ) (hn : 6 < n)
    (k : ℕ) (a : Fin k → ℕ)
    (ha1 : { a i | i } = { m | Nat.Coprime m n ∧ m < n })
    (d : ℕ) (hd : 0 < d)
    (ha2 : ∀ i : Fin k, (h : i + 1 < k) → a i + d = a ⟨i + 1, h⟩) :
    n.Prime ∨ n.isPowerOfTwo := by
  have hk : k ≠ 0 := by
    intro hk'
    have h': { a i | i } = ∅ := by
      apply Set.eq_empty_of_forall_notMem
      intro x
      dsimp
      push_neg
      intro i
      rw [hk'] at i
      apply finZeroElim i
    rw [h'] at ha1
    contrapose! ha1
    use 1
    constructor
    · exact Nat.coprime_one_left n
    · lia
  haveI : NeZero k := { out := hk }
  have ha : ∀ (i : ℕ) (hi : i < k), a ⟨i, hi⟩ = a 0 + i * d := by
    intro i hi
    induction' i with i' hi'
    · rw [zero_mul, add_zero]
      rfl
    · have hi'' : i' < k := lt_trans' hi (lt_add_one i')
      rw [← ha2 ⟨i', hi''⟩, hi' hi'']
      ring
  have h : ∃ a₀ : ℕ, ∀ m : ℕ, (Nat.Coprime m n ∧ m < n ↔ ∃ (i : ℕ), i < k ∧ m = a₀ + i * d) := by
    use a 0
    intro m
    constructor
    · rintro hm
      have hm'' : m ∈ {m | m.Coprime n ∧ m < n} := hm
      rw [← ha1] at hm''
      rcases hm'' with ⟨i, hi⟩
      use i.val
      constructor
      · exact Fin.isLt i
      · rw [← hi]
        apply ha
    · rintro ⟨i, hik, hi⟩
      have hm : m ∈ { a i | i } := by
        use ⟨i, hik⟩
        rw [hi]
        apply ha
      rw [ha1] at hm
      exact hm
  rcases h with ⟨a₀, ha₀⟩
  have h1 : Nat.Coprime 1 n ∧ 1 < n := by
    constructor
    · apply Nat.coprime_one_left
    · lia
  have hn_sub_1 : Nat.Coprime (n - 1) n ∧ (n - 1) < n := by
    constructor
    · rw [Nat.coprime_self_sub_left (by lia : _)]
      apply Nat.coprime_one_left
    · lia
  rw [ha₀] at h1 hn_sub_1
  rcases h1 with ⟨i1, hi1k, hi1⟩
  rcases hn_sub_1 with ⟨in_sub_1, hin_sub_1k, hin_sub_1⟩
  have h' : ∀ m : ℕ, 0 < m ∧ m < n → (Nat.Coprime m n ↔ m ≡ 1 [MOD d]):= by
    rintro m ⟨hm, hm'⟩
    constructor
    · intro hm''
      rcases (ha₀ m).mp ⟨hm'', hm'⟩ with ⟨i, hik, hi⟩
      rw [hi, hi1]
      rw [Nat.add_mul_modulus_modEq_iff, Nat.modEq_add_mul_modulus_iff]
    · intro hm''
      rw [Nat.ModEq.comm, Nat.modEq_iff_dvd' (by lia : _), dvd_iff_exists_eq_mul_left] at hm''
      rcases hm'' with ⟨i', hi'⟩
      rw [Nat.sub_eq_iff_eq_add (by lia : _), hi1, add_left_comm, ← add_mul] at hi'
      have him: ∃ i < k, m = a₀ + i * d := by
        use i' + i1
        constructor
        · apply lt_of_lt_of_le' hin_sub_1k
          rw [← Nat.mul_le_mul_right_iff hd, ← @Nat.add_le_add_iff_left _ _ a₀]
          lia
        · exact hi'
      exact ((ha₀ m).mpr him).left
  by_cases! hn' : 2 ∣ n
  · right
    rcases exists_powerOfTwo_mul_odd n (by lia : _) with ⟨t, l, htl, hl⟩
    by_cases! hl' : l = 1
    · rw [hl', mul_one] at htl
      rw [htl]
      use t
    · exfalso
      have ht : 0 < t := by lia
      have hl'' : l + 4 < n := by
        by_cases! ht' : t = 1
        · lia
        · rw [htl]
          calc l + 4
              < 2 ^ 2 * l := by lia
            _ ≤ 2 ^ t * l := by
              apply Nat.mul_le_mul_right
              exact Nat.pow_le_pow_right (by norm_num : _) (by lia : _)
      have hl_add_2 : Nat.Coprime (l + 2 ^ 1) n := aux hl (by norm_num : 1 ≠ 0) htl
      have hl_add_4 : Nat.Coprime (l + 2 ^ 2) n := aux hl (by norm_num : 2 ≠ 0) htl
      norm_num at hl_add_2 hl_add_4
      rw [h' (l + 2) (by lia : _)] at hl_add_2
      rw [h' (l + 4) (by lia : _), Nat.ModEq.comm] at hl_add_4
      have hl2 := Nat.ModEq.trans hl_add_2 hl_add_4
      rw [Nat.modEq_iff_dvd' (by lia : _), Nat.sub_add_eq, add_comm, Nat.add_sub_cancel] at hl2
      norm_num at hl2
      rw [dvd_iff_exists_eq_mul_left] at hl2
      rcases hl2 with ⟨c, hc⟩
      rw [hc, Nat.add_mul_modulus_modEq_iff] at hl_add_2
      rw [← h' l (by lia : _)] at hl_add_2
      contrapose hl_add_2
      apply Nat.not_coprime_of_dvd_of_dvd (by lia : 1 < l) (dvd_rfl)
      rw [htl]
      apply dvd_mul_left
  · left
    apply Nat.prime_of_coprime n (by lia : _)
    intro m hm hm'
    have h2 : Nat.Coprime 2 n := by
      rw [Nat.Prime.coprime_iff_not_dvd Nat.prime_two]
      exact hn'
    rw [h' 2 (by lia : _), Nat.ModEq.comm, Nat.modEq_iff_dvd' (by lia : _)] at h2
    norm_num at h2
    rw [Nat.coprime_comm, h' m (by lia : _)]
    rw [h2]
    apply Nat.modEq_one

end Imo1991P2

-- ═══ Imo1991P5 ═══

/-
Copyright (c) 2025 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 1991, Problem 5

Let ABC be a triangle and P be an interior point of ABC.
Show that at least one of the angles ∠PAB, ∠PBC, ∠PCA is
less than or equal to 30°.

-/

namespace Imo1991P5

open scoped Affine EuclideanGeometry Real



lemma mul3_le_add3_div_three_pow_three {a b c : ℝ}
    (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c)
    : (a * b * c) ≤ ((a + b + c) / 3) ^ 3 := by
    have h := Real.geom_mean_le_arith_mean3_weighted
      (by norm_num : (0 : ℝ) ≤ 1 / 3)
      (by norm_num : (0 : ℝ) ≤ 1 / 3)
      (by norm_num : (0 : ℝ) ≤ 1 / 3)
      ha hb hc (by norm_num)
    rw [← Real.mul_rpow ha hb, ← Real.mul_rpow (by positivity) hc] at h
    nth_rw 1 [one_div] at h
    rw [Real.rpow_inv_le_iff_of_pos (by positivity) (by positivity) (by norm_num)] at h
    rw [← mul_add, ← mul_add, div_mul_comm, mul_one, Real.rpow_ofNat] at h
    exact h

lemma map_mean3_le_mean3_map_of_concaveOn
    {s : Set ℝ} {f : ℝ → ℝ}
    (hf : ConcaveOn ℝ s f) {a b c : ℝ}
    (ha : a ∈ s) (hb : b ∈ s) (hc : c ∈ s)
    : (f a + f b + f c) / 3 ≤ f ((a + b + c) / 3) := by
  set w := fun i : Fin 3 ↦ (1 : ℝ) / 3 with hw
  set p := ![a, b, c] with hp
  have h₀ : ∀ i ∈ Finset.univ, 0 ≤ w i := by
    intro i hi
    rw [hw]
    dsimp
    norm_num
  have h₁ : ∑ i ∈ Finset.univ, w i = 1 := by
    rw [Fin.sum_univ_three, hw]
    dsimp
    norm_num
  have hmem : ∀ i ∈ Finset.univ, p i ∈ s := by
    intro i hi
    rw [hp]
    fin_cases i <;> dsimp
    · exact ha
    · exact hb
    · exact hc
  have h := ConcaveOn.le_map_sum hf h₀ h₁ hmem
  rw [Fin.sum_univ_three, Fin.sum_univ_three, hw, hp] at h
  dsimp at h
  rw [← mul_add, ← mul_add, ← mul_add, ← mul_add, div_mul_comm, mul_one, div_mul_comm, mul_one] at h
  exact h

lemma one_div_two_lt_sin {a : ℝ}
    (ha : π / 6 < a) (ha' : a < 5 * π / 6)
    : 1 / 2 < Real.sin a := by
    rw [← Real.sin_pi_div_six]
    by_cases! h : a < π / 2
    · apply Real.sin_lt_sin_of_lt_of_le_pi_div_two (by linarith) (by linarith) ha
    · nth_rw 2 [← Real.sin_pi_sub]
      apply Real.sin_lt_sin_of_lt_of_le_pi_div_two (by linarith) (by linarith) (by linarith)

theorem analytic_version {a₁ a₂ a₃ b₁ b₂ b₃ : ℝ}
    (hb₁ : 0 ≤ b₁) (hb₂ : 0 ≤ b₂) (hb₃ : 0 ≤ b₃)
    (hab : a₁ + a₂ + a₃ + b₁ + b₂ + b₃ = π)
    (h : Real.sin a₁ * Real.sin a₂ * Real.sin a₃ = Real.sin b₁ * Real.sin b₂ * Real.sin b₃)
    : a₁ ≤ π / 6 ∨ a₂ ≤ π / 6 ∨ a₃ ≤ π / 6 := by
  contrapose! h
  rcases h with ⟨ha₁', ha₂', ha₃'⟩
  apply ne_of_gt
  trans (1 / 2) ^ 3
  · have hsinb₁ := Real.sin_nonneg_of_nonneg_of_le_pi hb₁ (by linarith)
    have hsinb₂ := Real.sin_nonneg_of_nonneg_of_le_pi hb₂ (by linarith)
    have hsinb₃ := Real.sin_nonneg_of_nonneg_of_le_pi hb₃ (by linarith)
    apply lt_of_le_of_lt (mul3_le_add3_div_three_pow_three hsinb₁ hsinb₂ hsinb₃)
    rw [pow_lt_pow_iff_left₀ (by positivity) (by norm_num) (by norm_num)]
    have hb₁' : b₁ ∈ Set.Icc 0 π := by
      rw [Set.mem_Icc]
      constructor <;> linarith
    have hb₂' : b₂ ∈ Set.Icc 0 π := by
      rw [Set.mem_Icc]
      constructor <;> linarith
    have hb₃' : b₃ ∈ Set.Icc 0 π := by
      rw [Set.mem_Icc]
      constructor <;> linarith
    apply lt_of_le_of_lt (map_mean3_le_mean3_map_of_concaveOn
      strictConcaveOn_sin_Icc.concaveOn hb₁' hb₂' hb₃')
    rw [← Real.sin_pi_div_six]
    apply Real.sin_lt_sin_of_lt_of_le_pi_div_two (by linarith) (by linarith) (by linarith)
  · rw [pow_three']
    have ha₁'' : a₁ < 5 * π / 6 := by linarith
    have ha₂'' : a₂ < 5 * π / 6 := by linarith
    have ha₃'' : a₃ < 5 * π / 6 := by linarith
    apply mul_lt_mul'' _ (one_div_two_lt_sin ha₃' ha₃'') (by norm_num) (by norm_num)
    apply mul_lt_mul'' _ (one_div_two_lt_sin ha₂' ha₂'') (by norm_num) (by norm_num)
    apply one_div_two_lt_sin ha₁' ha₁''

-- Trigonometric Form of Ceva's Theorem
theorem trigonometric_ceva
    (A B C P : EuclideanSpace ℝ (Fin 2))
    (hABC : AffineIndependent ℝ ![A, B, C])
    : Real.sin (∠ P A B) * Real.sin (∠ P B C) * Real.sin (∠ P C A)
      = Real.sin (∠ A B P) * Real.sin (∠ B C P) * Real.sin (∠ C A P) := by
  have hAneB := (hABC.injective.ne (by decide : (0 : Fin 3) ≠ 1))
  have hBneC := (hABC.injective.ne (by decide : (1 : Fin 3) ≠ 2))
  have hCneA := (hABC.injective.ne (by decide : (2 : Fin 3) ≠ 0))
  dsimp [-ne_eq] at hAneB hBneC hCneA
  by_cases! h : P = A ∨ P = B ∨ P = C
  · casesm* _ ∨ _
    · rw [h]
      rw [EuclideanGeometry.angle_self_of_ne hAneB]
      rw [EuclideanGeometry.angle_self_of_ne hCneA.symm]
      rw [Real.sin_zero]
      ring
    · rw [h]
      rw [EuclideanGeometry.angle_self_of_ne hBneC]
      rw [EuclideanGeometry.angle_self_of_ne hAneB.symm]
      rw [Real.sin_zero]
      ring
    · rw [h]
      rw [EuclideanGeometry.angle_self_of_ne hCneA]
      rw [EuclideanGeometry.angle_self_of_ne hBneC.symm]
      rw [Real.sin_zero]
      ring
  · rcases h with ⟨hPA, hPB, hPC⟩
    have hAB := EuclideanGeometry.law_sin A B P
    have hBC := EuclideanGeometry.law_sin B C P
    have hCA := EuclideanGeometry.law_sin C A P
    rw [dist_comm] at hAB hBC hCA
    rw [← dist_ne_zero] at hPA hPB hPC
    rw [← eq_div_iff hPB] at hAB
    rw [← eq_div_iff hPC] at hBC
    rw [← eq_div_iff hPA] at hCA
    rw [hAB, hBC, hCA]
    field

lemma angle_eq_angle_add_angle_of_mem_interior
    {A B C P : EuclideanSpace ℝ (Fin 2)}
    (hABC : AffineIndependent ℝ ![A, B, C])
    (hP : P ∈ interior (convexHull ℝ {A, B, C}))
    : ∠ A B C = ∠ A B P + ∠ P B C := by
  have htot' : affineSpan ℝ (Set.range ![A, B, C]) = ⊤ := by
    rw [AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial]
    apply AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one hABC
    rw [finrank_euclideanSpace]
    simp only [Nat.succ_eq_add_one, zero_add, Nat.reduceAdd, Fintype.card_fin]
  set basis := AffineBasis.mk _ hABC htot' with h_basis
  have h_range : {A, B, C} = Set.range basis := by
    rw [h_basis, DFunLike.coe, AffineBasis.instFunLike]
    simp
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm]
  rw [h_range, AffineBasis.interior_convexHull] at hP
  dsimp at hP
  repeat rw [EuclideanGeometry.angle]
  have hA : A = basis 0 := by
    rw [h_basis, DFunLike.coe, AffineBasis.instFunLike]
    simp
  have hB : B = basis 1 := by
    rw [h_basis, DFunLike.coe, AffineBasis.instFunLike]
    simp
  have hC : C = basis 2 := by
    rw [h_basis, DFunLike.coe, AffineBasis.instFunLike]
    simp
  have hPB : P -ᵥ B ≠ 0 := by
    rw [vsub_eq_zero_iff_eq.ne]
    contrapose! hP
    use 0
    rw [hP, hB, AffineBasis.coord_apply_ne basis (by norm_num)]
  rw [InnerProductGeometry.angle_eq_angle_add_angle_iff hPB]
  right
  rw [Submodule.mem_span_pair]
  have hsum := AffineBasis.linear_combination_coord_eq_self basis P
  have hsum' := AffineBasis.sum_coord_apply_eq_one basis P
  rw [Fin.sum_univ_three] at hsum hsum'
  use ⟨(basis.coord 0) P, le_of_lt (hP 0)⟩
  use ⟨(basis.coord 2) P, le_of_lt (hP 2)⟩
  rw [NNReal.smul_def, NNReal.smul_def, NNReal.toReal, Subtype.val, Subtype.val]
  dsimp
  nth_rw 3 [← hsum]
  rw [smul_sub, smul_sub]
  rw [← hA, ← hB, ← hC, ← sub_eq_zero]
  abel_nf
  rw [← add_assoc, ← add_assoc]
  rw [← smul_add, ← smul_add, ← add_smul, ← add_smul, add_right_comm]
  rw [hsum', one_smul, neg_smul, one_smul, neg_add_cancel]

lemma affineIndependent_rotate {A B C : EuclideanSpace ℝ (Fin 2)}
    (hABC : AffineIndependent ℝ ![A, B, C])
    : AffineIndependent ℝ ![B, C, A] := by
  rw [affineIndependent_iff_not_collinear_set] at hABC ⊢
  rw [Set.pair_comm, Set.insert_comm]
  exact hABC

lemma sum_angle {A B C P : EuclideanSpace ℝ (Fin 2)}
    (hABC : AffineIndependent ℝ ![A, B, C])
    (hP : P ∈ interior (convexHull ℝ {A, B, C}))
    : ∠ P A B + ∠ P B C + ∠ P C A + ∠ A B P + ∠ B C P + ∠ C A P = π := by
  rw [← EuclideanGeometry.angle_add_angle_add_angle_eq_pi
    C (hABC.injective.ne (by decide : (1 : Fin 3) ≠ 0))]
  dsimp
  rw [angle_eq_angle_add_angle_of_mem_interior hABC hP]
  apply affineIndependent_rotate at hABC
  rw [Set.insert_comm, Set.pair_comm] at hP
  rw [angle_eq_angle_add_angle_of_mem_interior hABC hP]
  apply affineIndependent_rotate at hABC
  rw [Set.insert_comm, Set.pair_comm] at hP
  rw [angle_eq_angle_add_angle_of_mem_interior hABC hP]
  ring



theorem imo1991_p5
    (A B C P : EuclideanSpace ℝ (Fin 2))
    (hABC : AffineIndependent ℝ ![A, B, C])
    (hP : P ∈ interior (convexHull ℝ {A, B, C})) :
    ∠ P A B ≤ π / 6 ∨ ∠ P B C ≤ π / 6 ∨ ∠ P C A ≤ π / 6 := by
  have hsum := sum_angle hABC hP
  have hsin := trigonometric_ceva A B C P hABC
  apply analytic_version
    (EuclideanGeometry.angle_nonneg _ _ _)
    (EuclideanGeometry.angle_nonneg _ _ _)
    (EuclideanGeometry.angle_nonneg _ _ _)
    hsum hsin

end Imo1991P5

-- ═══ Imo1994P1 ═══

/-
Copyright (c) 2021 Antoine Labelle. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Labelle
-/




/-!
# International Mathmatical Olympiad 1994, Problem 1

Let `m` and `n` be two positive integers.
Let `a₁, a₂, ..., aₘ` be `m` different numbers from the set `{1, 2, ..., n}`
such that for any two indices `i` and `j` with `1 ≤ i ≤ j ≤ m` and `aᵢ + aⱼ ≤ n`,
there exists an index `k` such that `aᵢ + aⱼ = aₖ`.
Show that `(a₁+a₂+...+aₘ)/m ≥ (n+1)/2`
-/

open Finset

namespace Imo1994P1


/-
# Sketch of solution

We can order the numbers so that `a₁ ≤ a₂ ≤ ... ≤ aₘ`.
The key idea is to pair the numbers in the sum and show that `aᵢ + aₘ₊₁₋ᵢ ≥ n+1`.
Indeed, if we had `aᵢ + aₘ₊₁₋ᵢ ≤ n`, then `a₁ + aₘ₊₁₋ᵢ, a₂ + aₘ₊₁₋ᵢ, ..., aᵢ + aₘ₊₁₋ᵢ`
would be `m` elements of the set of `aᵢ`'s all larger than `aₘ₊₁₋ᵢ`, which is impossible.
-/

theorem tedious (m : ℕ) (k : Fin (m + 1)) : m - ((m + 1 - ↑k) + m) % (m + 1) = ↑k := by
  obtain ⟨k, hk⟩ := k
  rw [Nat.lt_succ_iff, le_iff_exists_add] at hk
  rcases hk with ⟨c, rfl⟩
  have : (k + c + 1 - k) + (k + c) = c + (k + c + 1) := by lia
  rw [Fin.val_mk, this, Nat.add_mod_right, Nat.mod_eq_of_lt, Nat.add_sub_cancel]
  lia



theorem imo1994_p1 (n : ℕ) (m : ℕ) (A : Finset ℕ) (hm : A.card = m + 1)
    (hrange : ∀ a ∈ A, 0 < a ∧ a ≤ n)
    (hadd : ∀ a ∈ A, ∀ b ∈ A, a + b ≤ n → a + b ∈ A) :
    (m + 1) * (n + 1) ≤ 2 * ∑ x ∈ A, x := by
  set a := orderEmbOfFin A hm
  -- We sort the elements of `A`
  have ha : ∀ i, a i ∈ A := fun i => orderEmbOfFin_mem A hm i
  set rev := Equiv.subLeft (Fin.last m)
  -- `i ↦ m-i`
  -- We reindex the sum by fin (m+1)
  have : ∑ x ∈ A, x = ∑ i : Fin (m + 1), a i := by
    convert sum_image fun x _ y _ => a.eq_iff_eq.1
    rw [← coe_inj]; simp [a]
  rw [this]; clear this
  -- The main proof is a simple calculation by rearranging one of the two sums
  suffices hpair : ∀ k ∈ univ, a k + a (rev k) ≥ n + 1 by calc
    2 * ∑ i : Fin (m + 1), a i = ∑ i : Fin (m + 1), a i + ∑ i : Fin (m + 1), a i := two_mul _
    _ = ∑ i : Fin (m + 1), a i + ∑ i : Fin (m + 1), a (rev i) := by rw [Equiv.sum_comp rev]
    _ = ∑ i : Fin (m + 1), (a i + a (rev i)) := sum_add_distrib.symm
    _ ≥ ∑ i : Fin (m + 1), (n + 1) := (sum_le_sum hpair)
    _ = (m + 1) * (n + 1) := by rw [sum_const, card_fin, Nat.nsmul_eq_mul]
  -- It remains to prove the key inequality, by contradiction
  rintro k -
  by_contra! h : a k + a (rev k) < n + 1
  -- We exhibit `k+1` elements of `A` greater than `a (rev k)`
  set f : Fin (m + 1) ↪ ℕ :=
    ⟨fun i => a i + a (rev k), by
      apply Function.Injective.of_eq_imp_le
      intro i j hij
      replace hij := Nat.le_of_eq hij
      rwa [add_le_add_iff_right, a.map_rel_iff] at hij ⟩
  -- Proof that the `f i` are greater than `a (rev k)` for `i ≤ k`
  have hf : map f (Icc 0 k) ⊆ map a.toEmbedding (Ioc (rev k) (Fin.last m)) := by
    intro x hx
    simp only [Equiv.subLeft_apply, a, rev] at h
    simp only [mem_map, mem_Icc, mem_Ioc, Fin.zero_le, true_and, Equiv.subLeft_apply,
      Function.Embedding.coeFn_mk, RelEmbedding.coe_toEmbedding, f, rev] at hx ⊢
    rcases hx with ⟨i, ⟨hi, rfl⟩⟩
    have h1 : a i + a (Fin.last m - k) ≤ n := by linarith only [h, a.monotone hi]
    have h2 : a i + a (Fin.last m - k) ∈ A := hadd _ (ha _) _ (ha _) h1
    rw [← mem_coe, ← range_orderEmbOfFin A hm, Set.mem_range] at h2
    obtain ⟨j, hj⟩ := h2
    refine ⟨j, ⟨?_, Fin.le_last j⟩, hj⟩
    rw [← a.strictMono.lt_iff_lt, hj]
    simpa using (hrange (a i) (ha i)).1
  -- A set of size `k+1` embed in one of size `k`, which yields a contradiction
  simpa [Fin.val_sub, tedious, rev] using card_le_card hf



end Imo1994P1

-- ═══ Imo1994P6 ═══

/-
Copyright (c) 2026 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Rydh
-/





/-!
# International Mathematical Olympiad 1994, Problem 6

Show that there exists a set A of positive integers with the following
property: For any infinite set S of primes there exist two positive integers
m ∈ A and n ∉ A each of which is a product of k distinct elements of S for
some k ≥ 2.

-/

namespace Imo1994P6

def IsProductOfkDistinctMembers (x : ℕ) (k : ℕ) (S : Set ℕ) : Prop :=
  ∃ S' : Finset S, S'.card = k ∧ x = ∏ p ∈ S', p.val



def Primes := { p : ℕ | p.Prime }
instance : Infinite Primes := Nat.infinite_setOf_prime.to_subtype
noncomputable def primes_iso : ℕ ≃o ↑Primes := Nat.Subtype.orderIsoOfNat Primes

-- Number of distinct prime factors of x
def ω : ℕ → ℕ := fun x ↦ (Nat.primeFactors x).card

lemma prod_of_primes {S : Set ℕ} {S' : Finset S} (h : ∀p ∈ S, p.Prime) :
  (∏ p ∈ S', p.val).primeFactors = S'.map ⟨Subtype.val, Subtype.val_injective⟩ := by
  have : ∏ p ∈ S', p.val = ∏ p ∈ S'.map ⟨Subtype.val, Subtype.val_injective⟩, p :=
    Eq.symm (Finset.prod_map S' { toFun := Subtype.val, inj' := Subtype.val_injective } fun x ↦ x)
  rw [this, Nat.primeFactors_prod]
  aesop

lemma orderiso_min_image {α : Type} [DecidableEq α] [LinearOrder α] (f : ℕ ≃o α) (k i : ℕ) (h₁ : 0 < k)
  : ((Finset.range k).image (fun j ↦ f (j + i))).min' (Finset.image_nonempty.mpr (Finset.nonempty_range_iff.mpr (Nat.ne_zero_of_lt h₁))) = f i := by
  let S := (Finset.range k).image (fun j ↦ f (j + i))
  have h_non_empty : S.Nonempty := by grind only [Finset.image_nonempty, Finset.nonempty_range_iff]
  have h' : S.min' h_non_empty = f i := by
    have h₄: ∀ j : ℕ, f i ≤ f (j + i) := by intro i ; aesop
    have h₅: f i ∈ S := by aesop
    have h₆: ∀x ∈ S, ∃j, x = f j := by grind
    rw [Finset.min'_eq_iff]
    grind
  grind only [Finset.coe_min']


lemma min_of_embedded {A : Set ℕ} (S : Finset A) (h : S.Nonempty) :
  (S.map ⟨Subtype.val, Subtype.val_injective⟩).min' (Finset.Nonempty.map h) = (S.min' h).val := by
  let T : Finset ℕ := S.map ⟨Subtype.val, Subtype.val_injective⟩
  apply le_antisymm
  · have hmem : (S.min' h).val ∈ T := by simp [T, Finset.min'_mem]
    exact Finset.min'_le T (↑(S.min' h)) hmem
  · apply Finset.le_min'
    intro x hx
    rcases Finset.mem_map.mp hx with ⟨y, hy, rfl⟩
    exact Finset.min'_le S y hy

lemma prod_of_distinct_members (k i : ℕ) (S : Set ℕ) (f : ℕ ≃o S) : IsProductOfkDistinctMembers (∏ p ∈ ((Finset.range k).image (fun j ↦ f (j+i))), p) k S := by
  unfold IsProductOfkDistinctMembers
  let Sₘ := (Finset.range k).image (fun j ↦ f (j+i))
  let m : ℕ := ∏ p ∈ Sₘ, p
  use Sₘ
  have hinj : (fun j ↦ (f (j + i))).Injective := by grind only [Function.not_injective_iff, OrderIso.apply_eq_iff_eq]
  have : Sₘ.card = k := by
    unfold Sₘ
    rw [Finset.card_image_of_injective (Finset.range k) hinj]
    grind
  constructor
  · exact this
  · constructor

lemma primeFactors_card  {S : Set ℕ} (k i : ℕ) (f : ℕ ≃o S) (h : ∀ s ∈ S, s.Prime) : ω (∏ p ∈ ((Finset.range k).image (fun j ↦ f (j+i))), p) = k := by
  let Sₙ := (Finset.range k).image (fun j ↦ f (j+i))
  let n : ℕ := ∏ p ∈ Sₙ, p
  unfold ω
  rw [prod_of_primes h]
  simp
  rw [Finset.card_image_of_injective]
  · exact Finset.card_range k
  · exact fun _ _ h => Nat.add_right_cancel (f.injective h)





theorem imo1994_p6 :
  ∃ A : Set ℕ, (∀ a ∈ A, 0 < a) ∧ ∀ S : Set ℕ, Infinite S ∧ (∀ p ∈ S, p.Prime) →
    ∃ k m n : ℕ, 2 ≤ k ∧
      (m ∈ A ∧ 0 < m ∧ IsProductOfkDistinctMembers m k S) ∧
      (n ∉ A ∧ 0 < n ∧ IsProductOfkDistinctMembers n k S) := by
  -- Solution based on https://prase.cz/kalva/imo/isoln/isoln946.html
  -- Note that https://artofproblemsolving.com/wiki/index.php/1994_IMO_Problems/Problem_6
  -- interprets the problem differently, allowing m and n to be products of different
  -- numbers of primes, which is not what the original wording suggests.

  let A : Set ℕ := { x | ∃ h : 1 < x, primes_iso ((ω x) - 1) < (Nat.primeFactors x).min' (Nat.nonempty_primeFactors.mpr h) }
  use A
  refine ⟨fun a ha ↦ ?_, ?_⟩
  · grind
  intro S ⟨hS_inf, hS_mem_prime⟩

  let pₛ := Nat.Subtype.orderIsoOfNat S

  -- Note: John Scholes' proof use the index of the smallest prime in S to construct k,
  -- but that might result in k being 1 (if 2 ∈ S). For that reason, we ignore the smallest
  -- prime in S, both when constructing k and when selecting prime factors for m and n.

  -- k is the number of factors to use when constructing m and n
  -- The order isomorphism is 0-based, so we add one
  let k := (primes_iso.symm ⟨pₛ 1, hS_mem_prime (pₛ 1).val (pₛ 1).val_prop⟩) + 1

  have hk_gt_two : 2 ≤ k := by
    unfold k
    simp
    have h₁ : 3 ≤ (pₛ 1).val := by
      have h : (pₛ 0).val < (pₛ 1).val := by
        simp_all only [Subtype.coe_lt_coe, OrderIso.lt_iff_lt, zero_lt_one, pₛ]
      have : (pₛ 0).val ∈ S := Subtype.coe_prop (pₛ 0)
      replace : (pₛ 0).val.Prime := hS_mem_prime (↑(pₛ 0)) this
      replace : 2 ≤ (pₛ 0).val := Nat.Prime.two_le this
      grind
    have h₂ : ∀ p, 3 ≤ p.val → 1 ≤ primes_iso.symm p := by
      intro p hp
      by_contra
      simp at this
      have : p.val = 2 := by
        unfold primes_iso at this
        have hq : ∀ q : ↑Primes, q ≤ p → (Nat.Subtype.orderIsoOfNat Primes).symm q ≤ (Nat.Subtype.orderIsoOfNat Primes).symm p := by
          exact fun _ hq ↦ (OrderIso.le_iff_le (Nat.Subtype.orderIsoOfNat Primes).symm).mpr hq
        rw [this] at hq
        replace hq : ∀ q ≤ p, (Nat.Subtype.orderIsoOfNat Primes).symm q = 0 := fun q a ↦ Nat.eq_zero_of_le_zero (hq q a)
        replace : p = Nat.Subtype.orderIsoOfNat Primes 0 := (OrderIso.symm_apply_eq (Nat.Subtype.orderIsoOfNat Primes)).mp this
        replace hq : ∀ q ≤ p, q = Nat.Subtype.orderIsoOfNat Primes 0 := fun q a ↦ (OrderIso.symm_apply_eq (Nat.Subtype.orderIsoOfNat Primes)).mp (hq q a)
        rw [←this] at hq
        let q : ↑Primes := ⟨2, Nat.prime_two⟩
        have hq_le : q ≤ p := Std.le_of_lt hp
        grind
      linarith
    exact Nat.one_le_of_lt (h₂ ⟨↑(pₛ 1), hS_mem_prime (↑(pₛ 1)) (Subtype.val_prop (pₛ 1))⟩ h₁)


  let Sⱼ := fun j ↦ (Finset.range k).image (fun i ↦ pₛ (i + j))

  have aux₁ {i : ℕ} : (primes_iso (ω (∏ p ∈ (Sⱼ i), p.val) - 1)).val = pₛ 1 := by
    rw [primeFactors_card k i pₛ hS_mem_prime]
    unfold k
    simp only [add_tsub_cancel_right, OrderIso.apply_symm_apply]

  have aux₃ {i : ℕ} : 1 < (∏ p ∈ (Sⱼ i), p.val) := by
    have hprime : ∀ x ∈ (Sⱼ i), x.val.Prime := by grind
    have h₁ : ∀ x ∈ (Sⱼ i), 1 < x.val := by intro x hx ; exact Nat.Prime.one_lt (hprime x hx)
    have h₂ : pₛ i ∈ (Sⱼ i) := by aesop
    have h₃ : 1 < (pₛ i).val := by grind
    have h₄ : ∃x ∈ (Sⱼ i), 1 < x.val := by use pₛ i
    exact (Finset.one_lt_prod_iff_of_one_le (fun x hx ↦ le_of_lt (h₁ x hx))).mpr h₄

  have aux₂ {i : ℕ} : (∏ p ∈ (Sⱼ i), p.val).primeFactors.min' (Nat.nonempty_primeFactors.mpr aux₃) = pₛ i := by
    have hnon_empty : (Sⱼ i).Nonempty := (Finset.image_nonempty.mpr (Finset.nonempty_range_iff.mpr (Nat.ne_zero_of_lt hk_gt_two)))
    have : (Sⱼ i).min' hnon_empty = pₛ i := by grind only [orderiso_min_image]
    conv => arg 1 ; arg 1 ; rw [prod_of_primes hS_mem_prime]
    rw [min_of_embedded (Sⱼ i) hnon_empty, this]


  -- Define m and prove m ∈ A
  let Sₘ := Sⱼ 2
  let m : ℕ := ∏ p ∈ Sₘ, p
  have hm_in_A : m ∈ A := by
    rw [Set.mem_setOf_eq, aux₁]
    use aux₃
    rw [aux₂]
    simp only [Subtype.coe_lt_coe, OrderIso.lt_iff_lt, Nat.one_lt_two]


  -- Define n and prove n ∉ A
  let Sₙ := Sⱼ 1
  let n : ℕ := ∏ p ∈ Sₙ, p
  have hn_nin_A : n ∉ A := by
    by_contra hn_in_A
    obtain ⟨_, hn₂⟩ := hn_in_A
    rw [aux₁, aux₂] at hn₂
    simp_all only [Subtype.coe_lt_coe, OrderIso.lt_iff_lt]
    exact (lt_self_iff_false 1).mp hn₂

  -- Prove that m and n are positive
  have hm_pos : 0 < m := Nat.zero_lt_of_lt aux₃
  have hn_pos : 0 < n := Nat.zero_lt_of_lt aux₃

  -- Prove that both m and n is the product of k primes from S
  have hm_prod : IsProductOfkDistinctMembers m k S := prod_of_distinct_members k 2 S pₛ
  have hn_prod : IsProductOfkDistinctMembers n k S := prod_of_distinct_members k 1 S pₛ
  use k, m, n

end Imo1994P6

-- ═══ Imo1995P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zheng Yuan
-/





/-!
# International Mathematical Olympiad 1995, Problem 2

Let a, b, c be positive real numbers such that abc = 1. Show that

    1 / (a³(b + c)) + 1 / (b³(c + a)) + 1 / (c³(a + b)) ≥ 3/2.
-/

namespace Imo1995P2

open Finset

theorem imo1995_p2 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)
    (habc : a * b * c = 1) :
    3 / 2 ≤ 1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b)) := by
  -- We follow the third solution from AoPS (https://artofproblemsolving.com/wiki/index.php/1995_IMO_Problems/Problem_2)

  have h1 : (1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b))) * (a * (b + c) + b * (c + a) + c * (a + b)) ≥ (1 / a + 1 / b + 1 / c) ^ 2 := by

    let f : Fin 3 → ℝ := fun i =>
      match i with
      | 0 => Real.sqrt (1 / (a^3 * (b + c)))
      | 1 => Real.sqrt (1 / (b^3 * (c + a)))
      | 2 => Real.sqrt (1 / (c^3 * (a + b)))

    let g : Fin 3 → ℝ := fun i =>
      match i with
      | 0 => Real.sqrt (a * (b + c))
      | 1 => Real.sqrt (b * (c + a))
      | 2 => Real.sqrt (c * (a + b))

    have cauchy := sum_mul_sq_le_sq_mul_sq {0, 1, 2} f g
    have lhs0 : 1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b)) = ∑ i ∈ {0, 1, 2}, f i ^ 2 := by
      have hbca' : (b + c)⁻¹ * (a ^ 3)⁻¹ ≥ 0 := by positivity
      have hcab' : (c + a)⁻¹ * (b ^ 3)⁻¹ ≥ 0 := by positivity
      have habc' : (a + b)⁻¹ * (c ^ 3)⁻¹ ≥ 0 := by positivity
      simp [sq, f, Real.mul_self_sqrt, hbca', hcab', habc', add_assoc]

    have lhs1 : a * (b + c) + b * (c + a) + c * (a + b) = ∑ i ∈ {0, 1, 2}, g i ^ 2 := by
      have habc : a * (b + c) ≥ 0 := by positivity
      have hbca : b * (c + a) ≥ 0 := by positivity
      have hcab : c * (a + b) ≥ 0 := by positivity
      simp only [Fin.isValue, sq, mem_insert, zero_ne_one, mem_singleton, Fin.reduceEq, or_self,
                 not_false_eq_true, sum_insert, habc, Real.mul_self_sqrt, hbca, sum_singleton, hcab, g]
      ring

    rw [lhs0, lhs1] at *

    have rhs : 1 / a + 1 / b + 1 / c = ∑ i ∈ {0, 1, 2}, f i * g i := by
      simp only [one_div, Fin.isValue, mul_inv_rev, mem_insert, zero_ne_one, mem_singleton,
                 Fin.reduceEq, or_self, not_false_eq_true, sum_insert, sum_singleton, f, g]
      have helper (x : ℝ) (hx : x > 0) : x * √x = √(x ^ 3) := by
        simp only [pow_three]
        have hx' : 0 ≤ x := le_of_lt hx
        have naive : x * x = x ^ 2 := (pow_two x).symm
        have naive' : x ^ 2 * x = x * (x * x) := by ring
        calc x * √x
          _ = (√x * √x) * √x := by rw [Real.mul_self_sqrt hx']
          _ = (√(x ^ 2)) * √x := by rw [← Real.sqrt_mul' x hx', naive]
          _ = √(x ^ 2) * √x := by ring_nf
          _ = √(x ^ 2 * x) := (Real.sqrt_mul' (x ^ 2) hx').symm
          _ = √(x * (x * x)) := by rw [naive']

      have ha' : √((b + c)⁻¹ * (a ^ 3)⁻¹) * √(a * (b + c)) = 1 / a := by
        rw [mul_comm, ←mul_inv, Real.sqrt_inv]
        field_simp
        rw [Real.sqrt_mul (by positivity), Real.sqrt_mul (by positivity),
            ←mul_assoc, helper a ha]

      have hb' : √((c + a)⁻¹ * (b ^ 3)⁻¹) * √(b * (c + a)) = 1 / b := by
        rw [mul_comm, ←mul_inv, Real.sqrt_inv]
        field_simp
        rw [Real.sqrt_mul (by positivity), Real.sqrt_mul (by positivity),
            ←mul_assoc, helper b hb]

      have hc' : √((a + b)⁻¹ * (c ^ 3)⁻¹) * √(c * (a + b)) = 1 / c := by
        rw [mul_comm, ←mul_inv, Real.sqrt_inv]
        field_simp
        rw [Real.sqrt_mul (by positivity), Real.sqrt_mul (by positivity),
            ←mul_assoc, helper c hc]

      rw [ha', hb', hc']
      ring

    rw [rhs] at *
    exact cauchy

  have cauchy_helper (x y z : ℝ) (hy : 0 < y) (hmain : x * y ≥ z) : x ≥ z / y :=
    (div_le_iff₀ hy).mpr hmain

  have h1_div : 1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b)) ≥ (1 / a + 1 / b + 1 / c) ^ 2 / (a * (b + c) + b * (c + a) + c * (a + b)) := by
    let x := 1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b))
    let y := a * (b + c) + b * (c + a) + c * (a + b)
    let z := (1 / a + 1 / b + 1 / c) ^ 2
    apply cauchy_helper x y z (by positivity) h1

  have h2 : (1 / a + 1 / b + 1 / c) ^ 2 = (a * b + b * c + c * a) ^ 2 := by
    have ha' : 1 / a = b * c := by
      rw [← habc]; field_simp
    have hb' : 1 / b = a * c := by
      rw [← habc]; field_simp
    have hc' : 1 / c = a * b := (eq_one_div_of_mul_eq_one_left habc).symm
    rw [ha', hb', hc']
    ring

  have h3 : a * b + b * c + c * a ≥ 3 := by

    have amgm := Real.geom_mean_le_arith_mean3_weighted
      (show 0 ≤ 1 / 3 by norm_num)
      (show 0 ≤ 1 / 3 by norm_num)
      (show 0 ≤ 1 / 3 by norm_num)
      (show 0 ≤ a * b by positivity)
      (show 0 ≤ b * c by positivity)
      (show 0 ≤ c * a by positivity)
      (show 1 / 3 + 1 / 3 + 1 / 3 = 1 by norm_num)

    have exchange : a * b * (b * c) * (c * a) = a * b * c * (a * b * c) := by ring
    calc a * b + b * c + c * a
      _ = 3 * (1 / 3 * (a * b) + 1 / 3 * (b * c) + 1 / 3 * (c * a)) := by ring
      _ ≥ 3 * ((a * b) ^ (1 / 3:ℝ) * (b * c) ^ (1 / 3:ℝ) * (c * a) ^ (1 / 3:ℝ)) := by nlinarith only [amgm]
      _ = 3 * ((a * b * (b * c)) ^ (1 / 3:ℝ) * (c * a) ^ (1 / 3:ℝ)) := by rw [← Real.mul_rpow]; all_goals positivity
      _ = 3 * ((a * b * (b * c) * (c * a)) ^ (1 / 3:ℝ)) := by rw [← Real.mul_rpow]; all_goals positivity
      _ = 3 * (a * b * c * (a * b * c)) ^ (1 / 3:ℝ) := by rw [exchange]
      _ = 3 := by simp [habc]

  calc 1 / (a^3 * (b + c)) + 1 / (b^3 * (c + a)) + 1 / (c^3 * (a + b))
    _ ≥ (1 / a + 1 / b + 1 / c) ^ 2 / (a * (b + c) + b * (c + a) + c * (a + b)) := h1_div
    _ = (a * b + b * c + c * a) ^ 2 / (a * (b + c) + b * (c + a) + c * (a + b)) := by rw [h2]
    _ = (a * b + b * c + c * a) ^ 2 / (2 * (a * b + b * c + c * a)) := by field_simp; ring
    _ = 1 / 2 * (a * b + b * c + c * a) := by field_simp
    _ ≥ 3 / 2 := by nlinarith only [h3]

end Imo1995P2

-- ═══ Imo1996P4 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Rydh
-/





/-!
# International Mathematical Olympiad 1996, Problem 4

The positive integers a and b are such that the numbers 15a + 16b
and 16a − 15b are both squares of positive integers. What is the least
possible value that can be taken on by the smaller of these two squares?

-/

namespace Imo1996P4

noncomputable def solution : ℤ := 231361

def S := { l | ∃ a b m n : ℤ,
    0 < a ∧ 0 < b ∧ 0 < m ∧ 0 < n ∧
    15*a + 16*b = m^2 ∧
    16*a - 15*b = n^2 ∧
    l = min (m^2) (n^2) }



lemma coprime {n : ℤ} {p : ℕ} (hp : p.Prime) (h_not_dvd : ¬(p : ℤ) ∣ n) : IsCoprime ↑p n := by
  rw [Int.isCoprime_iff_nat_coprime]
  simp only [Int.natAbs_natCast]
  apply hp.coprime_iff_not_dvd.mpr
  contrapose! h_not_dvd
  exact Int.ofNat_dvd_left.mpr h_not_dvd

lemma false_of_zero_eqMod_pos {p a : ℕ} (h₁ : 0 ≡ a [ZMOD p]) (h₂ : 0 < a) (h₃ : a < p) : False := by
  have h_p_dvd_one := Int.modEq_zero_iff_dvd.mp h₁.symm
  have : p ≤ a := Nat.le_of_dvd h₂ (Int.ofNat_dvd.mp h_p_dvd_one)
  exact Nat.not_le_of_lt h₃ this



theorem imo1996P4 : solution ∈ S ∧ ∀ x ∈ S, solution ≤ x := by
  have h_pos : ∀ x ∈ S, 0 < x := by
    intro x hx
    unfold S at hx
    aesop

  have h_sol : 481^2 ∈ S := by
    unfold S
    use 14911, 481, 481, 481
    norm_num

  have h_div : ∀ x ∈ S, 481^2 ∣ x := by
    intro x hx
    unfold S at hx
    obtain ⟨a, b, m, n, ha, hb, hm, hn, h1, h2, h3, rfl⟩ := hx
    have h : 13 * 37 * (a^2 + b^2) = m^4 + n^4 := by grind

    have h_4_div_13 : 13 ∣ m^4 + n^4 := by grind
    have h_4_div_37 : 37 ∣ m^4 + n^4 := by grind

    have h_4_mod_13 : m^4 + n^4 ≡ 0 [ZMOD 13] := Int.ModEq.symm (Dvd.dvd.zero_modEq_int h_4_div_13)
    have h_4_mod_37 : m^4 + n^4 ≡ 0 [ZMOD 37] := Int.ModEq.symm (Dvd.dvd.zero_modEq_int h_4_div_37)

    have aux₁ {p : ℕ} {A B C : ℤ} (h₁ : A = B * C) (h₂ : B ≡ 0 [ZMOD p]) : A ≡ 0 [ZMOD p] := by
      have := h₂.mul_right C
      simp at this
      simp [h₁, this]

    have h_12 : m^12 + n^12 = (m^4 + n^4)*(m^8 - m^4*n^4 + n^8) := by linarith
    have h_12_mod_13 : m^12 + n^12 ≡ 0 [ZMOD 13] := aux₁ h_12 h_4_mod_13
    have h_12_mod_37 : m^12 + n^12 ≡ 0 [ZMOD 37] := aux₁ h_12 h_4_mod_37

    have h_36 : m^36 + n^36 = (m^12 + n^12)*(m^24 - m^12*n^12 + n^24) := by linarith
    have h_36_mod_37 : m^36 + n^36 ≡ 0 [ZMOD 37] := aux₁ h_36 h_12_mod_37

    /-
      Using Fermat's little theorem, show that if m^(p-1) + n^(p-1) ≡ 0 (mod p) then
      both m and n are congruent to 0 mod p.
    -/
    have aux₂ (p : ℕ) (h₁ : Nat.Prime p) (h₂ : 2 < p) (h₃ : m^(p-1) + n^(p-1) ≡ 0 [ZMOD p]) :
        m ≡ 0 [ZMOD p] ∧ n ≡ 0 [ZMOD p] := by
      have hp_pred_ne_zero : p - 1 ≠ 0 := by
        have := Nat.Prime.one_lt h₁
        grind
      by_cases h_m_zero : m ≡ 0 [ZMOD p]
      · have h_n_zero : n ≡ 0 [ZMOD p] := by
          by_contra h_n_nonzero
          rw [Int.modEq_zero_iff_dvd] at h_n_nonzero
          have h_coprime : IsCoprime ↑p n := coprime h₁ h_n_nonzero
          have h_eq_zero_m_pow: m^(p-1) ≡ 0 [ZMOD p] := by
            have : m^(p-1) ≡ 0 ^ (p-1) [ZMOD p] := Int.ModEq.pow (p-1) h_m_zero
            rw [zero_pow hp_pred_ne_zero] at this
            exact this
          have h_eq_zero_n_pow: n^(p-1) ≡ 0 [ZMOD p] := by
            have := h₃.sub h_eq_zero_m_pow
            simp_all

          have h_eq_one_n_pow := Int.ModEq.pow_card_sub_one_eq_one h₁ h_coprime.symm
          have h_zero_eq_one := h_eq_zero_n_pow.symm.trans h_eq_one_n_pow
          exact false_of_zero_eqMod_pos h_zero_eq_one Nat.one_pos (Nat.Prime.one_lt h₁)
        exact ⟨h_m_zero, h_n_zero⟩
      · by_contra h_ne_zero
        rw [Int.modEq_zero_iff_dvd] at h_m_zero
        have h_coprime : IsCoprime ↑p m := coprime h₁ h_m_zero
        have h_eq_one_m_pow := Int.ModEq.pow_card_sub_one_eq_one h₁ h_coprime.symm
        have h_eq_neg_one := h₃.sub h_eq_one_m_pow
        simp at h_eq_neg_one

        have : n^(p-1) ≡ 1 [ZMOD p] := by
          by_cases h_n_zero : n ≡ 0 [ZMOD p]
          · by_contra
            have : n^(p-1) ≡ 0 ^ (p-1) [ZMOD p] := Int.ModEq.pow (p-1) h_n_zero
            rw [zero_pow hp_pred_ne_zero] at this
            have := Int.ModEq.add_right 1 (this.symm.trans h_eq_neg_one).symm
            simp at this
            exact false_of_zero_eqMod_pos this Nat.one_pos (Nat.Prime.one_lt h₁)
          · rw [Int.modEq_zero_iff_dvd] at h_n_zero
            have h_coprime : IsCoprime ↑p n := coprime h₁ h_n_zero
            have h_eq_one_n_pow := Int.ModEq.pow_card_sub_one_eq_one h₁ h_coprime.symm
            exact h_eq_one_n_pow

        have := Int.ModEq.add_right 1 (h_eq_neg_one.symm.trans this)
        simp at this
        exact false_of_zero_eqMod_pos this Nat.zero_lt_two (Nat.lt_of_succ_le h₂)

    have h_m_n_modEq_zero_13 : m ≡ 0 [ZMOD 13] ∧ n ≡ 0 [ZMOD 13] := aux₂ 13 (by norm_num) (by norm_num) h_12_mod_13
    have h_m_n_modEq_zero_37 : m ≡ 0 [ZMOD 37] ∧ n ≡ 0 [ZMOD 37] := aux₂ 37 (by norm_num) (by norm_num) h_36_mod_37

    -- Now we know that both m and n are divisible by 13 and 37, so by 481, or 481^2 divides both m^2 and n^2

    have h_dvd_m : 481 ∣ m := by
      have h0 : 13 ∣ m := Int.modEq_zero_iff_dvd.mp h_m_n_modEq_zero_13.left
      have h1 : 37 ∣ m := Int.modEq_zero_iff_dvd.mp h_m_n_modEq_zero_37.left
      grind
    have h_dvd_m_sqr : 481^2 ∣ m^2 := pow_dvd_pow_of_dvd h_dvd_m 2

    have h_dvd_n : 481 ∣ n := by
      have h0 : 13 ∣ n := Int.modEq_zero_iff_dvd.mp h_m_n_modEq_zero_13.right
      have h1 : 37 ∣ n := Int.modEq_zero_iff_dvd.mp h_m_n_modEq_zero_37.right
      grind
    have h_dvd_n_sqr : 481^2 ∣ n^2 := pow_dvd_pow_of_dvd h_dvd_n 2

    -- Applying this to min concludes the proof of the lemma
    have h_dvd_min : 481^2 ∣ m^2 ∧ 481^2 ∣ n^2 := by grind
    have h_dvd_min_either {x y n : ℤ} (h₁ : n ∣ x) (h₂ : n ∣ y) : n ∣ min x y := by grind
    exact h_dvd_min_either h_dvd_min.left h_dvd_min.right

  -- Finally use the above to finish the problem
  constructor
  · exact h_sol
  · intro x hx
    have h1 : 0 < x := h_pos x hx
    have h2 : 481^2 ∣ x := h_div x hx
    exact Int.le_of_dvd h1 h2

end Imo1996P4

-- ═══ Imo1996P6 ═══

/-
Copyright (c) 2025 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Markus Rydh
-/






/-!
# International Mathematical Olympiad 1996, Problem 6

Let p, q, n be three positive integers with p + q < n. Let (x₀, x₁, . . . , xₙ)
be an (n + 1)-tuple of integers satisfying the following conditions:
(a) x₀ = xₙ = 0.
(b) For each i with 1 ≤ i ≤ n, either xᵢ − xᵢ₋₁ = p or xᵢ − xᵢ₋₁ = −q.
Show that there exist indices i < j with (i, j) ≠ (0, n), such that xᵢ = xⱼ.

-/

namespace Imo1996P6



lemma one_lt_gcd_of_not_coprime {p q : ℕ} (h₁ : 0 < p) (h₂ : ¬Nat.Coprime p q) : 1 < p.gcd q :=
  Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨(Nat.gcd_pos_of_pos_left q h₁).ne', by simp_all⟩

lemma dist_gt_one_of_ne_sign {p q : ℤ} (h₁ : p.sign ≠ q.sign) (h₂ : p ≠ 0) (h₃ : q ≠ 0) : 1 < |p - q| := by
  grind

lemma diff_ne_pm_one_of_dist_gt_one {p q : ℤ} (h : 1 < |p - q|) : p - q ≠ 1 ∧ p - q ≠ -1 := by
  grind

lemma ne_zero_of_eq_mul {a b c : ℤ} (h₁ : a ≠ 0) (h₂ : a = b * c) : b ≠ 0 ∧ c ≠ 0 := by
  grind

lemma sum_bivalued {p q : ℤ} (s : Finset (ℕ)) (f : ℕ → ℤ) (h : ∀ i ∈ s, f i = p ∨ f i = q) :
  ∃ r : ℕ, ∑ i ∈ s, f i = r * p + (s.card - r) * q ∧ r ≤ s.card := by
  let s₂ := s.filter (fun i ↦ f i = p)
  let r := s₂.card
  use r
  have h_sum_split : ∑ i ∈ s, f i = ∑ i ∈ s₂, f i + ∑ i ∈ (s \ s₂), f i := by
    rw [← Finset.sum_disjUnion (Finset.disjoint_sdiff)]
    have : s₂.disjUnion (s \ s₂) (Finset.disjoint_sdiff) = s := by grind
    rw [this]
  have h_s₂ : ∀ i ∈ s₂, f i = p := by grind
  have h_s_s₂ : ∀ i ∈ (s \ s₂), f i = q := by grind
  rw [Finset.sum_congr rfl h_s₂, Finset.sum_congr rfl h_s_s₂, Finset.sum_const, Finset.sum_const] at h_sum_split
  grind



theorem imo1996_p6 {p q n : ℕ} (x : ℕ → ℤ)
    (h₁ : 0 < p) (h₂ : 0 < q) (h₃ : 0 < n) (h₄ : p + q < n)
    (h₅ : x 0 = 0) (h₆ : x n = 0)
    (h₇ : ∀ i < n, x (i + 1) - x i = p ∨ x (i + 1) - x i = -q) :
    ∃ i j : ℕ, 0 ≤ i ∧ i < j ∧ j ≤ n ∧ (i, j) ≠ (0, n) ∧ x i = x j := by
  -- Based on solution from https://prase.cz/kalva/imo/isoln/isoln966.html
  have h_tsum_i := Finset.sum_range_sub x
  simp only [h₅, sub_zero] at h_tsum_i

  -- If p and q is not coprime, then we can divide p, q and x i by their gcd and use induction
  by_cases h_coprime : ¬ Nat.Coprime p q
  · let w := p.gcd q
    have h_one_lt_w : 1 < w := one_lt_gcd_of_not_coprime h₁ h_coprime
    have h_w_pos : 0 < ↑w := Nat.gcd_pos_of_pos_left q h₁
    have h_w_dvd_xi : ∀ i ≤ n, ↑w ∣ (x i) := by
      intro i hi
      by_cases h_zero : i = 0
      · rw [h_zero, h₅] ; exact Int.dvd_zero ↑w
      · rw [← h_tsum_i]
        have : ∀ j < n, ↑w ∣ x (j + 1) - x j := by
          intro j hj
          have h_or := h₇ j hj
          cases' h_or with hp hq
          · rw [hp]
            exact Rat.normalize.dvd_num rfl
          · rw [hq, dvd_neg]
            exact Int.gcd_dvd_right p q
        have h_mem : ∀ k ∈ Finset.range i, k < n := by
          intro k hk
          rw [Finset.mem_range] at hk
          exact Nat.lt_of_lt_of_le hk hi
        exact Finset.dvd_sum fun k hk ↦ this k (h_mem k hk)

    -- Setup new p', q' and x' and prove all hypothesis needed for the recursion
    obtain ⟨p', hp'⟩ := exists_eq_mul_left_of_dvd (Nat.gcd_dvd_left p q)
    obtain ⟨q', hq'⟩ := exists_eq_mul_left_of_dvd (Nat.gcd_dvd_right p q)
    have : ∃ x' : ℕ → ℤ, ∀ i ≤ n, x i = x' i * w := by
      use (fun i ↦ (x i) / w)
      intro i hi
      exact (Int.ediv_mul_cancel (h_w_dvd_xi i hi)).symm

    obtain ⟨x', hx'⟩ := this
    have h₁' : 0 < p' := by rw [hp'] at h₁ ; exact Nat.pos_of_mul_pos_right h₁
    have h₂' : 0 < q' := by rw [hq'] at h₂ ; exact Nat.pos_of_mul_pos_right h₂
    have h₄' : p' + q' < n := by
      have h_lt_p : p' < p := by rw [hp'] ; exact (Nat.lt_mul_iff_one_lt_right h₁').mpr h_one_lt_w
      have h_lt_q : q' < q := by rw [hq'] ; exact (Nat.lt_mul_iff_one_lt_right h₂').mpr h_one_lt_w
      exact Nat.lt_trans (Nat.add_lt_add h_lt_p h_lt_q) h₄
    have h_w_ne : (w : ℤ) ≠ 0 := Int.ofNat_ne_zero.mpr (Nat.ne_zero_of_lt h_one_lt_w)
    have h₅' : x' 0 = 0 := eq_zero_of_ne_zero_of_mul_right_eq_zero h_w_ne ((hx' 0 (Nat.zero_le n)).symm.trans h₅)
    have h₆' : x' n = 0 := eq_zero_of_ne_zero_of_mul_right_eq_zero h_w_ne ((hx' n le_rfl).symm.trans h₆)
    have h₇' : ∀ i < n, x' (i + 1) - x' i = p' ∨ x' (i + 1) - x' i = -q' := by
      intro i hi
      cases' h₇ i hi with hp hq
      · left
        rwa [hx' i (Nat.le_of_succ_le hi), hx' (i + 1) (Order.add_one_le_iff.mpr hi), hp', ←sub_mul, Nat.cast_mul,
            mul_right_cancel_iff_of_pos (Int.natCast_pos.mpr h_w_pos)] at hp
      · right
        rwa [hx' i (Nat.le_of_succ_le hi), hx' (i + 1) (Order.add_one_le_iff.mpr hi), hq', ←sub_mul, Nat.cast_mul,
            ←neg_mul, mul_right_cancel_iff_of_pos (Int.natCast_pos.mpr h_w_pos)] at hq

    -- Now use recursion to prove it for the reduced problem
    have h_ind := imo1996_p6 x' h₁' h₂' h₃ h₄' h₅' h₆' h₇'
    obtain ⟨i, j, h_i_pos, h_i_lt_j, h_j_lt_n, h_not_first_last, h_x'i_eq_x'j⟩ := h_ind
    -- Finally, use that result to get our solution from the reduced problem
    have h_xi_eq_xj : x i = x j := by
      rwa [hx' i (lt_of_lt_of_le h_i_lt_j h_j_lt_n).le, hx' j h_j_lt_n, mul_right_cancel_iff_of_pos (Int.natCast_pos.mpr h_w_pos)]
    exact ⟨i, j, h_i_pos, h_i_lt_j, h_j_lt_n, h_not_first_last, h_xi_eq_xj⟩


  -- Here we know that p and q are coprime
  simp at h_coprime
  let g := fun i ↦ x (i + 1) - x i
  let I := Finset.range n

  have {i : ℕ} : i ∈ I → i < n := by grind
  obtain ⟨s, hs, h_s_le_n⟩ := sum_bivalued I g (fun i a ↦ Or.symm (h₇ i (this a)))
  let r := n - s
  have h_eq_add : n = r + s := by grind
  have h_rp_eq_sq : r * p = s * q := by grind

  obtain ⟨k, hk⟩ := Nat.Coprime.dvd_of_dvd_mul_right h_coprime (Dvd.intro_left r h_rp_eq_sq)

  have h_s_pos : 0 < s := by
    by_contra
    simp at this
    have h_rp_zero : r * p = 0 := by
      rw [this, zero_mul] at h_rp_eq_sq
      exact h_rp_eq_sq
    have h_r_zero : r = 0 := by
      apply eq_zero_or_eq_zero_of_mul_eq_zero at h_rp_zero
      exact h_rp_zero.resolve_right (Nat.ne_zero_of_lt h₁)
    have h_n_zero : n = 0 := by
      rw [h_eq_add, h_r_zero, this, zero_add]
    exact Nat.ne_zero_of_lt h₃ h_n_zero

  have h_r_pos : 0 < r := by
    have h_sq_pos : 0 < s * q := mul_pos h_s_pos h₂
    have h_rp_pos : 0 < r * p := Nat.lt_of_lt_of_eq h_sq_pos (Eq.symm h_rp_eq_sq)
    exact Nat.pos_of_mul_pos_right h_rp_pos
  have h_k_pos : 0 < k := by grind only
  have h_k_gt_one : 1 < k := by
    by_contra
    have h_one : k = 1 := by linarith
    have h1: s = p := by simp [hk, h_one]
    have h2: r = q := by
      simp [h1, mul_comm] at h_rp_eq_sq
      exact h_rp_eq_sq.resolve_right (Nat.ne_zero_of_lt h₁)
    lia

  have h_p_add_q_mul_k_eq_n : (p + q) * k = n := by
    rw [hk, mul_comm, mul_assoc] at h_rp_eq_sq
    have : r = k * q := Nat.eq_of_mul_eq_mul_left h₁ h_rp_eq_sq
    rw [mul_comm] at this
    simp [h_eq_add, hk, this, ←add_mul, add_comm]

  have h_k_dvd_n : k ∣ n := Dvd.intro_left (p + q) h_p_add_q_mul_k_eq_n
  obtain ⟨h, hh⟩ := h_k_dvd_n
  have h_pos : 0 < h := by grind only
  have h_lt_n : h < n := by rw [hh] ; exact lt_mul_left h_pos h_k_gt_one

  have h_h_eq_p_add_q : h = p + q := by
    rw [hh, mul_comm] at h_p_add_q_mul_k_eq_n
    exact (Nat.eq_of_mul_eq_mul_left h_k_pos h_p_add_q_mul_k_eq_n).symm

  let d := fun i ↦ x (i + h) - x i
  have h_h_dvd_di : ∀ i ≤ n - h, ↑h ∣ d i := by
    intro i hi
    unfold d
    have : x (i + h) - x i = ∑ j ∈ Finset.Ico i (i + h), (x (j + 1) - x j) := by
      have hlt : i ≤ i + h := by lia
      rw [←h_tsum_i (i + h), ←h_tsum_i, sub_eq_iff_eq_add]
      conv_rhs =>
        rw [add_comm]
      rw [Finset.sum_range_add_sum_Ico (fun j ↦ x (j + 1) - x j) hlt]
    have : ∃t : ℕ, ∑ j ∈ Finset.Ico i (i + h), (x (j + 1) - x j) = t * p + (h - t) * (-q) := by
      have : ∀ j ∈ Finset.Ico i (i + h), x (j + 1) - x j = p ∨ x (j + 1) - x j = -q := by
        intro j hj
        have h_j_lt_n : j < n := by
          rw [Finset.mem_Ico] at hj
          lia
        exact h₇ j h_j_lt_n
      obtain ⟨t, ht⟩ := sum_bivalued (Finset.Ico i (i + h)) (fun j ↦ x (j + 1) - x j) this
      use t
      simp [ht]
    obtain ⟨t, ht⟩ := this
    rw [this, ht]
    have : (↑t : ℤ) * ↑p + (↑h - ↑t) * -↑q = (↑t - ↑q) * ↑h := by
      calc
        (↑t : ℤ) * ↑p + (↑h - ↑t) * -↑q = ↑t * (↑p + ↑q) - ↑h * ↑q := by grind
        _ = (↑t - ↑q) * ↑h := by rw [h_h_eq_p_add_q] ; grind
    exact Dvd.intro_left (↑t - ↑q) this.symm

  have h_di_delta : ∀ i < n - h, d (i + 1) - d i ∈ { z : ℤ | z = 0 ∨ z = h ∨ z = -h } := by
    intro i hi
    unfold d
    have : d (i + 1) - d i = g (i + h) - g i := by
      unfold d
      grind only
    rw [this]
    have h₈ : ∀ i < n, g i = p ∨ g i = -q := h₇
    have h_gih := h₈ (i + h) (by lia)
    have h_gi := h₈ i (by lia)
    cases' h_gih with h_gihp h_gihq
    · cases' h_gi with h_gip h_giq
      · rw [h_gihp, h_gip]
        simp
      · rw [h_gihp, h_giq]
        simp [h_h_eq_p_add_q]
    · cases' h_gi with h_gip h_giq
      · rw [h_gihq, h_gip, ←neg_sub]
        simp [h_h_eq_p_add_q]
      · rw [h_gihq, h_giq]
        simp


  -- First, if there is any d i = 0, then this trivially gives the proof
  by_cases! h_di_zero : ∃i ≤ n - h, d i = 0
  · obtain ⟨i, hi, hdi⟩ := h_di_zero
    exact ⟨i, i+h, Nat.zero_le i, (lt_add_iff_pos_right i).mpr h_pos, by lia, by grind only, (Int.eq_of_sub_eq_zero hdi).symm⟩


  -- Here we have ∀ i, d i ≠ 0. We complete the proof by contradiction
  by_contra
  -- Either all are positive or all negative. Otherwise we must have an i such that
  -- d i and d (i+1) have different signs and are multiples of h so that their absolute difference
  -- is at least 2h, which is a contradiction since the difference is in {0, h, -h} (due to h_di_delta)
  let I₂ := Finset.range (n - h + 1)
  have h_di_pos_or_neg : (∀ i ∈ I₂, 0 < d i) ∨ (∀ i ∈ I₂, d i < 0) := by
    by_contra h_pos_and_neg
    simp at h_pos_and_neg
    let s0 := (d 0).sign
    let I₃ := I₂.filter (fun j ↦ (d j).sign ≠ s0)
    have h_I3_nonempty : I₃.Nonempty := by
      obtain ⟨i, hi, h_di_le⟩ := h_pos_and_neg.1
      obtain ⟨j, hj, h_dj_ge⟩ := h_pos_and_neg.2
      have h_di_neg : d i < 0 := lt_of_le_of_ne h_di_le (h_di_zero i (by simp [I₂] at hi; lia))
      have h_dj_pos : 0 < d j := lt_of_le_of_ne h_dj_ge (h_di_zero j (by simp [I₂] at hj; lia)).symm
      have h_diff_sign : (d i).sign ≠ (d j).sign := by simp [Int.sign_eq_one_of_pos h_dj_pos, Int.sign_eq_neg_one_of_neg h_di_neg]
      rcases eq_or_ne (d i).sign s0 with h_eq | h_ne
      · exact ⟨j, Finset.mem_filter.mpr ⟨hj, fun h ↦ h_diff_sign (h_eq ▸ h.symm)⟩⟩
      · exact ⟨i, Finset.mem_filter.mpr ⟨hi, h_ne⟩⟩
    let t := I₃.min' h_I3_nonempty
    have h_t_in_I₃ : t ∈ I₃ := Finset.min'_mem I₃ h_I3_nonempty
    have h_t_pos : 0 < t := Nat.pos_of_ne_zero fun h_eq ↦ (Finset.mem_filter.mp h_t_in_I₃).2 (h_eq ▸ rfl)

    have h_t_in_I₂ : t ∈ I₂ := Finset.mem_of_mem_filter t h_t_in_I₃
    have h_t_pred_in_I₂ : t - 1 ∈ I₂ := Finset.mem_range.mpr (Nat.sub_lt_of_lt (Finset.mem_range.mp h_t_in_I₂))
    have h_t_pred_not_in_I₃ : t - 1 ∉ I₃ := fun h_in ↦ Nat.not_le_of_lt (Nat.sub_one_lt_of_lt h_t_pos) (I₃.min'_le _ h_in)
    have h_diff_sgn : (d (t - 1)).sign ≠ (d t).sign := by
      have h_t_pred_sign : (d (t - 1)).sign = s0 := by_contra fun h ↦ h_t_pred_not_in_I₃ (Finset.mem_filter.mpr ⟨h_t_pred_in_I₂, h⟩)
      exact ne_of_eq_of_ne h_t_pred_sign (Finset.mem_filter.mp h_t_in_I₃).2.symm
    have h_t_lt_nh : t < n - h + 1 := Finset.mem_range.mp (Finset.mem_of_mem_filter t h_t_in_I₃)
    obtain ⟨v, hv⟩ := exists_eq_mul_left_of_dvd (h_h_dvd_di t (Nat.le_of_lt_succ h_t_lt_nh))
    obtain ⟨w, hw⟩ := exists_eq_mul_left_of_dvd (h_h_dvd_di (t-1) (by lia))
    have h_v_ne_zero : v ≠ 0 := (ne_zero_of_eq_mul (h_di_zero t (Nat.le_of_lt_succ h_t_lt_nh)) hv).1
    have h_w_ne_zero : w ≠ 0 := (ne_zero_of_eq_mul (h_di_zero (t-1) (by lia)) hw).1
    replace h_diff_sgn : v.sign ≠ w.sign := by
      have : (↑h : ℤ).sign = 1 := Int.sign_eq_one_of_pos (Int.natCast_pos.mpr h_pos)
      rw [hv, hw, Int.sign_mul, Int.sign_mul, this, mul_one, mul_one] at h_diff_sgn
      exact h_diff_sgn.symm
    have h_di_delta_t_minus_1 := h_di_delta (t - 1) (Nat.sub_lt_right_of_lt_add h_t_pos h_t_lt_nh)
    simp [Nat.sub_add_cancel h_t_pos] at h_di_delta_t_minus_1
    have : d t - d (t - 1) = (v - w) * ↑h := by
      rw [hv, hw, ←sub_mul]
    repeat rw [this] at h_di_delta_t_minus_1
    have h_h_ne : (h : ℤ) ≠ 0 := Int.natCast_ne_zero_iff_pos.mpr h_pos
    rcases h_di_delta_t_minus_1 with h_zero | h_eq_h | h_eq_neg_h
    · exact h_diff_sgn (congrArg Int.sign (Int.eq_of_sub_eq_zero ((mul_eq_zero.mp h_zero).resolve_right (by linarith))))
    · exact (diff_ne_pm_one_of_dist_gt_one (dist_gt_one_of_ne_sign h_diff_sgn h_v_ne_zero h_w_ne_zero)).1
        (mul_right_cancel₀ h_h_ne (by rwa [Int.one_mul]))
    · have : w - v = 1 := mul_right_cancel₀ h_h_ne (by linarith)
      exact (diff_ne_pm_one_of_dist_gt_one (dist_gt_one_of_ne_sign h_diff_sgn.symm h_w_ne_zero h_v_ne_zero)).1 this

  -- The sum ∑ i < k, d(i*h) = x(n) - x(0) = 0, but all terms have the same sign
  have h_range_nonempty : (Finset.range k).Nonempty := ⟨0, Finset.mem_range.mpr h_k_pos⟩
  have h_k_sub_mul : (k - 1) * h = n - h := by rw [hh]; exact Nat.sub_one_mul k h
  have h_mult_in_I₂ : ∀ i < k, i * h ∈ I₂ := fun i hi ↦ Finset.mem_range.mpr (by
    calc i * h ≤ (k - 1) * h := Nat.mul_le_mul_right h ((Nat.le_sub_one_iff_lt h_k_pos).mpr hi)
      _ = n - h := h_k_sub_mul
      _ < n - h + 1 := Nat.lt_succ_self _)
  have h_di_pos_or_neg' : (∀ i ∈ Finset.range k, 0 < d (i * h)) ∨ (∀ i ∈ Finset.range k, d (i * h) < 0) :=
    h_di_pos_or_neg.imp (fun hp i hi ↦ hp (i * h) (h_mult_in_I₂ i (Finset.mem_range.mp hi)))
      (fun hn i hi ↦ hn (i * h) (h_mult_in_I₂ i (Finset.mem_range.mp hi)))
  have h_sum_eq_zero : ∑ i ∈ Finset.range k, d (i * h) = 0 := by
    have heq : ∀ i, d (i * h) = x ((i + 1) * h) - x (i * h) := fun i ↦ by simp only [d]; ring_nf
    simp_rw [heq, Finset.sum_range_sub (fun i ↦ x (i * h)), Nat.zero_mul, hh.symm, h₅, h₆, sub_zero]
  rcases h_di_pos_or_neg' with h_pos | h_neg
  · exact (Finset.sum_pos h_pos h_range_nonempty).ne h_sum_eq_zero.symm
  · exact (Finset.sum_neg h_neg h_range_nonempty).ne h_sum_eq_zero
termination_by p
decreasing_by
  rw [hp']
  exact (Nat.lt_mul_iff_one_lt_right (Nat.zero_lt_of_lt h₁')).mpr h_one_lt_w

end Imo1996P6

-- ═══ Imo1997P3 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan
-/





/-!
# International Mathematical Olympiad 1997, Problem 3

Let $x_1, x_2, \dots, x_n$ be real numbers satisfying the conditions
$|x_1 + x_2 + \cdots + x_n| = 1$ and
$|x_i| ≤ \frac{n+1}2$ for $i = 1, 2, \dots, n$. Show that there exists
a permutation $y_1, y_2, \dots, y_n$ of $x_1, x_2, \dots, x_n$ such
that $|y_1 + 2y_2 + \cdots + ny_n| ≤ \frac{n+1}2$.
-/

namespace Imo1997P3



/-
# Solution
For a permutation $π$ let $S(π) = \sum_{i=1}^n i x_{π(i)}$. We wish to show that there exists $π$
with $|S(π)| ≤ \frac{n+1}2$.
Suppose the contrary, that all permutations satisfy $\frac{n+1}2 < |S(π)|$. Then we note that for
two permutations $π, π'$ differing by a swap of adjacent elements, say $x_k$ and $x_{k+1}$,
$|S(π) - S(π')| = |x_k - x_{k+1}| ≤ n + 1$. This being the size of the interval
$[-\frac{n+1}/2, \frac{n+1}/2]$ forbidden to the $|S(π)|$, $S(π)$ and $S(π')$ must be on the
same side of said interval, i.e. they have the same sign.
By induction all the $S(\pi)$ have the same sign.
But now consider the identity permutation $1$ and the reverse permutation $R$. We have
$|S(1) + S(R)| = |(1 + n)x_1 + \cdots + (n + 1)x_n| = (n + 1)|x_1 + \cdots + x_n| = n + 1$.
Since $S(1)$ and $S(R)$ have the same sign yet are strictly larger than $\frac{n+1}2$ in
absolute value, $|S(1) + S(R)| > n + 1$, which yields a contradiction. Therefore the initial
assumption that all permutations satisfy $\frac{n+1}2 < |S(π)|$ must be false; the result follows.
-/

def S {n : ℕ} (x : Fin n → ℝ) (p : Equiv.Perm (Fin n)) : ℝ :=
  ∑ i, (i + 1) * x (p i)

lemma sign_eq_of_abs_sub_le {a b c : ℝ} (ha : c / 2 < |a|) (hb : c / 2 < |b|) (hc : 0 < c)
    (hs : |a - b| ≤ c) : SignType.sign a = SignType.sign b := by
  rcases lt_trichotomy 0 a with ha' | rfl | ha' <;>
  rcases lt_trichotomy 0 b with hb' | rfl | hb' <;>
  simp_all [abs_of_pos, abs_of_neg, abs_le] <;> linarith

lemma lt_abs_add_of_sign_eq {a b c : ℝ} (ha : c / 2 < |a|) (hb : c / 2 < |b|) (hc : 0 < c)
    (hs : SignType.sign a = SignType.sign b) : c < |a + b| := by
  rcases lt_trichotomy 0 a with ha' | rfl | ha' <;>
  rcases lt_trichotomy 0 b with hb' | rfl | hb' <;>
  simp_all [abs_of_pos, abs_of_neg, lt_abs]
  · left; linarith
  · linarith
  · right; linarith

/-- For fixed nonempty `x`, assuming the opposite of what is to be proven,
the signs of `S x p` are all the same. -/
lemma sign_eq_of_contra {n : ℕ}
    {x : Fin (n + 1) → ℝ} (hx₂ : ∀ i, |x i| ≤ ((n + 1 : ℕ) + 1) / 2)
    (h : ∀ (p : Equiv.Perm (Fin (n + 1))), ((n + 1 : ℕ) + 1) / 2 < |S x p|) :
    ∀ p, SignType.sign (S x 1) = SignType.sign (S x p) := fun p ↦ by
  induction p using Submonoid.induction_of_closure_eq_top_right
    (Equiv.Perm.mclosure_swap_castSucc_succ n) with
  | one => rfl
  | mul_right p s sform ih =>
    suffices |S x p - S x (p * s)| ≤ (n + 1 : ℕ) + 1 by
      rw [ih]; exact sign_eq_of_abs_sub_le (h _) (h _) (by positivity) this
    rw [Set.mem_range] at sform; obtain ⟨i, hi⟩ := sform
    iterate 2 rw [S, ← Finset.sum_add_sum_compl {i.castSucc, i.succ}]
    have cg : ∑ j ∈ {i.castSucc, i.succ}ᶜ, (j + 1) * x ((p * s) j) =
        ∑ j ∈ {i.castSucc, i.succ}ᶜ, (j + 1) * x (p j) := by
      congr! 3 with j mj; rw [Equiv.Perm.mul_apply, ← hi]; congr
      rw [Finset.mem_compl, Finset.mem_insert, Finset.mem_singleton, not_or] at mj
      exact Equiv.swap_apply_of_ne_of_ne mj.1 mj.2
    rw [cg, add_sub_add_right_eq_sub,
      Finset.sum_pair Fin.castSucc_lt_succ.ne, Finset.sum_pair Fin.castSucc_lt_succ.ne,
      Equiv.Perm.mul_apply, Equiv.Perm.mul_apply, ← hi, Equiv.swap_apply_left,
      Equiv.swap_apply_right, add_comm, add_sub_add_comm, ← sub_mul, ← sub_mul, Fin.val_succ,
      Fin.val_castSucc, Nat.cast_add, Nat.cast_one, add_sub_cancel_left, sub_add_cancel_left,
      one_mul, neg_one_mul]
    calc
      _ ≤ |x (p i.succ)| + |-x (p i.castSucc)| := abs_add_le ..
      _ ≤ ((n + 1 : ℕ) + 1) / 2 + ((n + 1 : ℕ) + 1) / 2 := by
        rw [abs_neg]; exact add_le_add (hx₂ _) (hx₂ _)
      _ = _ := add_halves _

lemma S_one_add_S_revPerm {n : ℕ}
    {x : Fin n → ℝ} (hx₁ : |∑ i, x i| = 1) : |S x 1 + S x Fin.revPerm| = n + 1 := by
  nth_rw 2 [S]; rw [← Fin.revPerm.sum_comp _ _ (by simp)]
  simp_rw [Fin.revPerm_apply, Fin.val_rev, Fin.rev_rev, S, Equiv.Perm.one_apply,
           ← Finset.sum_add_distrib, ← add_mul]
  have cg : ∑ i : Fin n, (i + 1 + ((n - (i + 1) : ℕ) + 1)) * x i = ∑ i, (n + 1) * x i := by
    congr! 2 with i; norm_cast; lia
  rw [cg, ← Finset.mul_sum, abs_mul, hx₁, mul_one]; exact abs_of_nonneg (by positivity)



theorem imo1997_p3 {n : ℕ} {x : Fin n → ℝ} (hx₁ : |∑ i, x i| = 1)
    (hx₂ : ∀ i, |x i| ≤ (n + 1) / 2) :
    ∃ p : Equiv.Perm (Fin n), |∑ i, (i + 1) * x (p i)| ≤ (n + 1) / 2 := by
  match n with
  | 0 => simp
  | n + 1 =>
    by_contra! h
    exact (lt_abs_add_of_sign_eq (h _) (h _) (by positivity)
      (sign_eq_of_contra hx₂ h _)).ne' (S_one_add_S_revPerm hx₁)

end Imo1997P3

-- ═══ Imo1997P5 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Roozbeh Yousefzadeh, Ilmārs Cīrulis
-/





/-!
# International Mathematical Olympiad 1997, Problem 5

Determine all pairs of integers 1 ≤ a,b that satisfy a ^ (b ^ 2) = b ^ a.
-/

namespace Imo1997P5



lemma ineq₁ {n b : ℕ} (hb : 2 ≤ b) (hn : 5 ≤ n) : n < b ^ (n - 2) := by
  induction n, hn using Nat.le_induction with
  | base => norm_num; linarith [Nat.pow_le_pow_left hb 3]
  | succ n hn iH => rw [show n + 1 - 2 = n - 2 + 1 by lia, Nat.pow_succ]; nlinarith

lemma ineq₂ {n b : ℕ} (hb : 2 ≤ b) (hn : 5 ≤ n) : n * b ^ 2 < b ^ n := by
  nth_rw 2 [show n = n - 2 + 2 by lia]
  rw [Nat.pow_add]
  nlinarith [ineq₁ hb hn]

lemma ineq₃ {x y b : ℕ} (hb : 2 ≤ b) (hxy : x < y) : b + x < b ^ 2 * y := by
  induction b, hb using Nat.le_induction <;> nlinarith

lemma ineq₄ {b : ℕ} (n : ℕ) (hb : 2 ≤ b) : b * n < (b ^ n) ^ 2 := by
  induction n with
  | zero => simp
  | succ n iH => ring_nf at *; exact ineq₃ hb iH

lemma aux₁ {n b : ℕ} (h : n * b ^ 2 = b ^ n) : b ≤ 1 ∨ n ≤ 4 := by grind [ineq₂]

lemma aux₂ {n b : ℕ} (h : b * n = (b ^ n) ^ 2) : b ≤ 1 := by grind [ineq₄]

lemma aux₃ {n a b c d : ℕ} (hb : b ≠ 0) (h : c ^ b = d ^ b * n ^ a) : d ∣ c :=
  (Nat.pow_dvd_pow_iff hb).mp (Dvd.intro (n ^ a) h.symm)



noncomputable def solution_set : Set (ℕ × ℕ) := {(1, 1), (16, 2), (27, 3)}

theorem imo1997_p5 (a b : ℕ) (ha : 0 < a) (hb : 0 < b) :
    a ^ (b ^ 2) = b ^ a ↔ (a, b) ∈ solution_set := by
  simp [solution_set]; constructor <;> intro H
  · by_cases h₁ : 2 * b ^ 2 ≤ a
    · have h₂ : b ^ a = (b ^ 2) ^ (b ^ 2) * b ^ (a - 2 * b ^ 2) := by
        rw [← pow_mul, ← pow_add]; congr; lia
      have h₃ : b ^ 2 ∣ a := by
        rw [h₂] at H
        exact aux₃ (by positivity) H
      obtain ⟨d, hd⟩ := h₃
      rw [hd, mul_comm, pow_mul, Nat.pow_left_inj (pow_ne_zero 2 (Nat.ne_zero_of_lt hb))] at H
      obtain h₄ | h₄ := aux₁ H
      · interval_cases b; grind
      · interval_cases d
        · simp at H
        · have h₃ : b = 1 := by nlinarith
          grind
        · nlinarith
        · have h₃ : b = 3 := by nlinarith
          grind
        · have h₃ : b = 2 := by
            rw [show b ^ 4 = b ^ 2 * b ^ 2 by ring] at H
            have h₄ : b ^ 2 = 4 := by nlinarith
            nlinarith
          grind
    · simp at h₁
      have h₂ : (b ^ 2) ^ (b ^ 2) = a ^ (b ^ 2) * b ^ (2 * b ^ 2 - a) := by
        rw [H, ← pow_add, ← pow_mul]; congr; lia
      have h₃ : a ∣ b ^ 2 := aux₃ (by positivity) h₂
      obtain ⟨d, hd⟩ := h₃
      rw [hd, mul_comm, pow_mul, Nat.pow_left_inj (Nat.ne_zero_of_lt ha)] at H
      rw [← H] at hd
      have h₄ := aux₂ hd.symm
      interval_cases a; grind
  · grind

end Imo1997P5

-- ═══ Imo1998P2 ═══

/-
Copyright (c) 2020 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/




/-!
# International Mathematical Olympiad 1998, Problem 2
In a competition, there are `a` contestants and `b` judges, where `b ≥ 3` is an odd integer. Each
judge rates each contestant as either "pass" or "fail". Suppose `k` is a number such that, for any
two judges, their ratings coincide for at most `k` contestants.

Prove that `k / a ≥ (b - 1) / (2b)`.
-/

open scoped Classical

variable {C J : Type*} (r : C → J → Prop)

namespace Imo1998P2

noncomputable section

/-- An ordered pair of judges. -/
abbrev JudgePair (J : Type*) :=
  J × J

/-- The first judge from an ordered pair of judges. -/
abbrev JudgePair.judge₁ : JudgePair J → J :=
  Prod.fst

/-- The second judge from an ordered pair of judges. -/
abbrev JudgePair.judge₂ : JudgePair J → J :=
  Prod.snd

/-- The proposition that the judges in an ordered pair are distinct. -/
abbrev JudgePair.Distinct (p : JudgePair J) :=
  p.judge₁ ≠ p.judge₂

/-- The proposition that the judges in an ordered pair agree about a contestant's rating. -/
abbrev JudgePair.Agree (p : JudgePair J) (c : C) :=
  r c p.judge₁ ↔ r c p.judge₂

/-- The set of contestants on which two judges agree. -/
def agreedContestants [Fintype C] (p : JudgePair J) : Finset C :=
  Finset.univ.filter fun c => p.Agree r c



/-- A triple consisting of contestant together with an ordered pair of judges. -/
abbrev AgreedTriple (C J : Type*) :=
  C × JudgePair J

/-- The contestant from the triple consisting of a contestant and an ordered pair of judges. -/
abbrev AgreedTriple.contestant : AgreedTriple C J → C :=
  Prod.fst

/-- The ordered pair of judges from the triple consisting of a contestant and an ordered pair of
judges. -/
abbrev AgreedTriple.judgePair : AgreedTriple C J → JudgePair J :=
  Prod.snd

/-
## Solution
The problem asks us to think about triples consisting of a contestant and two judges whose ratings
agree for that contestant. We thus consider the subset `A ⊆ C × JJ` of all such incidences of
agreement, where `C` and `J` are the sets of contestants and judges, and `JJ = J × J - {(j, j)}`. We
have natural maps: `left : A → C` and `right: A → JJ`. We count the elements of `A` in two ways: as
the sum of the cardinalities of the fibres of `left` and as the sum of the cardinalities of the
fibres of `right`. We obtain an upper bound on the cardinality of `A` from the count for `right`,
and a lower bound from the count for `left`. These two bounds combine to the required result.

First consider the map `right : A → JJ`. Since the size of any fibre over a point in JJ is bounded
by `k` and since `|JJ| = b^2 - b`, we obtain the upper bound: `|A| ≤ k(b^2-b)`.

Now consider the map `left : A → C`. The fibre over a given contestant `c ∈ C` is the set of
ordered pairs of (distinct) judges who agree about `c`. We seek to bound the cardinality of this
fibre from below. Minimum agreement for a contestant occurs when the judges' ratings are split as
evenly as possible. Since `b` is odd, this occurs when they are divided into groups of size
`(b-1)/2` and `(b+1)/2`. This corresponds to a fibre of cardinality `(b-1)^2/2` and so we obtain
the lower bound: `a(b-1)^2/2 ≤ |A|`.

Rearranging gives the result.
-/

section

@[simp]
theorem JudgePair.agree_iff_same_rating (p : JudgePair J) (c : C) :
    p.Agree r c ↔ (r c p.judge₁ ↔ r c p.judge₂) :=
  Iff.rfl

variable [Fintype J] [Fintype C]

/-- All incidences of agreement. -/
def A : Finset (AgreedTriple C J) :=
  Finset.univ.filter @fun (a : AgreedTriple C J) =>
    (a.judgePair.Agree r a.contestant ∧ a.judgePair.Distinct)

theorem A_maps_to_offDiag_judgePair (a : AgreedTriple C J) :
    a ∈ A r → a.judgePair ∈ Finset.offDiag (@Finset.univ J _) := by simp [A, Finset.mem_offDiag]

theorem A_fibre_over_contestant (c : C) :
    (Finset.univ.filter fun p : JudgePair J => p.Agree r c ∧ p.Distinct) =
      ((A r).filter fun a : AgreedTriple C J => a.contestant = c).image Prod.snd := by
  ext p
  simp [A]

theorem A_fibre_over_contestant_card (c : C) :
    (Finset.univ.filter fun p : JudgePair J => p.Agree r c ∧ p.Distinct).card =
      ((A r).filter fun a : AgreedTriple C J => a.contestant = c).card := by
  rw [A_fibre_over_contestant r]
  apply Finset.card_image_of_injOn
  unfold Set.InjOn AgreedTriple.contestant
  aesop

theorem A_fibre_over_judgePair {p : JudgePair J} (h : p.Distinct) :
    agreedContestants r p = ((A r).filter fun a : AgreedTriple C J => a.judgePair = p).image
    AgreedTriple.contestant := by
  dsimp only [A, agreedContestants]; ext c; constructor <;> intro h
  · rw [Finset.mem_image]; refine ⟨⟨c, p⟩, ?_⟩; aesop
  · aesop

theorem A_fibre_over_judgePair_card {p : JudgePair J} (h : p.Distinct) :
    (agreedContestants r p).card =
      ((A r).filter fun a : AgreedTriple C J => a.judgePair = p).card := by
  rw [A_fibre_over_judgePair r h]
  apply Finset.card_image_of_injOn
  unfold Set.InjOn AgreedTriple.judgePair
  aesop

theorem A_card_upper_bound {k : ℕ}
    (hk : ∀ p : JudgePair J, p.Distinct → (agreedContestants r p).card ≤ k) :
    (A r).card ≤ k * (Fintype.card J * Fintype.card J - Fintype.card J) := by
  change _ ≤ k * (Finset.card _ * Finset.card _ - Finset.card _)
  rw [← Finset.offDiag_card]
  apply Finset.card_le_mul_card_image_of_maps_to (A_maps_to_offDiag_judgePair r)
  intro p hp
  have hp' : p.Distinct := by simp [Finset.mem_offDiag] at hp; exact hp
  rw [← A_fibre_over_judgePair_card r hp']; apply hk; exact hp'

end

theorem add_sq_add_sq_sub {α : Type*} [Ring α] (x y : α) :
    (x + y) * (x + y) + (x - y) * (x - y) = 2 * x * x + 2 * y * y := by noncomm_ring

theorem norm_bound_of_odd_sum {x y z : ℤ} (h : x + y = 2 * z + 1) :
    2 * z * z + 2 * z + 1 ≤ x * x + y * y := by
  suffices 4 * z * z + 4 * z + 1 + 1 ≤ 2 * x * x + 2 * y * y by
    rw [← mul_le_mul_iff_right₀ zero_lt_two]; ring_nf at this ⊢; exact this
  have h' : (x + y) * (x + y) = 4 * z * z + 4 * z + 1 := by rw [h]; ring
  rw [← add_sq_add_sq_sub, h', add_le_add_iff_left]
  suffices 0 < (x - y) * (x - y) by apply Int.add_one_le_of_lt this
  rw [mul_self_pos, sub_ne_zero]; apply Int.ne_of_odd_add ⟨z, h⟩

section

variable [Fintype J]

theorem judge_pairs_card_lower_bound {z : ℕ} (hJ : Fintype.card J = 2 * z + 1) (c : C) :
    2 * z * z + 2 * z + 1 ≤ (Finset.univ.filter fun p : JudgePair J => p.Agree r c).card := by
  let x := (Finset.univ.filter fun j => r c j).card
  let y := (Finset.univ.filter fun j => ¬r c j).card
  have h : (Finset.univ.filter fun p : JudgePair J => p.Agree r c).card = x * x + y * y := by
    simp [x, y, ← Finset.filter_product_card]
  rw [h]; apply Int.le_of_ofNat_le_ofNat; simp only [Int.natCast_add, Int.natCast_mul]
  apply norm_bound_of_odd_sum
  suffices x + y = 2 * z + 1 by simp [← Int.natCast_add, this]
  rw [Finset.card_filter_add_card_filter_not, ← hJ]; rfl

theorem distinct_judge_pairs_card_lower_bound {z : ℕ} (hJ : Fintype.card J = 2 * z + 1) (c : C) :
    2 * z * z ≤ (Finset.univ.filter fun p : JudgePair J => p.Agree r c ∧ p.Distinct).card := by
  let s := Finset.univ.filter fun p : JudgePair J => p.Agree r c
  let t := Finset.univ.filter fun p : JudgePair J => p.Distinct
  have hs : 2 * z * z + 2 * z + 1 ≤ s.card := judge_pairs_card_lower_bound r hJ c
  have hst : s \ t = Finset.univ.diag := by
    ext p; constructor <;> intro hp
    · aesop
    · unfold s t
      suffices p.judge₁ = p.judge₂ by simp [this]
      aesop
  have hst' : (s \ t).card = 2 * z + 1 := by rw [hst, Finset.diag_card, ← hJ]; rfl
  rw [Finset.filter_and, ← Finset.sdiff_sdiff_self_left s t, Finset.card_sdiff_of_subset]
  · rw [hst']; exact Nat.le_sub_of_add_le hs
  · apply Finset.sdiff_subset

theorem A_card_lower_bound [Fintype C] {z : ℕ} (hJ : Fintype.card J = 2 * z + 1) :
    2 * z * z * Fintype.card C ≤ (A r).card := by
  have h : ∀ a, a ∈ A r → Prod.fst a ∈ @Finset.univ C _ := by intros; apply Finset.mem_univ
  apply Finset.mul_card_image_le_card_of_maps_to h
  intro c _
  rw [← A_fibre_over_contestant_card]
  apply distinct_judge_pairs_card_lower_bound r hJ

end

theorem clear_denominators {a b k : ℕ} (ha : 0 < a) (hb : 0 < b) :
    (b - 1 : ℚ) / (2 * b) ≤ k / a ↔ ((b : ℕ) - 1) * a ≤ k * (2 * b) := by
  rw [div_le_div_iff₀]
  -- Porting note: proof used to finish with `<;> norm_cast <;> simp [ha, hb]`
  · convert Nat.cast_le (α := ℚ)
    · aesop
    · norm_cast
  all_goals simp [ha, hb]



end

theorem imo1998_p2 [Fintype J] [Fintype C] (a b k : ℕ) (hC : Fintype.card C = a)
    (hJ : Fintype.card J = b) (ha : 0 < a) (hb : Odd b)
    (hk : ∀ p : JudgePair J, p.Distinct → (agreedContestants r p).card ≤ k) :
    (b - 1 : ℚ) / (2 * b) ≤ k / a := by
  rw [clear_denominators ha hb.pos]
  obtain ⟨z, hz⟩ := hb; rw [hz] at hJ; rw [hz]
  have h := le_trans (A_card_lower_bound r hJ) (A_card_upper_bound r hk)
  rw [hC, hJ] at h
  -- We are now essentially done; we just need to bash `h` into exactly the right shape.
  have hl : k * ((2 * z + 1) * (2 * z + 1) - (2 * z + 1)) = k * (2 * (2 * z + 1)) * z := by
    simp only [mul_comm, add_mul, one_mul, add_tsub_cancel_right]; ring
  have hr : 2 * z * z * a = 2 * z * a * z := by ring
  rw [hl, hr] at h
  cases z with
  | zero => simp
  | succ z => exact le_of_mul_le_mul_right h z.succ_pos


end Imo1998P2

-- ═══ Imo1999P3 ═══

/-
Copyright (c) 2026 lean-tom. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: lean-tom (with assistance from Gemini)
-/



/-!
# International Mathematical Olympiad 1999, Problem 3

Consider an `n × n` square board, where `n` is a fixed even positive integer.
The board is divided into `n^2` unit squares. We say that two different squares on the
board are adjacent if they have a common side.
`N` unit squares on the board are marked in such a way that every square (marked
or unmarked) on the board is adjacent to at least one marked square.
Determine the smallest possible value of `N`.
-/

namespace Imo1999P3

-- 1. Basic Definitions (Visible in Problem Statement)

abbrev Square (n : ℕ) := Fin n × Fin n

/-- Definition of adjacency: Two squares are adjacent if they share a common side. -/
def Adjacent {n : ℕ} (p1 p2 : Square n) : Prop :=
  let (r1, c1) := p1; let (r2, c2) := p2
  ((r1 : ℤ) - r2).natAbs + ((c1 : ℤ) - c2).natAbs = 1

/-- A set s is a valid marking if every square in the grid is adjacent to some square in s. -/
def IsValidMarking {n : ℕ} (s : Finset (Square n)) : Prop :=
  ∀ p : Square n, ∃ m ∈ s, Adjacent p m



-- 2. Construction Definitions (Hidden implementation details)

open Finset Classical

/-- Helper predicate for the internal logic of the construction.
    We divide the grid based on parity and modulo 4 conditions. -/
def isSw (n : ℕ) (x y : ℕ) : Prop :=
  -- sw_lower: x, y even, x+y is divisible by 4, x+y < n
  (x % 2 = 0 ∧ y % 2 = 0 ∧ (x + y) % 4 = 0 ∧ x + y < n) ∨
  -- sw_upper: x, y odd, x+y is divisible by 4, x+y ≧ n (including the boundary)
  (x % 2 = 1 ∧ y % 2 = 1 ∧ (x + y) % 4 = 0 ∧ n ≤ x + y)

/-- The set "sw" (Marked squares with even coordinate sum). -/
noncomputable def sw (n : ℕ) : Finset (Square n) :=
  univ.filter (λ p => isSw n p.1 p.2)

/-- The set "sb" (Marked squares with odd coordinate sum, symmetric to sw). -/
noncomputable def sb (n : ℕ) : Finset (Square n) :=
  univ.filter (λ p => isSw n (n - 1 - p.1) p.2)

/-- The definition of the solution set based on the construction logic.
    Defined as the union of sw and sb. -/
noncomputable def solutionSet (n : ℕ) : Finset (Square n) :=
  sw n ∪ sb n

/-- Set of all squares where the sum of coordinates is even. -/
noncomputable def squaresEvenSum (n : ℕ) : Finset (Square n) :=
  univ.filter (λ p => (p.1.val + p.2.val) % 2 = 0)

/-- Set of all squares where the sum of coordinates is odd. -/
noncomputable def squaresOddSum (n : ℕ) : Finset (Square n) :=
  univ.filter (λ p => (p.1.val + p.2.val) % 2 = 1)


-- 3. Construction Lemmas

/--
The transformation used to map the set `sw` to a triangular region in `Fin k × Fin k`.
-/
def transform (n k : ℕ) (h_n : n = 2 * k) (p : Square n) : Fin k × Fin k :=
  let x := p.1.val; let y := p.2.val
  if _ : x % 2 = 0 then
    -- Lower part map
    let u : Fin k := ⟨x / 2, by omega⟩; let v : Fin k := ⟨y / 2, by omega⟩
    (u, v)
  else
    -- Upper part map
    let u : Fin k := ⟨k - 1 - x / 2, by omega⟩; let v : Fin k := ⟨k - 1 - y / 2, by omega⟩
    (u, v)

/-- Helper lemma for triangular number summation. -/
lemma sum_range_sub_eq_triangular (k : ℕ) : ∑ i ∈ range k, (k - i) = k * (k + 1) / 2 := by
  induction k with
  | zero => simp
  | succ m ih =>
    rw [Finset.sum_range_succ']; simp only [Nat.succ_sub_succ_eq_sub, Nat.sub_zero]; rw [ih]
    apply Nat.eq_div_of_mul_eq_left (by decide)
    rw [Nat.add_mul]
    have h_dvd : 2 ∣ m * (m + 1) :=
      Nat.dvd_of_mod_eq_zero (Nat.even_iff.mp (Nat.even_mul_succ_self m))
    rw [Nat.div_mul_cancel h_dvd]
    ring

/--
Lemma: The transformation is injective on the set sw.
-/
lemma transform_inj_on_sw (n k : ℕ) (h_n : n = 2 * k) :
  ∀ a ∈ sw n, ∀ b ∈ sw n, transform n k h_n a = transform n k h_n b → a = b := by
  intro a ha b hb h_eq

  -- Preparation: expand definitions
  unfold sw at ha hb; rw [mem_filter] at ha hb ; unfold isSw at hb; simp only [transform] at h_eq

  -- Split cases and simplify common goals immediately
  split_ifs at h_eq <;>
    simp only [Prod.mk.injEq] at h_eq <;>
    rcases h_eq with ⟨h_u, h_v⟩ <;>
    apply Fin.mk.inj at h_u <;> apply Fin.mk.inj at h_v
  -- Case 1: Both in Lower
  · ext
    · omega
    · have : a.2.val % 2 = 0 := by rcases ha.2 with h | h <;> omega
      omega
  -- Case 2: a in Lower, b in Upper -> Parity contradiction
  · exfalso
    have : (a.1.val / 2 + a.2.val / 2) % 2 = 0 := by
      rcases ha.2 with h | h <;> omega
    omega
  -- Case 3: a in Upper, b in Lower -> Parity contradiction
  · exfalso
    have : ((k - 1 - a.2.val / 2) + (k - 1 - a.1.val / 2)) % 2 = 1 := by
      rcases ha.2 with h | h <;> omega
    omega
  -- Case 4: Both in Upper
  · have : a.1.val % 2 = 1 ∧ a.2.val % 2 = 1 := by
      rcases ha.2 with h | h
      · have := h.1; contradiction
      · exact ⟨h.1, h.2.1⟩
    ext <;> omega

/--
Lemma: The transformation maps sw onto t (Surjectivity).
For every point p in the triangular set t, there exists a pre-image in sw.
-/
lemma transform_surjective_on_t (n k : ℕ) (h_n : n = 2 * k) :
  let t : Finset (Fin k × Fin k) := univ.filter (λ p => p.1.val + p.2.val < k)
  ∀ x ∈ t, ∃ p ∈ sw n, transform n k h_n p = x := by
  intro t x hx
  rw [mem_filter] at hx

  let u := x.1.val; let v := x.2.val

  -- Inverse construction logic
  if _ : (u + v) % 2 = 0 then
    -- Inverse to Lower
    let p : Square n := (⟨2 * u ,by omega⟩, ⟨2 * v , by omega⟩)
    use p
    constructor
    · -- p ∈ sw
      unfold sw; rw [mem_filter]; simp only [Finset.mem_univ, true_and]; unfold isSw
      left; simp only [p]; refine ⟨?_, ?_, ?_, ?_⟩ <;> omega
    · -- transform p = x
      simp only [transform, p]
      split_ifs with h_p_even
      · ext <;> dsimp <;> omega
      · omega
  else
    -- Inverse to Upper
    let p : Square n := (⟨2 * (k - 1 - u) + 1, by omega⟩, ⟨2 * (k - 1 - v) + 1, by omega⟩)
    use p
    constructor
    · -- p ∈ sw
      unfold sw; rw [mem_filter]; simp only [Finset.mem_univ, true_and]; unfold isSw
      right; simp only [p]; rw [h_n]; refine ⟨?_, ?_, ?_, ?_⟩ <;> omega
    · -- transform p = x
      simp only [transform, p]
      split_ifs with h_p_even
      · omega
      · ext <;> dsimp <;> omega

/-- Calculate the cardinality of the 'sw' set (White squares in the construction).
    It corresponds to a triangular number. -/
lemma card_sw_eq_triangular (n k : ℕ) (h_n : n = 2 * k) :
  (sw n).card = k * (k + 1) / 2 := by
  -- 1. Define a simple triangular target set t
  let t : Finset (Fin k × Fin k) := univ.filter (λ p => p.1.val + p.2.val < k)

  -- 2. Prove t has cardinality k(k+1)/2
  have h_card_t : t.card = k * (k + 1) / 2 := by
    let s := (Finset.range k).sigma (λ i => Finset.range (k - i))
    have h_bij : t.card = s.card := by
      apply Finset.card_bij (λ p _ => ⟨p.1.val, p.2.val⟩)
      · intro p hp
        rw [mem_filter] at hp; simp only [s, mem_sigma, mem_range]
        constructor <;> omega
      · intro _ _ _ _ h
        simp at h
        ext
        · exact h.1
        · exact h.2
      · intro ⟨i, j⟩ h
        simp only [s, mem_sigma, mem_range] at h
        refine ⟨(⟨i, by omega⟩, ⟨j, by omega⟩), ?_, ?_⟩
        · rw [mem_filter]; simp; omega
        · simp
    rw [h_bij, Finset.card_sigma]; simp only [Finset.card_range]
    exact sum_range_sub_eq_triangular k

  -- 3. Define mapping f using the global definition
  let f := transform n k h_n

  -- 4. Use card_bij to show |sw| = |t|
  rw [← h_card_t]
  apply Finset.card_bij (λ p _ => f p)

  -- [Goal A] Range check: p ∈ sw -> f p ∈ t
  · intro p hp
    unfold sw at hp; rw [mem_filter] at hp
    -- Expand f (transform) and split cases
    simp only [f, transform]
    split_ifs
    · -- Case: sw_lower
      simp [t, mem_filter]; unfold isSw at hp
      rcases hp.2 with h|h
      · -- Valid case
        omega
      · -- Contradiction case (x is odd)
        omega
    · -- Case: sw_upper
      simp [t, mem_filter]; unfold isSw at hp
      rcases hp.2 with h|h
      · -- Contradiction case (x is even)
        omega
      · -- Valid case
        omega

  -- [Goal B] Injectivity
  · apply transform_inj_on_sw n k h_n

  -- [Goal C] Surjectivity
  · intro b hb
    -- 1. Expand definitions
    simp only [f]
    -- 2. Obtain the pre-image p using the surjectivity lemma
    rcases transform_surjective_on_t n k h_n b hb with ⟨p, hp, heq⟩
    -- 3. Use p
    use p

/-- Lemma: Adjacent squares always have different parity of the sum of their coordinates. -/
lemma adjacent_parity_ne {n : ℕ} {p m : Square n} (h : Adjacent p m) :
    (p.1.val + p.2.val) % 2 ≠ (m.1.val + m.2.val) % 2 := by
  unfold Adjacent at h
  let r1 := (p.1.val : ℤ); let c1 := (p.2.val : ℤ)
  let r2 := (m.1.val : ℤ); let c2 := (m.2.val : ℤ)
  -- Since the sum of absolute differences is 1, (Δr, Δc) is (±1, 0) or (0, ±1)
  have h_cases : (r1 - r2).natAbs = 1 ∧ (c1 - c2).natAbs = 0 ∨
                 (r1 - r2).natAbs = 0 ∧ (c1 - c2).natAbs = 1 := by omega
  rcases h_cases with ⟨_, _⟩ | ⟨_, _⟩ <;> omega

-- 4. Lower Bound Lemma (Key Logic)

/-- Condition for a set of points to be "independent" (pairwise distance > 2).
    This matches the `sw` condition. -/
def IsIndependentPoint (n : ℕ) (p : Square n) : Prop := isSw n p.1 p.2

/-- Lemma: Independent points cannot share a common neighbor.
    If p1, p2 ∈ sw and they both are adjacent to m, then p1 = p2. -/
lemma independent_points_cant_share_neighbor (n : ℕ) (p1 p2 m : Square n)
  (h1 : IsIndependentPoint n p1) (h2 : IsIndependentPoint n p2)
  (h_adj1 : Adjacent p1 m) (h_adj2 : Adjacent p2 m) : p1 = p2 := by

  -- Prepare for contradiction and unfold definitions
  by_contra h_ne
  unfold IsIndependentPoint isSw at h1 h2; unfold Adjacent at h_adj1 h_adj2

  -- Decompose points into coordinates
  rcases p1 with ⟨⟨x1, _⟩, ⟨y1, _⟩⟩
  rcases p2 with ⟨⟨x2, _⟩, ⟨y2, _⟩⟩
  rcases m  with ⟨⟨xm, _⟩, ⟨ym, _⟩⟩
  simp only [Prod.ext_iff, Fin.ext_iff] at h_ne

  -- Cast to Int to avoid Nat subtraction saturation (crucial for omega)
  let ix1 : ℤ := x1; let iy1 : ℤ := y1
  let ix2 : ℤ := x2; let iy2 : ℤ := y2
  let ixm : ℤ := xm; let iym : ℤ := ym
  simp only at h1 h2 h_adj1 h_adj2

  -- Check all parity combinations (Lower/Upper) for contradiction
  rcases h1 with h1 | h1 <;> rcases h2 with h2 | h2 <;> omega

/--
Helper: A parity-dependent transformation.
If target_parity is 0, it keeps points as is.
Otherwise (assumed to be 1), it reflects the x-coordinate (n - 1 - x).
-/
def parityTransform (n : ℕ) (target_parity : ℕ) (p : Square n) : Square n :=
  if target_parity = 0 then
    p
  else
    (⟨n - 1 - p.1.val, by omega⟩, p.2)

/--
Lemma: parityTransform is injective.
-/
lemma parity_transform_injective (n target_parity : ℕ) :
    Function.Injective (parityTransform n target_parity) := by
  intro p1 p2 h
  simp [parityTransform] at h; split_ifs at h <;> simp_all; ext <;> omega

/--
  **Lower Bound Lemma (Revised):**
  If s covers all squares with a specific target parity (0 or 1),
  then |s| ≥ n(n+2)/8.
-/
lemma card_lower_bound_of_cover (n k : ℕ) (h_n : n = 2 * k)
  (s : Finset (Square n)) (target_parity : ℕ)
  (h_tp_range : target_parity ≤ 1)
  (h_cover : ∀ p : Square n, (p.1.val + p.2.val) % 2 = target_parity → ∃ m ∈ s, Adjacent p m)
  : s.card ≥ n * (n + 2) / 8 := by

  -- 1. Base Set sw definition
  -- Use sw n directly to avoid shadowing issues
  have h_card_sw : (sw n).card = k * (k + 1) / 2 :=
    card_sw_eq_triangular n k h_n

  -- 2. Define the image set i using the parity transformation
  let trans := parityTransform n target_parity
  let i := (sw n).map ⟨trans, parity_transform_injective n target_parity⟩

  have h_card_i : i.card = k * (k + 1) / 2 := by simp [i, h_card_sw]

  -- 3. Property: All points in i have the correct target parity
  have h_i_parity : ∀ p ∈ i, (p.1.val + p.2.val) % 2 = target_parity := by
    intro p hp
    rw [mem_map] at hp
    rcases hp with ⟨a, ha_sw, rfl⟩
    -- Analyze parity of the transformed point
    simp [trans, parityTransform]
    split_ifs with h_tp_zero
    · -- target_parity = 0 (Identity)
      subst h_tp_zero
      unfold sw at ha_sw; rw [mem_filter] at ha_sw; unfold isSw at ha_sw
      rcases ha_sw.2 with h|h <;> omega
    · -- target_parity = 1 (Reflection)
      unfold sw at ha_sw; rw [mem_filter] at ha_sw; unfold isSw at ha_sw
      rcases ha_sw with ⟨_, h_sw⟩
      simp [h_n]
      rcases h_sw with h|h <;> omega

  -- 4. Construct injection f: i -> s
  -- We map each p ∈ i to its neighbor m ∈ s
  let f_rel : i → s → Prop := λ p m => Adjacent p.1 m.1
  have h_exists : ∀ p : i, ∃ m : s, f_rel p m := by
    intro p
    have h_par := h_i_parity p.1 p.2
    rcases h_cover p.1 h_par with ⟨m, hm_in, h_adj⟩
    use ⟨m, hm_in⟩

  let f (p : i) : s := Classical.choose (h_exists p)
  have h_f (p : i) : Adjacent p.1 (f p).1 := Classical.choose_spec (h_exists p)

  -- 5. Prove Injectivity of f
  -- This is the core logic: "Neighbors of independent points are distinct"
  have h_inj : Function.Injective f := by
    intro p1 p2 h_eq
    let m := (f p1).1
    have h_adj1 : Adjacent p1.1 m := h_f p1
    have h_adj2 : Adjacent p2.1 m := by
      have h_m_eq : (f p2).1 = m := by rw [← h_eq]
      rw [← h_m_eq]
      exact h_f p2

    -- Unpack the points back to the original sw set (Pre-image)
    rcases p1 with ⟨val1, prop1⟩
    rcases p2 with ⟨val2, prop2⟩
    simp [i] at prop1 prop2
    rcases prop1 with ⟨p1x, p1y, ⟨h_mem1, h_eq1⟩⟩
    rcases prop2 with ⟨p2x, p2y, ⟨h_mem2, h_eq2⟩⟩
    apply Subtype.ext

    if h_par : target_parity = 0 then
      -- Case 1: Identity transform
      simp [trans, parityTransform, h_par] at h_eq1 h_eq2
      have h_adj_v1 : Adjacent val1 m := h_adj1
      have h_adj_v2 : Adjacent val2 m := h_adj2
      rw [← h_eq1] at h_adj_v1; rw [← h_eq2] at h_adj_v2
      have h_indep1 : IsIndependentPoint n (p1x, p1y) := by
        unfold sw at h_mem1; rw [mem_filter] at h_mem1; exact h_mem1.2
      have h_indep2 : IsIndependentPoint n (p2x, p2y) := by
        unfold sw at h_mem2; rw [mem_filter] at h_mem2; exact h_mem2.2
      have h_base_eq : (p1x, p1y) = (p2x, p2y) :=
        independent_points_cant_share_neighbor n _ _ m h_indep1 h_indep2 h_adj_v1 h_adj_v2
      dsimp; rw [← h_eq1, ← h_eq2]; exact h_base_eq
    else
      -- Case 2: Reflection transform
      unfold Adjacent at h_adj1 h_adj2
      simp [trans, parityTransform, h_par] at h_eq1 h_eq2
      unfold sw at h_mem1 h_mem2; rw [mem_filter] at h_mem1 h_mem2
      let m_inv : Square n := (⟨n - 1 - m.1.val, by omega⟩, m.2)
      have h_adj_b1 : Adjacent (p1x, p1y) m_inv := by
        dsimp at h_adj1; rw [← h_eq1] at h_adj1; simp at h_adj1
        unfold Adjacent; dsimp [m_inv]; omega
      have h_adj_p2 : Adjacent (p2x, p2y) m_inv := by
        dsimp at h_adj2; rw [← h_eq2] at h_adj2; simp at h_adj2
        unfold Adjacent; dsimp [m_inv]; omega
      have h_base_eq : (p1x, p1y) = (p2x, p2y) :=
        independent_points_cant_share_neighbor n (p1x, p1y) (p2x, p2y) m_inv
          h_mem1.2 h_mem2.2 h_adj_b1 h_adj_p2
      dsimp; rw [← h_eq1, ← h_eq2]
      injection h_base_eq with h_b h_sw
      subst h_b h_sw; rfl

  -- 6. Final Calculation
  have h_card := Fintype.card_le_of_injective f h_inj
  simp only [Fintype.card_coe, card_map, i] at h_card
  rw [h_card_sw] at h_card
  have h_mul : n * (n + 2) = 4 * (k * (k + 1)) := by rw [h_n]; ring
  rw [h_mul]; omega


/--
Lemma: For any square `q` whose coordinate sum is odd,
there exists a marked square in `sw` adjacent to `q`.
This handles the detailed case analysis for the valid marking construction.
-/
lemma exists_adjacent_in_sw_of_odd_sum (n : ℕ) (h_pos : 0 < n) (h_even : Even n)
    (q : Square n) (h_sum_odd : (q.1.val + q.2.val) % 2 = 1) :
    ∃ m ∈ sw n, Adjacent q m := by
  let qx := q.1.val; let qy := q.2.val
  have h_n_mod2 : n % 2 = 0 := (Nat.even_iff).mp h_even
  -- The logic below exhaustively checks cases based on the construction of sw.
  unfold sw; simp only [mem_filter, Finset.mem_univ, true_and]; unfold isSw Adjacent

  if _ : qx + qy < n then
    -- Case: Lower Triangle region
    if _ : (qx + qy) % 4 = 1 then
      if _ : qy % 2 = 1 then
        -- Neighbor below
        let my : Fin n := ⟨qy - 1, by omega⟩
        use (q.1, my); have : my.val = qy - 1 := rfl; dsimp; omega
      else
        -- Neighbor left
        let mx : Fin n := ⟨qx - 1, by omega⟩
        use (mx, q.2); have : mx.val = qx - 1 := rfl; dsimp; omega
    else
        -- Case: Sum % 4 = 3 (Implied by odd sum and != 1)
        by_cases h_boundary : qx + qy = n - 1
        · -- Boundary case: requires care to stay within bounds
          if _ : qy % 2 = 1 then
            let mx : Fin n := ⟨qx + 1, by omega⟩
            use (mx, q.2); have : mx.val = qx + 1 := rfl; dsimp; omega
          else
            let my : Fin n := ⟨qy + 1, by omega⟩
            use (q.1, my); have : my.val = qy + 1 := rfl; dsimp; omega
        · -- Normal Lower case (Sum % 4 = 3, not boundary)
          if _ : qy % 2 = 1 then
            let my : Fin n := ⟨qy + 1, by omega⟩
            use (q.1, my); have : my.val = qy + 1 := rfl; dsimp; omega
          else
            let mx : Fin n := ⟨qx + 1, by omega⟩
            use (mx, q.2); have : mx.val = qx + 1 := rfl; dsimp; omega
  else
    -- Case: Upper Triangle region (qx + qy ≥ n)
    if _ : (qx + qy) % 4 = 1 then
        if _ : qy % 2 = 1 then
          let mx : Fin n := ⟨qx - 1, by omega⟩
          use (mx, q.2); have : mx.val = qx - 1 := rfl; dsimp; omega
        else
          let my : Fin n := ⟨qy - 1, by omega⟩
          use (q.1, my); have : my.val = qy - 1 := rfl; dsimp; omega
    else
        -- Case Sum % 4 = 3 in Upper
        if _ : qy % 2 = 1 then
          let mx : Fin n := ⟨qx + 1, by omega⟩
          use (mx, q.2); have : mx.val = qx + 1 := rfl; dsimp; omega
        else
          let my : Fin n := ⟨qy + 1, by omega⟩
          use (q.1, my); have : my.val = qy + 1 := rfl; dsimp; omega

/--
Lemma: The sets sw and sb are disjoint.
(Points in sw have even sum, points in sb have odd sum relative to the transform).
-/
lemma disjoint_sw_sb (n : ℕ) (h_pos : 0 < n) (h_even : Even n) :
  Disjoint (sw n) (sb n) := by
  rw [Finset.disjoint_left]
  intro p hp_sw hp_sb
  unfold sw at hp_sw; rw [mem_filter] at hp_sw
  unfold sb at hp_sb; rw [mem_filter] at hp_sb
  let x := p.1.val; let y := p.2.val

  -- Extract parity facts from predicates
  have h_sw_mod2 : (x + y) % 2 = 0 := by
    rcases hp_sw.2 with h | h <;> { have := h.2.2.1; omega }
  have h_sb_mod2 : (n - 1 - x + y) % 2 = 0 := by
    rcases hp_sb.2 with h | h <;> { have := h.2.2.1; omega }

  -- Derive contradiction
  have h_contra : (n - 1) % 2 = 0 := by omega
  have h_n_mod2 : n % 2 = 0 := (Nat.even_iff).mp h_even
  omega

/--
Lemma: Symmetry implies |sw| = |sb|.
The map x ↦ n - 1 - x is a bijection swapping the two sets.
-/
lemma card_sw_eq_card_sb (n : ℕ) :
  (sw n).card = (sb n).card := by
  let f : Square n → Square n := λ p =>
    (⟨n - 1 - p.1.val, by omega⟩, p.2)
  apply Finset.card_bijective f
  · -- Bijective
    rw [Function.Bijective]; constructor
    · intro a b h; simp [f] at h; ext <;> omega
    · intro b; use f b; simp [f]
      ext
      · have h_le : b.1.val ≤ n - 1 := Nat.le_pred_of_lt b.1.isLt
        apply Nat.sub_sub_self h_le
      · rfl
  · -- Maps sw to sb (and vice versa logic implies bijection on domains)
    intro p
    simp only [f]; unfold sw sb; simp only [mem_filter, Finset.mem_univ, true_and]
    have h_rev : n - 1 - (n - 1 - p.1.val) = p.1.val := by omega
    simp_rw [h_rev]

-- 5. Sufficiency Proof (Size and Validity)

theorem imo1999_p3_sufficiency (n : ℕ) (h_pos : 0 < n) (h_even : Even n) :
  let min_k := n * (n + 2) / 4; let s := solutionSet n
  s.card = min_k ∧ IsValidMarking s := by

  have h_n_mod2 : n % 2 = 0 := (Nat.even_iff).mp h_even

  intro min_k s
  constructor
  · -- Part 1: Cardinality (|s| = min_k)
    -- 1. Decomposition
    have h_union : s = sw n ∪ sb n := rfl

    -- 2. Apply Lemmata
    have h_disjoint := disjoint_sw_sb n h_pos h_even
    have h_sym := card_sw_eq_card_sb n

    -- Calculate |sw|
    have h_card_sw : (sw n).card = n * (n + 2) / 8 := by
      let k := n / 2
      have hk : n = 2 * k := by omega
      rw [card_sw_eq_triangular n k hk, hk]
      rw [← Nat.mul_add 2 k 1, Nat.mul_assoc, Nat.mul_left_comm k 2]; omega

    rw [h_union, Finset.card_union_of_disjoint h_disjoint, ← h_sym, h_card_sw]
    have h_arith : 2 * (n * (n + 2) / 8) = n * (n + 2) / 4 := by
      rcases h_even with ⟨k, rfl⟩
      simp only [← two_mul]
      rw [← Nat.mul_add 2 k 1, Nat.mul_assoc, Nat.mul_left_comm k 2]
      rcases Nat.even_mul_succ_self k with ⟨m, hm⟩; omega
    omega

  · -- Part 2: Validity
    intro p

    rcases Nat.mod_two_eq_zero_or_one (p.1.val + p.2.val) with h_even_sum | h_odd_sum
    · -- Case: Even sum (Use Reflection + Lemma)
      -- 1. Reflect point p to p'
      let p' : Square n := (⟨n - 1 - p.1.val, by omega⟩, p.2)

      -- 2. p' has odd sum
      have h_p'_odd : (p'.1.val + p'.2.val) % 2 = 1 := by
         have h_x_sum : p'.1.val + p.1.val = n - 1 := by
            have : p'.1.val = n - 1 - p.1.val := rfl; omega
         have h_y_eq : p'.2.val = p.2.val := rfl
         omega

      -- 3. Apply the global Lemma to p' to find neighbor m' in sw
      rcases exists_adjacent_in_sw_of_odd_sum n h_pos h_even p' h_p'_odd with ⟨m', hm'_sw, h_adj'⟩

      -- 4. Reflect m' back to m to find neighbor in sb
      let m : Square n := (⟨n - 1 - m'.1.val, by omega⟩, m'.2)
      use m
      constructor
      · -- m ∈ sb implies m ∈ s
        simp only [s, solutionSet, mem_union]
        right
        unfold sb; rw [mem_filter]; simp only [Finset.mem_univ, true_and]
        have h_coord : n - 1 - m.1.val = m'.1.val := by
            have : m.1.val = n - 1 - m'.1.val := rfl; omega
        rw [h_coord]; unfold sw at hm'_sw; rw [mem_filter] at hm'_sw; exact hm'_sw.2
      · -- Adjacency is preserved under reflection
        unfold Adjacent; simp
        have h_dist : ((p.1.val : ℤ) - m.1.val).natAbs = ((p'.1.val : ℤ) - m'.1.val).natAbs := by
           have : p'.1.val = n - 1 - p.1.val := rfl
           have : m.1.val = n - 1 - m'.1.val := rfl
           omega
        rw [h_dist]; exact h_adj'

    · -- Case: Odd sum (Directly apply Lemma)
      -- Directly call the lemma
      rcases exists_adjacent_in_sw_of_odd_sum n h_pos h_even p h_odd_sum with ⟨m, hm_sw, h_adj⟩
      use m
      constructor
      · -- m ∈ sw implies m ∈ s
        simp only [s, solutionSet, mem_union]
        left; exact hm_sw
      · exact h_adj


-- 6. Necessity Proof (|S| ≧ N)

theorem imo1999_p3_necessity (n : ℕ) (h_even : Even n) (s : Finset (Square n)) :
  IsValidMarking s → s.card ≥ n * (n + 2) / 4 := by
  intro h_valid
  have h_n_mod2 : n % 2 = 0 := Nat.even_iff.mp h_even
  rcases h_even with ⟨k, h_n⟩
  let sw := s.filter (λ p => (p.1.val + p.2.val) % 2 = 0)
  let sb := s.filter (λ p => (p.1.val + p.2.val) % 2 = 1)
  have h_disjoint : Disjoint sw sb := by
    rw [Finset.disjoint_left]
    intro p h_in_sw h_in_sb
    rw [mem_filter] at h_in_sw h_in_sb
    have h0 := h_in_sw.2; have h1 := h_in_sb.2
    rw [h0] at h1; contradiction
  have h_union : s = sw ∪ sb := by
    ext p; rw [mem_union, mem_filter, mem_filter]
    constructor <;> intro h
    · simp [h]; omega
    · rcases h with ⟨h, _⟩ | ⟨h, _⟩ <;> exact h

  have h_card_s : s.card = sw.card + sb.card := by
    rw [h_union, Finset.card_union_of_disjoint h_disjoint]

  let even_sum_squares := squaresEvenSum n
  let odd_sum_squares  := squaresOddSum n

  have h_cover_even : ∀ p ∈ even_sum_squares, ∃ m ∈ sb, Adjacent p m := by
    intro p hp
    rcases h_valid p with ⟨m, hm_in_s, h_adj⟩
    use m; constructor
    · dsimp [sb]; rw [mem_filter]
      use hm_in_s
      dsimp [even_sum_squares] at hp; unfold squaresEvenSum at hp; rw [mem_filter] at hp
      have h_ne := adjacent_parity_ne h_adj
      omega
    · exact h_adj

  have h_cover_odd : ∀ p ∈ odd_sum_squares, ∃ m ∈ sw, Adjacent p m := by
    intro p hp
    rcases h_valid p with ⟨m, hm_in_s, h_adj⟩
    use m; constructor
    · dsimp [sw]; rw [mem_filter]
      use hm_in_s
      dsimp [odd_sum_squares] at hp; unfold squaresOddSum at hp; rw [mem_filter] at hp
      have h_ne := adjacent_parity_ne h_adj
      omega
    · exact h_adj

  -- Apply Lower Bound Lemma
  have h_bound_sb : sb.card ≥ n * (n + 2) / 8 := by
    rw [← two_mul] at h_n
    apply card_lower_bound_of_cover n k h_n sb 0 zero_le_one
    intro p h_parity0
    refine h_cover_even p ?_
    dsimp [even_sum_squares, squaresEvenSum]
    exact (mem_filter_univ p).mpr h_parity0

  have h_bound_sw : sw.card ≥ n * (n + 2) / 8 := by
    rw [← two_mul] at h_n
    apply card_lower_bound_of_cover n k h_n sw 1 (le_refl _)
    intro p h_parity1
    refine h_cover_odd p ?_
    dsimp [odd_sum_squares, squaresOddSum]
    exact (mem_filter_univ p).mpr h_parity1

  rw [h_card_s]
  have h_sum_ge : sw.card + sb.card ≥ n * (n + 2) / 8 + n * (n + 2) / 8 :=
    Nat.add_le_add h_bound_sw h_bound_sb

  have h_mul : n * (n + 2) / 8 + n * (n + 2) / 8 = n * (n + 2) / 4 := by
    rw [h_n]
    rcases Nat.even_mul_succ_self k with ⟨m, hm⟩
    have h_eq : 2 * k * (2 * k + 2) = 8 * m := by
      rw [← Nat.mul_add 2 k 1, Nat.mul_assoc, Nat.mul_left_comm k 2, hm]; ring
    simp only [← two_mul]; rw [h_eq]; omega
  rw [h_mul] at h_sum_ge
  exact h_sum_ge



noncomputable def solution_value (n : ℕ) : ℕ := n * (n + 2) / 4

theorem imo1999_p3 (n : ℕ) (h_pos : 0 < n) (h_even : Even n) :
  IsLeast
    {k : ℕ | ∃ s : Finset (Square n), IsValidMarking s ∧ s.card = k}
    (solution_value n) := by
  constructor
  -- 1. Membership (Sufficiency): A valid marking of size N exists.
  · simp only [Set.mem_setOf_eq]
    use solutionSet n
    exact (imo1999_p3_sufficiency n h_pos h_even).symm
  -- 2. Lower Bound (Necessity): Any valid marking has size at least N.
  · intro k hk
    simp only [Set.mem_setOf_eq] at hk
    rcases hk with ⟨s, h_valid, h_card_eq⟩
    have h_ge := imo1999_p3_necessity n h_even s h_valid
    rw [← h_card_eq]
    exact h_ge

end Imo1999P3

-- ═══ Imo2000P2 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 2000, Problem 2

Let a, b, c be positive real numbers such that abc = 1. Show that

    (a - 1 + 1/b)(b - 1 + 1/c)(c - 1 + 1/a) ≤ 1.
-/

namespace Imo2000P2



lemma schur (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) :
    a^2 * b + a^2 * c + b^2 * a + b^2 * c + c^2 * a + c^2 * b ≤
    a^3 + b^3 + c^3 + 3 * a * b * c := by
  wlog Hcb : c ≤ b with h1
  · have h3 : b ≤ c := le_of_not_ge Hcb
    linarith [h1 a c b ha hc hb h3]
  wlog Hba : b ≤ a with h2
  · have h4 : a ≤ b := le_of_not_ge Hba
    obtain hca | hac : c ≤ a ∨ a ≤ c := le_total c a
    · have := h2 b a c hb ha hc hca h4
      linarith only [this]
    · have := h2 b c a hb hc ha hac Hcb
      linarith only [this]
  have h5 : a * (a - b) * (a - c) + b * (b - a) * (b - c) =
            (a - b) * (a * (a - c) - b * (b - c)) := by ring

  have h6 : 0 ≤ (a - b) * (a * (a - c) - b * (b - c)) := by
    apply mul_nonneg
    · exact sub_nonneg_of_le Hba
    · nlinarith

  rw [← h5] at h6
  have h12 : 0 ≤ (c - a) * (c - b) := by nlinarith only [Hba, Hcb]
  have h13 : 0 ≤ c * (c - a) * (c - b) := by nlinarith only [hc, h12]
  linarith

lemma lemma1 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) :
    (-x + y + z) * (x - y + z) * (x + y - z) ≤ x * y * z := by
  linarith [schur x y z (le_of_lt hx) (le_of_lt hy) (le_of_lt hz)]

lemma lemma2 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b)
    (habc : a * b * c = 1) :
    ∃ x y z : ℝ, 0 < x ∧ 0 < y ∧ 0 < z ∧
                 a = x / y ∧ b = y / z ∧ c = z / x := by
  refine ⟨a, 1, (1/b), ha, zero_lt_one, ?_, ?_, ?_, ?_⟩
  · exact one_div_pos.mpr hb
  · exact (div_one a).symm
  · exact (one_div_one_div b).symm
  · field_simp; linarith



theorem imo2000_p2 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)
    (habc : a * b * c = 1) :
    (a - 1 + 1 / b) * (b - 1 + 1 / c) * (c - 1 + 1 / a) ≤ 1 := by
  -- we follow the solution from
  -- https://web.evanchen.cc/exams/IMO-2000-notes.pdf

  -- Let a = x/y, b = y/z, c = z/x for x, y, z > 0.
  obtain ⟨x,y,z, hx, hy, hz, rfl, rfl, rfl⟩ := lemma2 a b c ha hb habc
  have h1 := lemma1 x y z hx hy hz
  have h2 : 0 < y * z * x := by positivity
  suffices H : (x - y + z) * (y - z + x) * (z - x + y) ≤ (y * z * x) by
    field_simp
    grind
  linarith


end Imo2000P2

-- ═══ Imo2001P1 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 2001, Problem 1

Let ABC be an acute-angled triangle with O as its circumcenter. Let P
on line BC be the foot of the altitude from A. Assume that
∠BCA ≥ ∠ABC + 30°. Prove that ∠CAB + ∠COP < 90°.
-/

namespace Imo2001P1

open scoped EuclideanGeometry



open EuclideanGeometry Affine.Simplex Affine.Triangle

-- We need some instances in order to talk about oriented angles.

local instance planeFiniteDim :
    Fact (Module.finrank ℝ (EuclideanSpace ℝ (Fin 2)) = 2) :=
  ⟨finrank_euclideanSpace_fin⟩

noncomputable local instance someOrientation :
    Module.Oriented ℝ (EuclideanSpace ℝ (Fin 2)) (Fin 2) :=
  ⟨Module.Basis.orientation (Module.finBasisOfFinrankEq _ _ planeFiniteDim.out)⟩

lemma aux₀ {x y : ℝ} (h : ∃ k : ℤ, x = y * k)
  (hx : |x| < y)
  : x = 0 := by
    rcases h with ⟨k, hk⟩
    rw [hk]
    apply mul_eq_zero_of_right
    simp
    contrapose! hx
    rw [hk, abs_mul]
    have h₁ : (1 : ℝ) ≤ |↑k| := by
      rw [← Int.cast_one, ← Int.cast_abs, Int.cast_le]
      exact Int.one_le_abs hx
    calc y
        ≤ |y| := by exact le_abs_self y
      _ = |y| * 1 := by exact (mul_one |y|).symm
      _ ≤ |y| * |↑k| := by exact mul_le_mul_of_nonneg_left h₁ (abs_nonneg y)

lemma aux₁ {x y z : ℝ}
  (hx' : 0 ≤ x) (hy' : y ≤ 0)
  (hx : |x| < z) (hy : |y| < z)
  : |x + y| < z := by
    rw [abs_lt]
    constructor
    · calc -z
          _ < y := by exact (abs_lt.mp hy).left
          _ = 0 + y := by exact (zero_add y).symm
          _ ≤ x + y := by exact add_le_add_left hx' y
    · calc x + y
        _ ≤ x + 0 := by exact add_le_add_right hy' x
        _ = x := by exact add_zero x
        _ < z := by exact (abs_lt.mp hx).right

lemma aux₂ {x y z : ℝ} (h : |x + y| = z)
  (hx : |x| < z) (hy : |y| < z)
  : |x| + |y| = z := by
    symm
    rw [← h, abs_add_eq_add_abs_iff]
    contrapose! h
    apply ne_of_lt
    by_cases hx' : 0 ≤ x
    · have hy' := h.left hx'
      exact aux₁ hx' (le_of_lt hy') hx hy
    · push_neg at hx'
      have hy' := h.right (le_of_lt hx')
      rw [add_comm]
      exact aux₁ (le_of_lt hy') (le_of_lt hx') hy hx

lemma aux₃ {a b : Real.Angle} (h : 2 • a + 2 • b = Real.pi)
  (ha : |a.toReal| < Real.pi / 2) (hb : |b.toReal| < Real.pi / 2)
  : |a.toReal| + |b.toReal| = Real.pi / 2 := by
    rw [← Real.Angle.coe_toReal a, ← Real.Angle.coe_toReal b] at h
    set a' := a.toReal
    set b' := b.toReal
    rw [← smul_add] at h
    rw [Real.Angle.two_nsmul_eq_pi_iff, ← Real.Angle.coe_add] at h
    repeat rw [Real.Angle.angle_eq_iff_two_pi_dvd_sub] at h
    have h₁ : |a' + b'| < Real.pi := by
      calc |a' + b'|
          ≤ |a'| + |b'| := by exact abs_add_le a' b'
        _ < Real.pi / 2 + Real.pi / 2 := by exact add_lt_add ha hb
        _ = Real.pi := by ring
    have h₂ : 0 ≤ Real.pi / 2 := by
      apply div_nonneg Real.pi_nonneg
      norm_num
    have h₃ : |a' + b'| + |Real.pi / 2| < 2 * Real.pi := by
      calc |a' + b'| + |Real.pi / 2|
            < Real.pi + |Real.pi / 2| := by exact add_lt_add_left h₁ _
          _ = Real.pi + Real.pi / 2 := by exact (add_right_inj _).mpr (abs_eq_self.mpr h₂)
          _ ≤ Real.pi + Real.pi / 2 + Real.pi / 2 := by exact (le_add_iff_nonneg_right _).mpr h₂
          _ = 2 * Real.pi := by ring
    have h₄ : |a' + b'| = Real.pi / 2 := by
      rw [abs_eq h₂]
      rcases h with pos|neg
      · left
        apply eq_of_sub_eq_zero
        apply aux₀ pos
        calc |a' + b' - Real.pi / 2|
            ≤ |a' + b'| + |Real.pi / 2| := by exact abs_sub _ _
          _ < 2 * Real.pi := by exact h₃
      · right
        apply eq_of_sub_eq_zero
        rw [← neg_div]
        apply aux₀ neg
        rw [neg_div, sub_neg_eq_add]
        calc |a' + b' + Real.pi / 2|
            ≤ |a' + b'| + |Real.pi / 2| := by exact abs_add_le _ _
          _ < 2 * Real.pi := by exact h₃
    exact aux₂ h₄ ha hb

lemma aux₄ {a : Real.Angle} (h : 2 • 2 • a = 0) (ha : |a.toReal| < Real.pi / 2)
  : |a.toReal| = 0 := by
    rw [smul_smul] at h
    have h₁ : 2 * 2 = 4 := by norm_num
    rw [h₁] at h
    rw [← Real.Angle.coe_toReal a] at h
    set a' := a.toReal
    rw [← Real.Angle.coe_nsmul] at h
    rw [Real.Angle.coe_eq_zero_iff] at h
    rcases h with ⟨k, hk⟩
    have h₂ : a' = Real.pi / 2 * k:= by
      calc a'
          = (4 • a') / 4 := by ring
        _ = k • (2 * Real.pi) / 4 := by rw [hk]
        _ = Real.pi / 2 * k := by ring
    rw [abs_eq_zero]
    exact aux₀ ⟨k, h₂⟩ ha

lemma aux₅ {x y z: ℝ} (h : ∃ k : ℤ, x - y = z * k)
  (hz : 0 < z) (hy : |y| ≤ z / 2)
  : |y| ≤ |x| := by
  rcases h with ⟨k, hk⟩
  by_cases h': k = 0
  · rw [h', Int.cast_zero, mul_zero, sub_eq_zero] at hk
    rw [hk]
  · push_neg at h'
    apply le_trans hy
    have h₁ : (1 : ℝ) ≤ |↑k| := by
      rw [← Int.cast_one, ← Int.cast_abs, Int.cast_le]
      exact Int.one_le_abs h'
    rw [sub_eq_iff_eq_add] at hk
    rw [hk]
    rw [le_abs] at *
    rw [abs_le] at *
    rcases h₁ with pos|neg
    · left
      calc z / 2
          = z * 1 + -(z / 2) := by ring
        _ ≤ z * ↑k + y := by
          apply add_le_add
          · rw [mul_le_mul_iff_right₀ hz]
            exact pos
          · exact hy.left
    · right
      calc z / 2
          = z * 1 + -(z / 2) := by ring
        _ ≤ z * (-↑k) + -y := by
            apply add_le_add
            · rw [mul_le_mul_iff_right₀ hz]
              exact neg
            · apply neg_le_neg
              exact hy.right
        _ = -(z * ↑k + y) := by ring

lemma aux₆ {a b c : Real.Angle} (h : a + b = c)
  : |c.toReal| ≤ |a.toReal| + |b.toReal| := by
    rw [← Real.Angle.coe_toReal a] at h
    rw [← Real.Angle.coe_toReal b] at h
    rw [← Real.Angle.coe_toReal c] at h
    set a' := a.toReal
    set b' := b.toReal
    set c' := c.toReal
    rw [← Real.Angle.coe_add] at h
    rw [Real.Angle.angle_eq_iff_two_pi_dvd_sub] at h
    calc |c'|
        ≤ |a' + b'| := by
          apply aux₅ h Real.two_pi_pos
          rw [mul_div_cancel_left₀ Real.pi (by norm_num:(2 : ℝ) ≠ 0)]
          exact Real.Angle.abs_toReal_le_pi c
      _ ≤ |a'| + |b'| := by apply abs_add_le

lemma aux₇ {a : Real.Angle} : Real.sin |a.toReal| = |a.sin| := by
  nth_rw 2 [← Real.Angle.coe_toReal a]
  rw [Real.Angle.sin_coe]
  have ha' := Real.Angle.abs_toReal_le_pi a
  exact (Real.abs_sin_eq_sin_abs_of_abs_le_pi ha').symm

structure Imo2001q1Cfg where
  (A B C : EuclideanSpace ℝ (Fin 2))
  (hABC : AffineIndependent ℝ ![A, B, C])
  (hAcuteA : ∠ C A B < Real.pi / 2)
  (hAcuteB : ∠ A B C < Real.pi / 2)
  (hAcuteC : ∠ B C A < Real.pi / 2)
  (hAB : ∠ A B C + Real.pi / 6 ≤ ∠ B C A)

namespace Imo2001q1Cfg

variable (cfg : Imo2001q1Cfg)

def ABC : Affine.Triangle ℝ (EuclideanSpace ℝ (Fin 2)) :=
  ⟨![cfg.A, cfg.B, cfg.C], cfg.hABC⟩

noncomputable def P : EuclideanSpace ℝ (Fin 2) :=
  cfg.ABC.altitudeFoot 0

noncomputable def O :EuclideanSpace ℝ (Fin 2) :=
  cfg.ABC.circumcenter

lemma A_ne_B : cfg.A ≠ cfg.B := by
    exact cfg.hABC.injective.ne (by decide : (0 : Fin 3) ≠ 1)

lemma A_ne_C : cfg.A ≠ cfg.C := by
    exact cfg.hABC.injective.ne (by decide : (0 : Fin 3) ≠ 2)

lemma C_ne_B : cfg.C ≠ cfg.B := by
  exact cfg.hABC.injective.ne (by decide : (2 : Fin 3) ≠ 1)

lemma CO_circumradius : dist cfg.O cfg.C = cfg.ABC.circumradius := by
  exact dist_circumcenter_eq_circumradius' cfg.ABC 2

lemma C_ne_O : cfg.O ≠ cfg.C := by
  rw [← dist_pos, CO_circumradius]
  exact circumradius_pos cfg.ABC

lemma A_opposite_BC : {cfg.B, cfg.C} = Set.range (cfg.ABC.faceOpposite 0).points := by
  apply Set.eq_of_subset_of_card_le
  · intro x x_in
    simp at *
    rcases x_in with h'|h'
    · use 1
      rw [h']
      simp
      rfl
    · use 2
      rw [h']
      simp
      rfl
  · simp
    calc (Finset.image cfg.ABC.points {0}ᶜ).card
        ≤ ({0}ᶜ : Finset (Fin (2 + 1))).card := by exact Finset.card_image_le
      _ = 2 := by
        rw [Finset.card_compl]
        simp
      _ = ({cfg.B, cfg.C} : Finset _).card := by
        rw [Finset.card_insert_of_notMem, Finset.card_singleton]
        simp
        exact (C_ne_B cfg).symm

lemma PBC_collinear : Collinear ℝ {cfg.P, cfg.B, cfg.C} := by
  apply collinear_insert_of_mem_affineSpan_pair
  rw [A_opposite_BC]
  apply altitudeFoot_mem_affineSpan_faceOpposite

lemma APx_eq : ∀ x ∈ ({cfg.B, cfg.C} : Set _), ∠ cfg.A cfg.P x = Real.pi / 2 := by
  intro x hx
  rw [EuclideanGeometry.angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]
  rw [real_inner_comm]
  apply Submodule.IsOrtho.inner_eq (vectorSpan_isOrtho_altitude_direction cfg.ABC 0)
  · have h₁ := A_opposite_BC cfg
    simp at h₁
    apply vsub_mem_vectorSpan_of_mem_affineSpan_of_mem_affineSpan
    · rw [← h₁]
      exact mem_affineSpan _ hx
    · rw [← h₁]
      exact Collinear.mem_affineSpan_of_mem_of_ne (PBC_collinear cfg) (by simp:_) (by simp:_) (by simp:_) (C_ne_B cfg).symm
  · apply vsub_mem_vectorSpan _ (mem_altitude cfg.ABC 0) (altitudeFoot_mem_altitude cfg.ABC 0)

lemma APC_eq : ∠ cfg.A cfg.P cfg.C = Real.pi / 2 := by
  apply APx_eq
  simp

lemma APB_eq : ∠ cfg.A cfg.P cfg.B = Real.pi / 2 := by
  apply APx_eq
  simp

lemma PC_eq : dist cfg.P cfg.C = dist cfg.C cfg.A * Real.cos (∠ cfg.A cfg.C cfg.P) := by
  symm
  rw [mul_comm, angle_comm, dist_comm cfg.C cfg.A, dist_comm cfg.P cfg.C]
  exact cos_angle_mul_dist_of_angle_eq_pi_div_two (APC_eq cfg)

lemma non_sbtw_BCP : ¬Sbtw ℝ cfg.B cfg.C cfg.P := by
  intro h
  have h₁ := h.angle₁₂₃_eq_pi
  contrapose! h₁
  apply ne_of_lt
  have h₂ := oangle_add (C_ne_B cfg).symm (A_ne_C cfg) h.ne_right.symm
  have h₃ := angle_le_pi_div_two_of_angle_eq_pi_div_two (APC_eq cfg)
  calc ∠ cfg.B cfg.C cfg.P
      ≤ ∠ cfg.B cfg.C cfg.A + ∠ cfg.P cfg.C cfg.A := by
        rw [angle_comm cfg.P cfg.C cfg.A]
        exact angle_le_angle_add_angle cfg.C cfg.B cfg.A cfg.P
    _ < Real.pi / 2 + Real.pi / 2 := by
      apply add_lt_add_of_lt_of_le cfg.hAcuteC h₃
    _ = Real.pi := by ring

lemma wbtw_BPC : Wbtw ℝ cfg.P cfg.B cfg.C ∨ Wbtw ℝ cfg.C cfg.P cfg.B := by
  have h₁ := non_sbtw_BCP cfg
  have h₂ := (PBC_collinear cfg).wbtw_or_wbtw_or_wbtw
  contrapose! h₁
  constructor
  · grind
  · rcases h₁ with ⟨h_PBC, h_CPB⟩
    constructor
    · exact C_ne_B cfg
    · contrapose! h_CPB
      rw [h_CPB]
      apply wbtw_self_left

lemma P_ne_C : cfg.P ≠ cfg.C := by
  intro h
  have h₁ := cfg.hAcuteC
  contrapose! h₁
  apply le_of_eq
  rw [← h, angle_comm, APB_eq]

lemma oriented_BCO_CAB : 2 • ∡ cfg.B cfg.C cfg.O + 2 • ∡ cfg.C cfg.A cfg.B = Real.pi := by
  apply Sphere.two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi
  · apply mem_circumsphere cfg.ABC 2
  · apply mem_circumsphere cfg.ABC 0
  · apply mem_circumsphere cfg.ABC 1
  · exact A_ne_C cfg
  · exact A_ne_B cfg
  · exact C_ne_B cfg

lemma acute_BCO : ∠ cfg.B cfg.C cfg.O < Real.pi / 2 := by
  rw [angle_eq_abs_oangle_toReal (C_ne_B cfg).symm (C_ne_O cfg)]
  apply Sphere.abs_oangle_center_right_toReal_lt_pi_div_two
  · apply mem_circumsphere cfg.ABC 2
  · apply mem_circumsphere cfg.ABC 1

lemma BCO_CAB : ∠ cfg.B cfg.C cfg.O + ∠ cfg.C cfg.A cfg.B = Real.pi / 2 := by
  have h₁ := oriented_BCO_CAB cfg
  have h₂ := acute_BCO cfg
  have h₃ := cfg.hAcuteA
  rw [angle_eq_abs_oangle_toReal (C_ne_B cfg).symm (C_ne_O cfg)] at *
  rw [angle_eq_abs_oangle_toReal (A_ne_C cfg).symm (A_ne_B cfg).symm] at *
  exact aux₃ h₁ h₂ h₃

lemma xCP_eq_xCB : ∀ x, x ≠ cfg.C → ∠ x cfg.C cfg.P = ∠ x cfg.C cfg.B := by
  intro x hx
  have h₁ : ∡ x cfg.C cfg.P = ∡ x cfg.C cfg.B := by
    apply eq_of_sub_eq_zero
    rw [oangle_sub_left hx (C_ne_B cfg).symm (P_ne_C cfg)]
    rw [oangle_eq_zero_iff_wbtw, wbtw_comm]
    exact wbtw_BPC cfg
  rw [angle_eq_abs_oangle_toReal hx (C_ne_B cfg).symm]
  rw [angle_eq_abs_oangle_toReal hx (P_ne_C cfg)]
  rw [h₁]

lemma OCP_eq_OCB : ∠ cfg.O cfg.C cfg.P = ∠ cfg.O cfg.C cfg.B := by
  exact xCP_eq_xCB cfg cfg.O (C_ne_O cfg)

lemma CAB_OCP : ∠ cfg.C cfg.A cfg.B = Real.pi / 2 - ∠ cfg.O cfg.C cfg.P := by
  rw [← BCO_CAB, OCP_eq_OCB, angle_comm cfg.B cfg.C cfg.O]
  ring

lemma oriented_BOC_BAC : ∡ cfg.B cfg.O cfg.C = 2 • ∡ cfg.B cfg.A cfg.C:= by
  apply Sphere.oangle_center_eq_two_zsmul_oangle
  · apply mem_circumsphere cfg.ABC 1
  · apply mem_circumsphere cfg.ABC 0
  · apply mem_circumsphere cfg.ABC 2
  · exact A_ne_B cfg
  · exact A_ne_C cfg

lemma angle_in_ABC_pos (i j k : Fin 3) (h : Function.Injective ![i, j, k])
  : ∠ (cfg.ABC.points i) (cfg.ABC.points j) (cfg.ABC.points k) ≠ 0 := by
  intro h'
  rw [angle_eq_zero_iff_ne_and_wbtw] at h'
  have h₁ : Function.Injective ![j, i, k] := by
    have h' : ![j, i, k] = Function.comp ![i, j, k] ![1, 0, 2]  := by
      ext x
      fin_cases x <;> simp
    rw [h']
    exact Function.Injective.comp h (by decide)
  have h₂ : Function.Injective ![j, k, i] := by
    have h' : ![j, k, i] = Function.comp ![i, j, k] ![1, 2, 0]  := by
      ext x
      fin_cases x <;> simp
    rw [h']
    exact Function.Injective.comp h (by decide)
  have h₃ := AffineIndependent.not_wbtw_of_injective j i k h₁ cfg.ABC.independent
  have h₄ := AffineIndependent.not_wbtw_of_injective j k i h₂ cfg.ABC.independent
  tauto

lemma BOC_non_collinear : ¬Collinear ℝ {cfg.B, cfg.O, cfg.C} := by
  intro h
  rw [← oangle_eq_zero_or_eq_pi_iff_collinear] at h
  rw [oriented_BOC_BAC] at h
  apply Real.Angle.two_zsmul_eq_zero_iff.mpr at h
  have h₁ := cfg.hAcuteA
  rw [angle_comm] at h₁
  rw [angle_eq_abs_oangle_toReal (A_ne_B cfg).symm (A_ne_C cfg).symm] at h₁
  have h₂ := aux₄ h h₁
  rw [←angle_eq_abs_oangle_toReal (A_ne_B cfg).symm (A_ne_C cfg).symm] at h₂
  apply angle_in_ABC_pos cfg (1 : Fin 3) 0 2 (by decide)
  exact h₂

lemma OCP_non_collinear : ¬Collinear ℝ {cfg.P, cfg.C, cfg.O} := by
  intro h
  apply BOC_non_collinear cfg
  have h₁ : cfg.O ∈ affineSpan ℝ {cfg.P, cfg.C} := by
    exact Collinear.mem_affineSpan_of_mem_of_ne h (by simp:_) (by simp:_) (by simp:_) (P_ne_C cfg)
  have h₂ : cfg.B ∈ affineSpan ℝ {cfg.P, cfg.C} := by
    exact Collinear.mem_affineSpan_of_mem_of_ne (PBC_collinear cfg) (by simp:_) (by simp:_) (by simp:_) (P_ne_C cfg)
  have h₃ := collinear_insert_insert_of_mem_affineSpan_pair h₁ h₂
  exact Collinear.subset (by grind:_) (h₃)

lemma ACP_eq_ACB : ∠ cfg.A cfg.C cfg.P = ∠ cfg.A cfg.C cfg.B := by
  exact xCP_eq_xCB cfg cfg.A (A_ne_C cfg)

lemma CA_eq : dist cfg.C cfg.A = 2 * cfg.ABC.circumradius * Real.sin (∠ cfg.A cfg.B cfg.C) := by
  rw [angle_eq_abs_oangle_toReal (A_ne_B cfg) (C_ne_B cfg)]
  rw [aux₇]
  have h₁ : |(∡ cfg.A cfg.B cfg.C).sin| ≠ 0 := by
    rw [abs_ne_zero, Real.Angle.sin_ne_zero_iff]
    constructor
    · intro h'
      rw [oangle_eq_zero_iff_angle_eq_zero (A_ne_B cfg) (C_ne_B cfg)] at h'
      apply angle_in_ABC_pos cfg (0 : Fin 3) 1 2 (by decide)
      exact h'
    · apply oangle_eq_pi_iff_angle_eq_pi.not.mpr
      exact ne_of_lt (lt_trans cfg.hAcuteB (div_two_lt_of_pos Real.pi_pos))
  have h₂ : dist cfg.C cfg.A / |(∡ cfg.A cfg.B cfg.C).sin| = 2 * cfg.ABC.circumradius := by
    rw [circumradius, dist_comm]
    apply Sphere.dist_div_sin_oangle_eq_two_mul_radius
    · apply mem_circumsphere cfg.ABC 0
    · apply mem_circumsphere cfg.ABC 1
    · apply mem_circumsphere cfg.ABC 2
    · exact A_ne_B cfg
    · exact A_ne_C cfg
    · exact (C_ne_B cfg).symm
  calc dist cfg.C cfg.A
      = dist cfg.C cfg.A / |(∡ cfg.A cfg.B cfg.C).sin| * |(∡ cfg.A cfg.B cfg.C).sin| := by
        rw [div_mul_cancel₀]
        exact h₁
    _ = 2 * cfg.ABC.circumradius * |(∡ cfg.A cfg.B cfg.C).sin| := by
      rw [h₂]

lemma four_sin_B_cos_A_le_one : 4 * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.C cfg.B) ≤ 1 := by
  have h₁ : Real.cos (∠ cfg.A cfg.C cfg.B) ≤ Real.cos (∠ cfg.A cfg.B cfg.C + Real.pi / 6) := by
    apply Real.cos_le_cos_of_nonneg_of_le_pi
    · apply add_nonneg (angle_nonneg _ _ _)
      positivity
    · apply angle_le_pi
    · nth_rw 2 [angle_comm]
      exact cfg.hAB
  have h₂ : 0 < Real.sin (∠ cfg.A cfg.B cfg.C) := by
    apply Real.sin_pos_of_mem_Ioo
    simp
    constructor
    · apply lt_of_le_of_ne (angle_nonneg _ _ _)
      symm
      exact angle_in_ABC_pos cfg (0 : Fin 3) 1 2 (by decide)
    · exact lt_trans cfg.hAcuteB (div_two_lt_of_pos Real.pi_pos)
  calc 4 * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.C cfg.B)
      ≤ 4 * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.B cfg.C + Real.pi / 6) := by
        rw [mul_le_mul_iff_right₀]
        · exact h₁
        · positivity
    _ = 2 * (2 * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.B cfg.C + Real.pi / 6)) := by ring
    _ = 2 * (Real.sin (∠ cfg.A cfg.B cfg.C - (∠ cfg.A cfg.B cfg.C + Real.pi / 6)) + Real.sin (∠ cfg.A cfg.B cfg.C + (∠ cfg.A cfg.B cfg.C + Real.pi / 6))) := by
        rw [Real.two_mul_sin_mul_cos]
    _ = 2 * (Real.sin (- Real.pi / 6) + Real.sin (2 * ∠ cfg.A cfg.B cfg.C + Real.pi / 6)) := by ring_nf
    _ = 2 * (- 1 / 2 + Real.sin (2 * ∠ cfg.A cfg.B cfg.C + Real.pi / 6)) := by
        rw [neg_div, Real.sin_neg, Real.sin_pi_div_six, neg_div]
    _ ≤ 2 * (- 1 / 2 + 1) := by
        rw [mul_le_mul_iff_right₀]
        · rw [add_le_add_iff_left]
          apply Real.sin_le_one
        · norm_num
    _ = 1 := by norm_num

lemma two_mul_PC_le_circumradius : 2 * dist cfg.P cfg.C ≤ cfg.ABC.circumradius := by
  rw [PC_eq, ACP_eq_ACB, CA_eq]
  calc 2 * (2 * circumradius cfg.ABC * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.C cfg.B))
      = circumradius cfg.ABC * (4 * Real.sin (∠ cfg.A cfg.B cfg.C) * Real.cos (∠ cfg.A cfg.C cfg.B)) := by ring
    _ ≤ circumradius cfg.ABC * 1 := by
      rw [mul_le_mul_iff_right₀ (circumradius_pos cfg.ABC)]
      exact four_sin_B_cos_A_le_one cfg
    _ = circumradius cfg.ABC := by ring

lemma PC_lt_PO : dist cfg.P cfg.C < dist cfg.P cfg.O := by
  have h₁ : dist cfg.O cfg.C < dist cfg.O cfg.P + dist cfg.P cfg.C := by
    rw [dist_lt_dist_add_dist_iff]
    intro h'
    apply OCP_non_collinear cfg
    exact Collinear.subset (by grind:_) (h'.collinear)
  calc dist cfg.P cfg.C
      = 2 * dist cfg.P cfg.C - dist cfg.P cfg.C:= by ring
    _ ≤ cfg.ABC.circumradius - dist cfg.P cfg.C := by exact sub_le_sub_right (two_mul_PC_le_circumradius cfg) _
    _ = dist cfg.O cfg.C - dist cfg.P cfg.C := by rw [CO_circumradius]
    _ < dist cfg.O cfg.P + dist cfg.P cfg.C - dist cfg.P cfg.C := by exact sub_lt_sub_right h₁ _
    _ = dist cfg.O cfg.P := by ring
    _ = dist cfg.P cfg.O := by apply dist_comm

lemma COP_le_OCP : ∠ cfg.C cfg.O cfg.P < ∠ cfg.O cfg.C cfg.P := by
  rw [angle_comm cfg.C cfg.O cfg.P, angle_comm cfg.O cfg.C cfg.P]
  rw [angle_lt_iff_dist_lt (OCP_non_collinear cfg)]
  exact PC_lt_PO cfg

theorem result : ∠ cfg.C cfg.A cfg.B + ∠ cfg.C cfg.ABC.circumcenter cfg.P < Real.pi / 2 := by
  rw [CAB_OCP]
  calc Real.pi / 2 - ∠ cfg.O cfg.C cfg.P + ∠ cfg.C cfg.O cfg.P
      < Real.pi / 2 - ∠ cfg.O cfg.C cfg.P + ∠ cfg.O cfg.C cfg.P := add_lt_add_right (COP_le_OCP cfg) _
    _ = Real.pi / 2 := by ring

end Imo2001q1Cfg



theorem imo2001_p1
    (A B C : EuclideanSpace ℝ (Fin 2))
    (hABC : AffineIndependent ℝ ![A, B, C])
    (hAcuteA : ∠ C A B < Real.pi / 2)
    (hAcuteB : ∠ A B C < Real.pi / 2)
    (hAcuteC : ∠ B C A < Real.pi / 2)
    (hAB : ∠ A B C + Real.pi / 6 ≤ ∠ B C A)
    : let ABC : Affine.Triangle _ _ := ⟨![A, B, C], hABC⟩
      let P := ABC.altitudeFoot 0
      ∠ C A B + ∠ C ABC.circumcenter P < Real.pi / 2 := by
  set cfg : Imo2001q1Cfg := ⟨A, B, C, hABC, hAcuteA, hAcuteB, hAcuteC, hAB⟩
  exact cfg.result

end Imo2001P1

-- ═══ Imo2001P2 ═══

/-
Copyright (c) 2021 Tian Chen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tian Chen
-/




/-!
# International Mathematical Olympiad 2001, Problem 2

Let a, b, c be positive reals. Prove that

    a / √(a² + 8bc) + b / √(b² + 8ca) + c / √(c² + 8ab) ≥ 1.
-/

open Real

namespace Imo2001P2

variable {a b c : ℝ}



/-
## Solution

This proof is based on the bound
$$
\frac{a}{\sqrt{a^2 + 8bc}} ≥
\frac{a^{\frac43}}{a^{\frac43} + b^{\frac43} + c^{\frac43}}.
$$
-/

theorem bound (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    a ^ 4 / (a ^ 4 + b ^ 4 + c ^ 4) ≤ a ^ 3 / sqrt ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) := by
  rw [div_le_div_iff₀ (by positivity) (by positivity)]
  calc a ^ 4 * sqrt ((a ^ 3) ^ 2 + (8:ℝ) * b ^ 3 * c ^ 3)
      = a ^ 3 * (a * sqrt ((a ^ 3) ^ 2 + (8:ℝ) * b ^ 3 * c ^ 3)) := by ring
    _ ≤ a ^ 3 * (a ^ 4 + b ^ 4 + c ^ 4) := ?_
  gcongr
  apply le_of_pow_le_pow_left₀ two_ne_zero (by positivity)
  rw [mul_pow, sq_sqrt (by positivity), ← sub_nonneg]
  calc
    (a ^ 4 + b ^ 4 + c ^ 4) ^ 2 - a ^ 2 * ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)
      = 2 * (a ^ 2 * (b ^ 2 - c ^ 2)) ^ 2 + (b ^ 4 - c ^ 4) ^ 2 +
        (2 * (a ^ 2 * b * c - b ^ 2 * c ^ 2)) ^ 2 := by ring
    _ ≥ 0 := by positivity

theorem imo2001_p2' (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    1 ≤ a ^ 3 / sqrt ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) +
      b ^ 3 / sqrt ((b ^ 3) ^ 2 + 8 * c ^ 3 * a ^ 3) +
        c ^ 3 / sqrt ((c ^ 3) ^ 2 + 8 * a ^ 3 * b ^ 3) :=
  have H : a ^ 4 + b ^ 4 + c ^ 4 ≠ 0 := by positivity
  calc
    _ ≥ _ := add_le_add (add_le_add (bound ha hb hc) (bound hb hc ha)) (bound hc ha hb)
    _ = 1 := by ring_nf at H ⊢; field_simp



theorem imo2001_p2 (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : 1 ≤
    a / sqrt (a ^ 2 + 8 * b * c) + b / sqrt (b ^ 2 + 8 * c * a) +
    c / sqrt (c ^ 2 + 8 * a * b) :=
  have h3 : ∀ {x : ℝ}, 0 < x → (x ^ (3 : ℝ)⁻¹) ^ 3 = x := fun hx =>
    show ↑3 = (3 : ℝ) by norm_num ▸ rpow_inv_natCast_pow hx.le three_ne_zero
  calc
    1 ≤ _ := imo2001_p2' (rpow_pos_of_pos ha (3 : ℝ)⁻¹)
                         (rpow_pos_of_pos hb (3 : ℝ)⁻¹)
                         (rpow_pos_of_pos hc (3 : ℝ)⁻¹)
    _ = _ := by rw [h3 ha, h3 hb, h3 hc]


end Imo2001P2

-- ═══ Imo2001P3 ═══

/-
Copyright (c) 2024 the Compfiles Contributers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan, David Renshaw
-/





/-!
# International Mathematical Olympiad 2001, Problem 3

Twenty-one girls and twenty-one boys took part in a mathematical competition.
It turned out that each contestant solved at most six problems, and for each
pair of a girl and a boy, there was at most one problem solved by both the
girl and the boy. Show that there was a problem solved by at least three
girls and at least three boys.
-/

namespace Imo2001P3

open Finset

/-- A problem is easy for a cohort (boys or girls) if at least three
    of its members solved it. -/
def Easy {α : Type} [Fintype α] (F : α → Finset ℕ) (p : ℕ) : Prop := 3 ≤ #{i | p ∈ F i}



/-
# Solution
Note that not all of the problems a girl $g$ solves can be "hard" for boys, in the sense that
at most two boys solved it. If that was true, by condition 1 at most $6 × 2 = 12$ boys solved
some problem $g$ solved, but by condition 2 that property holds for all 21 boys, which is a
contradiction.
Hence there are at most 5 problems $g$ solved that are hard for boys, and the number of girl-boy
pairs who solved some problem in common that was hard for boys is at most $5 × 2 × 21 = 210$.
By the same reasoning this bound holds when "girls" and "boys" are swapped throughout, but there
are $21^2$ girl-boy pairs in all and $21^2 > 210 + 210$, so some girl-boy pairs solved only problems
in common that were not hard for girls or boys. By condition 2 the result follows.
-/

open Classical in
/-- Every contestant solved at most five problems that were not easy for the other cohort. -/
lemma card_not_easy_le_five {α β : Type} [Fintype α]
    {β_solved : β → Finset ℕ} {α_solved : α → Finset ℕ}
    (hcard : 21 = Fintype.card α)
    {i : β} (hG : #(β_solved i) ≤ 6) (hB : ∀ j, ¬Disjoint (β_solved i) (α_solved j)) :
    #{p ∈ β_solved i | ¬Easy α_solved p} ≤ 5 := by
  by_contra! h
  replace h := le_antisymm (card_filter_le ..) (hG.trans h)
  simp_rw [card_filter_eq_iff, Easy, not_le] at h
  suffices 21 ≤ 12 by norm_num at this
  calc
    _ = #{j | ¬Disjoint (β_solved i) (α_solved j)} := by simp [filter_true_of_mem fun j _ ↦ hB j]
                                                         exact hcard
    _ = #((β_solved i).biUnion fun p ↦ {j | p ∈ α_solved j}) := by congr 1; ext j; simp [not_disjoint_iff]
    _ ≤ ∑ p ∈ β_solved i, #{j | p ∈ α_solved j}              := card_biUnion_le
    _ ≤ ∑ p ∈ β_solved i, 2                           := sum_le_sum fun p mp ↦ Nat.le_of_lt_succ (h p mp)
    _ ≤ _                                      := by rw [sum_const, smul_eq_mul]; lia

open Classical in
/-- There are at most 210 girl-boy pairs who solved some problem in common that was not easy for
a fixed cohort. -/
lemma card_not_easy_le_210 {α β : Type} [Fintype α] [Fintype β]
    (hcard_α : 21 = Fintype.card α)
    (hcard_β : 21 = Fintype.card β)
    {α_solved : α → Finset ℕ} {β_solved : β → Finset ℕ}
    (hA : ∀ i, #(β_solved i) ≤ 6) (hB : ∀ i j, ¬Disjoint (β_solved i) (α_solved j)) :
    #{ij : β × α | ∃ p, ¬Easy α_solved p ∧ p ∈ β_solved ij.1 ∩ α_solved ij.2} ≤ 210 :=
  calc
    _ = ∑ i, #{j | ∃ p, ¬Easy α_solved p ∧ p ∈ β_solved i ∩ α_solved j} := by
      simp_rw [card_filter, ← univ_product_univ, sum_product]
    _ = ∑ i, #({p ∈ β_solved i | ¬Easy α_solved p}.biUnion fun p ↦ {j | p ∈ α_solved j}) := by
      congr!; ext
      simp_rw [mem_biUnion, mem_inter, mem_filter, mem_univ, true_and]
      grind
    _ ≤ ∑ i, ∑ p ∈ β_solved i with ¬Easy α_solved p, #{j | p ∈ α_solved j} := sum_le_sum fun _ _ ↦ card_biUnion_le
    _ ≤ ∑ i, ∑ p ∈  β_solved i with ¬Easy α_solved p, 2 := by
      gcongr with i _ p mp
      rw [mem_filter, Easy, not_le] at mp
      exact Nat.le_of_lt_succ mp.2
    _ ≤ ∑ i : β, 5 * 2 := by
      gcongr with i
      rw [sum_const, smul_eq_mul]
      exact mul_le_mul_left (card_not_easy_le_five hcard_α (hA _) (hB _)) _
    _ = _ := by simp [←hcard_β]



theorem imo2001_p3
    {Girl Boy : Type}
    [Fintype Girl] [Fintype Boy] [DecidableEq Girl] [DecidableEq Boy]
    {G : Girl → Finset ℕ} {B : Boy → Finset ℕ} -- solved problems
    (hcard_girl : 21 = Fintype.card Girl)
    (hcard_boy : 21 = Fintype.card Boy)
    (G_le_6 : ∀ i, #(G i) ≤ 6) -- Every girl solved at most six problems.
    (B_le_6 : ∀ j, #(B j) ≤ 6) -- Every boy solved at most six problems.
    (G_inter_B : ∀ i j, ¬Disjoint (G i) (B j)) :
    ∃ p, Easy G p ∧ Easy B p := by
  have B_inter_G : ∀ i j, ¬Disjoint (B i) (G j) := fun i j ↦ by
    rw [disjoint_comm]; exact G_inter_B j i
  have cB := card_not_easy_le_210 hcard_boy hcard_girl G_le_6 G_inter_B
  have cG := card_not_easy_le_210 hcard_girl hcard_boy B_le_6 B_inter_G
  rw [← card_map ⟨_, Prod.swap_injective⟩] at cG
  have key := (card_union_le _ _).trans (add_le_add cB cG) |>.trans_lt
    (show _ < #(@univ (Girl × Boy) _) by simp [←hcard_boy, ←hcard_girl])
  obtain ⟨⟨i, j⟩, -, hij⟩ := exists_mem_notMem_of_card_lt_card key
  simp_rw [mem_union, mem_map, mem_filter, mem_univ, Function.Embedding.coeFn_mk, Prod.exists,
    Prod.swap_prod_mk, Prod.mk.injEq, existsAndEq, true_and, and_true, not_or, not_exists,
    not_and', not_not, mem_inter, and_imp] at hij
  obtain ⟨p, pG, pB⟩ := not_disjoint_iff.mp (G_inter_B i j)
  use p, hij.2 _ pB pG, hij.1 _ pG pB

end Imo2001P3

-- ═══ Imo2001P4 ═══

/-
Copyright (c) 2025 the Compfiles Contributers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan
-/





/-!
# International Mathematical Olympiad 2001, Problem 4

Let $n > 1$ be an odd integer and let $c_1, c_2, \dots, c_n$ be integers. For
each permutation $a = (a_1, a_2, \dots, a_n)$ of $\{1, 2, \dots, n\}$, define
$S(a) = \sum_{i=1}^n c_i a_i$. Prove that there exist two permutations
$a ≠ b$ of $\{1, 2, \dots, n\}$ such that $n!$ is a divisor of $S(a) - S(b)$.
-/

namespace Imo2001Q4

open Equiv Finset
open scoped Nat

variable {n : ℕ} {c : Fin n → ℤ}

/-- The function `S` in the problem. As implemented here it accepts a
permutation of `Fin n` rather than `Icc 1 n`, and as such contains `+ 1`
to compensate. -/
def S (c : Fin n → ℤ) (a : Perm (Fin n)) : ℤ := ∑ i, c i * (a i + 1)



/-
# Solution
Suppose for contradiction that all the $S(a)$ have distinct residues modulo $n!$, then
$$\sum_{i=0}^{n!-1} i ≡ \sum_a S(a) = \sum_i c_i \sum_a a_i = (n-1)! \frac{n(n+1)}2 \sum_i c_i$$
$$= n! \frac{n+1}2 \sum_i c_i ≡ 0 \bmod n$$
where the last equality relies on $n$ being odd. But $\sum_{i=0}^{n!-1} i = \frac{n!(n!-1)}2$
is not divisible by $n!$, since the quotient is $\frac{n!-1}2$ and $n!$ is even when $n > 1$.
-/

/-- Assuming the opposite of what is to be proved, the sum of `S` over all permutations is
congruent to the sum of all residues modulo `n!`, i.e. `n! * (n! - 1) / 2`. -/
lemma sum_range_modEq_sum_of_contra (hS : ¬∃ a b, a ≠ b ∧ (n ! : ℤ) ∣ S c a - S c b) :
    n ! * ((n ! : ℤ) - 1) / 2 ≡ ∑ a, S c a [ZMOD n !] := by
  have mir : ∀ a, S c a % n ! ∈ Ico (0 : ℤ) n ! := fun a ↦ by
    rw [mem_Ico]; constructor
    · exact Int.emod_nonneg _ (by positivity)
    · exact Int.emod_lt_of_pos _ (by positivity)
  let f : Perm (Fin n) → Ico (0 : ℤ) n ! := fun a ↦ ⟨_, mir a⟩
  have bijf : Function.Bijective f := by
    rw [Fintype.bijective_iff_injective_and_card, Fintype.card_coe, Int.card_Ico, sub_zero,
      Int.toNat_natCast, Fintype.card_perm, Fintype.card_fin]; refine ⟨?_, rfl⟩
    contrapose! hS; unfold Function.Injective at hS; push_neg at hS; obtain ⟨a, b, he, hn⟩ := hS
    use a, b, hn; simp only [f, Subtype.mk.injEq] at he; exact Int.ModEq.dvd he.symm
  let e : Perm (Fin n) ≃ Ico (0 : ℤ) n ! := ofBijective _ bijf
  change _ % _ = _ % _; rw [sum_int_mod]; congr 1
  change _ = ∑ i, (e i).1; rw [Equiv.sum_comp]
  change _ = ∑ i : { x // x ∈ _ }, id i.1; simp_rw [sum_coe_sort, id_eq]
  have Ico_eq : Ico (0 : ℤ) n ! = (range n !).map ⟨_, Nat.cast_injective⟩ := by
    ext i
    simp_rw [mem_Ico, mem_map, mem_range, Function.Embedding.coeFn_mk]
    constructor <;> intro h
    · lift i to ℕ using h.1; rw [Nat.cast_lt] at h; simp [h.2]
    · obtain ⟨z, lz, rfl⟩ := h; simp [lz]
  rw [Ico_eq, sum_map, Function.Embedding.coeFn_mk, ← Nat.cast_sum, sum_range_id]
  change _ = ((_ : ℕ) : ℤ) / (2 : ℕ)
  rw [Nat.cast_mul, Nat.cast_ofNat, Nat.cast_pred (Nat.factorial_pos n)]

/-- The sum over all permutations of `Icc 1 n` of the entry at any fixed position is
`(n - 1)! * (n * (n + 1) / 2)`. -/
lemma sum_perm_add_one {i : Fin n} (hn : 1 ≤ n) :
    ∑ a : Perm (Fin n), ((a i).1 + 1) = (n - 1)! * (n * (n + 1) / 2) := by
  rw [le_iff_exists_add'] at hn; obtain ⟨n, rfl⟩ := hn
  rw [← Equiv.sum_comp (Equiv.mulRight (Equiv.swap i 0))]
  simp_rw [coe_mulRight, Perm.coe_mul, Function.comp_apply, add_tsub_cancel_right,
    swap_apply_left, univ_perm_fin_succ, sum_map, coe_toEmbedding, Fintype.sum_prod_type,
    Perm.decomposeFin_symm_apply_zero, sum_const, smul_eq_mul, ← mul_sum,
    Finset.card_univ, Fintype.card_perm, Fintype.card_fin]
  congr 1
  have es := sum_range_add id 1 (n + 1)
  simp_rw [id_eq, sum_range_one, zero_add, add_comm 1] at es
  rw [Fin.sum_univ_eq_sum_range (· + 1), ← es, sum_range_id, add_tsub_cancel_right, mul_comm]

/-- For odd `n`, the sum of `S` over all permutations is divisible by `n!`. -/
lemma sum_modEq_zero_of_odd (hn : Odd n) : ∑ a, S c a ≡ 0 [ZMOD n !] := by
  unfold S; rw [sum_comm]
  conv_lhs => enter [2, i, 2, a]; rw [← Nat.cast_one, ← Nat.cast_add]
  simp_rw [← mul_sum, ← Nat.cast_sum]
  have eqv : ∀ i, c i * ↑(∑ a : Perm (Fin n), ((a i).1 + 1)) =
      c i * ((n - 1)! * (n * (n + 1) / 2) : ℕ) := fun i ↦ by rw [sum_perm_add_one hn.pos]
  rw [sum_congr rfl fun i _ ↦ eqv i, ← sum_mul,
    Nat.mul_div_assoc _ (hn.add_odd odd_one).two_dvd, ← mul_assoc, mul_comm _ n,
    Nat.mul_factorial_pred hn.pos.ne', Nat.cast_mul, ← mul_assoc, ← mul_rotate]
  exact (Int.dvd_mul_left ..).modEq_zero_int



theorem imo2001_p4 (hn : Odd n ∧ 1 < n) :
    ∃ a b, a ≠ b ∧ (n ! : ℤ) ∣ S c a - S c b := by
  by_contra h
  have key := (sum_range_modEq_sum_of_contra h).trans (sum_modEq_zero_of_odd hn.1)
  rw [Int.modEq_zero_iff_dvd, dvd_def] at key; obtain ⟨c, hc⟩ := key
  have feven : 2 ∣ (n ! : ℤ) := mod_cast Nat.dvd_factorial zero_lt_two hn.2
  nth_rw 3 [← Int.ediv_mul_cancel feven] at hc
  rw [mul_comm, Int.mul_ediv_assoc _ feven, mul_rotate] at hc
  have halfpos : 0 < (n ! : ℤ) / 2 :=
    Int.ediv_pos_of_pos_of_dvd (by positivity) zero_le_two feven
  rw [mul_left_inj' halfpos.ne', sub_eq_iff_eq_add] at hc
  rw [← even_iff_two_dvd, ← Int.not_odd_iff_even] at feven
  exact feven ⟨_, hc⟩

end Imo2001Q4

-- ═══ Imo2001P6 ═══

/-
Copyright (c) 2021 Sara Díaz Real. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sara Díaz Real
-/





/-!
# International Mathematical Olympiad 2001, Problem 6

Let a, b, c, d be integers with a > b > c > d > 0. Suppose that

  ac + bd = (a + b - c + d) * (-a + b + c + d).

Prove that ab + cd is not prime.
-/

namespace Imo2001P6

theorem imo2001_p6 {a b c d : ℤ} (hd : 0 < d) (hdc : d < c) (hcb : c < b) (hba : b < a)
    (h : a * c + b * d = (a + b - c + d) * (-a + b + c + d)) : ¬Prime (a * b + c * d) := by
  intro (h0 : Prime (a * b + c * d))
  have ha : 0 < a := by lia
  have hb : 0 < b := by lia
  have hc : 0 < c := by lia
  -- the key step is to show that `a*c + b*d` divides the product `(a*b + c*d) * (a*d + b*c)`
  have dvd_mul : a * c + b * d ∣ (a * b + c * d) * (a * d + b * c) := by
    use b ^ 2 + b * d + d ^ 2
    linear_combination b * d * h
  -- since `a*b + c*d` is prime (by assumption), it must divide `a*c + b*d` or `a*d + b*c`
  obtain (h1 : a * b + c * d ∣ a * c + b * d) | (h2 : a * c + b * d ∣ a * d + b * c) :=
    h0.left_dvd_or_dvd_right_of_dvd_mul dvd_mul
  -- in both cases, we derive a contradiction
  · have aux : 0 < a * c + b * d := by positivity
    have : a * b + c * d ≤ a * c + b * d := Int.le_of_dvd aux h1
    nlinarith only [hba, hcb, hdc, h, this]
  · have aux : 0 < a * d + b * c := by positivity
    have : a * c + b * d ≤ a * d + b * c := Int.le_of_dvd aux h2
    nlinarith only [hba, hdc, h, this]


end Imo2001P6

-- ═══ Imo2003P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ansar Azhdarov
-/





/-!
# International Mathematical Olympiad 2003, Problem 1

Let A be a 101-element subset of S = {1,2,...10⁶}. Prove that
there exist numbers t₁, t₂, ..., t₁₀₀ in S such that the sets

     Aⱼ = {x + tⱼ | x ∈ A},     j = 1,2, ..., 100

are pairwise disjoint.
-/

namespace Imo2003P1

abbrev S := Finset.Icc 1 1000000



/- Proof by induction on the number of tᵢ's -/
theorem induction_lemma (A : Finset ℕ) (_AS : A ⊆ S) (Acard : A.card = 101)
    {k : ℕ} (hk : k ≤ 100) :
    ∃ t ⊆ S, t.card = k ∧ ∀ x ∈ t, ∀ y ∈ t, x ≠ y → Disjoint {x + a | a ∈ A} {y + a | a ∈ A} := by
  classical
  induction' k with k h
  · exact ⟨∅, by simp⟩
  · obtain ⟨t, tS, tcard, ht⟩ := h (by lia)

    /- For a shift of A by x, consider the shifts by y ∈ S intersecting it -/
    let f (x : ℕ) := {y ∈ S | ¬ Disjoint {x + a | a ∈ A} {y + a | a ∈ A}}

    obtain ⟨a, aA⟩ : A.Nonempty := Finset.card_pos.mp (by lia)

    let B := insert (a, a) A.offDiag

    have Bcard : B.card = 10101 := by
      have : (a, a) ∉ A.offDiag := by simp
      rw [Finset.card_insert_of_notMem this]
      norm_num [Acard]

    /- These correspond to some pairs of points from A overlaying after the shifts -/
    have hchoose (x : ℕ) : ∀ y : f x, ∃ p : B, x + p.1.1 = y + p.1.2 := by
      intro ⟨y, yf⟩
      unfold f at yf
      simp at yf
      have := yf.2
      simp [Set.not_disjoint_iff] at this
      obtain ⟨b, bA, c, cA, hbc⟩ := this
      by_cases b = c
      · use ⟨(a, a), by grind⟩; grind
      · use ⟨(b, c), by grind⟩; grind

    have fcard (x : ℕ) (xt : x ∈ t) : (f x).card ≤ 10101 := by
      choose u hu using hchoose x
      have : u.Injective := by
        intro y z hyz
        have hy := (hu y)
        have hz := (hu z)
        rw [Subtype.ext_iff, SetLike.coe_eq_coe]
        simp [hyz ▸ hy] at hz
        exact hz
      exact Bcard ▸ Finset.card_le_card_of_injective this

    have Ufcard : (t.biUnion f).card ≤ 999999 := by
      refine le_trans Finset.card_biUnion_le ?_
      refine le_trans (Finset.sum_le_sum fcard) ?_
      simp [tcard]
      lia

    /- By counting, there must be a shift by x ∈ S intersecting neither of the shifts by tᵢ -/
    have : ∃ x ∈ S, x ∉ t.biUnion f := by
      refine Finset.exists_mem_notMem_of_card_lt_card ?_
      exact lt_of_le_of_lt Ufcard (by norm_num)

    obtain ⟨w, wS, wUf⟩ := this

    have xf (x : ℕ) (xS : x ∈ S) : x ∈ f x := by
      unfold f
      simp [Finset.mem_filter, xS]
      push_neg
      use x + a
      simp [aA]

    have wt : w ∉ t := by grind

    have tw (x : ℕ) (xt : x ∈ t) : Disjoint {x + a | a ∈ A} {w + a | a ∈ A} := by
      contrapose! wUf
      unfold f
      simp [wS]
      use x

    let r := insert w t

    have rS : r ⊆ S := Finset.insert_subset wS tS

    have rcard : r.card = k + 1 := by
      rw [Finset.card_insert_of_notMem wt]
      congr

    have hr : ∀ x ∈ r, ∀ y ∈ r, x ≠ y → Disjoint {x + a | a ∈ A} {y + a | a ∈ A} := by
      intro x xr y yr xy
      rw [Finset.mem_insert] at xr yr
      rcases xr with xz | xt
      · rcases yr with yz | yt
        · lia
        · rw [xz]
          exact Disjoint.symm (tw y yt)
      · rcases yr with yz | yt
        · rw [yz]
          exact tw x xt
        · exact ht x xt y yt xy

    use r



theorem imo2003_p1 (A : Finset ℕ) (AS : A ⊆ S) (Acard : A.card = 101) :
    ∃ t ⊆ S, t.card = 100 ∧ ∀ x ∈ t, ∀ y ∈ t, x ≠ y → Disjoint {x + a | a ∈ A} {y + a | a ∈ A} :=
  induction_lemma A AS Acard (Nat.le_refl _)

end Imo2003P1

-- ═══ Imo2003P2 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 2003, Problem 2

Determine all pairs of positive integers (a,b) such that

                  a²/(2ab² - b³ + 1)

is a positive integer.
-/

namespace Imo2003P2



lemma aux₁ {n : ℤ} (hn : 0 < n) : 1 < 8 * n ^ 3 := by
  suffices 1 ≤ n ^ 3 by lia
  exact one_le_pow₀ hn



noncomputable def solution_set : Set (ℤ × ℤ) := {(a, b) | ∃ n : ℤ, 0 < n ∧ a = 2 * n ∧ b = 1}
  ∪ {(a, b) | ∃ n : ℤ, 0 < n ∧ a = n ∧ b = 2 * n}
  ∪ {(a, b) | ∃ n : ℤ, 0 < n ∧ a = 8 * n ^ 4 - n ∧ b = 2 * n}

theorem imo2003_p2 (a b : ℤ) :
    (a,b) ∈ solution_set ↔
    0 < a ∧ 0 < b ∧
    ∃ c, 0 < c ∧ c * (2 * a * b^2 - b^3 + 1) = a^2 := by
  constructor
  · rintro ((hab|hab)|hab) <;> rcases hab with ⟨n, hn, hna, hnb⟩ <;> rw [hna, hnb]
    · constructorm* _ ∧ _
      · positivity
      · norm_num
      · use n
        constructor
        · positivity
        · ring
    · constructorm* _ ∧ _
      · positivity
      · positivity
      · use n ^ 2
        constructor
        · positivity
        · ring
    · constructorm* _ ∧ _
      · rw [sub_pos]
        rw [(by ring : 8 * n ^ 4 = n * (8 * n ^ 3))]
        apply lt_mul_right hn
        apply aux₁ hn
      · positivity
      · use n ^ 2
        constructor
        · positivity
        · ring
  · rintro ⟨ha, hb, ⟨c, hc, habc⟩⟩
    have habc' : a * a - (2 * b ^ 2 * c) * a + (b ^ 3 - 1) * c = 0 := by
      rw [← pow_two, ← habc]
      ring
    rw [solution_set, Set.union_assoc]
    rcases vieta_formula_quadratic habc' with ⟨a', ha', haa'₀, haa'₁⟩
    by_cases! ha'0 : a' = 0
    · left
      rw [ha'0, mul_zero] at haa'₁
      symm at haa'₁
      rw [mul_eq_zero_iff_right (by lia : _), sub_eq_zero] at haa'₁
      rw [pow_eq_one_iff_of_ne_zero (by norm_num : _)] at haa'₁
      norm_num at haa'₁
      rw [ha'0, haa'₁] at haa'₀
      norm_num at haa'₀
      use c
    · right
      have ha'_pos : 0 < a' := by
        apply lt_of_le_of_ne _ ha'0.symm
        rw [← mul_nonneg_iff_of_pos_left ha, haa'₁]
        rw [mul_nonneg_iff_of_pos_right hc, sub_nonneg]
        apply Int.le_of_lt_add_one
        rw [lt_add_iff_pos_left]
        positivity
      wlog ha_le_a' : a ≤ a' generalizing a a'
      · have ha'bc : c * (2 * a' * b ^ 2 - b ^ 3 + 1) = a' ^ 2 := by
          rw [sub_add, sub_eq_zero] at ha'
          rw [pow_two a', ha']
          ring
        rw [add_comm] at haa'₀
        rw [mul_comm] at haa'₁
        have h := this a' ha'_pos ha'bc ha' a habc' haa'₀ haa'₁ (by lia : _) ha (by lia : _)
        rcases h with (ha'b|ha'b) <;> rcases ha'b with ⟨n, hn, hna', hnb⟩ <;> rw [hna', hnb] at haa'₀ ha'
        · right
          use n, hn
          have hc' : c = n ^ 2 := by
            rw [← add_zero c, ← ha']
            ring
          rw [hc'] at haa'₀
          constructor
          · apply @Int.add_left_cancel n
            rw [haa'₀]
            ring
          · exact hnb
        · left
          use n, hn
          have hn' : 0 < (8 * n ^ 3 - 1) ^ 2 := by
            apply pow_pos
            rw [sub_pos]
            apply aux₁ hn
          have hc' : c = n ^ 2 := by
            rw [← mul_right_cancel_iff_of_pos hn', ← add_zero (c * (8 * n ^ 3 - 1) ^ 2), ← ha']
            ring
          rw [hc'] at haa'₀
          constructor
          · apply @Int.add_left_cancel (8 * n ^ 4 - n)
            rw [haa'₀]
            ring
          · exact hnb
      left
      have hba : b ≤ 2 * a := by
        rw [← sub_nonneg, ← mul_nonneg_iff_of_pos_left (by positivity : 0 < b ^ 2)]
        rw [← add_le_add_iff_right 1, Int.add_one_le_iff, ← mul_pos_iff_of_pos_left hc]
        rw [(by ring : c * (b ^ 2 * (2 * a - b) + 1) = c * (2 * a * b ^ 2 - b ^ 3 + 1)), habc]
        positivity
      by_cases! hba' : b = 2 * a
      · use a
      · exfalso
        have h' := ha_le_a'
        rw [← mul_le_mul_iff_of_pos_left ha, ← pow_two, ← habc, haa'₁] at h'
        rw [mul_comm, mul_le_mul_iff_of_pos_right hc, ← sub_nonneg] at h'
        have hab : a < b := by
          rw [← sub_pos, ← mul_pos_iff_of_pos_left (by positivity : 0 < b ^ 2)]
          rw [← Int.add_one_le_iff, ← sub_nonneg]
          rw [← mul_nonneg_iff_of_pos_left (by positivity : (0 : ℤ) < 2)]
          rw [(by ring : 2 * (b ^ 2 * (b - a) - (0 + 1)) = b ^ 3 - 1 - (2 * a * b ^ 2 - b ^ 3 + 1))]
          exact h'
        have hba'' := lt_of_le_of_ne hba hba'
        have h'' :  b ^ 2 < 2 * a * b ^ 2 - b ^ 3 + 1 := by
          rw [← Int.add_one_le_iff, add_le_add_iff_right]
          rw [(by ring : 2 * a * b ^ 2 - b ^ 3 = b ^ 2 * (2 * a - b))]
          rw [le_mul_iff_one_le_right (by positivity : _), ← zero_add 1]
          rw [Int.add_one_le_iff, sub_pos]
          exact hba''
        contrapose! habc
        apply ne_of_gt
        calc a ^ 2
            < b ^ 2 := by
              rw [pow_lt_pow_iff_left₀ (by lia : _) (by lia : _) (by norm_num : _)]
              exact hab
          _ ≤ c * b ^ 2 := by
              rw [le_mul_iff_one_le_left (by positivity : _)]
              lia
          _ < c * (2 * a * b ^ 2 - b ^ 3 + 1) := Int.mul_lt_mul_of_pos_left h'' hc


end Imo2003P2

-- ═══ Imo2003P6 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Zhiyi Luo
-/





/-!
# International Mathematical Olympiad 2003, Problem 6

Let p be a prime number. Prove that there exists a prime number q
such that for every integer n, the number nᵖ - p is not divisible
by q.
-/

namespace Imo2003P6



lemma exists_prime_mod_m_ne_1_and_dvd
    {n m : Nat} (npos : n ≠ 0) (hn : n % m ≠ 1) (hm : m ≠ 1)
    : ∃ p : Nat, p.Prime ∧ p ∣ n ∧ p % m ≠ 1 := by
  by_contra! h
  let l := n.primeFactorsList
  have : ∀ p ∈ l, p % m = 1 := by
    intro p pl
    exact h _ (Nat.prime_of_mem_primeFactorsList pl) (Nat.dvd_of_mem_primeFactorsList pl)
  have : n % m = 1 := calc n % m
    _ = l.prod % m := by rw [Nat.prod_primeFactorsList npos]
    _ = (l.map (fun p ↦ p % m)).prod % m := List.prod_nat_mod l m
    _ = (l.map (fun p ↦ 1)).prod % m := by rw [List.map_inj_left.mpr this]
    _ = 1 % m := by rw [List.prod_eq_one (by simp)]
    _ = 1 := Nat.one_mod_eq_one.mpr hm
  contradiction



theorem imo2003_p6 (p : ℕ) (hp : p.Prime) :
    ∃ q : ℕ, q.Prime ∧ ∀ n, ¬((q : ℤ) ∣ (n : ℤ)^p - (p : ℤ)) := by
  -- Direct translation of https://artofproblemsolving.com/community/c6h98p279

  open Finset in

  rcases Nat.Prime.eq_two_or_odd hp with rfl | p_odd

  · -- p = 2
    use 5
    constructor
    · exact Nat.prime_five

    intro n
    by_contra hdvd

    let m := n % 5
    have : 0 ≤ m := Int.emod_nonneg n (by norm_num)
    have : m < 5 := Int.emod_lt_of_pos n (by norm_num)

    have : 2 ≡ m ^ 2 [ZMOD 5] := calc
      2 ≡ n ^ 2 [ZMOD 5] := Int.modEq_iff_dvd.mpr hdvd
      _ ≡ m ^ 2 [ZMOD 5] := Int.ModEq.pow 2 (Int.mod_modEq n 5).symm
    have : 5 ∣ m ^ 2 - 2 := Int.dvd_self_sub_of_emod_eq (id (Int.ModEq.symm this))

    interval_cases m <;> norm_num at this

  -- p > 2
  let N := ∑ i ∈ range p, p^i
  have N_nz : N ≠ 0 := by
    apply Nat.ne_zero_iff_zero_lt.mpr
    apply sum_pos
    · exact fun _ _ ↦ Nat.pow_pos (Nat.Prime.pos hp)
    exact nonempty_range_iff.mpr hp.ne_zero

  have p_ge_3 : p - 1 > 1 := by
    by_contra h
    simp only [gt_iff_lt, not_lt, tsub_le_iff_right, Nat.reduceAdd] at h
    interval_cases p
    · norm_num at hp
    · norm_num at hp
    · norm_num at p_odd

  have N_mod_p_ne_1 : N % (p ^ 2) ≠ 1 := by
    have : (p + 1) % (p ^ 2) = p + 1 := by
      have : p + 1 < p ^ 2 := by
        suffices 1 < p ^ 2 - p by exact Nat.add_lt_of_lt_sub' this
        calc
          1 < p * (p - 1) := by
            apply Nat.one_lt_mul_iff.mpr
            exact ⟨Nat.Prime.pos hp, by simp [hp.one_lt], Or.inl hp.one_lt⟩
          _ = p ^ 2 - p := by simp [Nat.pow_two, Nat.mul_sub]
      exact Nat.mod_eq_of_lt this
    have : ∀ m ≥ 2, (∑ i ∈ range m, p^i) % (p ^ 2) = p + 1 := by
      intro m hm
      cases m with | zero => norm_num at hm | succ m =>
      cases m with | zero => norm_num at hm | succ m =>
      induction' m with m ih
      · simpa
      simp at *
      rw [sum_range_succ, Nat.add_mod, ih]
      rw [Nat.mod_eq_zero_of_dvd (pow_dvd_pow p (by simp))]
      simpa
    rw [this _ (Nat.Prime.two_le hp)]
    simp [Nat.Prime.ne_zero hp]

  have p_sq_ne_1 : p ^ 2 ≠ 1 := by
    refine Ne.symm (Nat.ne_of_lt ?_)
    apply one_lt_pow₀ (Nat.Prime.one_lt hp) (by norm_num)

  rcases exists_prime_mod_m_ne_1_and_dvd
    N_nz N_mod_p_ne_1 p_sq_ne_1 with ⟨q, ⟨hq, hqN, h3⟩⟩

  have q_dvd_pp_1 : q ∣ p^p - 1 := calc
    q ∣ N := hqN
    _ ∣ p^p - 1 := by
      use p - 1
      simp [N]
      apply Nat.add_one_inj.mp
      have : p^p - 1 + 1 = p^p := Nat.sub_add_cancel (Nat.one_le_pow _ _ hp.pos)
      rw [this]
      have : p = p - 1 + 1 := (Nat.succ_pred_prime hp).symm
      nth_rw 1 [this]; nth_rw 4 [this]
      rw [geom_sum_mul_add (p - 1) p]

  use q
  constructor
  · exact hq

  intro n hn

  have np_congr_p : (n : ZMod q) ^ p = p := by
    rw [← Int.cast_pow, ← AddCommGroupWithOne.intCast_ofNat p]
    rw [← (ZMod.intCast_eq_intCast_iff_dvd_sub _ _ _).mpr hn]

  have pp_congr_1 : (p : ZMod q) ^ p = (1 : ZMod q) := by
    rw [← Nat.cast_pow, ← Nat.cast_one]
    apply (ZMod.natCast_eq_natCast_iff' _ _ _).mpr
    apply Eq.symm
    apply (Nat.modEq_iff_dvd' _).mpr
    · exact q_dvd_pp_1
    exact hp.one_le.trans (Nat.le_self_pow hp.ne_zero _)

  have : (n : ZMod q) ^ (p ^ 2) = 1 := by
    rw [Nat.pow_two, pow_mul]
    rw [np_congr_p, pp_congr_1]

  let d := orderOf (n : ZMod q)

  have : d ∣ p ^ 2 := orderOf_dvd_of_pow_eq_one this
  rcases (Nat.dvd_prime_pow hp).mp this with ⟨k, ⟨k_le, d_eq_pk⟩⟩
  rcases Nat.lt_or_eq_of_le k_le with hk | rfl

  · -- k < 2
    have : (n : ZMod q) ^ p = ((1 : ℕ) : ZMod q) := by
      rw [Nat.cast_one]
      interval_cases k
      all_goals simp at d_eq_pk
      · -- k = 0
        simp [orderOf_eq_one_iff.mp d_eq_pk]
      · -- k = 1
        rw [← d_eq_pk]
        exact pow_orderOf_eq_one _
    have : (p : ZMod q) = ((1 : ℕ) : ZMod q) := by
      rw [← Nat.cast_one]
      exact (np_congr_p.symm).trans this
    have : p ≡ 1 [MOD q] := (ZMod.natCast_eq_natCast_iff _ _ _).mp this
    have q_dvd_p_1 : q ∣ p - 1 := (Nat.modEq_iff_dvd' hp.one_le).mp (id (Nat.ModEq.symm this))

    have one_mod_p_1 : 1 % (p - 1) = 1 :=
      (Nat.mod_eq_iff_lt (by lia)).mpr p_ge_3
    have p_mod_p_1 : p % (p - 1) = 1 := by
      rw [Nat.mod_eq_sub_mod]
      · have : p - (p - 1) = 1 := Nat.sub_sub_self hp.one_le
        simp [this, one_mod_p_1]
      · exact Nat.sub_le _ _
    have : N % (p - 1) = 1 := calc N % (p - 1)
      _ = (∑ i ∈ range p, (p^i) % (p - 1)) % (p - 1) := Finset.sum_nat_mod _ _ _
      _ = (∑ i ∈ range p, 1) % (p - 1) := by
        congr; funext i
        simp [Nat.pow_mod, one_mod_p_1, p_mod_p_1]
      _ = 1 := by simp [p_mod_p_1]
    have : Nat.gcd N (p - 1) = 1 :=
      calc Nat.gcd N (p - 1)
        _ = Nat.gcd (N % (p - 1)) (p - 1) := (Nat.mod_modEq _ _).symm.gcd_eq
        _ = 1 := by
          rw [this]
          exact Nat.gcd_one_left _

    have : q ≤ 1 := by
      apply Nat.le_of_dvd (by norm_num)
      rw [← this]
      exact Nat.dvd_gcd hqN q_dvd_p_1

    linarith [this, hq.one_lt]

  -- k = 2
  rcases eq_zero_or_neZero (n : ZMod q) with hn0 | hn0
  · -- n = 0 (mod q)
    have q_dvd_p : (p : ZMod q) = 0 :=
      calc (p : ZMod q)
        _ = (n : ZMod q) ^ p := by rw [np_congr_p]
        _ = 0 := by
          rw [hn0, zero_pow (Nat.Prime.ne_zero hp)]
    rw [ZMod.natCast_eq_zero_iff] at q_dvd_p

    have : N % p = 1 := calc N % p
      _ = (∑ i ∈ range p, (p^i) % p) % p := Finset.sum_nat_mod _ _ _
      _ = (∑ i ∈ range (p - 1 + 1), (p^i) % p) % p := by
        nth_rw 1 [← Nat.succ_pred_prime hp]
        simp
      _ = (∑ i ∈ range (p - 1), p^(i+1) % p + 1) % p := by
        simp [Finset.sum_range_succ']
      _ = (∑ i ∈ range (p - 1), 0 + 1) % p := by
        congr; funext i
        apply Nat.mod_eq_zero_of_dvd
        exact Dvd.intro_left (p.pow i) rfl
      _ = 1 := by
        simp
        rw [Nat.one_mod_eq_one.mpr (Nat.Prime.ne_one hp)]
    have : Nat.gcd N p = 1 :=
      calc Nat.gcd N p
        _ = Nat.gcd (N % p) p := (Nat.mod_modEq _ _).symm.gcd_eq
        _ = 1 := by rw [this, Nat.gcd_one_left]

    have : q ≤ 1 := by
      apply Nat.le_of_dvd (by norm_num)
      rw [← this]
      exact Nat.dvd_gcd hqN q_dvd_p

    linarith [this, hq.one_lt]

  · -- n ≠ 0 (mod q)
    have : p ^ 2 ∣ q - 1 := by
      rw [← d_eq_pk]
      apply orderOf_dvd_of_pow_eq_one
      apply @ZMod.pow_card_sub_one_eq_one _ (Fact.mk hq) _ hn0.out
    have : (q - 1) % (p ^ 2) = 0 := Nat.mod_eq_zero_of_dvd this
    have : q % (p ^ 2) = 1 := by
      rw [← Nat.succ_pred_prime hq]
      simp [Nat.add_mod, this]
      exact Nat.one_mod_eq_one.mpr p_sq_ne_1
    contradiction


end Imo2003P6

-- ═══ Imo2004P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 2004, Problem 2

Find all polynomials P with real coefficients such that
for all reals a,b,c such that ab + bc + ca = 0 we have

    P(a - b) + P(b - c) + P(c - a) = 2P(a + b + c).
-/

namespace Imo2004P2

open Polynomial

noncomputable def SolutionSet : Set (Polynomial ℝ) := {P | ∃ s t : ℝ, P = s • X ^ 4 + t • X ^ 2}

theorem imo2004_p2 (P : Polynomial ℝ) :
    P ∈ SolutionSet ↔
    ∀ a b c, a * b + b * c + c * a = 0 →
      P.eval (a - b) + P.eval (b - c) + P.eval (c - a) =
      2 * P.eval (a + b + c) := by
  constructor
  · rintro ⟨s, t, hp⟩ a b c habc
    simp [hp]
    rw [← sub_eq_zero]
    rw [← zero_mul (- 6 * t - 6 * s * (a * b + b * c + c * a) - 12 * s * (a * a + b * b + c * c)), ← habc]
    ring
  · intro habc
    have hPaPbPc : ∀ Pa Pb Pc : Polynomial ℝ, Pa * Pb + Pb * Pc + Pc * Pa = 0 →
      P.comp (Pa - Pb) + P.comp (Pb - Pc) + P.comp (Pc - Pa) = 2 * P.comp (Pa + Pb + Pc) := by
      intro Pa Pb Pc hPaPbPc'
      apply Polynomial.funext
      intro r
      simp only [eval_add, eval_mul, eval_comp, eval_sub, eval_ofNat]
      apply habc (Pa.eval r) (Pb.eval r) (Pc.eval r)
      simp only [← eval_add, ← eval_mul, hPaPbPc', eval_zero]
    use P.coeff 4, P.coeff 2
    apply ext
    intro n
    by_cases! hn : n = 2 ∨ n = 4
    · rcases hn with (hn|hn) <;> rw [hn] <;> simp
    · simp
      repeat rw [if_neg (by tauto : _)]
      rw [add_zero]
      by_cases! hn'' : n = 0
      · have h := habc 0 0 0 (by ring : _)
        simp at h
        rw [← coeff_zero_eq_eval_zero] at h
        rw [← sub_eq_zero] at h
        ring_nf at h
        rw [hn'', h]
      · by_cases! hn' : ¬2 ∣ n
        · have h' := hPaPbPc X 0 0 (by ring : _)
          ring_nf at h'
          rw [ext_iff] at h'
          have h := h' n
          simp only [coeff_add, ← C_ofNat, coeff_mul_C] at h
          rw [neg_eq_neg_one_mul, ← C_1, ← C_neg, comp_C_mul_X_coeff] at h
          rw [comp_X, comp_zero, coeff_C_ne_zero hn'', ← sub_eq_zero, add_zero] at h
          nth_rw 1 [← mul_one (P.coeff n)] at h
          simp only [← mul_add, ← mul_sub] at h
          apply (mul_eq_zero_iff_right _).mp h
          contrapose! hn'
          ring_nf at hn'
          rw [neg_add_eq_sub, sub_eq_zero] at hn'
          rw [neg_one_pow_eq_one_iff_even (by norm_num : _), even_iff_two_dvd] at hn'
          exact hn'
        · have hn''' : 6 ≤ n := by
            contrapose! hn'
            interval_cases n <;> norm_num at *
          have h' := hPaPbPc (- 2 • X) (3 • X) (6 • X) (by ring : _)
          ring_nf at h'
          rw [ext_iff] at h'
          have h := h' n
          simp only [coeff_add, ← C_ofNat, coeff_mul_C, X_mul_C, ← neg_mul, ← C_neg, comp_C_mul_X_coeff] at h
          rw [← sub_eq_zero] at h
          simp only [← mul_add, mul_assoc, ← mul_sub] at h
          apply (mul_eq_zero_iff_right _).mp h
          apply ne_of_gt
          repeat rw [neg_pow, (neg_one_pow_eq_one_iff_even (by norm_num : _)).mpr (even_iff_two_dvd.mpr hn'), one_mul]
          rw [sub_pos]
          calc (7 : ℝ) ^ n * 2
              < 7 ^ n * (8 / 7) ^ 6 := by
                rw [mul_lt_mul_iff_of_pos_left (by positivity : _)]
                norm_num
            _ ≤ 7 ^ n * (8 / 7) ^ n := by
                rw [mul_le_mul_iff_of_pos_left (by positivity : _)]
                rw [pow_le_pow_iff_right₀ (by norm_num : _)]
                exact hn'''
            _ = 8 ^ n := by rw [← mul_pow, mul_div_cancel₀ 8 (by norm_num : _)]
            _ < 5 ^ n + 3 ^ n + 8 ^ n := by
                rw [lt_add_iff_pos_left]
                positivity


end Imo2004P2

-- ═══ Imo2005P2 ═══

/-
Copyright (c) 2026 Constantin Seebach. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Constantin Seebach
-/





/-!
# International Mathematical Olympiad 2005, Problem 2

Let $a_1, a_2, \dots$ be a sequence of integers with infinitely many positive and negative terms.
Suppose that for every positive integer $n$ the numbers $a_1, a_2, \dots, a_n$ leave $n$ different remainders upon division by $n$.
Prove that every integer occurs exactly once in the sequence.
-/

namespace Imo2005P2




/-
We follow the proof from https://artofproblemsolving.com/wiki/index.php/2005_IMO_Problems/Problem_2
-/

def prefix_max (a : ℕ → ℤ) (n : ℕ) (npos : 0 < n) : ℤ :=
  Finset.max' ((Finset.range n).image (fun i => a i)) (by
    simpa using Nat.ne_zero_of_lt npos)

def prefix_min (a : ℕ → ℤ) (n : ℕ) (npos : 0 < n) : ℤ :=
  Finset.min' ((Finset.range n).image (fun i => a i)) (by
    simpa using Nat.ne_zero_of_lt npos)

def consecutive {S : Type} [SetLike S ℤ] (s : S) : Prop := ∀ (a b c : ℤ), a < b → b < c → a ∈ s → c ∈ s → b ∈ s

theorem consecutive' {S : Type} [SetLike S ℤ] {s : S} (h : consecutive s) : ∀ (a b c : ℤ), a ≤ b → b ≤ c → a ∈ s → c ∈ s → b ∈ s := by
  unfold consecutive at h
  grind only

theorem consecutive_insert_max' (s : Finset ℤ) (hne : s.Nonempty) (hc : consecutive s) : consecutive (insert (s.max' hne + 1) s) := by
  intro a b c h1 h2 u1 u2
  by_cases m : c < s.max' hne + 1
  · suffices b ∈ s by exact Finset.mem_insert_of_mem this
    apply hc a b c h1 h2 <;> grind only [= Finset.mem_insert]
  · have : c = s.max' hne + 1 := by
      simp at m
      simp at u2
      apply u2.by_cases (by simp)
      intro h
      have : s.max' hne < c := by exact (Finset.max'_lt_iff s hne).mpr m
      rw [Finset.max'_lt_iff s hne (x:=c)] at this
      grind only [this _ h]
    subst this
    by_cases m' : b = s.max' hne
    · subst m'
      simp only [Finset.mem_insert, left_eq_add, one_ne_zero, false_or]
      exact Finset.max'_mem s hne
    have : b < s.max' hne := by omega
    suffices b ∈ s by exact Finset.mem_insert_of_mem this
    apply hc a b (s.max' hne) h1 this
    · grind
    · exact Finset.max'_mem s hne

theorem consecutive_insert_min' (s : Finset ℤ) (hne : s.Nonempty) (hc : consecutive s) : consecutive (insert (s.min' hne - 1) s) := by
  intro a b c h1 h2 u1 u2
  by_cases m : s.min' hne - 1 < a
  · suffices b ∈ s by exact Finset.mem_insert_of_mem this
    apply hc a b c h1 h2 <;> grind only [= Finset.mem_insert]
  · have : a = s.min' hne - 1 := by
      simp at m
      simp at u1
      apply u1.by_cases (by simp)
      intro h
      have : a < s.min' hne := by exact (Finset.lt_min'_iff s hne).mpr m
      rw [Finset.lt_min'_iff s hne (x:=a)] at this
      grind only [this _ h]
    subst this
    by_cases m' : b = s.min' hne
    · subst m'
      refine Finset.mem_insert_of_mem ?_
      exact Finset.min'_mem s hne
    have : s.min' hne < b := by omega
    suffices b ∈ s by exact Finset.mem_insert_of_mem this
    apply hc (s.min' hne) b c this h2
    · exact Finset.min'_mem s hne
    · grind

theorem a_injective (a : ℕ → ℤ) (rem : ∀ n > 0, ((Finset.range n).image (fun i => a i % n)).card = n) : Function.Injective a := by
  intro i1 i2 e
  contrapose! rem
  let B := 1 + max i1 i2
  use B, (by positivity)
  nth_rw 3 [←Finset.card_range B]
  rw [ne_eq, Finset.card_image_iff, Set.InjOn]
  simp only [Finset.coe_range, Set.mem_Iio, not_forall, exists_prop]
  use i1, ?_, i2, ?_, ?_
  · unfold B
    omega
  · unfold B
    omega
  · rw [e]

theorem mod_nonzero (a : ℕ → ℤ) (rem : ∀ n > 0, ((Finset.range n).image (fun i => a i % n)).card = n) (a0 : a 0 = 0)
: ∀ n > 0, ∀ d > n, ¬ a n % d = 0 := by
  intro n npos d dgt
  contrapose! rem
  use d, (by grind)
  nth_rw 3 [←Finset.card_range d]
  rw [ne_eq, Finset.card_image_iff, Set.InjOn]
  simp only [Finset.coe_range, Set.mem_Iio, not_forall, exists_prop]
  use 0, ?_, n, ?_, ?_
  · exact Nat.ne_of_lt npos
  · grind
  · exact dgt
  · rw [rem, a0]
    simp

theorem abs_bound (a : ℕ → ℤ) (rem : ∀ n > 0, ((Finset.range n).image (fun i => a i % n)).card = n) (a0 : a 0 = 0)
: ∀ n, |a n| ≤ n := by
  intro n
  by_cases nz : n = 0
  · subst nz
    rw [a0]
    simp
  by_contra! c
  have : ¬ a n % (a n).natAbs = 0 := by
    apply mod_nonzero a rem a0 n
    · exact Nat.zero_lt_of_ne_zero nz
    · grind
  simp only [Nat.cast_natAbs, Int.cast_abs, Int.cast_eq, Int.emod_abs, EuclideanDomain.mod_self,
    not_true_eq_false] at this

theorem an_inductive' (a : ℕ → ℤ) (rem : ∀ n > 0, ((Finset.range n).image (fun i => a i % n)).card = n) (a0 : a 0 = 0)
: ∀ n, consecutive ((Finset.range n).image (fun i => a i)) ∧ ∀ npos: n > 0, (a n = prefix_max a n npos + 1 ∨ a n = prefix_min a n npos - 1) := by
  intro n
  induction n with
  | zero =>
    unfold consecutive
    simp
  | succ n ih =>
    rw [show ∀ (a b : Prop), a ∧ b ↔ a ∧ (a → b) by grind only]
    and_intros
    · have : Finset.image (fun i ↦ a i) (Finset.range (n + 1)) = insert (a n) (Finset.image (fun i ↦ a i) (Finset.range n)) := by
        rw [Finset.insert_eq]
        ext x
        simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff, Finset.singleton_union,
          Finset.mem_insert]
        grind
      rw [this]
      by_cases npos : 0 < n
      · apply (ih.right npos).by_cases
        · intro h
          rw [h]
          apply consecutive_insert_max'
          apply ih.left
        · intro h
          rw [h]
          apply consecutive_insert_min'
          apply ih.left
      · simp only [not_lt, nonpos_iff_eq_zero] at npos
        subst npos
        intro x y z
        grind

    · intro con npos'
      have notmod' : ∀ i ≤ n, ¬ a i = (a (n+1) : ZMod (n+2)) := by
        intro i ilen
        contrapose! rem
        use n+2, (by simp)
        nth_rw 3 [←Finset.card_range (n+2)]
        rw [ne_eq, Finset.card_image_iff, Set.InjOn]
        simp
        use i, (by grind), n+1, (by simp)
        and_intros
        · rw [ZMod.intCast_eq_intCast_iff] at rem
          exact Int.ModEq.eq rem
        · grind only

      let modset := Finset.image (fun i ↦ a i % ↑(n+2)) (Finset.range (n+2))

      have modset_Ico : modset = Finset.Ico (α:=ℤ) 0 (n+2) := by
        unfold modset
        rw [←Finset.eq_iff_card_le_of_subset]
        · rw [rem]
          repeat simp
        · refine Finset.image_subset_iff.mpr ?_
          intro i _
          rw [Finset.mem_Ico]
          and_intros
          · apply Int.emod_nonneg
            omega
          · apply Int.emod_lt_of_pos
            omega

      have hmodmax : (prefix_max a (n + 1) npos' + 1).cast = (a (n + 1) : ZMod (n+2)) := by
        have : (a (n+1) - 1) % (n+2) ∈ modset := by
          rw [modset_Ico, Finset.mem_Ico]
          and_intros
          · apply Int.emod_nonneg
            omega
          · apply Int.emod_lt_of_pos
            omega
        unfold modset at this
        simp only [Nat.cast_add, Nat.cast_ofNat, Finset.mem_image, Finset.mem_range] at this
        let ⟨i, h1, h2⟩ := this
        rw [←Int.ModEq, show @Nat.cast ℤ _ n + 2 = (n+2).cast by simp,
          ←ZMod.intCast_eq_intCast_iff] at h2
        have h1 : i < n+1 := by
          by_contra
          have : i = n+1 := by omega
          subst i
          rw [←sub_eq_zero] at h2
          simp only [Int.cast_sub, Int.cast_one, sub_sub_cancel, ZMod.one_eq_zero_iff] at h2
          grind only
        have : a i + 1 = (a (n + 1) : ZMod (n+2)) := by
          rw [h2]
          simp
        rw [←this]
        simp only [Int.cast_add, Int.cast_one, add_left_inj]
        unfold prefix_max
        let := Finset.max'_mem (Finset.image (fun i ↦ a i) (Finset.range (n + 1))) (by simp)
        simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
        let ⟨j, jb, jh⟩ := this
        rw [←jh]
        congr
        by_contra c
        let := consecutive' con (a i) (a i + 1) (a j) (by simp) ?_ ?_ ?_
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
          let ⟨k, kh1, kh2⟩ := this
          contrapose! notmod'
          use k, kh1
          rw [kh2, Int.cast_add, h2]
          simp
        · rw [jh]
          rw [Order.add_one_le_iff]
          apply Finset.lt_max'_of_mem_erase_max'
          simp only [Finset.mem_erase, ne_eq, Finset.mem_image, Finset.mem_range,
            Order.lt_add_one_iff]
          rw [←jh]
          and_intros
          · rw [Eq.comm]
            exact Ne.intro fun x ↦ c (a_injective _ rem x)
          · use i
            simp only [and_true]
            exact Nat.le_of_lt_succ h1
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
          use i
          simp [Nat.le_of_lt_succ h1]
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
          use j

      have hmodmin : (prefix_min a (n + 1) npos' - 1).cast = (a (n + 1) : ZMod (n+2)) := by
        have : (a (n+1) + 1) % (n+2) ∈ modset := by
          rw [modset_Ico, Finset.mem_Ico]
          and_intros
          · apply Int.emod_nonneg
            omega
          · apply Int.emod_lt_of_pos
            omega
        unfold modset at this
        simp only [Nat.cast_add, Nat.cast_ofNat, Finset.mem_image, Finset.mem_range] at this
        let ⟨i, h1, h2⟩ := this
        rw [←Int.ModEq, show @Nat.cast ℤ _ n + 2 = (n+2).cast by simp,
          ←ZMod.intCast_eq_intCast_iff] at h2
        have h1 : i < n+1 := by
          by_contra
          have : i = n+1 := by omega
          subst i
          rw [←sub_eq_zero] at h2
          simp only [Int.cast_add, Int.cast_one, sub_add_cancel_left, neg_eq_zero,
            ZMod.one_eq_zero_iff] at h2
          grind only
        have : a i - 1 = (a (n + 1) : ZMod (n+2)) := by
          rw [h2]
          simp
        rw [←this]
        simp only [Int.cast_sub, Int.cast_one, sub_left_inj]
        unfold prefix_min
        let := Finset.min'_mem (Finset.image (fun i ↦ a i) (Finset.range (n + 1))) (by simp)
        simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
        let ⟨j, jb, jh⟩ := this
        rw [←jh]
        congr
        by_contra c
        let := consecutive' con (a j) (a i - 1) (a i) ?_ (by simp) ?_ ?_
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
          let ⟨k, kh1, kh2⟩ := this
          contrapose! notmod'
          use k, kh1
          rw [kh2, Int.cast_sub, h2]
          simp
        · rw [jh]
          rw [Order.le_sub_one_iff]
          apply Finset.min'_lt_of_mem_erase_min'
          simp only [Finset.mem_erase, ne_eq, Finset.mem_image, Finset.mem_range,
            Order.lt_add_one_iff]
          rw [←jh]
          and_intros
          · rw [Eq.comm]
            exact Ne.intro fun x ↦ c (a_injective _ rem x)
          · use i
            simp only [and_true]
            exact Nat.le_of_lt_succ h1
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
          use j
        · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
          use i
          simp [Nat.le_of_lt_succ h1]

      by_cases pos : a (n+1) > 0
      · apply Or.inl
        have : (@Int.cast (ZMod (n+2)) _ (a (n + 1))).cast = a (n+1) := by
          have : (@Int.cast (ZMod (n+2)) _ (a (n + 1))) = ⟨(a (n+1)).toNat, by {
            rw [Nat.lt_add_one_iff]
            zify
            trans |a (n+1)|
            · simp only [Int.ofNat_toNat, sup_le_iff, abs_nonneg, and_true]
              exact le_abs_self _
            · apply abs_bound _ rem a0
          }⟩ := by
            rw [ZMod.intCast_eq_iff]
            use 0
            simp only [ZMod.natCast_val, Nat.cast_add, Nat.cast_ofNat, mul_zero, add_zero]
            rw [ZMod.cast_eq_val]
            unfold ZMod.val
            simp only [Int.ofNat_toNat, left_eq_sup]
            exact Int.le_of_lt pos
          rw [this]
          rw [ZMod.cast_eq_val]
          unfold ZMod.val
          simp only [Int.ofNat_toNat, sup_eq_left, ge_iff_le]
          exact Int.le_of_lt pos
        rw [ZMod.intCast_eq_iff] at hmodmax
        let ⟨k, kh⟩ := hmodmax
        simp only [ZMod.natCast_val, Nat.cast_add, Nat.cast_ofNat] at kh
        rw [this] at kh
        rw [kh]
        let := Finset.max'_mem (Finset.image (fun i ↦ a i) (Finset.range (n + 1))) (by simp)
        simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
        let ⟨j, jb, jh⟩ := this
        unfold prefix_max at kh
        rw [←jh, Int.sub_eq_iff_eq_add.symm] at kh
        have nkneg : ¬ k < 0 := by
          have : _ := abs_bound _ rem a0 (n+1)
          rw [←kh, abs_le] at this
          let := this.right
          have : a j ≥ 0 := by
            rw [jh]
            apply Finset.le_max'
            simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
            use 0
            simp [a0]
          have : - ↑(n + 1) ≤ (↑n + 2) * k := by omega
          contrapose! this
          suffices (↑n + 2) * k ≤ (↑n + 2) * (-1) by omega
          rw [mul_le_mul_iff_of_pos_left]
          · exact Int.add_le_zero_iff_le_neg.mp this
          · exact Int.sign_eq_one_iff_pos.mp rfl
        have nkpos : ¬ k > 0 := by
          rw [←kh] at pos
          simp at pos
          have : a j ≤ j := by
            have : _ := abs_bound _ rem a0 j
            exact le_of_max_le_left this
          have : (n + 2) * k ≤ n := by omega
          contrapose! this
          apply Int.lt_of_add_one_le
          trans n+2
          · simp
          · nth_rw 1 [←mul_one (n.cast+2)]
            rw [mul_le_mul_iff_of_pos_left]
            · exact Int.le_of_sub_one_lt this
            · exact Int.sign_eq_one_iff_pos.mp rfl
        grind only
      · apply Or.inr
        have neg : a (n+1) < 0 := by
          let := a_injective a rem
          grind only
        have : (@Int.cast (ZMod (n+2)) _ (a (n + 1))).cast = n+2 + a (n+1) := by
          have : (@Int.cast (ZMod (n+2)) _ (a (n + 1))) = ⟨(n+2 + a (n+1)).toNat, by {
            rw [Nat.lt_add_one_iff]
            zify
            simp only [Int.ofNat_toNat, sup_le_iff]
            and_intros
            · linarith
            · exact Int.zero_le_ofNat (n + 1)
          }⟩ := by
            rw [ZMod.intCast_eq_iff]
            use -1
            simp
            rw [ZMod.cast_eq_val]
            unfold ZMod.val
            simp
            rw [max_eq_left]
            · lia
            · let := abs_le.mp (abs_bound _ rem a0 (n+1))
              omega
          rw [this]
          rw [ZMod.cast_eq_val]
          unfold ZMod.val
          simp only [Int.ofNat_toNat, sup_eq_left, ge_iff_le]
          let := abs_le.mp (abs_bound _ rem a0 (n+1))
          lia
        rw [ZMod.intCast_eq_iff] at hmodmin
        let ⟨k, kh⟩ := hmodmin
        simp only [ZMod.natCast_val, Nat.cast_add, Nat.cast_ofNat] at kh
        rw [this] at kh
        rw [kh]
        let := Finset.min'_mem (Finset.image (fun i ↦ a i) (Finset.range (n + 1))) (by simp)
        simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
        let ⟨j, jb, jh⟩ := this
        unfold prefix_min at kh
        rw [←jh] at kh
        have kh : a j - 1 - (↑n + 2) * (k+1) = a (n + 1) := by lia
        suffices k = -1 by lia
        have nkpos : ¬ k+1 > 0 := by
          have : _ := abs_bound _ rem a0 (n+1)
          rw [←kh, abs_le] at this
          let ⟨h1, h2⟩ := this
          have : a j ≤ 0 := by
            rw [jh]
            apply Finset.min'_le
            simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff]
            use 0
            simp [a0]
          have : - ↑(n + 1) ≤ - 1 - (↑n + 2) * (k + 1) := by lia
          contrapose! this
          suffices - (↑n + 2) * (k + 1) ≤ -↑(n + 1) by lia
          suffices ↑(n + 2) * 1 ≤ ↑(n + 2) * (k + 1) by lia
          rw [mul_le_mul_iff_of_pos_left]
          · exact Int.le_of_sub_one_lt this
          · exact Int.sign_eq_one_iff_pos.mp rfl
        have nkneg : ¬ k+1 < 0 := by
          rw [←kh] at neg
          simp at neg
          have : a j ≥ -j := by
            have : _ := abs_bound _ rem a0 j
            exact neg_le_of_abs_le this
          have : (n + 2) * (k+1) ≥ -n := by omega
          contrapose! this
          apply Int.lt_of_le_sub_one
          trans -n-2
          · suffices (↑n + 2) * (k + 1) ≤ (↑n + 2) * (-1) by lia
            rw [mul_le_mul_iff_of_pos_left]
            · exact Int.add_le_zero_iff_le_neg.mp this
            · exact Int.sign_eq_one_iff_pos.mp rfl
          · simp
        grind only




theorem imo2005_p2 (a : ℕ → ℤ)
  (pos_inf : Set.Infinite {i | 0 < a i})
  (neg_inf : Set.Infinite {i | a i < 0})
  (rem : ∀ n > 0, ((Finset.range n).image (fun i => a i % n)).card = n)
    : ∀ z : ℤ, ∃! i, a i = z := by

  replace pos_inf : Set.Infinite { a i | (i) (_ : 0 < a i)} := by
    rw [←Set.infinite_image_iff (f:=a)] at pos_inf
    · simp only [exists_prop]
      exact pos_inf
    · exact (a_injective a rem).injOn
  replace neg_inf : Set.Infinite { a i | (i) (_ : a i < 0)} := by
    rw [←Set.infinite_image_iff (f:=a)] at neg_inf
    · simp only [exists_prop]
      exact neg_inf
    · exact (a_injective a rem).injOn

  wlog a0 : a 0 = 0
  · let a' (i) := a i - a 0
    have : _ := this a' ?_ ?_ ?_ ?_
    · intro z
      unfold a' at this
      let := this (z - a 0)
      simp only [sub_left_inj] at this
      exact this
    · intro n npos
      nth_rw 3 [←rem n npos]
      apply Finset.card_bij (fun x h => (x + a 0)%n)
      · simp
        lia
      · unfold a'
        simp only [Finset.mem_image, Finset.mem_range, forall_exists_index, and_imp,
          forall_apply_eq_imp_iff₂, Int.emod_add_emod, sub_add_cancel]
        intro x1 _ x2 _ e
        exact (Int.emod_sub_cancel_right (a 0)).mpr e
      · simp only [Finset.mem_image, Finset.mem_range, exists_prop, exists_exists_and_eq_and,
          Int.emod_add_emod, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
        intro x xltn
        use x
        and_intros
        · exact xltn
        · unfold a'
          simp
    · unfold a'
      apply Set.infinite_of_not_bddAbove
      have : Set.Infinite ((·.toNat) '' {a i | (i) (pos: 0 < a i)}) := by
        refine Set.Infinite.image ?_ pos_inf
        intro x1 h1 x2 h2 e
        grind
      let := Set.Infinite.not_bddAbove this
      rw [not_bddAbove_iff] at this ⊢
      intro b
      let ⟨y, yh⟩ := this (b.natAbs + (a 0).natAbs)
      use y - a 0
      simp only [exists_prop, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and,
        Int.sub_pos, sub_left_inj] at yh ⊢
      let ⟨⟨i, h1, h2⟩, h3⟩ := yh
      and_intros
      · use i
        lia
      · grind only
    · unfold a'
      apply Set.infinite_of_not_bddBelow
      have : Set.Infinite ((fun x => (-x).toNat) '' {a i | (i) (neg: a i < 0)}) := by
        refine Set.Infinite.image ?_ neg_inf
        intro x1 h1 x2 h2 e
        grind
      let := Set.Infinite.not_bddAbove this
      rw [not_bddAbove_iff] at this
      rw [not_bddBelow_iff] at ⊢
      intro b
      let ⟨y, yh⟩ := this (b.natAbs + (a 0).natAbs)
      use -y - a 0
      simp only [exists_prop, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and, sub_neg,
        sub_left_inj] at yh ⊢
      let ⟨⟨i, h1, h2⟩, h3⟩ := yh
      and_intros
      · use i
        and_intros
        · grind only
        · grind only
      · grind only
    · exact Int.sub_self (a 0)

  suffices Function.Surjective a by
    apply Function.Bijective.existsUnique
    and_intros
    · exact a_injective a rem
    · exact this

  intro z
  let con (n) := (an_inductive' a rem a0 n).left
  have : z = 0 ∨ z < 0 ∨ 0 < z := by grind only
  apply this.elim3
  · intro zz
    subst zz
    use 0
  · intro zneg
    obtain ⟨i, ih⟩ : ∃ i, a i < z := by
      have : Set.Infinite ((fun x => (-x).toNat) '' {a i | (i) (neg: a i < 0)}) := by
        refine Set.Infinite.image ?_ neg_inf
        intro x1 h1 x2 h2 e
        grind
      let := Set.Infinite.not_bddAbove this
      rw [not_bddAbove_iff] at this
      let ⟨y, yh1, yh2⟩ := this (-z).toNat
      simp only [exists_prop, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and] at yh1
      let ⟨i, ih⟩ := yh1
      use i
      lia
    let := (con (i+1)) (a i) z 0 ?_ ?_ ?_ ?_
    · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
      grind only
    · exact ih
    · exact zneg
    · rw [Finset.mem_image]
      use i
      simp
    · rw [Finset.mem_image]
      use 0
      simp [a0]
  · intro zpos
    obtain ⟨i, ih⟩ : ∃ i, z < a i := by
      have : Set.Infinite ((·.toNat) '' {a i | (i) (pos: 0 < a i)}) := by
        refine Set.Infinite.image ?_ pos_inf
        intro x1 h1 x2 h2 e
        grind
      let := Set.Infinite.not_bddAbove this
      rw [not_bddAbove_iff] at this
      let ⟨y, yh1, yh2⟩ := this z.toNat
      simp only [exists_prop, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and] at yh1
      let ⟨i, ih⟩ := yh1
      use i
      lia
    let := (con (i+1)) 0 z (a i) ?_ ?_ ?_ ?_
    · simp only [Finset.mem_image, Finset.mem_range, Order.lt_add_one_iff] at this
      grind only
    · exact zpos
    · exact ih
    · rw [Finset.mem_image]
      use 0
      simp [a0]
    · rw [Finset.mem_image]
      use i
      simp


end Imo2005P2

-- ═══ Imo2005P3 ═══

/-
Copyright (c) 2021 Manuel Candales. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Manuel Candales
-/




/-!
# International Mathematical Olympiad 2005, Problem 3
Let `x`, `y` and `z` be positive real numbers such that `xyz ≥ 1`. Prove that:
`(x^5 - x^2)/(x^5 + y^2 + z^2) + (y^5 - y^2)/(y^5 + z^2 + x^2) + (z^5 - z^2)/(z^5 + x^2 + y^2) ≥ 0`
-/

namespace Imo2005P3



/-
# Solution
The solution by Iurie Boreico from Moldova is presented, which won a special prize during the exam.
The key insight is that `(x^5-x^2)/(x^5+y^2+z^2) ≥ (x^2-y*z)/(x^2+y^2+z^2)`, which is proven by
factoring `(x^5-x^2)/(x^5+y^2+z^2) - (x^5-x^2)/(x^3*(x^2+y^2+z^2))` into a non-negative expression
and then making use of `xyz ≥ 1` to show `(x^5-x^2)/(x^3*(x^2+y^2+z^2)) ≥ (x^2-y*z)/(x^2+y^2+z^2)`.
-/

theorem key_insight (x y z : ℝ) (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z ≥ 1) :
    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) ≥ (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) := by
  have key :
    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) -
        (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) =
      (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /
        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) := by
    field_simp
    ring
  have h₅ :
    (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /
        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) ≥ 0 := by positivity
  calc
    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2)
      ≥ (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by linarith only [key, h₅]
    _ ≥ (x ^ 5 - x ^ 2 * (x * y * z)) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by gcongr
    _ = (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) := by field_simp



theorem imo2005_p3 (x y z : ℝ) (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z ≥ 1) :
    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +
        (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) ≥
      0 := by
  calc
    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +
          (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) ≥
        (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) + (y ^ 2 - z * x) / (y ^ 2 + z ^ 2 + x ^ 2) +
          (z ^ 2 - x * y) / (z ^ 2 + x ^ 2 + y ^ 2) := by
      gcongr ?_ + ?_ + ?_ <;> apply key_insight <;> linarith
    _ = 1 / 2 * ((x - y) ^ 2 + (y - z) ^ 2 + (z - x) ^ 2) / (x ^ 2 + y ^ 2 + z ^ 2) := by ring
    _ ≥ 0 := by positivity


end Imo2005P3

-- ═══ Imo2006P5 ═══

/-
Copyright (c) 2022 Violeta Hernández Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta Hernández Palacios
-/




/-!
# International Mathematical Olympiad 2006, Problem 5

Let $P(x)$ be a polynomial of degree $n>1$ with integer coefficients, and let $k$ be a positive
integer. Consider the polynomial $Q(x) = P(P(\ldots P(P(x))\ldots))$, where $P$ occurs $k$ times.
Prove that there are at most $n$ integers $t$ such that $Q(t)=t$.
-/

open Function Polynomial

namespace Imo2006P5



/-
## Sketch of solution

The following solution is adapted from
https://artofproblemsolving.com/wiki/index.php/2006_IMO_Problems/Problem_5.

Let $P^k$ denote the polynomial $P$ composed with itself $k$ times. We rely on a key observation: if
$P^k(t)=t$, then $P(P(t))=t$. We prove this by building the cyclic list
$(P(t)-t,P^2(t)-P(t),\ldots)$, and showing that each entry divides the next, which by transitivity
implies they all divide each other, and thus have the same absolute value.

If the entries in this list are all pairwise equal, then we can show inductively that for positive
$n$, $P^n(t)-t$ must always have the same sign as $P(t)-t$. Substituting $n=k$ gives us $P(t)=t$ and
in particular $P(P(t))=t$.

Otherwise, there must be two consecutive entries that are opposites of one another. This means
$P^{n+2}(t)-P^{n+1}(t)=P^n(t)-P^{n+1}(t)$, which implies $P^{n+2}(t)=P^n(t)$ and $P(P(t))=t$.

With this lemma, we can reduce the problem to the case $k=2$. If every root of $P(P(t))-t$ is also a
root of $P(t)-t$, then we're done. Otherwise, there exist $a$ and $b$ with $a\ne b$ and $P(a)=b$,
$P(b)=a$. For any root $t$ of $P(P(t))-t$, defining $u=P(t)$, we easily verify $a-t\mid b-u$,
$b-u\mid a-t$, $a-u\mid b-t$, $b-t\mid a-u$, which imply $|a-t|=|b-u|$ and $|a-u|=|b-t|$. By casing
on these equalities, we deduce $a+b=t+u$. This means that every root of $P(P(t))-t$ is a root of
$P(t)+t-a-b$, and we're again done.
-/

/-- If every entry in a cyclic list of integers divides the next, then they all have the same
absolute value. -/
theorem Int.natAbs_eq_of_chain_dvd {l : Cycle ℤ} {x y : ℤ} (hl : l.Chain (· ∣ ·)) (hx : x ∈ l)
    (hy : y ∈ l) : x.natAbs = y.natAbs := by
  rw [Cycle.chain_iff_pairwise] at hl
  exact Int.natAbs_eq_of_dvd_dvd (hl x hx y hy) (hl y hy x hx)

theorem Int.add_eq_add_of_natAbs_eq_of_natAbs_eq {a b c d : ℤ} (hne : a ≠ b)
    (h₁ : (c - a).natAbs = (d - b).natAbs) (h₂ : (c - b).natAbs = (d - a).natAbs) :
    a + b = c + d := by
  lia

/-- The main lemma in the proof: if $P^k(t)=t$, then $P(P(t))=t$. -/
theorem Polynomial.isPeriodicPt_eval_two {P : Polynomial ℤ} {t : ℤ}
    (ht : t ∈ periodicPts fun x => P.eval x) : IsPeriodicPt (fun x => P.eval x) 2 t := by
  -- The cycle [P(t) - t, P(P(t)) - P(t), ...]
  let C : Cycle ℤ := (periodicOrbit (fun x => P.eval x) t).map fun x => P.eval x - x
  have HC : ∀ {n : ℕ}, (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t ∈ C := by
    intro n
    rw [Cycle.mem_map, Function.iterate_succ_apply']
    exact ⟨_, iterate_mem_periodicOrbit ht n, rfl⟩
  -- Elements in C are all divisible by one another.
  have Hdvd : C.Chain (· ∣ ·) := by
    rw [Cycle.chain_map, periodicOrbit_chain' _ ht]
    intro n
    convert sub_dvd_eval_sub ((fun x => P.eval x)^[n + 1] t) ((fun x => P.eval x)^[n] t) P <;>
      rw [Function.iterate_succ_apply']
  -- Any two entries in C have the same absolute value.
  have Habs :
    ∀ m n : ℕ,
      ((fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t).natAbs =
        ((fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t).natAbs :=
    fun m n => Int.natAbs_eq_of_chain_dvd Hdvd HC HC
  -- We case on whether the elements on C are pairwise equal.
  by_cases HC' : C.Chain (· = ·)
  · -- Any two entries in C are equal.
    have Heq :
      ∀ m n : ℕ,
        (fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t =
          (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t :=
      fun m n => Cycle.chain_iff_pairwise.1 HC' _ HC _ HC
    -- The sign of P^n(t) - t is the same as P(t) - t for positive n. Proven by induction on n.
    have IH : ∀ n : ℕ, ((fun x => P.eval x)^[n + 1] t - t).sign = (P.eval t - t).sign := by
      intro n
      induction n with
      | zero => rfl
      | succ n IH =>
        apply Eq.trans _ (Int.sign_add_eq_of_sign_eq IH)
        have H := Heq n.succ 0
        dsimp at H ⊢
        rw [← H, sub_add_sub_cancel']
    -- This implies that the sign of P(t) - t is the same as the sign of P^k(t) - t, which is 0.
    -- Hence P(t) = t and P(P(t)) = P(t).
    rcases ht with ⟨_ | k, hk, hk'⟩
    · exact (irrefl 0 hk).elim
    · have H := IH k
      rw [hk'.isFixedPt.eq, sub_self, Int.sign_zero, eq_comm, Int.sign_eq_zero_iff_zero,
        sub_eq_zero] at H
      simp [IsPeriodicPt, IsFixedPt, H]
  · -- We take two nonequal consecutive entries.
    rw [Cycle.chain_map, periodicOrbit_chain' _ ht] at HC'
    push_neg at HC'
    obtain ⟨n, hn⟩ := HC'
    -- They must have opposite sign, so that P^{k + 1}(t) - P^k(t) = P^{k + 2}(t) - P^{k + 1}(t).
    obtain hn' | hn' := Int.natAbs_eq_natAbs_iff.1 (Habs n n.succ)
    · apply (hn _).elim
      convert hn' <;> simp only [Function.iterate_succ_apply']
    -- We deduce P^{k + 2}(t) = P^k(t) and hence P(P(t)) = t.
    · rw [neg_sub, sub_right_inj] at hn'
      simp only [Function.iterate_succ_apply'] at hn'
      exact isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate ht hn'.symm

theorem Polynomial.iterate_comp_sub_X_ne {P : Polynomial ℤ} (hP : 1 < P.natDegree) {k : ℕ}
    (hk : 0 < k) : P.comp^[k] X - X ≠ 0 := by
  rw [sub_ne_zero]
  apply_fun natDegree
  simpa using (one_lt_pow₀ hP hk.ne').ne'

/-- We solve the problem for the specific case k = 2 first. -/
theorem imo2006_p5' {P : Polynomial ℤ} (hP : 1 < P.natDegree) :
    (P.comp P - X).roots.toFinset.card ≤ P.natDegree := by
  -- Auxiliary lemmas on degrees.
  have hPX : (P - X).natDegree = P.natDegree := by
    rw [natDegree_sub_eq_left_of_natDegree_lt]
    simpa using hP
  have hPX' : P - X ≠ 0 := by
    intro h
    rw [h, natDegree_zero] at hPX
    rw [← hPX] at hP
    exact (zero_le_one.not_gt hP).elim
  -- If every root of P(P(t)) - t is also a root of P(t) - t, then we're done.
  by_cases H : (P.comp P - X).roots.toFinset ⊆ (P - X).roots.toFinset
  · exact (Finset.card_le_card H).trans
      ((Multiset.toFinset_card_le _).trans ((card_roots' _).trans_eq hPX))
  -- Otherwise, take a, b with P(a) = b, P(b) = a, a ≠ b.
  · rcases Finset.not_subset.1 H with ⟨a, ha, hab⟩
    replace ha := isRoot_of_mem_roots (Multiset.mem_toFinset.1 ha)
    rw [IsRoot.def, eval_sub, eval_comp, eval_X, sub_eq_zero] at ha
    rw [Multiset.mem_toFinset, mem_roots hPX', IsRoot.def, eval_sub, eval_X, sub_eq_zero] at hab
    set b := P.eval a
    -- More auxiliary lemmas on degrees.
    have hPab : (P + (X : ℤ[X]) - a - b).natDegree = P.natDegree := by
      rw [sub_sub, ← Int.cast_add]
      have h₁ : (P + X).natDegree = P.natDegree := by
        rw [natDegree_add_eq_left_of_natDegree_lt]
        simpa using hP
      rwa [natDegree_sub_eq_left_of_natDegree_lt]
      rw [h₁, natDegree_intCast]
      exact zero_lt_one.trans hP
    have hPab' : P + (X : ℤ[X]) - a - b ≠ 0 := by
      intro h
      rw [h, natDegree_zero] at hPab
      rw [← hPab] at hP
      exact (zero_le_one.not_gt hP).elim
    -- We claim that every root of P(P(t)) - t is a root of P(t) + t - a - b. This allows us to
    -- conclude the problem.
    suffices H' : (P.comp P - X).roots.toFinset ⊆ (P + (X : ℤ[X]) - a - b).roots.toFinset from
      (Finset.card_le_card H').trans
        ((Multiset.toFinset_card_le _).trans <| (card_roots' _).trans_eq hPab)
    · -- Let t be a root of P(P(t)) - t, define u = P(t).
      intro t ht
      replace ht := isRoot_of_mem_roots (Multiset.mem_toFinset.1 ht)
      rw [IsRoot.def, eval_sub, eval_comp, eval_X, sub_eq_zero] at ht
      simp only [mem_roots hPab', sub_eq_iff_eq_add, Multiset.mem_toFinset, IsRoot.def, eval_sub,
        eval_add, eval_X, eval_intCast, Int.cast_id, zero_add]
      -- An auxiliary lemma proved earlier implies we only need to show |t - a| = |u - b| and
      -- |t - b| = |u - a|. We prove this by establishing that each side of either equation divides
      -- the other.
      apply (Int.add_eq_add_of_natAbs_eq_of_natAbs_eq hab _ _).symm <;>
          apply Int.natAbs_eq_of_dvd_dvd <;> set u := P.eval t
      · rw [← ha, ← ht]; apply sub_dvd_eval_sub
      · apply sub_dvd_eval_sub
      · rw [← ht]; apply sub_dvd_eval_sub
      · rw [← ha]; apply sub_dvd_eval_sub



theorem imo2006_p5 {P : Polynomial ℤ} (hP : 1 < P.natDegree) {k : ℕ} (hk : 0 < k) :
    (P.comp^[k] X - X).roots.toFinset.card ≤ P.natDegree := by
  refine (Finset.card_le_card fun t ht => ?_).trans (imo2006_p5' hP)
  have hP' : P.comp P - X ≠ 0 := by
    simpa [Nat.iterate] using Polynomial.iterate_comp_sub_X_ne hP zero_lt_two
  replace ht := isRoot_of_mem_roots (Multiset.mem_toFinset.1 ht)
  rw [IsRoot.def, eval_sub, iterate_comp_eval, eval_X, sub_eq_zero] at ht
  rw [Multiset.mem_toFinset, mem_roots hP', IsRoot.def, eval_sub, eval_comp, eval_X, sub_eq_zero]
  exact Polynomial.isPeriodicPt_eval_two ⟨k, hk, ht⟩


end Imo2006P5

-- ═══ Imo2007P1 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 2007, Problem 1

Real numbers a₁, a₂, ..., aₙ are fixed. For each 1 ≤ i ≤ n,
we let dᵢ = max {aⱼ : 1 ≤ j ≤ i} - min {aⱼ : i ≤ j ≤ n},
and let d = max {dᵢ : 1 ≤ i ≤ n}.

(a) Prove that for any real numbers x₁ ≤ ... ≤ xₙ, we have
   max { |xᵢ - aᵢ| : 1 ≤ i ≤ n } ≥ d / 2.

(b) Show that there exists some choice of x₁ ≤ ... ≤ xₙ which achieves equality.
-/

namespace Imo2007P1

noncomputable abbrev d {n : ℕ} (a : Fin n → ℝ) (i : Fin n) :=
  (⨆ j : {j // j ≤ i}, a j) - (⨅ j : {j // i ≤ j}, a j)

theorem imo2007_p1a {n : ℕ} (hn : 0 < n) (a x : Fin n → ℝ) (h : Monotone x) :
    (⨆ i, d a i) / 2 ≤ ⨆ i, |x i - a i| := by
  have h₁ : ∃ i : Fin n, d a i = ⨆ i, d a i:= by
    haveI : Nonempty (Fin n) := Fin.pos_iff_nonempty.mp hn
    apply exists_eq_ciSup_of_finite
  rcases h₁ with ⟨i, hi⟩
  rw [←hi, d]
  have h₂ : ∃ j : {j // j ≤ i}, a j = ⨆ j : {j // j ≤ i}, a j:= by
    haveI : Nonempty {j // j ≤ i} := by
      rw [nonempty_subtype]
      use i
    apply exists_eq_ciSup_of_finite
  have h₃ : ∃ k : {k // i ≤ k}, a k = ⨅ k : {k // i ≤ k}, a k := by
    apply exists_eq_ciInf_of_finite
  rcases h₂ with ⟨j, hj⟩
  rcases h₃ with ⟨k, hk⟩
  rw [← hj, ← hk]
  apply le_of_not_gt
  intro h'
  have h₄ : ∀ i : Fin n, |x i - a i| < (a ↑j - a ↑k) / 2 := by
    intro i
    calc |x i - a i|
        ≤ ⨆ i, |x i - a i| := Finite.le_ciSup (fun i ↦ |x i - a i|) i
      _ < (a ↑j - a ↑k) / 2 := h'
  have h₅ : a ↑j - a ↑k < a ↑j - a ↑k := by
    calc a ↑j - a ↑k
      ≤ (a ↑j - a ↑k) + (x ↑k - x ↑j) := by
          apply le_add_of_nonneg_right
          apply sub_nonneg_of_le
          apply h
          exact le_trans j.prop k.prop
      _ = (a ↑j - x ↑j) + (x ↑k - a ↑k):= by module
      _ ≤ |a ↑j - x ↑j| + |x ↑k - a ↑k| := add_le_add (le_abs_self _) (le_abs_self _)
      _ = |x ↑j - a ↑j| + |x ↑k - a ↑k| := by rw [abs_sub_comm]
      _ < (a ↑j - a ↑k) / 2 + (a ↑j - a ↑k) / 2 := add_lt_add (h₄ j) (h₄ k)
      _ = a ↑j - a ↑k := add_halves _
  exact (lt_self_iff_false _).mp h₅

theorem imo2007_p1b {n : ℕ} (hn : 0 < n) {a : Fin n → ℝ} :
    ∃ x : Fin n → ℝ, Monotone x ∧
      (⨆ i, d a i) / 2 = ⨆ i, |x i - a i| := by
  haveI : Nonempty (Fin n) := Fin.pos_iff_nonempty.mp hn
  set d' := (⨆ i, d a i) / 2
  set x := fun (i: Fin n) ↦ (⨆ j : {j // j ≤ i}, a j) - d'
  use x
  have h : Monotone x := by
    intro i j i_le_j
    apply sub_le_sub_right
    haveI : Nonempty {j // j ≤ i} := by
      rw [nonempty_subtype]
      use i
    rw [ciSup_le_iff (Finite.bddAbove_range fun (j : { j // j ≤ i }) ↦ a j)]
    intro i'
    exact Finite.le_ciSup (fun (j' : { j' // j' ≤ j }) ↦ a j') ⟨i', le_trans i'.prop i_le_j⟩
  constructor
  · exact h
  · apply le_antisymm
    · exact imo2007_p1a hn a x h
    · rw [ciSup_le_iff (Finite.bddAbove_range fun i ↦ |x i - a i|)]
      intro i
      rw [abs_le']
      constructor
      · have h': x i - a i = ((⨆ j : {j // j ≤ i}, a j) - a i) - d' := by module
        rw [h', sub_le_iff_le_add, ← mul_two]
        calc (⨆ j : {j // j ≤ i}, a j) - a i
            ≤ (⨆ j : {j // j ≤ i}, a j) - (⨅ j : {j // i ≤ j}, a j) := by
              apply sub_le_sub_left
              exact Finite.ciInf_le (fun (j : { j // i ≤ j }) ↦ a j) ⟨i, le_rfl⟩
          _ ≤ ⨆ i, d a i := Finite.le_ciSup (fun i ↦ d a i) i
          _ = d' * 2 := (div_mul_cancel_of_invertible _ _).symm
      · calc -(x i - a i)
            = d' + (a i - (⨆ j : {j // j ≤ i}, a j)) := by module
          _ ≤ d' := by
              apply add_le_of_nonpos_right
              apply sub_nonpos_of_le
              haveI : Nonempty {j // j ≤ i} := by
                rw [nonempty_subtype]
                use i
              exact Finite.le_ciSup (fun (j : { j // j ≤ i }) ↦ a j) ⟨i, le_rfl⟩


end Imo2007P1

-- ═══ Imo2007P5 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gian Sanjaya
-/





/-!
# International Mathematical Olympiad 2007, Problem 5

Let a and b be positive integers. Show that if 4ab - 1 divides (4a² - 1)²
then a = b.
-/

namespace Imo2007P5



lemma bad_symm {n : ℤ} {a b : ℕ} (h : n * a * b - 1 ∣ (n * a ^ 2 - 1) ^ 2) :
  n * b * a - 1 ∣ (n * b ^ 2 - 1) ^ 2 := by
  rw [mul_right_comm, sub_sq', add_comm, mul_right_comm _ _ (1 : ℤ), ← sub_sq']
  replace h := dvd_mul_of_dvd_left h ((n * b ^ 2) ^ 2)
  rw [← mul_pow, sub_one_mul, mul_mul_mul_comm, ← sq, ← mul_pow, ← mul_pow, ← mul_assoc] at h
  rw [← Int.modEq_zero_iff_dvd] at h ⊢
  revert h
  refine ((Int.ModEq.sub_right _ ?_).pow _).trans
  nth_rewrite 1 [← one_pow 2]
  exact ((n * a * b).modEq_sub 1).symm.pow 2

lemma bad_exists_descent {n : ℤ} (hn : 1 < n) {a : ℕ}
  (h : 0 < a ∧ ∃ b : ℕ, a < b ∧ n * a * b - 1 ∣ (n * a ^ 2 - 1) ^ 2) :
  ∃ c : ℕ, 0 < c ∧ c < a ∧ n * c * a - 1 ∣ (n * c ^ 2 - 1) ^ 2 := by
  rcases h with ⟨h, b, h0, k, h1⟩
  rw [sq (a : ℤ), ← mul_assoc] at h1
  generalize ht : n * a = t at h1
  obtain ⟨c, rfl⟩ : ∃ c : ℤ, k = t * c - 1 := by
    replace h1 : (t * a - 1) ^ 2 ≡ (t * b - 1) * k [ZMOD t] := by rw [h1]
    have X : ∀ m : ℤ, t * m - 1 ≡ -1 [ZMOD t] := fun m ↦ by
      symm; rw [Int.modEq_iff_dvd, sub_neg_eq_add, sub_add_cancel]; exact ⟨m, rfl⟩
    replace h1 := ((X a).pow 2).symm.trans (h1.trans ((X b).mul_right _))
    rw [Int.modEq_iff_dvd, sq, ← mul_sub, sub_neg_eq_add, neg_one_mul, dvd_neg] at h1
    obtain ⟨c, h1⟩ := h1
    exact ⟨c, eq_sub_of_add_eq h1⟩

  ---- It suffices to show that `0 < c` and `c < (a : ℤ)`
  suffices h2 : c < a ∧ 0 < c by
    lift c to ℕ using le_of_lt h2.2
    rw [Int.natCast_pos, Int.ofNat_lt] at h2
    refine ⟨c, h2.2, h2.1, bad_symm ⟨t * b - 1, ?_⟩⟩
    rw [sq (a : ℤ), ← mul_assoc, ht, h1, mul_comm]

  ---- We do not need `n`; we just use `t` instead.
  replace ht : 1 < t := by
    rw [← Int.natCast_pos] at h
    have h2 := le_trans Int.one_nonneg (le_of_lt hn)
    rw [Int.lt_iff_add_one_le] at hn h ⊢
    rw [← ht]
    exact hn.trans (le_mul_of_one_le_right h2 h)

  clear hn n

  ---- Some ordering results
  have h2 := lt_trans one_pos ht
  have h3 : ∀ x y : ℤ, x < y ↔ t * x - 1 < t * y - 1 :=
    fun x y ↦ by rw [sub_lt_sub_iff_right, ← mul_lt_mul_iff_right₀ h2]
  replace h2 : ∀ x : ℤ, 0 < x ↔ 0 < t * x - 1 := by
    intro x
    rw [h3, mul_zero, Int.lt_iff_add_one_le, sub_add_cancel, le_iff_eq_or_lt]
    refine or_iff_right (λ h4 ↦ ne_of_gt ht ?_)
    rw [eq_comm, sub_eq_zero] at h4
    exact Int.eq_one_of_mul_eq_one_right (le_of_lt h2) h4

  ---- Rearranging and final step
  rw [← Int.natCast_pos, h2] at h
  rw [← Int.ofNat_lt, h3] at h0
  rw [h2, h3 c]
  constructor
  · rwa [← mul_lt_mul_iff_right₀ (lt_trans h h0), ← h1, sq, mul_lt_mul_iff_left₀ h]
  · rw [← mul_lt_mul_iff_right₀ (lt_trans h h0), mul_zero, ← h1]
    exact pow_pos h 2

lemma nat_pred_descent {P : ℕ → Prop} [DecidablePred P]
  (h : ∀ k : ℕ, P k → ∃ m : ℕ, m < k ∧ P m) : ∀ k : ℕ, ¬P k :=
  forall_not_of_not_exists λ h0 ↦ Exists.elim (h (Nat.find h0) (Nat.find_spec h0))
    λ _ h1 ↦ Nat.find_min h0 h1.1 h1.2

theorem generalized_imo2007_p5 {n : ℤ} (hn : 1 < n) :
    ∀ a b : ℕ, 0 < a → 0 < b → n * a * b - 1 ∣ (n * a ^ 2 - 1) ^ 2 → a = b := by
  let P : ℕ → Prop := λ k ↦ (0 < k ∧ ∃ m : ℕ, k < m ∧ n * k * m - 1 ∣ (n * k ^ 2 - 1) ^ 2)
  have h : ∀ k : ℕ, P k → ∃ m : ℕ, m < k ∧ P m :=
    λ k h ↦ Exists.elim (bad_exists_descent hn h)
      (λ c h0 ↦ ⟨c, h0.2.1, h0.1, k, h0.2.1, h0.2.2⟩)
  classical
  replace h := nat_pred_descent h
  intro a b ha hb h0
  by_contra! h1
  exact (lt_or_gt_of_ne h1).elim (λ h1 ↦ h a ⟨ha, b, h1, h0⟩)
    (λ h1 ↦ h b ⟨hb, a, h1, bad_symm h0⟩)



theorem imo2007_p5 (a b : ℤ) (ha : 0 < a) (hb : 0 < b)
    (hab : 4 * a * b - 1 ∣ (4 * a^2 - 1)^2) : a = b := by
  lift a to ℕ using le_of_lt ha
  lift b to ℕ using le_of_lt hb
  have ha' : 0 < a := Int.natCast_pos.mp ha
  have hb' : 0 < b := Int.natCast_pos.mp hb
  have hg := generalized_imo2007_p5 (n := 4) (by norm_num) a b ha' hb' hab
  exact congrArg Nat.cast hg


end Imo2007P5

-- ═══ Imo2008P2 ═══

/-
Copyright (c) 2021 Manuel Candales. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Manuel Candales
-/




/-!
# International Mathematical Olympiad 2008, Problem 2
(a) Prove that
          ```
          x^2 / (x-1)^2 + y^2 / (y-1)^2 + z^2 / (z-1)^2 ≥ 1
          ```
for all real numbers `x`,`y`, `z`, each different from 1, and satisfying `xyz = 1`.

(b) Prove that equality holds above for infinitely many triples of rational numbers `x`, `y`, `z`,
each different from 1, and satisfying `xyz = 1`.
-/

namespace Imo2008P2



/-
# Solution
(a) Since `xyz = 1`, we can apply the substitution `x = a/b`, `y = b/c`, `z = c/a`.
Then we define `m = c-b`, `n = b-a` and rewrite the inequality as `LHS - 1 ≥ 0`
using `c`, `m` and `n`. We factor `LHS - 1` as a square, which finishes the proof.

(b) We present a set `W` of rational triples. We prove that `W` is a subset of the
set of rational solutions to the equation, and that `W` is infinite.
-/

theorem subst_abc {x y z : ℝ} (h : x * y * z = 1) :
    ∃ a b c : ℝ, a ≠ 0 ∧ b ≠ 0 ∧ c ≠ 0 ∧ x = a / b ∧ y = b / c ∧ z = c / a := by
  use x, 1, 1 / y
  obtain ⟨⟨hx, hy⟩, _⟩ : (x ≠ 0 ∧ y ≠ 0) ∧ z ≠ 0 := by
    have := h.symm ▸ one_ne_zero
    simpa [not_or] using this
  have : z * (y * x) = 1 := by rw [← h]; ac_rfl
  simp [field, mul_assoc, *]



theorem imo2008_p2a (x y z : ℝ) (h : x * y * z = 1) (hx : x ≠ 1) (hy : y ≠ 1) (hz : z ≠ 1) :
    x ^ 2 / (x - 1) ^ 2 + y ^ 2 / (y - 1) ^ 2 + z ^ 2 / (z - 1) ^ 2 ≥ 1 := by
  obtain ⟨a, b, c, ha, hb, hc, rfl, rfl, rfl⟩ := subst_abc h
  obtain ⟨m, n, rfl, rfl⟩ : ∃ m n, b = c - m ∧ a = c - m - n := by use c - b, b - a; simp
  have hm_ne_zero : m ≠ 0 := by contrapose! hy; simp [field]; assumption
  have hn_ne_zero : n ≠ 0 := by contrapose! hx; simp [field]; assumption
  have hmn_ne_zero : m + n ≠ 0 := by contrapose! hz; field_simp; linarith
  have hc_sub_sub : c - (c - m - n) = m + n := by abel
  rw [ge_iff_le, ← sub_nonneg]
  convert sq_nonneg ((c * (m ^ 2 + n ^ 2 + m * n) - m * (m + n) ^ 2) / (m * n * (m + n)))
  simp [field, hc_sub_sub]; ring

def rationalSolutions :=
  {s : ℚ × ℚ × ℚ | ∃ x y z : ℚ, s = (x, y, z) ∧ x ≠ 1 ∧ y ≠ 1 ∧ z ≠ 1 ∧ x * y * z = 1 ∧
    x ^ 2 / (x - 1) ^ 2 + y ^ 2 / (y - 1) ^ 2 + z ^ 2 / (z - 1) ^ 2 = 1}

theorem imo2008_p2b : Set.Infinite rationalSolutions := by
  let W := {s : ℚ × ℚ × ℚ | ∃ x y z : ℚ, s = (x, y, z) ∧
    ∃ t : ℚ, t > 0 ∧ x = -(t + 1) / t ^ 2 ∧ y = t / (t + 1) ^ 2 ∧ z = -t * (t + 1)}
  have hW_sub_S : W ⊆ rationalSolutions := by
    intro s hs_in_W
    rw [rationalSolutions]
    simp only [Set.mem_setOf_eq] at hs_in_W ⊢
    rcases hs_in_W with ⟨x, y, z, h₁, t, ht_gt_zero, hx_t, hy_t, hz_t⟩
    use x, y, z
    have key_gt_zero : t ^ 2 + t + 1 > 0 := by positivity
    have h₂ : x ≠ 1 := by rw [hx_t]; simp [field]; linarith [key_gt_zero]
    have h₃ : y ≠ 1 := by rw [hy_t]; simp [field]; linarith [key_gt_zero]
    have h₄ : z ≠ 1 := by rw [hz_t]; linarith [key_gt_zero]
    have h₅ : x * y * z = 1 := by rw [hx_t, hy_t, hz_t]; field_simp
    have h₆ : x ^ 2 / (x - 1) ^ 2 + y ^ 2 / (y - 1) ^ 2 + z ^ 2 / (z - 1) ^ 2 = 1 := by
      have hx1 : (x - 1) ^ 2 = (t ^ 2 + t + 1) ^ 2 / t ^ 4 := by
        field_simp; rw [hx_t]; field_simp; ring
      have hy1 : (y - 1) ^ 2 = (t ^ 2 + t + 1) ^ 2 / (t + 1) ^ 4 := by
        field_simp; rw [hy_t]; field_simp; ring
      have hz1 : (z - 1) ^ 2 = (t ^ 2 + t + 1) ^ 2 := by rw [hz_t]; ring
      calc
        x ^ 2 / (x - 1) ^ 2 + y ^ 2 / (y - 1) ^ 2 + z ^ 2 / (z - 1) ^ 2 =
            (x ^ 2 * t ^ 4 + y ^ 2 * (t + 1) ^ 4 + z ^ 2) / (t ^ 2 + t + 1) ^ 2 := by
          rw [hx1, hy1, hz1]; field_simp
        _ = 1 := by rw [hx_t, hy_t, hz_t]; field_simp; ring
    exact ⟨h₁, h₂, h₃, h₄, h₅, h₆⟩
  have hW_inf : Set.Infinite W := by
    let g : ℚ × ℚ × ℚ → ℚ := fun s => -s.2.2
    let K := g '' W
    have hK_not_bdd : ¬BddAbove K := by
      rw [not_bddAbove_iff]
      intro q
      let t : ℚ := max (q + 1) 1
      use t * (t + 1)
      have h₁ : t * (t + 1) ∈ K := by
        let x : ℚ := -(t + 1) / t ^ 2
        let y : ℚ := t / (t + 1) ^ 2
        set z : ℚ := -t * (t + 1) with hz_def
        simp only [t, W, K, g, Set.mem_image, Prod.exists]
        use x, y, z; constructor
        · simp only [Set.mem_setOf_eq]
          use x, y, z; constructor
          · rfl
          · use t; constructor
            · exact lt_max_of_lt_right zero_lt_one
            exact ⟨rfl, rfl, rfl⟩
        · have hg : -z = g (x, y, z) := rfl
          rw [hg, hz_def]; ring
      have h₂ : q < t * (t + 1) := by
        calc
          q < q + 1 := lt_add_one q
          _ ≤ t := (le_max_left (q + 1) 1)
          _ ≤ t + t ^ 2 := by linarith [sq_nonneg t]
          _ = t * (t + 1) := by ring
      exact ⟨h₁, h₂⟩
    have hK_inf : Set.Infinite K := Set.infinite_of_not_bddAbove hK_not_bdd
    exact hK_inf.of_image g
  exact hW_inf.mono hW_sub_S



end Imo2008P2

-- ═══ Imo2008P3 ═══

/-
Copyright (c) 2021 Manuel Candales. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Manuel Candales
-/




/-!
# International Mathematical Olympiad 2008, Problem 3
Prove that there exist infinitely many positive integers `n` such that `n^2 + 1` has a prime
divisor which is greater than `2n + √(2n)`.
-/

open Real

namespace Imo2008P3



/-
# Solution
We first prove the following lemma: for every prime `p > 20`, satisfying `p ≡ 1 [MOD 4]`,
there exists `n ∈ ℕ` such that `p ∣ n^2 + 1` and `p > 2n + √(2n)`. Then the statement of the
theorem follows from the fact that there exist infinitely many primes `p ≡ 1 [MOD 4]`.

To prove the lemma, notice that `p ≡ 1 [MOD 4]` implies `∃ n ∈ ℕ` such that `n^2 ≡ -1 [MOD p]`
and we can take this `n` such that `n ≤ p/2`. Let `k = p - 2n ≥ 0`. Then we have:
`k^2 + 4 = (p - 2n)^2 + 4 ≣ 4n^2 + 4 ≡ 0 [MOD p]`. Then `k^2 + 4 ≥ p` and so `k ≥ √(p - 4) > 4`.
Then `p = 2n + k ≥ 2n + √(p - 4) = 2n + √(2n + k - 4) > √(2n)` and we are done.
-/

theorem p_lemma (p : ℕ) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p ≡ 1 [MOD 4]) (hp_gt_20 : p > 20) :
    ∃ n : ℕ, p ∣ n ^ 2 + 1 ∧ (p : ℝ) > 2 * n + sqrt (2 * n) := by
  haveI := Fact.mk hpp
  have hp_mod_4_ne_3 : p % 4 ≠ 3 := by linarith [show p % 4 = 1 from hp_mod_4_eq_1]
  obtain ⟨y, hy⟩ := ZMod.exists_sq_eq_neg_one_iff.mpr hp_mod_4_ne_3
  let m := ZMod.valMinAbs y
  let n := Int.natAbs m
  have hnat₁ : p ∣ n ^ 2 + 1 := by
    refine Int.natCast_dvd_natCast.mp ?_
    simp only [n, Int.natAbs_sq, Int.natCast_pow, Int.natCast_succ]
    refine (ZMod.intCast_zmod_eq_zero_iff_dvd (m ^ 2 + 1) p).mp ?_
    simp only [m, Int.cast_pow, Int.cast_add, Int.cast_one, ZMod.coe_valMinAbs]
    rw [pow_two, ← hy]; exact neg_add_cancel 1
  have hnat₂ : n ≤ p / 2 := ZMod.natAbs_valMinAbs_le y
  have hnat₃ : p ≥ 2 * n := by lia
  set k : ℕ := p - 2 * n with hnat₄
  have hnat₅ : p ∣ k ^ 2 + 4 := by
    obtain ⟨x, hx⟩ := hnat₁
    have : (p : ℤ) ∣ (k : ℤ) ^ 2 + 4 := by
      use (p : ℤ) - 4 * n + 4 * x
      have hcast₁ : (k : ℤ) = p - 2 * n := by assumption_mod_cast
      have hcast₂ : (n : ℤ) ^ 2 + 1 = p * x := by assumption_mod_cast
      linear_combination ((k : ℤ) + p - 2 * n) * hcast₁ + 4 * hcast₂
    assumption_mod_cast
  have hnat₆ : k ^ 2 + 4 ≥ p := Nat.le_of_dvd (k ^ 2 + 3).succ_pos hnat₅
  have hreal₁ : (k : ℝ) = p - 2 * n := by assumption_mod_cast
  have hreal₂ : (p : ℝ) > 20 := by assumption_mod_cast
  have hreal₃ : (k : ℝ) ^ 2 + 4 ≥ p := by assumption_mod_cast
  have hreal₅ : (k : ℝ) > 4 := by
    refine lt_of_pow_lt_pow_left₀ 2 k.cast_nonneg ?_
    linarith only [hreal₂, hreal₃]
  have hreal₆ : (k : ℝ) > sqrt (2 * n) := by
    refine lt_of_pow_lt_pow_left₀ 2 k.cast_nonneg ?_
    rw [sq_sqrt (mul_nonneg zero_le_two n.cast_nonneg)]
    linarith only [hreal₁, hreal₃, hreal₅]
  exact ⟨n, hnat₁, by linarith only [hreal₆, hreal₁]⟩



theorem imo2008_p3 : ∀ N : ℕ, ∃ n : ℕ, n ≥ N ∧
    ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ^ 2 + 1 ∧ (p : ℝ) > 2 * n + sqrt (2 * n) := by
  intro N
  obtain ⟨p, hpp, hineq₁, hpmod4⟩ := Nat.exists_prime_gt_modEq_one (N ^ 2 + 20) four_ne_zero
  obtain ⟨n, hnat, hreal⟩ := p_lemma p hpp hpmod4 (by lia)
  have hineq₂ : n ^ 2 + 1 ≥ p := Nat.le_of_dvd (n ^ 2).succ_pos hnat
  have hineq₃ : n * n ≥ N * N := by linarith [hineq₁, hineq₂]
  have hn_ge_N : n ≥ N := Nat.mul_self_le_mul_self_iff.mp hineq₃
  exact ⟨n, hn_ge_N, p, hpp, hnat, hreal⟩


end Imo2008P3

-- ═══ Imo2010P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Gian Sanjaya
-/





/-!
# International Mathematical Olympiad 2010, Problem 1

Determine all functions f : ℝ → ℝ such that for all x,y ∈ ℝ,

               f(⌊x⌋y) = f(x)⌊f(y)⌋.
-/

namespace Imo2010P1

noncomputable def solution_set : Set (ℝ → ℝ) :=
  { f | (∃ C, ⌊C⌋ = 1 ∧ f = Function.const _ C) ∨ f = Function.const _ 0 }

theorem imo2010_p1 (f : ℝ → ℝ) :
    f ∈ solution_set ↔ ∀ x y, f (⌊x⌋ * y) = f x * ⌊f y⌋ :=
---- `→`
⟨λ h x y ↦ h.elim
  (λ h ↦ Exists.elim h λ C h ↦ h.2.symm ▸ h.1.symm ▸
    (Int.cast_one : ((1 : ℤ) : ℝ) = 1).symm ▸ (mul_one C).symm)
  (λ h ↦  h.symm ▸ (zero_mul _).symm),
---- `←`
 λ h ↦ (mul_right_eq_self₀.mp ((congr_arg f (mul_zero _).symm).trans (h 0 0)).symm).imp
  ---- Case 1: `⌊f(0)⌋ = 1`
  (λ h0 ↦ ⟨f 0, Int.cast_eq_one.mp h0, funext λ x ↦
    (mul_one _).symm.trans <| h0 ▸ (h x 0).symm.trans <| congr_arg f (mul_zero _)⟩)
  ---- Case 2: `f(0) = 0`
  -- First reduce to `f(1) = 0`
  (λ h0 ↦ suffices f 1 = 0
      from funext λ y ↦ let h1 := (h 1 y).trans (mul_eq_zero_of_left this _)
                        suffices (⌊(1 : ℝ)⌋ : ℝ) = 1 from one_mul y ▸ this ▸ h1
    Int.cast_eq_one.mpr Int.floor_one
    -- Now reduce to `⌊f(1/2)⌋ = 0`
    suffices ⌊f 2⁻¹⌋ = 0
      from let h1 := (h 2 2⁻¹).trans (mul_eq_zero_of_right _ <| Int.cast_eq_zero.mpr this)
           suffices (⌊(2 : ℝ)⌋ : ℝ) * 2⁻¹ = 1 from this ▸ h1
      (mul_inv_eq_one₀ two_ne_zero).mpr
        (Int.cast_two (R := ℝ) ▸ Int.floor_intCast (R := ℝ) _ ▸ rfl)
    -- Now prove that `⌊f(1/2)⌋ = 0`
    (mul_eq_zero.mp <| (h 2⁻¹ 2⁻¹).symm.trans <| (congr_arg f <| mul_eq_zero_of_left
        (by norm_num) _).trans h0).elim
      (λ h1 ↦ h1.symm ▸ Int.floor_zero) Int.cast_eq_zero.mp)⟩


end Imo2010P1

-- ═══ Imo2011P3 ═══

/-
Copyright (c) 2021 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 2011, Problem 3

Let f : ℝ → ℝ be a function that satisfies

   f(x + y) ≤ y * f(x) + f(f(x))

for all x and y. Prove that f(x) = 0 for all x ≤ 0.
-/

namespace Imo2011P3

theorem imo2011_p3 (f : ℝ → ℝ) (hf : ∀ x y, f (x + y) ≤ y * f x + f (f x)) :
    ∀ x ≤ 0, f x = 0 := by
  -- Direct translation of the solution found in
  -- https://www.imo-official.org/problems/IMO2011SL.pdf

  -- reparameterize
  replace hf : ∀ x t, f t ≤ t * f x - x * f x + f (f x) := by
    intro x t
    calc f t = f (x + (t - x))             := by rw [add_eq_of_eq_sub' rfl]
           _ ≤ (t - x) * f x + f (f x)     := hf x (t - x)
           _ = t * f x - x * f x + f (f x) := by rw [sub_mul]

  have f_of_neg : ∀ x < 0, 0 ≤ f x := by
    have hab : ∀ a b, a * f a + b * f b ≤ 2 * f a * f b := fun a b ↦ by
      linarith [hf b (f a), hf a (f b)]

    intro x hx
    have h : x * f x ≤ 0 := add_le_iff_nonpos_left.mp (hab x (2 * f x))
    exact nonneg_of_mul_nonpos_right h hx

  have f_nonpos : ∀ x, f x ≤ 0 := by
    intro x
    by_contra! hp
    -- If we choose a small enough argument for f, then we get a contradiction.
    let s := (x * f x - f (f x)) / (f x)
    have hm : min 0 s - 1 < s := (sub_one_lt _).trans_le (min_le_right 0 s)
    have hml : min 0 s - 1 < 0 := (sub_one_lt _).trans_le (min_le_left 0 s)
    suffices f (min 0 s - 1) < 0 from
      not_le.mpr this (f_of_neg (min 0 s - 1) hml)

    calc f (min 0 s - 1)
         ≤ (min 0 s - 1) * f x - x * f x + f (f x) := hf x (min 0 s - 1)
       _ < s * f x - x * f x + f (f x) :=
               by linarith [(mul_lt_mul_iff_right₀ hp).mpr hm]
       _ = 0 := by rw [(eq_div_iff hp.ne.symm).mp rfl]; linarith

  replace f_of_neg : ∀ x < 0, f x = 0 := by
    intro x hx
    exact (f_nonpos x).antisymm (f_of_neg x hx)

  intro x hx
  obtain (h_x_neg : x < 0) | (rfl : x = 0) := hx.lt_or_eq
  · exact f_of_neg _ h_x_neg
  · suffices 0 ≤ f 0 from (f_nonpos 0).antisymm this
    have hno : f (-1) = 0 := f_of_neg (-1) neg_one_lt_zero
    have hp := hf (-1) (-1)
    rw [hno, mul_zero, sub_zero, zero_add] at hp
    exact hp


end Imo2011P3

-- ═══ Imo2011P5 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Francesco Cappetti
-/





/-!
# International Mathematical Olympiad 2011, Problem 5

Let f be a function from the set of integers to the set
of positive integers. Suppose that, for any two integers
m and n, the difference f(m) - f(n) is divisible by
f (m - n). Prove that, for all integers m and n with
f(m) ≤ f(n), the number f(n) is divisible by f(m).
-/

namespace Imo2011P5

theorem imo2011_p5 (f : ℤ → ℤ)
    (f_pos : ∀ n, 0 < f n)
    (h : ∀ m n, f (m - n) ∣ f m - f n)
    : ∀ m n, f m ≤ f n → f m ∣ f n := by
  -- Direct translation of the solution found at
  -- https://artofproblemsolving.com/community/c6h418981p2365084

  have f_n_dvd_f_zero : ∀ n, f n ∣ f 0 := by
    intro n
    have : f n ∣ f n - f 0 := by
      calc f n
        _ = f (n - 0) := by rw [sub_zero]
        _ ∣ f n - f 0 := h n 0
    exact (Int.dvd_iff_dvd_of_dvd_sub this).mp (dvd_refl (f n))

  have f_neg_n_eq_f_n : ∀ n, f (-n) = f n := by
    intro n

    have f_neg_n_dvd_f_n : f (-n) ∣ f n := by
      have :=
        calc f (-n)
          _ = f (0 - n) := by rw [zero_sub]
          _ ∣ f 0 - f n := h 0 n
      exact (Int.dvd_iff_dvd_of_dvd_sub this).mp (f_n_dvd_f_zero (-n))

    have f_n_dvd_f_neg_n : f n ∣ f (-n) := by
      have :=
        calc f n
          _ = f (0 - -n) := by rw [sub_neg_eq_add, zero_add]
          _ ∣ f 0 - f (-n) := h 0 (-n)
      exact (Int.dvd_iff_dvd_of_dvd_sub this).mp (f_n_dvd_f_zero n)

    have f_neg_n_nonneg : 0 ≤ f (-n) := le_of_lt (f_pos (-n))
    have f_n_nonneg : 0 ≤ f n := le_of_lt (f_pos n)

    exact Int.dvd_antisymm f_neg_n_nonneg f_n_nonneg f_neg_n_dvd_f_n f_n_dvd_f_neg_n

  intro m n f_m_le_f_n

  by_cases h0 : f m < f n ∧ ¬f m ∣ f n

  · have h1 : f (m + n) ≤ f n - f m := by
      have := by
        calc f (m + n)
          _ = f (m - -n) := by rw [Int.sub_neg]
          _ ∣ f m - f (-n) := h m (-n)
          _ = f m - f n := by rw [f_neg_n_eq_f_n]
          _ = -(f n - f m) := by rw [neg_sub]
          _ ∣ f n - f m := by rw [neg_dvd]
      have f_n_sub_f_m_pos : 0 < f n - f m := by linarith
      exact Int.le_of_dvd f_n_sub_f_m_pos this

    have h2 : ¬f m ∣ f (n + m) := by
      have :=
        calc f m
          _ = f (n + m - n) := by rw [add_tsub_cancel_left]
          _ ∣ f (n + m) - f n := h (n + m) n
      grind [Int.dvd_iff_dvd_of_dvd_sub]

    have h3 : |f (n + m) - f m| ≠ 0 := by
      intro abs_f_n_add_m_sub_f_m_eq_zero
      rw [abs_eq_zero, sub_eq_zero] at abs_f_n_add_m_sub_f_m_eq_zero
      simp [abs_f_n_add_m_sub_f_m_eq_zero] at h2

    have h4 : f n ≤ f (n + m) - f m ∨ f n ≤ f m - f (n + m) := by
      have :=
        calc f n
          _ = f (n + m - m) := by rw [Int.add_sub_cancel]
          _ ∣ f (n + m) - f m := h (n + m) m
          _ ∣ |f (n + m) - f m| := by rw [dvd_abs]
      have : f n ≤ |f (n + m) - f m| := Int.le_of_dvd (by grind) (by grind)
      rw [le_abs] at this
      cases this with
      | inl _ => grind
      | inr _ => grind

    cases h4 with
    | inl _ => grind
    | inr _ => grind

  · push_neg at h0
    by_cases f_m_eq_f_n : f m = f n
    · rw [f_m_eq_f_n]
    · grind


end Imo2011P5

-- ═══ Imo2012P2 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 2012, Problem 2

Let a₂, a₃, ..., aₙ be positive reals with product 1, where n ≥ 3.
Show that
  (1 + a₂)²(1 + a₃)³...(1 + aₙ)ⁿ > nⁿ.
-/

namespace Imo2012P2



universe u v

lemma Finset.prod_eq_prod_iff_of_pos_of_le {ι : Type u} {R : Type v}
    [CommMonoidWithZero R] [PartialOrder R] [ZeroLEOneClass R]
    [PosMulStrictMono R] [MulPosStrictMono R] [Nontrivial R]
    [DecidableEq ι] {f g : ι → R} {s : Finset ι}
    (h₀ : ∀ i ∈ s, 0 < f i) (h₁ : ∀ i ∈ s, f i ≤ g i) :
    ∏ i ∈ s, f i = ∏ i ∈ s, g i ↔ ∀ i ∈ s, f i = g i := by
  constructor
  · intro h i hi
    rw [← Finset.insert_erase hi] at h
    repeat rw [Finset.prod_insert (Finset.notMem_erase i s)] at h
    have h' : ∏ x ∈ s.erase i, f x ≤ ∏ x ∈ s.erase i, g x := by
      apply Finset.prod_le_prod
      · intro i' hi'
        exact le_of_lt (h₀ i' (Finset.mem_of_mem_erase hi'))
      · intro i' hi'
        exact h₁ i' (Finset.mem_of_mem_erase hi')
    have h'' : 0 < ∏ x ∈ s.erase i, g x := by
      apply lt_of_le_of_lt' h'
      apply Finset.prod_pos
      intro i' hi'
      exact h₀ i' (Finset.mem_of_mem_erase hi')
    rw [mul_eq_mul_iff_eq_and_eq_of_pos (h₁ i hi) h' (h₀ i hi) h''] at h
    exact h.left
  · intro h
    exact Finset.prod_congr (by rfl) h

lemma Real.geom_mean_eq_arith_mean2_weighted_iff
    {w₁ w₂ p₁ p₂ : ℝ} (hw₁ : 0 < w₁) (hw₂ : 0 < w₂)
    (hp₁ : 0 < p₁) (hp₂ : 0 < p₂) (hw : w₁ + w₂ = 1) :
    p₁ ^ w₁ * p₂ ^ w₂ = w₁ * p₁ + w₂ * p₂ ↔ p₁ = p₂ := by
  have h' := Real.geom_mean_eq_arith_mean_weighted_iff' Finset.univ ![w₁, w₂] ![p₁, p₂]
  simp at h'
  have h'' := h' hw₁ hw₂ hw (le_of_lt hp₁) (le_of_lt hp₂)
  rw [h'']
  constructor
  · intro h
    nth_rw 1 [h.left]
    nth_rw 2 [h.right]
  · intro h
    rw [h, ← add_mul, hw, one_mul]
    constructor <;> rfl

lemma aux₁ {n : ℕ} (hn : 2 ≤ n) : (n : ℝ) ^ n = ∏ i ∈ Finset.Icc 2 n, (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) := by
  induction' n, hn using Nat.le_induction with n' hn' h'
  · norm_num
  · nth_rw 3 [← Nat.succ_eq_add_one]
    rw [← Nat.succ_eq_succ, ← Finset.insert_Icc_right_eq_Icc_succ (by lia : 2 ≤ n'.succ)]
    rw [Finset.prod_insert (by simp), Nat.succ_eq_succ, Nat.succ_eq_add_one, ← h']
    push_cast
    field_simp
    ring

lemma aux₂ {i : ℕ} {x : ℝ} (hi : 2 ≤ i) (hx : 0 < x) :
    (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * x =
    (i : ℝ) ^ i * (x ^ (1 / (i : ℝ)) * (1 / ((i : ℝ) - 1)) ^ (((i : ℝ) - 1) / (i : ℝ))) ^ i := by
  have hpos₁ : 0 < (i : ℝ) := by
    rw [Nat.cast_pos]
    lia
  have hpos₂ : 0 < (i : ℝ) - 1 := by
    rw [← Nat.cast_one, ← Nat.cast_sub (by lia), Nat.cast_pos]
    lia
  repeat rw [← Real.rpow_natCast]
  rw [Real.mul_rpow (by positivity) (by positivity), ← Real.rpow_mul (by positivity)]
  rw [← Real.rpow_mul (by positivity), Real.div_rpow (by positivity) (by positivity)]
  rw [Real.one_rpow]
  repeat rw [div_mul_cancel₀ _ (by positivity)]
  field_simp
  rw [Real.rpow_one, mul_comm, Nat.cast_sub (by lia), Nat.cast_one]

lemma aux₃ {i : ℕ} {x : ℝ} (hi : 2 ≤ i) (hx : 0 < x) : (1 + x) ^ i =
    (i : ℝ) ^ i * ((1 / (i : ℝ)) * x + (((i : ℝ) - 1) / (i : ℝ)) * (1 / ((i : ℝ) - 1))) ^ i := by
  have hpos₁ : 0 < (i : ℝ) := by
    rw [Nat.cast_pos]
    lia
  have hpos₂ : 0 < (i : ℝ) - 1 := by
    rw [← Nat.cast_one, ← Nat.cast_sub (by lia), Nat.cast_pos]
    lia
  repeat rw [← Real.rpow_natCast]
  rw [← Real.mul_rpow (by positivity) (by positivity)]
  field_simp
  ring_nf

lemma aux₄ {i : ℕ} {x : ℝ} (hi : 2 ≤ i) (hx : 0 < x) :
    (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * x ≤ (1 + x) ^ i := by
  have hpos₁ : 0 < (i : ℝ) := by
      rw [Nat.cast_pos]
      lia
  have hpos₂ : 0 < (i : ℝ) - 1 := by
    rw [← Nat.cast_one, ← Nat.cast_sub (by lia), Nat.cast_pos]
    lia
  rw [aux₂ hi hx, aux₃ hi hx, mul_le_mul_iff_right₀ (by positivity)]
  rw [pow_le_pow_iff_left₀ (by positivity) (by positivity) (by lia)]
  apply Real.geom_mean_le_arith_mean2_weighted (by positivity) (by positivity) (by positivity) (by positivity)
  field

lemma aux₅ {i : ℕ} {x : ℝ} (hi : 2 ≤ i) (hx : 0 < x) :
    (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * x = (1 + x) ^ i ↔ x = 1 / ((i : ℝ) - 1) := by
  have hpos₁ : 0 < (i : ℝ) := by
      rw [Nat.cast_pos]
      lia
  have hpos₂ : 0 < (i : ℝ) - 1 := by
    rw [← Nat.cast_one, ← Nat.cast_sub (by lia), Nat.cast_pos]
    lia
  rw [aux₂ hi hx, aux₃ hi hx, mul_left_cancel_iff_of_pos (by positivity)]
  repeat rw [← Real.rpow_natCast]
  rw [Real.rpow_left_inj (by positivity) (by positivity) (by positivity)]
  apply Real.geom_mean_eq_arith_mean2_weighted_iff (by positivity) (by positivity) (by positivity) (by positivity)
  field

lemma aux₆ {n : ℕ} (hn : 2 ≤ n) : ∏ x ∈ Finset.Icc 2 n, ((x : ℝ) - 1) = Nat.factorial (n - 1) := by
  induction' n, hn using Nat.le_induction with n' hn' h'
  · norm_num
  · nth_rw 1 [← Nat.succ_eq_add_one]
    rw [← Nat.succ_eq_succ, ← Finset.insert_Icc_right_eq_Icc_succ (by lia : 2 ≤ n'.succ)]
    rw [Finset.prod_insert (by simp), Nat.succ_eq_succ, Nat.succ_eq_add_one, h']
    push_cast
    field_simp
    ring_nf
    norm_cast
    rw [Nat.mul_factorial_pred (by lia: _)]



theorem imo2012_p2 (n : ℕ) (hn : 3 ≤ n) (a : Finset.Icc 2 n → ℝ)
    (apos : ∀ i, 0 < a i) (aprod : ∏ i, a i = 1) :
    (n:ℝ)^n < ∏ i, (1 + a i)^i.val := by
  set a' : ℕ → ℝ := fun i ↦ if hi : i ∈ Finset.Icc 2 n then a ⟨i, hi⟩ else 1
  have haa' : ∀ i : Finset.Icc 2 n, i ∈ Finset.univ → a i = a' i.val := by
    intro i hi
    simp only [a']
    rw [dif_pos]
  rw [Finset.prod_congr (by rfl) haa'] at aprod
  rw [← Finset.prod_subtype (Finset.Icc 2 n) (by simp)] at aprod
  have ha'i : ∀ i : Finset.Icc 2 n, i ∈ Finset.univ →
    (1 + a i) ^ i.val = (1 + a' i.val) ^ i.val := by
    intro i hi
    rw [haa' i hi]
  rw [Finset.prod_congr (by rfl) ha'i]
  rw [← Finset.prod_subtype (Finset.Icc 2 n) (by simp) (fun i : ℕ ↦ (1 + a' i) ^ i)]
  have hnn : ∀ (n : ℕ) (a' : ℕ → ℝ), 2 ≤ n → ∏ i ∈ Finset.Icc 2 n, a' i = 1 →
    (n : ℝ) ^ n = ∏ i ∈ Finset.Icc 2 n, (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * a' i := by
    intro n a' hn ha'prod
    rw [Finset.prod_mul_distrib, ha'prod, mul_one]
    exact aux₁ hn
  rw [hnn n a' (by lia) aprod]
  have ha'pos : ∀ i : ℕ, 0 < a' i := by
    intro i
    simp only [a']
    by_cases! hi : i ∈ Finset.Icc 2 n
    · rw [dif_pos hi]
      apply apos
    · rw [dif_neg hi]
      norm_num
  have hnn' : ∀ i ∈ Finset.Icc 2 n, 0 < (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * a' i := by
    intro i hi
    rw [Finset.mem_Icc] at hi
    rw [mul_pos_iff_of_pos_right (ha'pos i)]
    rw [div_pos_iff_of_pos_left (pow_pos (Nat.cast_pos.mpr (by lia)) _)]
    apply pow_pos
    rw [← Nat.cast_one, ← Nat.cast_sub (by lia), Nat.cast_pos]
    lia
  have hnn'' : ∀ i ∈ Finset.Icc 2 n, 0 ≤ (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * a' i := by
    intro i hi
    apply le_of_lt
    exact hnn' i hi
  have hann : ∀ i ∈ Finset.Icc 2 n, (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * a' i ≤ (1 + a' i) ^ i := by
    intro i hi
    exact aux₄ (Finset.mem_Icc.mp hi).left (ha'pos i)
  apply lt_of_le_of_ne (Finset.prod_le_prod hnn'' hann)
  contrapose! aprod with h'
  rw [Finset.prod_eq_prod_iff_of_pos_of_le hnn' hann] at h'
  have hann' : ∀ i ∈ Finset.Icc 2 n,
    (i : ℝ) ^ i / ((i : ℝ) - 1) ^ (i - 1) * a' i = (1 + a' i) ^ i ↔ a' i = 1 / ((i : ℝ) - 1) := by
    intro i hi
    exact aux₅ (Finset.mem_Icc.mp hi).left (ha'pos i)
  have ha' : ∀ i ∈ Finset.Icc 2 n, a' i = 1 / ((i : ℝ) - 1) := by
    intro i hi
    rw [← hann' i hi]
    exact h' i hi
  rw [Finset.prod_congr (by rfl) ha', Finset.prod_div_distrib, Finset.prod_eq_one (by simp)]
  apply ne_of_lt
  rw [aux₆ (by lia : 2 ≤ n), div_lt_comm₀ (Nat.cast_pos.mpr (Nat.factorial_pos _)) (by norm_num)]
  rw [div_one, ← Nat.cast_one, Nat.cast_lt]
  apply lt_of_le_of_ne (Nat.one_le_iff_ne_zero.mpr (Nat.ne_zero_iff_zero_lt.mpr (Nat.factorial_pos _)))
  symm
  intro h''
  rw [Nat.factorial_eq_one] at h''
  lia


end Imo2012P2

-- ═══ Imo2012P4 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: spinylobster, ondanaoto, Seasawher
-/





/-!
# International Mathematical Olympiad 2012, Problem 4

Determine all functions f : ℤ → ℤ such that for all integers a,b,c with a + b + c = 0,
the following equality holds:
  f(a)² + f(b)² + f(c)² = 2f(a)f(b) + 2f(b)f(c) + 2f(c)f(a).
-/

namespace Imo2012P4



def odd_const : Set (ℤ → ℤ) := fun f =>
  ∃ c : ℤ, ∀ x : ℤ,
    (Odd x → f x = c) ∧ (Even x → f x = 0)

def mod4_cycle : Set (ℤ → ℤ) := fun f =>
  ∃ c : ℤ, ∀ x : ℤ, f x =
  match x % 4 with
    | 0 => 0
    | 2 => 4 * c
    | _ => c

def square_set : Set (ℤ → ℤ) := fun f =>
  ∃ c : ℤ, ∀ x : ℤ, f x = x ^ 2 * c

theorem sub_sq'' {x y : Int} : x ^ 2 + y ^ 2 = (2 * x * y) ↔ x = y := by
  rw [← sub_eq_zero, ← sub_sq', sq_eq_zero_iff, sub_eq_zero]

theorem Int.lt_of_ns_lt_ns {x x' : ℕ} (h : Int.negSucc x < Int.negSucc x') : x' < x := by
  grind

def myInduction.{u}
  {motive : ℤ -> Sort u}
  (P0 : motive 0) (P1 : motive 1) (P2 : motive 2) (P3 : motive 3)
  (add4 : ∀ x, motive (x + 4) = motive x)
  : ∀ x, motive x := by
    rintro (x | x)
    case ofNat =>
      match x with
      | 0 => exact P0
      | 1 => exact P1
      | 2 => exact P2
      | 3 => exact P3
      | x' + 4 =>
        rw [show Int.ofNat (x' + 4) = (Int.ofNat x') + 4 by rfl, add4]
        have : sizeOf (x' : Int) < sizeOf ((x' + 4 : Nat) : Int) := by
          rw [← Int.ofNat_eq_natCast, ← Int.ofNat_eq_natCast]
          simp [sizeOf, Int._sizeOf_1]
        apply myInduction <;> assumption
    case negSucc =>
      rw [← add4]
      cases h : Int.negSucc x + 4
      case ofNat x' =>
        match x' with
        | 0 => exact P0
        | 1 => exact P1
        | 2 => exact P2
        | 3 => exact P3
        | x' + 4 => simp at h
      case negSucc x' =>
        have : x' < x := by
          have := Int.sub_lt_self (Int.negSucc x + 4) (b := 4) (h := by simp)
          conv at this => rhs; rw [h]
          simp at this
          apply Int.lt_of_ns_lt_ns this
        apply myInduction <;> assumption



noncomputable def solution_set : Set (ℤ → ℤ) := odd_const ∪ mod4_cycle ∪ square_set

theorem imo2012_p4 (f : ℤ → ℤ) :
    f ∈ solution_set ↔
    ∀ a b c : ℤ, a + b + c = 0 →
      (f a)^2 + (f b)^2 + (f c)^2 =
        2 * f a * f b + 2 * f b * f c + 2 * f c * f a := by

  constructor

  case mpr =>
    intro constraint

    have «f0=0» : f 0 = 0 := by
      have := constraint 0 0 0
      simp at this
      nlinarith

    -- `f` is an even function
    have even (t : ℤ) : f (- t) = f t := by
      have := constraint t (-t) 0
      simp [«f0=0»] at this
      rw [sub_sq''] at this
      symm; exact this

    have P (a b : ℤ) : (f a) ^ 2 + (f b) ^ 2 + f (a + b) ^ 2 =
                       2 * f a * f b + 2 * f (a + b) * (f a + f b) := by
      have := constraint a b (- (a + b)) (by lia)
      rw [even (a + b)] at this
      rw [this]
      ring

    have «P(a,a)» (a : ℤ) : f (2 * a) = 0 ∨ f (2 * a) = 4 * f a := by
      conv => rhs; rw [← sub_eq_zero]
      rw [← Int.mul_eq_zero]
      have := P a a; simp at this
      rw [← sub_eq_zero] at this; rw [← this]
      ring_nf

    have ext_eq_zero {{a : ℤ}} (h : f a = 0) : ∀ x, f (a * x) = 0 := by
      intro x
      induction' x using Int.induction_on with x ih i
      · simp [«f0=0»]
      · specialize P (a * x) a; simp_all
        simpa only [mul_add, mul_one] using P
      · have := P (a * ( -↑i - 1 )) a
        ring_nf at *
        aesop

    cases «P(a,a)» 1

    case inl «f2=0» =>
      simp at «f2=0»

      have even_zero : ∀ x, f (2 * x) = 0 := ext_eq_zero «f2=0»

      have sub_even {x : ℤ} (a : ℤ) : f x = f (x - 2 * a) := by
        have := P (x - (2 * a)) (2 * a)
        simp [even_zero] at this
        rwa [add_comm, sub_sq''] at this

      have h_odd_const (x : ℤ) : Odd x → f x = f 1 := by
        intro odd
        have ⟨k, hk⟩ := odd
        rw [sub_even k, hk]
        simp

      have f_in_odd_const : f ∈ odd_const := by
        use f 1
        intro x
        constructor

        case left =>
          apply h_odd_const

        case right =>
          rintro ⟨k, hk⟩
          convert even_zero k using 2
          lia
      left
      left
      assumption

    case inr «f2=4*f1» =>
      simp at «f2=4*f1»

      have when_f4_is_0 («f4=0» : f 4 = 0) : mod4_cycle f := by
        exists f 1
        have «f(x+4)=fx» (x : ℤ) : f (x + 4) = f x := by
          have «P(4,x)» := P 4 x
          simp [«f4=0»] at «P(4,x)»
          rw [show 2 * f (4 + x) * f x = 2 * f x * f (4 + x) by ac_rfl, sub_sq''] at «P(4,x)»
          rw [«P(4,x)»]; ac_rfl

        intro x; induction x using myInduction
        case P0 => simp [«f0=0»]
        case P1 => simp
        case P2 => simp [«f2=4*f1»]
        case P3 => rw [show 3 = -1 + 4 by rfl, «f(x+4)=fx», even]; simp
        case add4 x => simp; rw [«f(x+4)=fx»]

      have «P(1,2)» : f 3 = 9 * f 1 ∨ f 3 = f 1 := by
        have := P 1 2
        rw [«f2=4*f1», ← sub_eq_zero] at this
        rw [← sub_eq_zero, ← sub_eq_zero (a := f 3), ← Int.mul_eq_zero, ← this]
        ring_nf

      have «P(2,2)» : f 4 = 0 ∨ f 4 = 16 * f 1 := by convert «P(a,a)» 2 using 2; lia

      cases «P(1,2)»

      case inr «f3=f1» =>

        have «f4=0» : f 4 = 0 := by
          cases «P(2,2)»; case inl «f4=0» => assumption
          case inr «f4=4*f2» =>
            have «P(1,3)» := P 1 3
            simp [«f3=f1», «f4=4*f2»] at «P(1,3)» ⊢
            rw [← sub_eq_zero] at «P(1,3)»; ring_nf at «P(1,3)»
            simp [mul_eq_zero] at «P(1,3)»
            assumption

        have := when_f4_is_0 «f4=0»
        left
        right
        assumption

      case inl «f3=9*f1» =>

        cases «P(2,2)»

        case inl «f4=0» =>
          have := when_f4_is_0 «f4=0»
          left
          right
          assumption

        case inr «f4=16*f1» =>
          have «fx=x²f1» (x : ℤ) : f x = x ^ 2 * f 1 := by
            wlog pos : x ≥ 0 with H

            case inr =>
              rcases x with x | x; case ofNat => simp at pos
              rw [Int.negSucc_eq, even, neg_pow_two]
              apply H <;> try assumption
              · lia

            rcases x with x | x; case negSucc => simp at pos
            induction x using Nat.strongRecOn with
            | ind x ih =>
              rcases x with _ | x; case zero => simp [«f0=0»]

              have «fx=x²f1» : f x = x ^ 2 * f 1 := by apply ih <;> simp
              have := P x 1
              rw [«fx=x²f1», ← sub_eq_zero] at this
              replace this : (f (x + 1) - (x - 1) ^ 2 * f 1) *
                             (f (x + 1) - (x + 1) ^ 2 * f 1) = 0 := by
                rw [← this]; ring
              rw [mul_eq_zero, sub_eq_zero, sub_eq_zero] at this

              rcases this with «f(x+1)=(x-1)²*f1» | goal; case inr => exact goal

              have := P (x + 1) (-2)
              rw [show (x : ℤ) + 1 + (-2) = x - 1 by lia, even] at this
              have «f(x-1)=(x-1)²*f1» : f ((x : ℤ) - 1) = ((x : ℤ) - 1) ^ 2 * f 1 := by
                by_cases h : (x : ℤ) - 1 ≥ 0
                · rcases x with _ | x
                  case pos.zero => simp [even]
                  simp only [Nat.cast_add, Nat.cast_one, add_sub_cancel_right]
                  apply ih
                  · lia
                  · simp

                simp at h; simp [h, even]

              rw [«f2=4*f1», «f(x-1)=(x-1)²*f1», ← sub_eq_zero] at this
              replace this : (f (x + 1) - (x + 1) ^ 2 * f 1) *
                             (f (x + 1) - ((x : ℤ) - 3) ^ 2 * f 1) = 0 := by
                rw [← this]; ring_nf
              rw [mul_eq_zero, sub_eq_zero, sub_eq_zero] at this

              rcases this with goal | «f(x+1)=(x-3)²*f1»; case inl => exact goal
              have := «f(x+1)=(x-3)²*f1»
              rw [«f(x+1)=(x-1)²*f1», mul_eq_mul_right_iff, pow_eq_pow_iff_cases] at this
              lia

          right
          use f 1

  -- for all `f` in solution set, `f` satisfies the constraint
  case mp =>
    rintro ((sol | sol) | sol)
    all_goals
      intro a b c H
      have c_eq : c = - (a + b) := by lia
      rcases sol with ⟨d, h⟩

    · have ⟨hal, har⟩ := h a
      have ⟨hbl, hbr⟩ := h b
      have ⟨hcl, hcr⟩ := h c
      rcases Int.even_or_odd a with evena | odda <;>
      rcases Int.even_or_odd b with evenb | oddb
      · have hc : Even c := by
          rw [← even_neg, c_eq, neg_neg]
          exact Even.add evena evenb
        simp_all
      · have hc : Odd c := by
          rw [← odd_neg, c_eq, neg_neg]
          exact Even.add_odd evena oddb
        simp_all
        ring
      · have hc : Odd c := by
          rw [← odd_neg, c_eq, neg_neg]
          exact Even.odd_add evenb odda
        simp_all
        ring
      · have hc : Even c := by
          rw [← even_neg, c_eq, neg_neg]
          exact Odd.add_odd odda oddb
        simp_all
        ring

    · grind
    · rw [c_eq, h, h, h]
      ring_nf

end Imo2012P4

-- ═══ Imo2013P1 ═══

/-
Copyright (c) 2021 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/




/-!
# International Mathematical Olympiad 2013, Problem 1

Prove that for any pair of positive integers k and n, there exist k positive integers
m₁, m₂, ..., mₖ (not necessarily different) such that

  1 + (2ᵏ - 1)/ n = (1 + 1/m₁) * (1 + 1/m₂) * ... * (1 + 1/mₖ).

-/

namespace Imo2013P1



/-
# Solution

Adaptation of the solution found in https://www.imo-official.org/problems/IMO2013SL.pdf

We prove a slightly more general version where k does not need to be strictly positive.
-/

theorem prod_lemma (m : ℕ → ℕ+) (k : ℕ) (nm : ℕ+) :
    ∏ i ∈ Finset.range k, ((1 : ℚ) + 1 / ↑(if i < k then m i else nm)) =
      ∏ i ∈ Finset.range k, (1 + 1 / (m i : ℚ)) := by
  suffices ∀ i, i ∈ Finset.range k → (1 : ℚ) + 1 / ↑(if i < k then m i else nm) = 1 + 1 / m i from
    Finset.prod_congr rfl this
  intro i hi
  simp [Finset.mem_range.mp hi]



theorem imo2013_p1 (n : ℕ+) (k : ℕ) :
    ∃ m : ℕ → ℕ+,
      (1 : ℚ) + (2 ^ k - 1) / n = ∏ i ∈ Finset.range k, (1 + 1 / (m i : ℚ)) := by
  revert n
  induction' k with pk hpk
  · intro n; use fun (_ : ℕ) => (1 : ℕ+); simp
  -- For the base case, any m works.
  intro n
  obtain ⟨t, ht : ↑n = t + t⟩ | ⟨t, ht : ↑n = 2 * t + 1⟩ := (n : ℕ).even_or_odd
  · -- even case
    rw [← two_mul] at ht
    cases t with
    | zero =>
      -- Eliminate the zero case to simplify later calculations.
      exfalso; rw [Nat.mul_zero] at ht ; exact PNat.ne_zero n ht
    | succ t =>
    -- Now we have ht : ↑n = 2 * (t + 1).
    let t_succ : ℕ+ := ⟨t + 1, t.succ_pos⟩
    obtain ⟨pm, hpm⟩ := hpk t_succ
    let m i := if i < pk then pm i else ⟨2 * t + 2 ^ pk.succ, by positivity⟩
    use m
    have hmpk : (m pk : ℚ) = 2 * t + 2 ^ pk.succ := by
      have : m pk = ⟨2 * t + 2 ^ pk.succ, _⟩ := if_neg (irrefl pk); simp [this]
    have denom_ne_zero : (2 * (t : ℚ) + 2 * 2 ^ pk) ≠ 0 := by positivity
    calc
      ((1 : ℚ) + (2 ^ pk.succ - 1) / (n : ℚ) : ℚ)= 1 + (2 * 2 ^ pk - 1) / (2 * (t + 1) : ℕ) := by
        rw [ht, pow_succ']
      _ = (1 + 1 / (2 * t + 2 * 2 ^ pk)) * (1 + (2 ^ pk - 1) / (↑t + 1)) := by
        simp [field]
        left
        ring
      _ = (1 + 1 / (2 * t + 2 ^ pk.succ)) * (1 + (2 ^ pk - 1) / t_succ) := by
        -- porting note: used to work with `norm_cast`
        simp only [t_succ, PNat.mk_coe, Nat.cast_add, Nat.cast_one, pow_succ']
      _ = (∏ i ∈ Finset.range pk, (1 + 1 / (m i : ℚ))) * (1 + 1 / m pk) := by
        rw [prod_lemma, hpm, ← hmpk, mul_comm]
      _ = ∏ i ∈ Finset.range pk.succ, (1 + 1 / (m i : ℚ)) := by rw [← Finset.prod_range_succ _ pk]
  · -- odd case
    let t_succ : ℕ+ := ⟨t + 1, t.succ_pos⟩
    obtain ⟨pm, hpm⟩ := hpk t_succ
    let m i := if i < pk then pm i else ⟨2 * t + 1, Nat.succ_pos _⟩
    use m
    have hmpk : (m pk : ℚ) = 2 * t + 1 := by
      have : m pk = ⟨2 * t + 1, _⟩ := if_neg (irrefl pk)
      simp [this]
    have denom_ne_zero : 2 * (t : ℚ) + 1 ≠ 0 := by positivity
    calc
      ((1 : ℚ) + (2 ^ pk.succ - 1) / ↑n : ℚ) = 1 + (2 * 2 ^ pk - 1) / (2 * t + 1 : ℕ) := by
        rw [ht, pow_succ']
      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / (t + 1)) := by
        simp [field]
        ring
      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / t_succ) := by norm_cast
      _ = (∏ i ∈ Finset.range pk, (1 + 1 / (m i : ℚ))) * (1 + 1 / ↑(m pk)) := by
        rw [prod_lemma, hpm, ← hmpk, mul_comm]
      _ = ∏ i ∈ Finset.range pk.succ, (1 + 1 / (m i : ℚ)) := by rw [← Finset.prod_range_succ _ pk]


end Imo2013P1

-- ═══ Imo2013P5 ═══

/-
Copyright (c) 2021 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 2013, Problem 5

Let ℚ>₀ be the set of positive rational numbers. Let f: ℚ>₀ → ℝ be a function satisfying
the conditions

  (1) f(x) * f(y) ≥ f(x * y)
  (2) f(x + y)    ≥ f(x) + f(y)

for all x,y ∈ ℚ>₀. Given that f(a) = a for some rational a > 1, prove that f(x) = x for
all x ∈ ℚ>₀.

-/

namespace Imo2013P5



/-
# Solution

We provide a direct translation of the solution found in
https://www.imo-official.org/problems/IMO2013SL.pdf
-/

lemma le_of_all_pow_lt_succ {x y : ℝ} (hy : 1 < y)
    (h : ∀ n : ℕ, 0 < n → x^n - 1 < y^n) :
    x ≤ y := by
  by_contra! hxy
  obtain ⟨n, hn⟩ : ∃ n : ℕ, (x / y) ^ n > 2 := by
    refine pow_unbounded_of_one_lt _ ?_
    rwa [one_lt_div (by positivity)]
  have h_mul : x^n > 2 * y^n := by
    rwa [div_pow, gt_iff_lt, lt_div_iff₀ (by positivity)] at hn;
  specialize h n (Nat.pos_of_ne_zero (by rintro rfl; norm_num at hn))
  linarith only [h, h_mul, one_le_pow₀ (n := n) hy.le]

/--
 Like le_of_all_pow_lt_succ, but with a weaker assumption for y.
-/
lemma le_of_all_pow_lt_succ' {x y : ℝ} (hx : 1 < x) (hy : 0 < y)
    (h : ∀ n : ℕ, 0 < n → x^n - 1 < y^n) :
    x ≤ y := by
  refine le_of_all_pow_lt_succ ?_ h
  by_contra! hy''

  -- Then there exists y' such that 0 < y ≤ 1 < y' < x.
  obtain ⟨y', h1_lt_y', h_y'_lt_x⟩ := exists_between hx

  have h_y_lt_y' : y < y' := hy''.trans_lt h1_lt_y'
  have hh : ∀ n, 0 < n → x^n - 1 < y'^n := by
    intro n hn
    calc x^n - 1 < y^n  := h n hn
         _  ≤ y'^n := pow_le_pow_left₀ hy.le h_y_lt_y'.le n

  exact h_y'_lt_x.not_ge (le_of_all_pow_lt_succ h1_lt_y' hh)

lemma f_pos_of_pos {f : ℚ → ℝ} {q : ℚ} (hq : 0 < q)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n) :
    0 < f q := by
  have hfqn := calc f q.num = f (q * q.den) := by rw [←Rat.mul_den_eq_num]
                    _ ≤ f q * f q.den := H1 q q.den hq (Nat.cast_pos.mpr q.pos)

  -- Now we just need to show that `f q.num` and `f q.denom` are positive.
  -- Then nlinarith will be able to close the goal.
  have num_pos : 0 < q.num := Rat.num_pos.mpr hq
  have hqna : (q.num.natAbs : ℤ) = q.num := Int.natAbs_of_nonneg num_pos.le

  have hqfn' := calc (q.num : ℝ)
         = ((q.num.natAbs : ℤ) : ℝ) := congr_arg Int.cast (Eq.symm hqna)
       _ ≤ f q.num.natAbs           := H4 q.num.natAbs
                                            (Int.natAbs_pos.mpr (ne_of_gt num_pos))
       _ = f q.num                   := by rw [Nat.cast_natAbs, abs_of_nonneg num_pos.le]

  have f_num_pos := calc (0 : ℝ) < q.num := Int.cast_pos.mpr num_pos
                         _ ≤ f q.num     := hqfn'

  have f_den_pos := calc (0 : ℝ) < q.den := Nat.cast_pos.mpr q.pos
                         _ ≤ f q.den     := H4 q.den q.pos

  nlinarith

lemma fx_gt_xm1 {f : ℚ → ℝ} {x : ℚ} (hx : 1 ≤ x)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H2 : ∀ x y, 0 < x → 0 < y → f x + f y ≤ f (x + y))
    (H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n) :
    (x - 1 : ℝ) < f x := by
  have hx0 :=
    calc (x - 1 : ℝ)
          < ⌊x⌋₊   := by exact_mod_cast Nat.sub_one_lt_floor x
        _ ≤ f ⌊x⌋₊ := H4 _ (Nat.floor_pos.2 hx)

  obtain h_eq | h_lt := (Nat.floor_le <| zero_le_one.trans hx).eq_or_lt
  · rwa [h_eq] at hx0
  calc (x - 1 : ℝ) < f ⌊x⌋₊ := hx0
    _ < f (x - ⌊x⌋₊) + f ⌊x⌋₊ := lt_add_of_pos_left _ (f_pos_of_pos (sub_pos.mpr h_lt) H1 H4)
    _ ≤ f (x - ⌊x⌋₊ + ⌊x⌋₊)   := H2 _ _ (sub_pos.mpr h_lt) (Nat.cast_pos.2 (Nat.floor_pos.2 hx))
    _ = f x                   := by rw [sub_add_cancel]


lemma pow_f_le_f_pow {f : ℚ → ℝ} {n : ℕ} (hn : 0 < n) {x : ℚ} (hx : 1 < x)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n) :
    f (x^n) ≤ (f x)^n := by
  induction n with
  | zero => exfalso; exact Nat.lt_asymm hn hn
  | succ pn hpn =>
    cases pn with
    | zero => simp [pow_one]
    | succ pn =>
      have hpn' := hpn pn.succ_pos
      rw [pow_succ x (pn + 1), pow_succ (f x) (pn + 1)]
      have hxp : 0 < x := zero_lt_one.trans hx
      calc f ((x ^ (pn+1)) * x)
          ≤ f (x ^ (pn+1)) * f x := H1 (x ^ (pn+1)) x (pow_pos hxp (pn+1)) hxp
        _ ≤ (f x) ^ (pn+1) * f x := (mul_le_mul_iff_left₀ (f_pos_of_pos hxp H1 H4)).mpr hpn'

lemma fixed_point_of_pos_nat_pow {f : ℚ → ℝ} {n : ℕ} (hn : 0 < n)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n)
    (H5 : ∀ x : ℚ, 1 < x → (x : ℝ) ≤ f x)
    {a : ℚ} (ha1 : 1 < a) (hae : f a = a) :
    f (a^n) = a^n := by
  have hh0 : (a : ℝ) ^ n ≤ f (a ^ n) := by
    exact_mod_cast H5 (a ^ n) (one_lt_pow₀ ha1 hn.ne')

  have hh1 := calc f (a^n) ≤ (f a)^n := pow_f_le_f_pow hn ha1 H1 H4
                   _ = (a : ℝ)^n     := by rw [←hae]
  exact_mod_cast hh1.antisymm hh0

lemma fixed_point_of_gt_1 {f : ℚ → ℝ} {x : ℚ} (hx : 1 < x)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H2 : ∀ x y, 0 < x → 0 < y → f x + f y ≤ f (x + y))
    (H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n)
    (H5 : ∀ x : ℚ, 1 < x → (x : ℝ) ≤ f x)
    {a : ℚ} (ha1 : 1 < a) (hae : f a = a) :
    f x = x := by
  -- Choose n such that 1 + x < a^n.
  obtain ⟨N, hN⟩ := pow_unbounded_of_one_lt (1 + x) ha1
  have h_big_enough : (1:ℚ) < a^N - x := lt_sub_iff_add_lt.mpr hN
  have h1 := calc (x : ℝ) + ((a^N - x) : ℚ)
                ≤ f x + ((a^N - x) : ℚ) := add_le_add_left (H5 x hx) _
              _ ≤ f x + f (a^N - x)     := add_le_add_right (H5 _ h_big_enough) _
  have hxp : 0 < x := zero_lt_one.trans hx
  have hNp : 0 < N := by
    by_contra H; push_neg at H; rw [le_zero_iff.mp H] at hN; linarith

  have h2 := calc f x + f (a^N - x)
                ≤ f (x + (a^N - x)) := H2 x (a^N - x) hxp (zero_lt_one.trans h_big_enough)
              _ = f (a^N)           := by ring_nf
              _ = (a^N : ℝ)         := fixed_point_of_pos_nat_pow hNp H1 H4 H5 ha1 hae
              _ = (x:ℝ) + ((a^N:ℝ) - (x:ℝ))     := by ring

  have heq := h1.antisymm (by exact_mod_cast h2)
  linarith [H5 x hx, H5 _ h_big_enough]



theorem imo2013_p5
    (f : ℚ → ℝ)
    (H1 : ∀ x y, 0 < x → 0 < y → f (x * y) ≤ f x * f y)
    (H2 : ∀ x y, 0 < x → 0 < y → f x + f y ≤ f (x + y))
    (H_fixed_point : ∃ a, 1 < a ∧ f a = a) :
    ∀ x, 0 < x → f x = x := by
  obtain ⟨a, ha1, hae⟩ := H_fixed_point
  have H3 : ∀ x : ℚ, 0 < x → ∀ n : ℕ, 0 < n → ↑n * f x ≤ f (n * x) := by
    intro x hx n hn
    cases n with
    | zero => exfalso; exact Nat.lt_asymm hn hn
    | succ n =>
      induction n with
      | zero => simp [one_mul, Nat.cast_one]
      | succ pn hpn =>
        calc  ↑(pn + 2) * f x
            = (↑pn + 1 + 1) * f x            := by norm_cast
          _ = (↑pn + 1) * f x + f x          := by ring
          _ ≤ f ((↑pn.succ) * x) + f x       := by exact_mod_cast add_le_add_left
                                                    (hpn pn.succ_pos) (f x)
          _ ≤ f ((↑pn + 1) * x + x)          := by exact_mod_cast H2 _ _
                                                    (mul_pos pn.cast_add_one_pos hx) hx
          _ = f ((↑pn + 1 + 1) * x)          := by ring_nf
          _ = f (↑(pn + 2) * x)              := by norm_cast

  have H4 : ∀ n : ℕ, 0 < n → (n : ℝ) ≤ f n := by
    intro n hn
    have hf1 : 1 ≤ f 1 := by
      suffices ↑a * 1 ≤ ↑a * f 1 from (mul_le_mul_iff_right₀ (by positivity)).mp this
      calc _ = ↑a := mul_one _
           _ = f a        := hae.symm
           _ = f (a * 1)  := by rw [mul_one]
           _ ≤ f a * f 1  := (H1 a 1) (zero_lt_one.trans ha1) zero_lt_one
           _ = ↑a * f 1   := by rw [hae]

    calc (n : ℝ) = (n : ℝ) * 1 := (mul_one _).symm
         _ ≤ (n : ℝ) * f 1     := by gcongr
         _ ≤ f (n * 1)         := H3 1 zero_lt_one n hn
         _ = f n               := by rw [mul_one]

  have H5 : ∀ x : ℚ, 1 < x → (x : ℝ) ≤ f x := by
    intro x hx
    have hxnm1 : ∀ n : ℕ, 0 < n → (x : ℝ)^n - 1 < (f x)^n := by
      intro n hn
      calc (x : ℝ)^n - 1 < f (x^n) := by exact_mod_cast fx_gt_xm1 (one_le_pow₀ hx.le)
                                           H1 H2 H4
                       _ ≤ (f x)^n := pow_f_le_f_pow hn hx H1 H4
    have hx' : 1 < (x : ℝ) := mod_cast hx
    have hxp : 0 < x := zero_lt_one.trans hx
    exact le_of_all_pow_lt_succ' hx' (f_pos_of_pos hxp H1 H4) hxnm1

  have h_f_commutes_with_pos_nat_mul : ∀ n : ℕ, 0 < n → ∀ x : ℚ, 0 < x → f (n * x) = n * f x := by
    intro n hn x hx
    have h2 : f (n * x) ≤ n * f x := by
      rcases n with _ | _ | n
      · exact (Nat.lt_asymm hn hn).elim
      · simp
      · have hfneq : f (n.succ.succ) = n.succ.succ := by
          have := fixed_point_of_gt_1
              (Nat.one_lt_cast.mpr (Nat.succ_lt_succ n.succ_pos)) H1 H2 H4 H5 ha1 hae
          rwa [Rat.cast_natCast n.succ.succ] at this
        rw [←hfneq]
        exact H1 (n.succ.succ : ℚ) x (Nat.cast_pos.mpr hn) hx
    exact h2.antisymm (H3 x hx n hn)

  -- For the final calculation, we expand x as (2*x.num) / (2*x.denom), because
  -- we need the top of the fraction to be strictly greater than 1 in order
  -- to apply fixed_point_of_gt_1.
  intro x hx
  have H₀ : x * x.den = x.num := Rat.mul_den_eq_num x
  have H : (↑(2 * x.den) : ℚ) * x = (↑(2 * x.num) : ℚ) := by push_cast; linear_combination 2 * H₀
  set x2denom := 2 * x.den
  set x2num := 2 * x.num
  have hx2pos : 0 < 2 * x.den := by positivity
  have hx2cnezr : (x2denom : ℝ) ≠ (0 : ℝ) := by positivity
  have : 0 < x.num := Rat.num_pos.mpr hx
  have hx2num_gt_one : (1 : ℚ) < (2 * x.num : ℤ) := by norm_cast; lia
  apply mul_left_cancel₀ hx2cnezr
  calc
    x2denom * f x = f (x2denom * x) :=
        (h_f_commutes_with_pos_nat_mul x2denom hx2pos x hx).symm
    _ = f x2num := by rw [H]
    _ = x2num := fixed_point_of_gt_1 hx2num_gt_one H1 H2 H4 H5 ha1 hae
    _ = ((x2num : ℚ) : ℝ) := by norm_cast
    _ = (↑(x2denom * x) : ℝ) := by rw [H]
    _ = x2denom * x := by push_cast; rfl


end Imo2013P5

-- ═══ Imo2014P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 2014, Problem 1

Let a₀ < a₁ < a₂ < ... an infinite sequence of positive integers.
Prove that there exists a unique integer n ≥ 1 such that

  aₙ < (a₀ + a₁ + ... + aₙ)/n ≤ aₙ₊₁.
-/

namespace Imo2014P1



lemma lemma0 {p : ℕ → Prop} (h : ∃! n, p (n + 1)) : (∃! n, 0 < n ∧ p n) := by
  obtain ⟨n, hn1, hn2⟩ := h
  refine ⟨n + 1, ⟨Nat.succ_pos n, hn1⟩, fun m ⟨hm1, hm2⟩ ↦ ?_⟩
  specialize hn2 (m - 1)
  grind

lemma lemma1 (s : ℕ → ℤ) (hs : ∀ i, s i < s (i + 1)) (z : ℤ) (hs0 : s 0 < z) :
    ∃! i, s i < z ∧ z ≤ s (i + 1) := by
  have hmono : StrictMono s := strictMono_nat_of_lt_succ hs
  let S := { i | z ≤ s (i + 1) }
  have h3 : ∃ j, j ∈ S := by
    have h5 : ∀ i, s 0 + i ≤ s i := fun i ↦ by
      induction' i with i ih
      · simp
      · grind
    use Int.toNat (z - s 0)
    rw [Set.mem_setOf_eq]
    have h8 := h5 (Int.toNat (z - s 0))
    have h6 : 0 ≤ z - s 0 := by lia
    have h7 : ((Int.toNat (z - s 0)) :ℤ) = z - s 0 := Int.toNat_of_nonneg h6
    rw [h7] at h8
    rw [add_sub_cancel] at h8
    have h12 : s (Int.toNat (z - s 0)) < s (Int.toNat (z - s 0) + 1) := hs _
    lia
  use Nat.find h3
  dsimp [S]
  refine ⟨⟨?_, ?_⟩, ?_⟩
  · have h4 := Nat.find_min h3 (m := (Nat.find h3 - 1))
    obtain h5 | h5 := Nat.eq_zero_or_pos (Nat.find h3)
    · rwa [h5]
    · have h6 : Nat.find h3 - 1 < Nat.find h3 :=
        Nat.sub_one_lt_of_le h5 Nat.le.refl
      have h7 := h4 h6
      rw [Set.mem_setOf_eq] at h7
      push_neg at h7
      rwa [Nat.sub_add_cancel h5] at h7
  · exact Nat.find_spec h3
  · rintro m ⟨hm1, hm2⟩
    symm
    rw [Nat.find_eq_iff]
    refine ⟨hm2, ?_⟩
    intro k hk hkk
    have h9 : s (k + 1) ≤ s m := (StrictMono.le_iff_le hmono).mpr hk
    simp only [Set.mem_setOf_eq] at hkk
    lia



theorem imo2014_p1 (a : ℕ → ℤ) (apos : ∀ i, 0 < a i) (ha : ∀ i, a i < a (i + 1)) :
    ∃! n : ℕ, 0 < n ∧
              n * a n < (∑ i ∈ Finset.range (n + 1), a i) ∧
              (∑ i ∈ Finset.range (n + 1), a i) ≤ n * a (n + 1) := by
  -- Informal solution by Fedor Petrov, via Evan Chen:
  -- https://web.evanchen.cc/exams/IMO-2014-notes.pdf

  let b : ℕ → ℤ := fun i ↦ ∑ j ∈ Finset.range i, (a i - a (j + 1))
  have hb : ∀ i, b i = i * a i - ∑ j ∈ Finset.range i, a (j + 1) := by
    intro i
    simp [b]
  have hb1 : b 1 = 0 := by norm_num [b]
  have hm : ∀ i, 0 < i → b i < b (i + 1) := by
    intro i hi0
    rw [hb, hb]
    rw [Finset.sum_range_succ]
    have hi := ha i
    push_cast
    nlinarith

  have h1 : ∀ j,
    (0 < j ∧ j * a j < (∑ i ∈ Finset.range (j + 1), a i) ∧
                       (∑ i ∈ Finset.range (j + 1), a i) ≤ j * a (j + 1)) ↔
    (0 < j ∧ b j < a 0 ∧ a 0 ≤ b (j + 1)) := fun j ↦ by
    rw [hb, hb]
    constructor
    · rintro ⟨hj0, hj1, hj2⟩
      refine ⟨hj0, ?_, ?_⟩
      · suffices H : ↑j * a j < ∑ i ∈ Finset.range j, a (i + 1) + a 0 by
          exact Int.sub_left_lt_of_lt_add H
        rwa [Finset.sum_range_succ'] at hj1
      · rw [Finset.sum_range_succ'] at hj2
        rw [Finset.sum_range_succ]
        push_cast
        linarith
    · rintro ⟨hj0, hj1, hj2⟩
      refine ⟨hj0, ?_, ?_⟩
      · have H := Int.lt_add_of_sub_left_lt hj1
        rwa [Finset.sum_range_succ']
      · rw [Finset.sum_range_succ']
        rw [Finset.sum_range_succ] at hj2
        push_cast at hj2
        linarith
  have hm' : ∀ i, b (i + 1) < b (i + 1 + 1) := fun i ↦ hm (i + 1) (Nat.succ_pos _)
  have h3 : ∃! n, b (n + 1) < a 0 ∧ a 0 ≤ b (n + 2) :=
    lemma1 (fun i ↦ b (i + 1)) hm' (a 0) (hb1.trans_lt (apos 0))
  replace h3 := lemma0 (p := fun n ↦ b n < a 0 ∧ a 0 ≤ b (n + 1)) h3
  exact (existsUnique_congr h1).mpr h3


end Imo2014P1

-- ═══ Imo2014P4 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 2014, Problem 4

Let P and Q be on segment BC of an acute triangle ABC such that
∠PAB = ∠BCA and ∠CAQ = ∠ABC. Let M and N be points on lines AB
and AQ, respectively, such that P is the midpoint of AM and Q
is the midpoint of AN. Prove that BM and CN meet on the
circumcircle of triangle ABC.
-/

namespace Imo2014P4

open scoped EuclideanGeometry



open EuclideanGeometry Affine

local instance planeFiniteDim :
    Fact (Module.finrank ℝ (EuclideanSpace ℝ (Fin 2)) = 2) :=
  ⟨finrank_euclideanSpace_fin⟩

noncomputable local instance someOrientation :
    Module.Oriented ℝ (EuclideanSpace ℝ (Fin 2)) (Fin 2) :=
  ⟨Module.Basis.orientation (Module.finBasisOfFinrankEq _ _ planeFiniteDim.out)⟩

lemma angle_eq_of_oangle_eq {A₁ A₂ A₃ B₁ B₂ B₃ : EuclideanSpace ℝ (Fin 2)}
  (h: ∡ A₁ A₂ A₃ = ∡ B₁ B₂ B₃)
  (hA₁: A₁ ≠ A₂) (hA₂: A₃ ≠ A₂) (hB₁: B₁ ≠ B₂) (hB₂: B₃ ≠ B₂)
  : ∠ A₁ A₂ A₃ = ∠ B₁ B₂ B₃ := by
  rw [angle_eq_abs_oangle_toReal hA₁ hA₂, angle_eq_abs_oangle_toReal hB₁ hB₂, h]

lemma angle_eq_of_cos_angle_eq {A₁ A₂ A₃ B₁ B₂ B₃ : EuclideanSpace ℝ (Fin 2)}
  (h : Real.cos (∠ A₁ A₂ A₃) = Real.cos (∠ B₁ B₂ B₃)) : ∠ A₁ A₂ A₃ = ∠ B₁ B₂ B₃ := by
  unfold EuclideanGeometry.angle at *
  rw [InnerProductGeometry.cos_angle, InnerProductGeometry.cos_angle] at h
  unfold InnerProductGeometry.angle at *
  rw [h]

lemma eq_max_of_max_ne_top
  {A B : Submodule ℝ (EuclideanSpace ℝ (Fin 2))}
  (hA : Module.finrank ℝ A = 1)
  (h : A ⊔ B ≠ ⊤) : A = A ⊔ B := by
  apply Submodule.eq_of_le_of_finrank_eq le_sup_left
  rw [hA]
  have hAB := Submodule.finrank_le (A ⊔ B)
  rw [planeFiniteDim.out] at hAB
  have hAB' : 1 ≤ Module.finrank ℝ ↥(A ⊔ B) := by
    rw [← hA]
    exact Submodule.finrank_mono le_sup_left
  have hAB'' : Module.finrank ℝ ↥(A ⊔ B) ≠ 2 := by
    contrapose! h
    apply Submodule.eq_top_of_finrank_eq
    rw [planeFiniteDim.out, h]
  lia

lemma affineSpan_pair_finrank {A B : EuclideanSpace ℝ (Fin 2)}
  (hAB : A ≠ B): Module.finrank ℝ (affineSpan ℝ {A, B}).direction = 1 := by
  rw [direction_affineSpan]
  have h := affineIndependent_of_ne ℝ hAB
  have h' : Set.range ![A, B] = {A, B} := by
    simp
    rw [Set.pair_comm]
  rw [← h']
  apply AffineIndependent.finrank_vectorSpan h
  simp

lemma inter_nonempty_of_not_parallel
  {A₁ A₂ B₁ B₂ : EuclideanSpace ℝ (Fin 2)}
  (hA : A₁ ≠ A₂) (hB : B₁ ≠ B₂)
  (h : ¬line[ℝ, A₁, A₂] ∥ line[ℝ, B₁, B₂]) :
  Set.Nonempty ((line[ℝ, A₁, A₂] : Set _) ∩ (line[ℝ, B₁, B₂] : Set (EuclideanSpace ℝ (Fin 2)))) := by
  have hA' : (line[ℝ, A₁, A₂] : Set (EuclideanSpace ℝ (Fin 2))).Nonempty := by
    use A₁
    apply mem_affineSpan
    simp
  have hB' : (line[ℝ, B₁, B₂] : Set (EuclideanSpace ℝ (Fin 2))).Nonempty := by
    use B₁
    apply mem_affineSpan
    simp
  apply AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top hA' hB'
  contrapose! h
  rw [AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot]
  constructor
  · set A := (affineSpan ℝ {A₁, A₂}).direction
    set B := (affineSpan ℝ {B₁, B₂}).direction
    trans A ⊔ B
    · exact eq_max_of_max_ne_top (affineSpan_pair_finrank hA) h
    · symm
      rw [sup_comm] at *
      exact eq_max_of_max_ne_top (affineSpan_pair_finrank hB) h
  · rw [affineSpan_eq_bot, affineSpan_eq_bot]
    constructor <;> intro h' <;> contrapose! h' <;> simp

lemma mem_affineSpan_pair_of_collinear {A B C : EuclideanSpace ℝ (Fin 2)}
  (hBC : B ≠ C) (h : Collinear ℝ {A, B, C}) :
  A ∈ affineSpan ℝ {B, C} := by
  apply Collinear.mem_affineSpan_of_mem_of_ne h (by simp) (by simp) (by simp) hBC

lemma mem_circumsphere_of_concyclic
  (ABC : Affine.Triangle ℝ (EuclideanSpace ℝ (Fin 2))) (D : EuclideanSpace ℝ (Fin 2))
  (hABCD : Concyclic {D, ABC.points 0, ABC.points 1, ABC.points 2}) :
  D ∈ Affine.Simplex.circumsphere ABC := by
  have hABCD' := EuclideanGeometry.Concyclic.Cospherical hABCD
  rw [EuclideanGeometry.cospherical_iff_exists_sphere] at hABCD'
  rcases hABCD' with ⟨S, hS⟩
  have hABC := (Affine.Simplex.circumsphere_unique_dist_eq ABC).right
  have h : S = Affine.Simplex.circumsphere ABC := by
    apply hABC
    constructor
    · rw [Affine.Simplex.span_eq_top ABC planeFiniteDim.out]
      apply AffineSubspace.mem_top
    · intro x hx
      simp at hx
      rcases hx with ⟨i, hi⟩
      rw [← hi]
      fin_cases i <;> simp [-mem_sphere_iff_norm, -Metric.mem_sphere] at hi ⊢ <;> apply hS <;> simp
  rw [← h]
  apply hS
  simp

structure Imo2014q4Cfg where
  (A B C P Q M N : EuclideanSpace ℝ (Fin 2))
  (hABC : AffineIndependent ℝ ![A, B, C])
  (acuteA : ∠ C A B < Real.pi / 2)
  (acuteB : ∠ A B C < Real.pi / 2)
  (acuteC : ∠ B C A < Real.pi / 2)
  (hP : Wbtw ℝ B P C)
  (hQ : Wbtw ℝ B Q C)
  (hPAB : ∠ P A B = ∠ B C A)
  (hCAQ : ∠ C A Q = ∠ A B C)
  (hPAM : P = midpoint ℝ A M)
  (hQAN : Q = midpoint ℝ A N)

namespace Imo2014q4Cfg

variable (cfg : Imo2014q4Cfg)

def symm : Imo2014q4Cfg where
  A := cfg.A
  B := cfg.C
  C := cfg.B
  P := cfg.Q
  Q := cfg.P
  M := cfg.N
  N := cfg.M
  hABC := by
    rw [← affineIndependent_equiv (Equiv.swap (1 : Fin 3) 2)]
    convert cfg.hABC using 1
    ext x
    fin_cases x <;> rfl
  acuteA := by
    rw [angle_comm]
    exact cfg.acuteA
  acuteB := by
    rw [angle_comm]
    exact cfg.acuteC
  acuteC := by
    rw [angle_comm]
    exact cfg.acuteB
  hP := Wbtw.symm cfg.hQ
  hQ := Wbtw.symm cfg.hP
  hPAB := by
    rw [angle_comm cfg.Q cfg.A cfg.C]
    rw [angle_comm cfg.C cfg.B cfg.A]
    exact cfg.hCAQ
  hCAQ := by
    rw [angle_comm cfg.B cfg.A cfg.P]
    rw [angle_comm cfg.A cfg.C cfg.B]
    exact cfg.hPAB
  hPAM := cfg.hQAN
  hQAN := cfg.hPAM

noncomputable def L := midpoint ℝ cfg.B cfg.C

def ABC : Affine.Triangle ℝ (EuclideanSpace ℝ (Fin 2)) :=
  ⟨![cfg.A, cfg.B, cfg.C], cfg.hABC⟩

def D_set := ((line[ℝ, cfg.B, cfg.M] : Set _) ∩ (line[ℝ, cfg.C, cfg.N] : Set (EuclideanSpace ℝ (Fin 2))))

lemma L_symm : cfg.L = cfg.symm.L := by
  simp [L, symm]
  exact midpoint_comm cfg.B cfg.C

lemma D_symm : cfg.D_set = cfg.symm.D_set := by
  simp [D_set, symm]
  rw [Set.inter_comm]

lemma B_ne_A : cfg.B ≠ cfg.A := by
    exact cfg.hABC.injective.ne (by decide : (1 : Fin 3) ≠ 0)

lemma C_ne_A : cfg.C ≠ cfg.A := by
    exact cfg.hABC.injective.ne (by decide : (2 : Fin 3) ≠ 0)

lemma C_ne_B : cfg.C ≠ cfg.B := by
    exact cfg.hABC.injective.ne (by decide : (2 : Fin 3) ≠ 1)

lemma sin_angle_in_ABC_pos (i j k : Fin 3) (h : Function.Injective ![i, j, k])
  : Real.sin (∠ (cfg.ABC.points i) (cfg.ABC.points j) (cfg.ABC.points k)) ≠ 0 := by
  apply EuclideanGeometry.sin_ne_zero_of_not_collinear
  rw [← affineIndependent_iff_not_collinear_set]
  have h' : ![cfg.ABC.points i, cfg.ABC.points j, cfg.ABC.points k] = Function.comp cfg.ABC.points ![i, j, k]:= by
    ext x
    fin_cases x <;> simp
  rw [h']
  apply AffineIndependent.comp_embedding ⟨_, h⟩
  exact cfg.ABC.independent

lemma angle_in_ABC_pos (i j k : Fin 3) (h : Function.Injective ![i, j, k])
  : ∠ (cfg.ABC.points i) (cfg.ABC.points j) (cfg.ABC.points k) ≠ 0 := by
  have h':= sin_angle_in_ABC_pos cfg i j k h
  contrapose! h'
  rw [h']
  exact Real.sin_zero

lemma P_ne_B : cfg.P ≠ cfg.B := by
  have h' := angle_self_of_ne cfg.B_ne_A
  contrapose! h'
  nth_rw 1 [← h']
  rw [cfg.hPAB]
  exact angle_in_ABC_pos cfg (1 : Fin 3) 2 0 (by decide)

lemma oangle_PBA_eq_CBA : ∡ cfg.P cfg.B cfg.A = ∡ cfg.C cfg.B cfg.A := by
  apply Wbtw.oangle_eq_left cfg.hP
  exact cfg.P_ne_B

lemma PBA_eq_CBA : ∠ cfg.P cfg.B cfg.A = ∠ cfg.C cfg.B cfg.A := by
  exact angle_eq_of_oangle_eq cfg.oangle_PBA_eq_CBA cfg.P_ne_B cfg.B_ne_A.symm cfg.C_ne_B cfg.B_ne_A.symm

lemma P_ne_A : cfg.P ≠ cfg.A := by
  have h' := angle_self_of_ne cfg.B_ne_A.symm
  contrapose! h'
  nth_rw 1 [← h']
  rw [PBA_eq_CBA]
  exact angle_in_ABC_pos cfg (2 : Fin 3) 1 0 (by decide)

lemma oangle_PAB_eq_BCA : ∡ cfg.P cfg.A cfg.B = ∡ cfg.B cfg.C cfg.A := by
  apply oangle_eq_of_angle_eq_of_sign_eq (cfg.hPAB)
  rw [← oangle_swap₂₃_sign cfg.P cfg.B cfg.A]
  rw [← oangle_swap₁₂_sign cfg.C cfg.B cfg.A]
  rw [cfg.oangle_PBA_eq_CBA]

lemma APB_eq_CBA : ∠ cfg.B cfg.P cfg.A = ∠ cfg.B cfg.A cfg.C := by
  have h₁ := angle_add_angle_add_angle_eq_pi cfg.P cfg.B_ne_A
  have h₂ := angle_add_angle_add_angle_eq_pi cfg.C cfg.B_ne_A
  rw [← h₂, angle_comm cfg.A cfg.B cfg.P, cfg.hPAB] at h₁
  rw [PBA_eq_CBA] at h₁
  rw [angle_comm cfg.C cfg.B cfg.A, add_right_comm, add_left_cancel_iff] at h₁
  rw [h₁, angle_comm]

lemma AB_to_AP_eq_CB_to_CA : dist cfg.A cfg.B / dist cfg.A cfg.P = dist cfg.C cfg.B / dist cfg.C cfg.A := by
  have h₁ := law_sin cfg.B cfg.P cfg.A
  have h₂ := law_sin cfg.A cfg.B cfg.C
  rw [div_eq_div_iff (dist_ne_zero.mpr cfg.P_ne_A.symm) (dist_ne_zero.mpr cfg.C_ne_A)]
  rw [cfg.APB_eq_CBA, angle_comm cfg.A cfg.B cfg.P, cfg.PBA_eq_CBA] at h₁
  rw [angle_comm cfg.A cfg.B cfg.C, angle_comm cfg.C cfg.A cfg.B] at h₂
  have hBAC : Real.sin (∠ cfg.B cfg.A cfg.C) ≠ 0 := by
    exact sin_angle_in_ABC_pos cfg (1: Fin 3) 0 2 (by decide)
  have hCBA : Real.sin (∠ cfg.C cfg.B cfg.A) ≠ 0 := by
    exact sin_angle_in_ABC_pos cfg (2: Fin 3) 1 0 (by decide)
  apply mul_right_cancel₀ hBAC
  apply mul_left_cancel₀ hCBA
  rw [mul_assoc, ← mul_assoc, ← h₁]
  nth_rw 3 [mul_comm]
  rw [← h₂, dist_comm cfg.A cfg.P, dist_comm cfg.B cfg.C]
  ring

lemma AB_to_AM_eq_CL_to_CA : dist cfg.A cfg.B / dist cfg.A cfg.M = dist cfg.C cfg.L / dist cfg.C cfg.A := by
  rw [L, dist_right_midpoint, dist_comm cfg.B cfg.C, mul_div_assoc]
  rw [← AB_to_AP_eq_CB_to_CA, cfg.hPAM, dist_left_midpoint, Real.norm_ofNat]
  ring

lemma wbtw_APM : Wbtw ℝ cfg.A cfg.P cfg.M := by
  rw [cfg.hPAM]
  exact wbtw_midpoint _ _ _

lemma wbtw_CLB : Wbtw ℝ cfg.C cfg.L cfg.B := by
  rw [L, wbtw_comm]
  exact wbtw_midpoint _ _ _

lemma C_ne_L : cfg.C ≠ cfg.L := by
  rw [← dist_pos, L, dist_right_midpoint, Real.norm_ofNat]
  apply mul_pos (by norm_num)
  rw [dist_pos]
  exact cfg.C_ne_B.symm

lemma oangle_BAM_eq_LCA : ∡ cfg.M cfg.A cfg.B = ∡ cfg.L cfg.C cfg.A := by
  rw [← Wbtw.oangle_eq_left cfg.wbtw_APM cfg.P_ne_A]
  rw [Wbtw.oangle_eq_left cfg.wbtw_CLB cfg.C_ne_L.symm]
  exact cfg.oangle_PAB_eq_BCA

lemma M_ne_A : cfg.M ≠ cfg.A := by
  have h' := cfg.P_ne_A
  contrapose! h'
  rw [← dist_eq_zero, cfg.hPAM, dist_comm, dist_left_midpoint]
  apply mul_eq_zero_of_right
  rw [dist_eq_zero]
  exact h'.symm

lemma BAM_eq_LCA : ∠ cfg.M cfg.A cfg.B = ∠ cfg.L cfg.C cfg.A := by
  exact angle_eq_of_oangle_eq cfg.oangle_BAM_eq_LCA cfg.M_ne_A cfg.B_ne_A cfg.C_ne_L.symm cfg.C_ne_A.symm

lemma BM_to_AM_eq_LA_to_CA: dist cfg.B cfg.M / dist cfg.A cfg.M = dist cfg.L cfg.A / dist cfg.C cfg.A := by
  rw [← mul_self_inj (by positivity) (by positivity)]
  rw [← pow_two, ← pow_two, div_pow, div_pow]
  rw [pow_two, pow_two, pow_two, pow_two]
  rw [law_cos cfg.B cfg.A cfg.M, law_cos cfg.L cfg.C cfg.A]
  rw [sub_div, sub_div, add_div, add_div, angle_comm, cfg.BAM_eq_LCA]
  rw [← pow_two, ← pow_two, ← pow_two, ← div_pow, ← div_pow]
  rw [← pow_two, ← pow_two, ← pow_two, ← div_pow, ← div_pow]
  rw [dist_comm cfg.M cfg.A, dist_comm cfg.A cfg.C]
  nth_rw 1 [mul_div_right_comm]
  nth_rw 2 [mul_div_right_comm]
  nth_rw 3 [pow_two]
  nth_rw 5 [pow_two]
  rw [← div_div, ← div_div]
  nth_rw 1 [← mul_div]
  nth_rw 2 [← mul_div]
  rw [div_self (dist_ne_zero.mpr cfg.M_ne_A.symm), div_self (dist_ne_zero.mpr cfg.C_ne_A)]
  rw [mul_one, mul_one, mul_div_assoc, mul_div_assoc]
  rw [dist_comm cfg.B cfg.A, dist_comm cfg.L cfg.C]
  rw [AB_to_AM_eq_CL_to_CA]

lemma L_ne_A : cfg.L ≠ cfg.A := by
  have h' := wbtw_midpoint ℝ cfg.B cfg.C
  rw [← L] at h'
  contrapose! h'
  rw [h']
  have h := AffineIndependent.not_wbtw_of_injective (1 : Fin 3) 0 2 (by decide) cfg.ABC.independent
  exact h

lemma B_ne_M : cfg.B ≠ cfg.M := by
  intro h'
  rw [← dist_eq_zero] at *
  have h'' := cfg.BM_to_AM_eq_LA_to_CA
  rw [h', zero_div] at h''
  symm at h''
  rw [div_eq_zero_iff] at h''
  contrapose! h''
  rw [dist_ne_zero, dist_ne_zero]
  exact ⟨cfg.L_ne_A, cfg.C_ne_A⟩

lemma MBA_eq_CLA : ∠ cfg.M cfg.B cfg.A = ∠ cfg.C cfg.L cfg.A := by
  apply angle_eq_of_cos_angle_eq
  have h₁ := (law_cos cfg.M cfg.B cfg.A).symm
  have h₂ := (law_cos cfg.A cfg.L cfg.C).symm
  rw [← div_eq_one_iff_eq (mul_self_ne_zero.mpr (dist_ne_zero.mpr cfg.M_ne_A))] at h₁
  rw [← div_eq_one_iff_eq (mul_self_ne_zero.mpr (dist_ne_zero.mpr cfg.C_ne_A.symm))] at h₂
  rw [← h₂] at h₁
  rw [sub_div, sub_div, add_div, add_div] at h₁
  rw [← pow_two, ← pow_two, ← pow_two, ← div_pow, ← div_pow] at h₁
  rw [← pow_two, ← pow_two, ← pow_two, ← div_pow, ← div_pow] at h₁
  nth_rw 3 [pow_two] at h₁
  nth_rw 5 [pow_two] at h₁
  nth_rw 1 [mul_div_right_comm] at h₁
  nth_rw 2 [mul_div_right_comm] at h₁
  rw [← div_div, ← div_div] at h₁
  nth_rw 1 [← mul_div] at h₁
  nth_rw 2 [← mul_div] at h₁
  nth_rw 1 [← div_mul_eq_mul_div,] at h₁
  nth_rw 2 [← div_mul_eq_mul_div,] at h₁
  rw [← mul_div, ← mul_div] at h₁
  rw [dist_comm cfg.M cfg.A, dist_comm cfg.A cfg.C] at h₁
  rw [dist_comm cfg.M cfg.B, dist_comm cfg.A cfg.L] at h₁
  rw [cfg.BM_to_AM_eq_LA_to_CA, cfg.AB_to_AM_eq_CL_to_CA] at h₁
  rw [sub_right_inj] at h₁
  rw [angle_comm cfg.C cfg.L cfg.A]
  apply mul_left_cancel₀ _ h₁
  rw [mul_assoc]
  apply mul_ne_zero (by norm_num)
  apply mul_ne_zero
  · apply div_ne_zero
    · exact dist_ne_zero.mpr cfg.L_ne_A
    · exact dist_ne_zero.mpr cfg.C_ne_A
  · apply div_ne_zero
    · exact dist_ne_zero.mpr cfg.C_ne_L
    · exact dist_ne_zero.mpr cfg.C_ne_A

lemma oangle_MBA_eq_CLA : ∡ cfg.M cfg.B cfg.A = ∡ cfg.C cfg.L cfg.A := by
  apply oangle_eq_of_angle_eq_of_sign_eq (cfg.MBA_eq_CLA)
  rw [← oangle_swap₂₃_sign cfg.M cfg.A cfg.B]
  rw [← oangle_swap₁₂_sign cfg.L cfg.C cfg.A]
  rw [cfg.oangle_BAM_eq_LCA]

lemma oangle_NCA_eq_BLA: ∡ cfg.N cfg.C cfg.A = ∡ cfg.B cfg.L cfg.A := by
  have h := cfg.symm.oangle_MBA_eq_CLA
  rw [← L_symm] at h
  simp [symm] at h
  exact h

lemma oangle_NCA_MBA: (2 : ℤ) • ∡ cfg.N cfg.C cfg.A = (2 : ℤ) • ∡ cfg.M cfg.B cfg.A := by
  rw [oangle_MBA_eq_CLA, oangle_NCA_eq_BLA]
  have hL := sbtw_midpoint_of_ne ℝ cfg.C_ne_B.symm
  rw [← L] at hL
  rw [Sbtw.oangle_eq_add_pi_left hL cfg.L_ne_A.symm]
  rw [smul_add, two_zsmul (Real.pi : Real.Angle), Real.Angle.coe_pi_add_coe_pi, add_zero]

lemma N_ne_Q : cfg.M ≠ cfg.P := by
  rw [cfg.hPAM, ← dist_ne_zero, dist_right_midpoint]
  apply mul_ne_zero (by norm_num)
  rw [dist_ne_zero]
  exact cfg.M_ne_A.symm

lemma D_ne_C {D : EuclideanSpace ℝ (Fin 2)} (hD : D ∈ cfg.D_set) : D ≠ cfg.C := by
  rw [D_set, Set.mem_inter_iff] at hD
  intro h'
  rw [h'] at hD
  have hBCM := collinear_insert_of_mem_affineSpan_pair hD.left
  rw [Set.pair_comm, Set.insert_comm] at hBCM
  apply mem_affineSpan_pair_of_collinear cfg.C_ne_B at hBCM
  have hBPC := Wbtw.collinear cfg.hP
  rw [Set.insert_comm, Set.pair_comm] at hBPC
  apply mem_affineSpan_pair_of_collinear cfg.C_ne_B at hBPC
  have hPMBC := collinear_insert_insert_of_mem_affineSpan_pair hBCM hBPC
  nth_rw 2 [Set.insert_comm] at hPMBC
  rw [Set.pair_comm] at hPMBC
  nth_rw 1 [Set.insert_comm] at hPMBC
  nth_rw 2 [Set.insert_comm] at hPMBC
  have hBMP := Collinear.subset (Set.subset_insert _ _) hPMBC
  nth_rw 1 [Set.insert_comm] at hPMBC
  have hCMP := Collinear.subset (Set.subset_insert _ _) hPMBC
  apply mem_affineSpan_pair_of_collinear cfg.N_ne_Q at hBMP
  apply mem_affineSpan_pair_of_collinear cfg.N_ne_Q at hCMP
  have hAMP := Wbtw.collinear (wbtw_midpoint ℝ cfg.A cfg.M)
  rw [← cfg.hPAM, Set.pair_comm] at hAMP
  apply mem_affineSpan_pair_of_collinear cfg.N_ne_Q at hAMP
  have hABC := collinear_triple_of_mem_affineSpan_pair hAMP hBMP hCMP
  contrapose! hABC
  rw [← affineIndependent_iff_not_collinear_set]
  exact cfg.hABC

lemma D_ne_B {D : EuclideanSpace ℝ (Fin 2)} (hD : D ∈ cfg.D_set) : D ≠ cfg.B := by
  rw [cfg.D_symm] at hD
  have h := cfg.symm.D_ne_C hD
  simp [symm] at h
  exact h

lemma oangle_DBA_MBA {D : EuclideanSpace ℝ (Fin 2)} (hD : D ∈ cfg.D_set) :
  (2 : ℤ) • ∡ D cfg.B cfg.A = (2 : ℤ) • ∡ cfg.M cfg.B cfg.A := by
  rw [D_set, Set.mem_inter_iff] at hD
  have hDBM := collinear_insert_of_mem_affineSpan_pair hD.left
  exact Collinear.two_zsmul_oangle_eq_left hDBM (cfg.D_ne_B hD) cfg.B_ne_M.symm

lemma oangle_DCA_NCA {D : EuclideanSpace ℝ (Fin 2)} (hD : D ∈ cfg.D_set) :
  (2 : ℤ) • ∡ D cfg.C cfg.A = (2 : ℤ) • ∡ cfg.N cfg.C cfg.A := by
  rw [cfg.D_symm] at hD
  have h := cfg.symm.oangle_DBA_MBA hD
  simp [symm] at h
  exact h

theorem result₁ : Set.Nonempty cfg.D_set := by
  apply inter_nonempty_of_not_parallel cfg.B_ne_M cfg.symm.B_ne_M
  simp [symm]
  intro h'
  have h'' := AffineSubspace.Parallel.refl (affineSpan ℝ {cfg.B, cfg.C})
  nth_rw 1 [Set.pair_comm] at h''
  nth_rw 1 [Set.pair_comm] at h'
  nth_rw 2 [Set.pair_comm] at h'
  have h_CBM_BCM := EuclideanGeometry.two_zsmul_oangle_of_parallel h'' h'
  have h_CBM := EuclideanGeometry.oangle_sub_right cfg.C_ne_B cfg.B_ne_M.symm cfg.B_ne_A.symm
  have h_BCM := EuclideanGeometry.oangle_sub_right cfg.C_ne_B.symm cfg.symm.B_ne_M.symm cfg.C_ne_A.symm
  simp [symm] at h_BCM
  rw [← h_CBM, ← h_BCM, zsmul_sub, zsmul_sub] at h_CBM_BCM
  rw [cfg.oangle_NCA_MBA, sub_left_inj, ← sub_eq_zero, ← zsmul_sub] at h_CBM_BCM
  rw [oangle_rev cfg.A cfg.C cfg.B, sub_neg_eq_add] at h_CBM_BCM
  rw [← add_right_inj ((2 : ℤ) • ∡ cfg.B cfg.A cfg.C), add_zero, ← zsmul_add, ← add_assoc, add_right_comm] at h_CBM_BCM
  rw [EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi cfg.B_ne_A.symm cfg.C_ne_A  cfg.C_ne_B.symm] at h_CBM_BCM
  symm at h_CBM_BCM
  rw [two_zsmul (Real.pi : Real.Angle), Real.Angle.coe_pi_add_coe_pi] at h_CBM_BCM
  rw [Real.Angle.two_zsmul_eq_zero_iff, oangle_eq_zero_or_eq_pi_iff_collinear] at h_CBM_BCM
  rw [Set.insert_comm, collinear_iff_not_affineIndependent_set] at h_CBM_BCM
  contrapose! h_CBM_BCM
  exact cfg.hABC

theorem result₂ : cfg.D_set ⊆ Affine.Simplex.circumsphere cfg.ABC := by
  rintro D hD
  have h : (2 : ℤ) • ∡ D cfg.C cfg.A = (2 : ℤ) • ∡ D cfg.B cfg.A := by
    rw [cfg.oangle_DBA_MBA hD]
    rw [cfg.oangle_DCA_NCA hD]
    exact cfg.oangle_NCA_MBA
  rcases EuclideanGeometry.concyclic_or_collinear_of_two_zsmul_oangle_eq h with hh|hh
  · apply mem_circumsphere_of_concyclic cfg.ABC D
    simp [ABC]
    nth_rw 2 [Set.insert_comm]
    rw [Set.pair_comm]
    nth_rw 2 [Set.insert_comm]
    exact hh
  · have h' : {cfg.A, cfg.B, cfg.C} ⊆ ({D, cfg.C, cfg.B, cfg.A} : Set _) := by
      trans {cfg.C, cfg.B, cfg.A}
      · rw [Set.insert_comm, Set.pair_comm, Set.insert_comm]
      · exact Set.subset_insert D {cfg.C, cfg.B, cfg.A}
    apply Collinear.subset h' at hh
    rw [collinear_iff_not_affineIndependent_set] at hh
    contrapose! hh
    exact cfg.hABC

end Imo2014q4Cfg



theorem imo2014_p4
    (A B C P Q M N : EuclideanSpace ℝ (Fin 2))
    (hABC : AffineIndependent ℝ ![A, B, C])
    (acuteA : ∠ C A B < Real.pi / 2)
    (acuteB : ∠ A B C < Real.pi / 2)
    (acuteC : ∠ B C A < Real.pi / 2)
    (hP : Wbtw ℝ B P C)
    (hQ : Wbtw ℝ B Q C)
    (hPAB : ∠ P A B = ∠ B C A)
    (hCAQ : ∠ C A Q = ∠ A B C)
    (hPAM : P = midpoint ℝ A M)
    (hQAN : Q = midpoint ℝ A N)
    : let ABC : Affine.Triangle _ _ := ⟨![A, B, C], hABC⟩
      let D := (line[ℝ, B, M] : Set _) ∩ (line[ℝ, C, N] : Set (EuclideanSpace ℝ (Fin 2)))
      Set.Nonempty D ∧ D ⊆ Affine.Simplex.circumsphere ABC := by
  set cfg : Imo2014q4Cfg := ⟨A, B, C, P, Q, M, N, hABC, acuteA, acuteB, acuteC, hP, hQ, hPAB, hCAQ, hPAM, hQAN⟩
  exact ⟨cfg.result₁, cfg.result₂⟩


end Imo2014P4

-- ═══ Imo2016P4 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Benpigchu
-/





/-!
# International Mathematical Olympiad 2016, Problem 4

A set of positive integers is called *fragrant* if it contains
at least two elements and each of its elements has a prime
factor in common with at least one of the other elements.
Let P(n) = n² + n + 1. What is the least possible value of
positive integer b such that there exists a non-negative integer
a for which the set

  { P(a + 1), P(a + 2), ..., P(a + b) }

is fragrant?
-/

namespace Imo2016P4

abbrev Fragrant (s : Set ℕ+) : Prop :=
  2 ≤ s.ncard ∧ ∀ m ∈ s, ∃ n ∈ s, n ≠ m ∧ ¬Nat.Coprime m n

abbrev P (n : ℕ) : ℕ := n^2 + n + 1



def fragrantMap : ℕ → ℕ
  | 0 => 0
  | 1 => 5
  | 2 => 4
  | 3 => 6
  | 4 => 2
  | 5 => 1
  | 6 => 3
  | _ => 0

lemma P_inj : Function.Injective P := by
  apply StrictMono.injective
  intro i j hij
  rw [add_lt_add_iff_right]
  apply add_lt_add _ hij
  rw [pow_two, pow_two]
  exact Nat.mul_self_lt_mul_self hij

lemma ncard_set {a : ℕ} {b : ℕ+} : {p : ℕ+ | ∃ i : ℕ+, i ≤ b ∧ p = P (a + i)}.ncard = b := by
  set f : Fin b → ℕ+ := fun i : Fin b ↦ ⟨(P (a + i + 1)), (by simp : _)⟩
  have hset : Set.range f = {p : ℕ+ | ∃ i : ℕ+, i ≤ b ∧ p = P (a + i)} := by
    rw [Set.range_eq_iff]
    constructor
    · intro i
      simp [f]
      use ⟨i.val + 1, (by simp : _)⟩
      constructor
      · rw [← PNat.coe_le_coe, PNat.mk_coe]
        apply Nat.add_one_le_of_lt
        exact Fin.is_lt i
      · rw [PNat.mk_coe]
        ring
    · intro p hp
      rcases hp with ⟨i, hi, hi'⟩
      rw [← PNat.coe_le_coe] at hi
      have hival : i.val - 1 < b := by
        apply lt_of_lt_of_le _ hi
        apply Nat.sub_one_lt
        apply ne_of_gt
        exact PNat.pos i
      use ⟨i.val - 1, hival⟩
      apply PNat.eq
      rw [PNat.mk_coe, hi']
      simp [P]
      have hi'' : (1 : ℕ) ≤ ↑i := by
        apply PNat.one_le
      rw [add_assoc]
      rw [Nat.sub_add_cancel hi'']
  have hf : Function.Injective f := by
    intro i j hij
    simp [f] at hij
    rw [← PNat.coe_inj, PNat.mk_coe, PNat.mk_coe] at hij
    apply P_inj at hij
    apply Nat.add_right_cancel at hij
    apply Nat.add_left_cancel at hij
    exact Fin.eq_of_val_eq hij
  rw [← hset, Set.ncard_range_of_injective hf, Nat.card_fin]

lemma two_dvd_pow_two_add_self (x : ℤ) : ∃ k : ℤ, 2 * k + 1 = x ^ 2 + x + 1 := by
  mod_cases hx : x % 2
    <;> rw [Int.modEq_comm, Int.modEq_iff_dvd, dvd_iff_exists_eq_mul_right] at hx
    <;> rcases hx with ⟨k, hk⟩
    <;> rw [sub_eq_iff_eq_add] at hk
  · use k * (2 * k + 1)
    rw [hk]
    ring
  · use (2 * k + 1) * (k + 1)
    rw [hk]
    ring

lemma there_dvd_pow_two_add_self (x : ℤ) : ∃ k : ℤ, 3 * k + 1 = x ^ 2 + x + 1 ∨ 9 * k + 3 = x ^ 2 + x + 1 := by
  mod_cases hx : x % 3
    <;> rw [Int.modEq_comm, Int.modEq_iff_dvd, dvd_iff_exists_eq_mul_right] at hx
    <;> rcases hx with ⟨k, hk⟩
    <;> rw [sub_eq_iff_eq_add] at hk
  · use k * (3 * k + 1)
    left
    rw [hk]
    ring
  · use k * (k + 1)
    right
    rw [hk]
    ring
  · use (3 * k + 2) * (k + 1)
    left
    rw [hk]
    ring

lemma gcd_p_of_diff_one {a b : ℕ} (hab : a = b + 1) (hab' : ¬Nat.Coprime (P a) (P b)) : False := by
  have hpa := Nat.gcd_dvd_left (P a) (P b)
  have hpb := Nat.gcd_dvd_right (P a) (P b)
  rw [Nat.coprime_iff_gcd_eq_one] at hab'
  set p := (P a).gcd (P b) with hp
  simp [P] at hpa hpb
  rw [← Int.ofNat_dvd, Nat.cast_add, Nat.cast_add, Nat.cast_pow, Nat.cast_one] at hpa hpb
  rw [← Int.ofNat_inj, Nat.cast_add, Nat.cast_one] at hab
  rw [hab] at hpa
  ring_nf at hpa
  have h₁ := Int.dvd_sub hpa hpb
  ring_nf at h₁
  have h₂ := Int.dvd_sub (dvd_mul_of_dvd_left hpb 3) hpa
  ring_nf at h₂
  have h₃ := Int.dvd_sub (dvd_mul_of_dvd_left h₁ ↑b) h₂
  ring_nf at h₃
  have h₄ := Int.dvd_sub h₁ h₃
  ring_nf at h₄
  rcases two_dvd_pow_two_add_self (b : ℤ) with ⟨k, hk⟩
  have h₅ := hpb
  rw [← hk] at h₅
  have h₆ := Int.dvd_sub h₅ (dvd_mul_of_dvd_left h₄ k)
  ring_nf at h₆
  rw [Int.natCast_dvd, Int.natAbs_one, Nat.dvd_one] at h₆
  contrapose! hab'
  exact h₆

lemma gcd_p_of_diff_two {a b : ℕ} (hab : a = b + 2) (hab' : ¬Nat.Coprime (P a) (P b)) : Nat.gcd (P a) (P b) = 7 := by
  have hpa := Nat.gcd_dvd_left (P a) (P b)
  have hpb := Nat.gcd_dvd_right (P a) (P b)
  rw [Nat.coprime_iff_gcd_eq_one] at hab'
  set p := (P a).gcd (P b)
  simp [P] at hpa hpb
  rw [← Int.ofNat_dvd, Nat.cast_add, Nat.cast_add, Nat.cast_pow, Nat.cast_one] at hpa hpb
  rw [← Int.ofNat_inj, Nat.cast_add, Nat.cast_ofNat] at hab
  rw [hab] at hpa
  ring_nf at hpa
  have h₁ := Int.dvd_sub hpa hpb
  ring_nf at h₁
  have h₂ := Int.dvd_sub (dvd_mul_of_dvd_left hpb 5) hpa
  ring_nf at h₂
  have h₃ := Int.dvd_sub (dvd_mul_of_dvd_left h₁ ↑b) h₂
  ring_nf at h₃
  have h₄ := Int.dvd_sub (dvd_mul_of_dvd_left h₁ 3) (dvd_mul_of_dvd_left h₃ 2)
  ring_nf at h₄
  rcases two_dvd_pow_two_add_self (b : ℤ) with ⟨k, hk⟩
  have h₅ := hpb
  rw [← hk] at h₅
  have h₆ := Int.dvd_sub (dvd_mul_of_dvd_left h₅ 7) (dvd_mul_of_dvd_left h₄ k)
  ring_nf at h₆
  rw [Int.natCast_dvd] at h₆
  norm_num at h₆
  rw [Nat.dvd_prime (by norm_num : _)] at h₆
  rcases h₆ with h₆|h₆
  · contrapose! hab'
    exact h₆
  · exact h₆

lemma gcd_p_of_diff_three {a b : ℕ} (hab : a = b + 3) (hab' : ¬Nat.Coprime (P a) (P b)) : Nat.gcd (P a) (P b) = 3 := by
  have hpa := Nat.gcd_dvd_left (P a) (P b)
  have hpb := Nat.gcd_dvd_right (P a) (P b)
  rw [Nat.coprime_iff_gcd_eq_one] at hab'
  set p := (P a).gcd (P b)
  simp [P] at hpa hpb
  rw [← Int.ofNat_dvd, Nat.cast_add, Nat.cast_add, Nat.cast_pow, Nat.cast_one] at hpa hpb
  rw [← Int.ofNat_inj, Nat.cast_add, Nat.cast_ofNat] at hab
  rw [hab] at hpa
  ring_nf at hpa
  have h₁ := Int.dvd_sub hpa hpb
  ring_nf at h₁
  have h₂ := Int.dvd_sub (dvd_mul_of_dvd_left hpb 7) hpa
  ring_nf at h₂
  have h₃ := Int.dvd_sub (dvd_mul_of_dvd_left h₁ ↑b) h₂
  ring_nf at h₃
  have h₄ := Int.dvd_sub (dvd_mul_of_dvd_left h₁ 2) h₃
  ring_nf at h₄
  rcases two_dvd_pow_two_add_self (b : ℤ) with ⟨k, hk⟩
  have h₅ := hpb
  rw [← hk] at h₅
  have h₆ := Int.dvd_sub (dvd_mul_of_dvd_left h₅ 9) (dvd_mul_of_dvd_left h₄ k)
  ring_nf at h₆
  rcases there_dvd_pow_two_add_self (b : ℤ) with ⟨l, hl|hl⟩
  · have h₇ := hpb
    rw [← hl] at h₇
    have h₈ := Int.dvd_sub (dvd_mul_of_dvd_left h₇ 3) (dvd_mul_of_dvd_left h₆ l)
    ring_nf at h₈
    have h₉ := Int.dvd_sub h₇ (dvd_mul_of_dvd_left h₈ l)
    ring_nf at h₉
    rw [Int.natCast_dvd, Int.natAbs_one, Nat.dvd_one] at h₉
    contrapose! hab'
    exact h₉
  · have h₇ := hpb
    rw [← hl] at h₇
    have h₈ := Int.dvd_sub h₇ (dvd_mul_of_dvd_left h₆ l)
    ring_nf at h₈
    rw [Int.natCast_dvd] at h₈
    norm_num at h₈
    rw [Nat.dvd_prime (by norm_num : _)] at h₈
    rcases h₈ with h₈|h₈
    · contrapose! hab'
      exact h₈
    · exact h₈



noncomputable def Solution : ℕ+ := 6

theorem imo2016_p4 :
    IsLeast
      {b : ℕ+ | ∃ a : ℕ, Fragrant {p | ∃ i : ℕ+, i ≤ b ∧ p = P (a + i)}}
      Solution := by
  rw [Solution]
  constructor
  · set a := 196
    use a
    constructor
    · rw [ncard_set]
      norm_num
    · intro m hm
      simp at *
      rcases hm with ⟨i, hi, hmi⟩
      rw [← PNat.coe_le_coe, PNat.val_ofNat] at hi
      set result := fragrantMap i.val
      set val := P (a + result)
      have hval : 0 < val := by
        simp [val, result, fragrantMap]
      use ⟨val, hval⟩
      have hi' := PNat.pos i
      constructorm* _ ∧ _
      · have hresult : 0 < result := by
          simp [result, fragrantMap]
          interval_cases i.val <;> simp
        use ⟨result, hresult⟩
        constructor
        · rw [← PNat.coe_le_coe, PNat.val_ofNat, PNat.mk_coe]
          simp [result, fragrantMap]
          interval_cases i.val <;> simp
        · simp [val]
      · rw [← PNat.coe_inj]
        simp [hmi, val, a, result, fragrantMap]
        interval_cases i.val <;> simp
      · rw [← PNat.coprime_coe, PNat.mk_coe]
        simp [hmi, val, a, result, fragrantMap, P]
        interval_cases i.val <;> simp
  · rw [lowerBounds]
    intro b hb
    rcases hb with ⟨a, hcard, ha⟩
    set S := {p : ℕ+| ∃ i : ℕ+, i ≤ b ∧ p = P (a + i)} with hS
    by_contra! hb'
    rw [ncard_set] at hcard
    rw [← PNat.coe_lt_coe, PNat.val_ofNat] at hb'
    interval_cases hb : b.val
    · set pa1 : ℕ+ := ⟨(P (a + 1)), (by simp : _)⟩ with hpa1
      have hpa1S : pa1 ∈ S := by
        simp [S, hpa1]
        use ⟨1, (by norm_num : _)⟩
        simp
      rcases ha pa1 hpa1S with ⟨pi1, ⟨i1, hi1₁, hi1₂⟩, hpi1₁, hpi1₂⟩
      rw [← PNat.coe_le_coe, hb] at hi1₁
      rw [← PNat.coe_inj.ne, hi1₂, hpa1, PNat.mk_coe] at hpi1₁
      rw [hi1₂, hpa1, PNat.mk_coe] at hpi1₂
      have hi1 := i1.pos
      interval_cases i1.val
      · rw [ne_self_iff_false] at hpi1₁
        exact hpi1₁
      · rw [Nat.coprime_comm] at hpi1₂
        exact gcd_p_of_diff_one (by ring: (a + 2) = (a + 1) + 1) hpi1₂
    · set pa2 : ℕ+ := ⟨(P (a + 2)), (by simp : _)⟩ with hpa2
      have hpa2S : pa2 ∈ S := by
        simp [S, hpa2]
        use ⟨2, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      rcases ha pa2 hpa2S with ⟨pi2, ⟨i2, hi2₁, hi2₂⟩, hpi2₁, hpi2₂⟩
      rw [← PNat.coe_le_coe, hb] at hi2₁
      rw [← PNat.coe_inj.ne, hi2₂, hpa2, PNat.mk_coe] at hpi2₁
      rw [hi2₂, hpa2, PNat.mk_coe] at hpi2₂
      have hi2 := i2.pos
      interval_cases i2.val
      · exact gcd_p_of_diff_one (by ring: (a + 2) = (a + 1) + 1) hpi2₂
      · rw [ne_self_iff_false] at hpi2₁
        exact hpi2₁
      · rw [Nat.coprime_comm] at hpi2₂
        exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) hpi2₂
    · set pa2 : ℕ+ := ⟨(P (a + 2)), (by simp : _)⟩ with hpa2
      have hpa2S : pa2 ∈ S := by
        simp [S, hpa2]
        use ⟨2, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      have hpa2' : 7 ∣ P (a + 2) := by
        rcases ha pa2 hpa2S with ⟨pi2, ⟨i2, hi2₁, hi2₂⟩, hpi2₁, hpi2₂⟩
        rw [← PNat.coe_le_coe, hb] at hi2₁
        rw [← PNat.coe_inj.ne, hi2₂, hpa2, PNat.mk_coe] at hpi2₁
        rw [hi2₂, hpa2, PNat.mk_coe] at hpi2₂
        have hi2 := i2.pos
        interval_cases i2.val
        · exfalso
          exact gcd_p_of_diff_one (by ring: (a + 2) = (a + 1) + 1) hpi2₂
        · exfalso
          rw [ne_self_iff_false] at hpi2₁
          exact hpi2₁
        · exfalso
          rw [Nat.coprime_comm] at hpi2₂
          exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) hpi2₂
        · rw [Nat.coprime_comm] at hpi2₂
          have h := gcd_p_of_diff_two (by ring: (a + 4) = (a + 2) + 2) hpi2₂
          rw [← h]
          apply Nat.gcd_dvd_right
      set pa3 : ℕ+ := ⟨(P (a + 3)), (by simp : _)⟩ with hpa3
      have hpa3S : pa3 ∈ S := by
        simp [S, hpa3]
        use ⟨3, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      have hpa3' : 7 ∣ P (a + 3) := by
        rcases ha pa3 hpa3S with ⟨pi3, ⟨i3, hi3₁, hi3₂⟩, hpi3₁, hpi3₂⟩
        rw [← PNat.coe_le_coe, hb] at hi3₁
        rw [← PNat.coe_inj.ne, hi3₂, hpa3, PNat.mk_coe] at hpi3₁
        rw [hi3₂, hpa3, PNat.mk_coe] at hpi3₂
        have hi3 := i3.pos
        interval_cases i3.val
        · have h := gcd_p_of_diff_two (by ring: (a + 3) = (a + 1) + 2) hpi3₂
          rw [← h]
          apply Nat.gcd_dvd_left
        · exfalso
          exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) hpi3₂
        · exfalso
          rw [ne_self_iff_false] at hpi3₁
          exact hpi3₁
        · exfalso
          rw [Nat.coprime_comm] at hpi3₂
          exact gcd_p_of_diff_one (by ring: (a + 4) = (a + 3) + 1) hpi3₂
      have h := Nat.not_coprime_of_dvd_of_dvd (by norm_num : 1 < 7) hpa3' hpa2'
      exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) h
    · set pa3 : ℕ+ := ⟨(P (a + 3)), (by simp : _)⟩ with hpa3
      have hpa3S : pa3 ∈ S := by
        simp [S, hpa3]
        use ⟨3, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      have hpa3' : 7 ∣ P (a + 3) := by
        rcases ha pa3 hpa3S with ⟨pi3, ⟨i3, hi3₁, hi3₂⟩, hpi3₁, hpi3₂⟩
        rw [← PNat.coe_le_coe, hb] at hi3₁
        rw [← PNat.coe_inj.ne, hi3₂, hpa3, PNat.mk_coe] at hpi3₁
        rw [hi3₂, hpa3, PNat.mk_coe] at hpi3₂
        have hi3 := i3.pos
        interval_cases i3.val
        · have h := gcd_p_of_diff_two (by ring: (a + 3) = (a + 1) + 2) hpi3₂
          rw [← h]
          apply Nat.gcd_dvd_left
        · exfalso
          exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) hpi3₂
        · exfalso
          rw [ne_self_iff_false] at hpi3₁
          exact hpi3₁
        · exfalso
          rw [Nat.coprime_comm] at hpi3₂
          exact gcd_p_of_diff_one (by ring: (a + 4) = (a + 3) + 1) hpi3₂
        · rw [Nat.coprime_comm] at hpi3₂
          have h := gcd_p_of_diff_two (by ring: (a + 5) = (a + 3) + 2) hpi3₂
          rw [← h]
          apply Nat.gcd_dvd_right
      set pa2 : ℕ+ := ⟨(P (a + 2)), (by simp : _)⟩ with hpa2
      have hpa2S : pa2 ∈ S := by
        simp [S, hpa2]
        use ⟨2, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      have hpa2' : 7 ∣ P (a + 2) ∨ 3 ∣ P (a + 2) := by
        rcases ha pa2 hpa2S with ⟨pi2, ⟨i2, hi2₁, hi2₂⟩, hpi2₁, hpi2₂⟩
        rw [← PNat.coe_le_coe, hb] at hi2₁
        rw [← PNat.coe_inj.ne, hi2₂, hpa2, PNat.mk_coe] at hpi2₁
        rw [hi2₂, hpa2, PNat.mk_coe] at hpi2₂
        have hi2 := i2.pos
        interval_cases i2.val
        · exfalso
          exact gcd_p_of_diff_one (by ring: (a + 2) = (a + 1) + 1) hpi2₂
        · exfalso
          rw [ne_self_iff_false] at hpi2₁
          exact hpi2₁
        · exfalso
          rw [Nat.coprime_comm] at hpi2₂
          exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) hpi2₂
        · left
          rw [Nat.coprime_comm] at hpi2₂
          have h := gcd_p_of_diff_two (by ring: (a + 4) = (a + 2) + 2) hpi2₂
          rw [← h]
          apply Nat.gcd_dvd_right
        · right
          rw [Nat.coprime_comm] at hpi2₂
          have h := gcd_p_of_diff_three (by ring: (a + 5) = (a + 2) + 3) hpi2₂
          rw [← h]
          apply Nat.gcd_dvd_right
      set pa4 : ℕ+ := ⟨(P (a + 4)), (by simp : _)⟩ with hpa4
      have hpa4S : pa4 ∈ S := by
        simp [S, hpa4]
        use ⟨4, (by norm_num : _)⟩
        simp
        rw [← PNat.coe_le_coe, PNat.val_ofNat, hb]
        norm_num
      have hpa4' : 7 ∣ P (a + 4) ∨ 3 ∣ P (a + 4) := by
        rcases ha pa4 hpa4S with ⟨pi4, ⟨i4, hi4₁, hi4₂⟩, hpi4₁, hpi4₂⟩
        rw [← PNat.coe_le_coe, hb] at hi4₁
        rw [← PNat.coe_inj.ne, hi4₂, hpa4, PNat.mk_coe] at hpi4₁
        rw [hi4₂, hpa4, PNat.mk_coe] at hpi4₂
        have hi4 := i4.pos
        interval_cases i4.val
        · right
          have h := gcd_p_of_diff_three (by ring: (a + 4) = (a + 1) + 3) hpi4₂
          rw [← h]
          apply Nat.gcd_dvd_left
        · left
          have h := gcd_p_of_diff_two (by ring: (a + 4) = (a + 2) + 2) hpi4₂
          rw [← h]
          apply Nat.gcd_dvd_left
        · exfalso
          exact gcd_p_of_diff_one (by ring: (a + 4) = (a + 3) + 1) hpi4₂
        · exfalso
          exact false_of_ne hpi4₁
        · exfalso
          rw [Nat.coprime_comm] at hpi4₂
          exact gcd_p_of_diff_one (by ring: (a + 5) = (a + 4) + 1) hpi4₂
      by_cases hpa2pa4 : 3 ∣ P (a + 2) ∧ 3 ∣ P (a + 4)
      · have hpa2pa4' := Nat.dvd_gcd hpa2pa4.right hpa2pa4.left
        have hpa2pa4'' : ¬Nat.Coprime (P (a + 4)) (P (a + 2)) := by
          rw [Nat.coprime_iff_gcd_eq_one]
          contrapose! hpa2pa4'
          rw [hpa2pa4']
          norm_num
        have h := gcd_p_of_diff_two (by ring: (a + 4) = (a + 2) + 2) hpa2pa4''
        rw [h] at hpa2pa4'
        norm_num at hpa2pa4'
      · have hpa2pa4' : 7 ∣ P (a + 2) ∨ 7 ∣ P (a + 4) := by tauto
        rcases hpa2pa4' with (hpa2''|hpa4'')
        · have h := Nat.not_coprime_of_dvd_of_dvd (by norm_num : 1 < 7) hpa3' hpa2''
          exact gcd_p_of_diff_one (by ring: (a + 3) = (a + 2) + 1) h
        · have h := Nat.not_coprime_of_dvd_of_dvd (by norm_num : 1 < 7) hpa4'' hpa3'
          exact gcd_p_of_diff_one (by ring: (a + 4) = (a + 3) + 1) h

end Imo2016P4

-- ═══ Imo2018P2 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Clayton Knittel
-/





/-!
# International Mathematical Olympiad 2018, Problem 2

Determine all integers n ≥ 3 such that there exist real numbers
a₁, a₂, ..., aₙ satisfying

  aᵢaᵢ₊₁ + 1 = aᵢ₊₂,

where the indices are taken mod n.
-/

namespace Imo2018P2

abbrev P {n : ℕ} (a : ZMod n → ℝ) :=
  ∀ (i : ZMod n), a i * a (i + 1) + 1 = a (i + 2)



lemma not_dvd_prime_exists_mod_inverse {n p : ℕ} [NeZero n]
    (pp : p.Prime) (hn : 1 < n) (h : ¬p ∣ n) :
    ∃ c : ZMod n, p * c = 1 := by
  let ⟨c, hc⟩ := Nat.exists_mul_mod_eq_one_of_coprime
    ((pp.coprime_iff_not_dvd).mpr h) hn
  exists c
  rw [← Nat.cast_one, ← Nat.cast_mul, ZMod.natCast_eq_natCast_iff]
  change _ % n = _ % n
  rw [Nat.mod_eq_of_lt hn]
  exact hc.2

lemma mod_3_satisfies {n : ℕ} (hn : 3 ≤ n) (hd : 3 ∣ n) :
    ∃ a : ZMod n → ℝ, P a := by
  have : Fact (1 < n) := ⟨Nat.lt_of_add_left_lt hn⟩

  let fn : ZMod n → ℝ := fun i => if 3 ∣ i.val then 2 else -1
  exists fn
  intro i

  have :
      (3 ∣ i.val ∧ ¬3 ∣ (i + 1).val ∧ ¬3 ∣ (i + 2).val) ∨
      (¬3 ∣ i.val ∧ 3 ∣ (i + 1).val ∧ ¬3 ∣ (i + 2).val) ∨
      (¬3 ∣ i.val ∧ ¬3 ∣ (i + 1).val ∧ 3 ∣ (i + 2).val) := by
    mod_cases h : i.val % 3
    all_goals {
      repeat rw [Nat.dvd_iff_mod_eq_zero]
      repeat rw [ZMod.val_add, Nat.mod_mod_of_dvd _ hd,
                 Nat.add_mod i.val]
      rw [h, ZMod.val_one, ZMod.val_ofNat_of_lt hn]
      norm_num
    }

  refine this.by_cases ?_ (Or.by_cases · ?_ ?_)
  all_goals {
    intro h
    simp [fn, h]
    norm_num
  }

lemma three_periodic {n : ℕ} [NeZero n] {i : ZMod n} {a : ZMod n → ℝ} (ha : P a)
    : a i = a (i + 3) := by
  have (i : ZMod n) : a (i + 2) ^ 2 - a (i + 2) = a i * a (i + 3) - a i := by
    calc
      _ = a i * a (i + 1) * a (i + 2) := by rw [← ha i]; ring_nf
      _ = a i * (a (i + 1 + 2) - 1) := by rw [← ha (i + 1)]; ring_nf
      _ = a i * a (i + 3) - a i := by ring_nf

  have : ∑ i, a i ^ 2 = ∑ i, a i * a (i + 3) := by
    have h : ∑ i : ZMod n, (a (i + 2) ^ 2 - a (i + 2)) =
             ∑ i : ZMod n, (a i * a (i + 3) - a i) :=
      Finset.sum_congr rfl (fun i _ => this i)
    repeat rw [Finset.sum_sub_distrib] at h

    have := Equiv.sum_comp (Equiv.addRight 2) a
    dsimp at this
    rw [this] at h

    have : ∑ i, a (i + 2) ^ 2 = ∑ i, a i ^ 2:=
      Equiv.sum_comp (Equiv.addRight 2) ((a ·) ^ 2)
    rw [this] at h

    apply_fun (· + ∑ i, a i) at h
    simp at h
    exact h

  have : 2 * (∑ i, a i ^ 2 - ∑ i, a i * a (i + 3)) = 0 := by
    rw [sub_eq_zero.mpr this]
    norm_num

  have : 0 = ∑ i, (a i - a (i + 3)) ^ 2 := by
    calc
      0 = 2 * (∑ i, a i ^ 2 - ∑ i, a i * a (i + 3)) := this.symm
      _ = ∑ i, a i ^ 2 + ∑ i, a i ^ 2 - 2 * ∑ i, a i * a (i + 3) := by ring_nf
      _ = ∑ i, a i ^ 2 + ∑ i, a (i + 3) ^ 2 - 2 * ∑ i, a i * a (i + 3) := by
        have := Equiv.sum_comp (Equiv.addRight 3) ((a ·) ^ 2)
        dsimp at this
        rw [this]
      _ = ∑ i, (a i ^ 2 + a (i + 3) ^ 2 - 2 * a i * a (i + 3)) := by
        rw [Finset.sum_sub_distrib, Finset.sum_add_distrib, Finset.mul_sum]
        simp only [mul_assoc]
      _ = ∑ i, (a i - a (i + 3)) ^ 2 := by ring_nf

  have {i : ZMod n} : (a i - a (i + 3)) ^ 2 = 0 := by
    refine (Finset.sum_eq_zero_iff_of_nonneg ?_).mp this.symm i ?_
    · exact fun _ _ => sq_nonneg _
    · exact Finset.mem_univ _

  apply_fun (· - a (i + 3)) using add_left_injective _
  dsimp
  rw [eq_zero_of_pow_eq_zero this]
  norm_num

lemma satisfies_is_mod_3 {n : ℕ} (hn : 3 ≤ n) (h : ∃ a : ZMod n → ℝ, P a) :
    3 ∣ n := by
  have n_gt_1 : 1 < n := Nat.lt_of_add_left_lt hn
  have : Fact (1 < n) := ⟨n_gt_1⟩
  obtain ⟨a, ha⟩ := h

  have three_periodic' {i c : ZMod n} : a i = a (3 * c + i) := by
    rw [← ZMod.natCast_zmod_val c]
    induction c.val with
    | zero => simp
    | succ d ih =>
      rw [Nat.cast_add, mul_add, Nat.cast_one, mul_one,
          add_right_comm, ← three_periodic ha]
      exact ih

  by_contra h
  let ha_0 := ha 0
  rw [← one_add_one_eq_two, ← add_assoc] at ha_0

  have {i : ZMod n} : a i = a (i + 1) := by
    mod_cases h_dvd : n % 3
    · absurd h
      exact Nat.dvd_of_mod_eq_zero h_dvd
    all_goals {
      let ⟨x, y⟩ := not_dvd_prime_exists_mod_inverse Nat.prime_three n_gt_1 h
      dsimp at y
      rw [← y, add_comm, ← three_periodic']
    }
  repeat rw [← this] at ha_0
  apply_fun (· - a 0) at ha_0
  rw [add_sub_right_comm] at ha_0
  field_simp at ha_0

  have : ¬∃ x : ℝ, x * x - x + 1 = 0 := by
    intro ⟨x, hx⟩
    suffices x * x - x + 1 ≠ 0 from this hx
    have : x * x - x + 1 = (x - 1/2)^2 + 3/4 := by ring_nf
    have : (x - 1/2)^2 ≥ 0 := sq_nonneg _
    linarith
  apply this
  exists a 0
  linarith



noncomputable def solution_set : Set ℕ := { n | 3 ≤ n ∧ 3 ∣ n }

theorem imo2018_p2 (n : ℕ) :
    n ∈ solution_set ↔ 3 ≤ n ∧ ∃ a : ZMod n → ℝ, P a := by
  constructor
  · rintro ⟨h₁, h₂⟩
    exact ⟨h₁, mod_3_satisfies h₁ h₂⟩
  · rintro ⟨h₁, h₂⟩
    exact ⟨h₁, satisfies_is_mod_3 h₁ h₂⟩

end Imo2018P2

-- ═══ Imo2019P1 ═══

/-
Copyright (c) 2023 Moritz Firsching. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Firsching
-/




/-!
# International Mathematical Olympiad 2019, Problem 1
Let ℤ be the set of integers. Determine all functions f : ℤ → ℤ such that,
for all integers a and b,￼

   f(2 * a) + 2 * f(b) = f(f(a + b)).
-/

namespace Imo2019P1



-- proof of the following lemma suggested on Zulip by Riccardo Brasca
lemma additive_to_int_linear (f : ℤ → ℤ) (h: ∀ (x y : ℤ), f (x + y) = f x + f y):
   ∃ c, ∀ a, f a = c * a := by
  let g := AddMonoidHom.toIntLinearMap <| AddMonoidHom.mk' f h
  refine ⟨f 1, fun a => ?_⟩
  change g a = g 1 * a
  exact (Dual.apply_one_mul_eq g a).symm



noncomputable def solution_set : Set (ℤ → ℤ) :=
  { f | (∀ z, f z = 0) ∨ ∃ c, ∀ z, f z = 2 * z + c }

theorem imo2019_p1 (f : ℤ → ℤ) :
    (∀ a b, f (2 * a) + 2 * (f b) = f (f (a + b))) ↔ f ∈ solution_set := by
  -- Find that g(x) = f(x) - f(0) is linear and then deduce the rest.

  constructor; swap
  · intro hf a b
    obtain hf1 | hf2 := hf
    · simp [hf1]
    · obtain ⟨c, hc⟩ := hf2
      simp [hc]; ring
  intro hf
  let g : ℤ → ℤ := fun z => f z - f 0
  have hg : ∀z, g z = f z - f 0 := fun z => by rfl
  have : ∀ x y, g (x + y) = g x + g y := by
    intro x y
    simp only [hg]
    have hx := hf 0 (x + y)
    have hxy := hf x y
    have hx0 := hf x 0
    have h0x := hf 0 x
    simp at hx hx0 h0x
    lia
  have ⟨d, h⟩ : ∃ d, ∀ z, g z = d * z := additive_to_int_linear g this
  have hz : ∀ z, f z = d * z + f 0 := by
    intro z
    rw [← h z, hg, sub_add_cancel]
  by_cases hd : d = 0
  · left
    have : f 0 = 0 := by
      have := hf 0 0
      simp at this
      rw [hz (f 0), hz 0, hd] at this
      simp at this
      exact this
    intro z
    convert hz z
    rw [hd, this, zero_mul, add_zero]
  · right
    use f 0
    by_cases hf₀ : f 0 = 0
    · have := hf 1 0
      simp at this
      rw [hz (f 1), hz 2, hz 1, hf₀] at this
      simp [hd] at this
      convert hz
    · have := hf 0 0
      simp at this
      rw [hz (f 0), add_comm, add_right_cancel_iff] at this
      rw [← ne_eq] at hf₀
      have := Int.eq_of_mul_eq_mul_right hf₀ this
      convert hz


end Imo2019P1

-- ═══ Imo2019P2 ═══

/-
Copyright (c) 2022 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/




/-!
# International Mathematical Olympiad 2019, Problem 2

In triangle `ABC`, point `A₁` lies on side `BC` and point `B₁` lies on side `AC`. Let `P` and
`Q` be points on segments `AA₁` and `BB₁`, respectively, such that `PQ` is parallel to `AB`.
Let `P₁` be a point on line `PB₁`, such that `B₁` lies strictly between `P` and `P₁`, and
`∠PP₁C = ∠BAC`. Similarly, let `Q₁` be a point on line `QA₁`, such that `A₁` lies strictly
between `Q` and `Q₁`, and `∠CQ₁Q = ∠CBA`.

Prove that points `P`, `Q`, `P₁`, and `Q₁` are concyclic.
-/

open Affine Affine.Simplex EuclideanGeometry FiniteDimensional Module

open scoped Affine EuclideanGeometry Real

attribute [local instance] FiniteDimensional.of_fact_finrank_eq_two

variable (V : Type*) (Pt : Type*)

variable [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace Pt]

variable [NormedAddTorsor V Pt]

namespace Imo2019P2



/-
We follow Solution 1 from the
[official solutions](https://www.imo2019.uk/wp-content/uploads/2018/07/solutions-r856.pdf).
Letting the rays `AA₁` and `BB₁` intersect the circumcircle of `ABC` at `A₂` and `B₂`
respectively, we show with an angle chase that `P`, `Q`, `A₂`, `B₂` are concyclic and let `ω` be
the circle through those points. We then show that `C`, `Q₁`, `A₂`, `A₁` are concyclic, and
then that `Q₁` lies on `ω`, and similarly that `P₁` lies on `ω`, so the required four points are
concyclic.

Note that most of the formal proof is actually proving nondegeneracy conditions needed for that
angle chase / concyclicity argument, where an informal solution doesn't discuss those conditions
at all. Also note that (as described in `Geometry.Euclidean.Angle.Oriented.Basic`) the oriented
angles used are modulo `2 * π`, so parts of the angle chase that are only valid for angles modulo
`π` (as used in the informal solution) are represented as equalities of twice angles, which we write
as `(2 : ℤ) • ∡ _ _ _ = (2 : ℤ) • ∡ _ _ _`.
-/

/-
We apply the following conventions for formalizing IMO geometry problems. A problem is assumed
to take place in the plane unless that is clearly not intended, so it is not required to prove
that the points are coplanar (whether or not that in fact follows from the other conditions).
Angles in problem statements are taken to be unoriented. A reference to an angle `∠XYZ` is taken
to imply that `X` and `Z` are not equal to `Y`, since choices of junk values play no role in
informal mathematics, and those implications are included as hypotheses for the problem whether
or not they follow from the other hypotheses. Similar, a reference to `XY` as a line is taken to
imply that `X` does not equal `Y` and that is included as a hypothesis, and a reference to `XY`
being parallel to something is considered a reference to it as a line. However, such an implicit
hypothesis about two points being different is included only once for any given two points (even
if it follows from more than one reference to a line or an angle), if `X ≠ Y` is included then
`Y ≠ X` is not included separately, and such hypotheses are not included in the case where there
is also a reference in the problem to a triangle including those two points, or to strict
betweenness of three points including those two. If betweenness is stated, it is taken to be
strict betweenness. However, segments and sides are taken to include their endpoints (unless
this makes a problem false), although those degenerate cases might not necessarily have been
considered when the problem was formulated and contestants might not have been expected to deal
with them. A reference to a point being on a side or a segment is expressed directly with `Wbtw`
rather than more literally with `affineSegment`.
-/

noncomputable section

/-- A configuration satisfying the conditions of the problem. We define this structure to avoid
passing many hypotheses around as we build up information about the configuration; the final
result for a statement of the problem not using this structure is then deduced from one in terms
of this structure. -/
structure Imo2019q2Cfg where
  (A B C A₁ B₁ P Q P₁ Q₁ : Pt)
  affineIndependent_ABC : AffineIndependent ℝ ![A, B, C]
  wbtw_B_A₁_C : Wbtw ℝ B A₁ C
  wbtw_A_B₁_C : Wbtw ℝ A B₁ C
  wbtw_A_P_A₁ : Wbtw ℝ A P A₁
  wbtw_B_Q_B₁ : Wbtw ℝ B Q B₁
  PQ_parallel_AB : line[ℝ, P, Q] ∥ line[ℝ, A, B]
  -- A hypothesis implicit in the named line.
  P_ne_Q : P ≠ Q
  sbtw_P_B₁_P₁ : Sbtw ℝ P B₁ P₁
  angle_PP₁C_eq_angle_BAC : ∠ P P₁ C = ∠ B A C
  -- A hypothesis implicit in the first named angle.
  C_ne_P₁ : C ≠ P₁
  sbtw_Q_A₁_Q₁ : Sbtw ℝ Q A₁ Q₁
  angle_CQ₁Q_eq_angle_CBA : ∠ C Q₁ Q = ∠ C B A
  -- A hypothesis implicit in the first named angle.
  C_ne_Q₁ : C ≠ Q₁

/-- A default choice of orientation, for lemmas that need to pick one. -/
def someOrientation  [hd2 : Fact (finrank ℝ V = 2)] : Module.Oriented ℝ V (Fin 2) :=
  ⟨Basis.orientation (finBasisOfFinrankEq _ _ hd2.out)⟩

variable {V Pt}

namespace Imo2019q2Cfg

variable (cfg : Imo2019q2Cfg V Pt)

/-- The configuration has symmetry, allowing results proved for one point to be applied for
another (where the informal solution says "similarly"). -/
def symm : Imo2019q2Cfg V Pt where
  A := cfg.B
  B := cfg.A
  C := cfg.C
  A₁ := cfg.B₁
  B₁ := cfg.A₁
  P := cfg.Q
  Q := cfg.P
  P₁ := cfg.Q₁
  Q₁ := cfg.P₁
  affineIndependent_ABC := by
    rw [← affineIndependent_equiv (Equiv.swap (0 : Fin 3) 1)]
    convert cfg.affineIndependent_ABC using 1
    ext x
    fin_cases x <;> rfl
  wbtw_B_A₁_C := cfg.wbtw_A_B₁_C
  wbtw_A_B₁_C := cfg.wbtw_B_A₁_C
  wbtw_A_P_A₁ := cfg.wbtw_B_Q_B₁
  wbtw_B_Q_B₁ := cfg.wbtw_A_P_A₁
  PQ_parallel_AB := Set.pair_comm cfg.P cfg.Q ▸ Set.pair_comm cfg.A cfg.B ▸ cfg.PQ_parallel_AB
  P_ne_Q := cfg.P_ne_Q.symm
  sbtw_P_B₁_P₁ := cfg.sbtw_Q_A₁_Q₁
  angle_PP₁C_eq_angle_BAC :=
    angle_comm cfg.C cfg.Q₁ cfg.Q ▸ angle_comm cfg.C cfg.B cfg.A ▸ cfg.angle_CQ₁Q_eq_angle_CBA
  C_ne_P₁ := cfg.C_ne_Q₁
  sbtw_Q_A₁_Q₁ := cfg.sbtw_P_B₁_P₁
  angle_CQ₁Q_eq_angle_CBA :=
    angle_comm cfg.P cfg.P₁ cfg.C ▸ angle_comm cfg.B cfg.A cfg.C ▸ cfg.angle_PP₁C_eq_angle_BAC
  C_ne_Q₁ := cfg.C_ne_P₁

/- ### Configuration properties that are obvious from the diagram, and construction of the
points `A₂` and `B₂` -/

theorem A_ne_B : cfg.A ≠ cfg.B :=
  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) ≠ 1)

theorem A_ne_C : cfg.A ≠ cfg.C :=
  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) ≠ 2)

theorem B_ne_C : cfg.B ≠ cfg.C :=
  cfg.affineIndependent_ABC.injective.ne (by decide : (1 : Fin 3) ≠ 2)

theorem not_collinear_ABC : ¬Collinear ℝ ({cfg.A, cfg.B, cfg.C} : Set Pt) :=
  affineIndependent_iff_not_collinear_set.1 cfg.affineIndependent_ABC

/-- `ABC` as a `Triangle`. -/
def triangleABC : Triangle ℝ Pt :=
  ⟨_, cfg.affineIndependent_ABC⟩

theorem A_mem_circumsphere : cfg.A ∈ cfg.triangleABC.circumsphere :=
  cfg.triangleABC.mem_circumsphere 0

theorem B_mem_circumsphere : cfg.B ∈ cfg.triangleABC.circumsphere :=
  cfg.triangleABC.mem_circumsphere 1

theorem C_mem_circumsphere : cfg.C ∈ cfg.triangleABC.circumsphere :=
  cfg.triangleABC.mem_circumsphere 2

theorem symm_triangleABC : cfg.symm.triangleABC = cfg.triangleABC.reindex (Equiv.swap 0 1) := by
  ext i; fin_cases i <;> rfl

theorem symm_triangleABC_circumsphere :
    cfg.symm.triangleABC.circumsphere = cfg.triangleABC.circumsphere := by
  rw [symm_triangleABC, Affine.Simplex.circumsphere_reindex]

/-- `A₂` is the second point of intersection of the ray `AA₁` with the circumcircle of `ABC`. -/
def A₂ : Pt :=
  cfg.triangleABC.circumsphere.secondInter cfg.A (cfg.A₁ -ᵥ cfg.A)

/-- `B₂` is the second point of intersection of the ray `BB₁` with the circumcircle of `ABC`. -/
def B₂ : Pt :=
  cfg.triangleABC.circumsphere.secondInter cfg.B (cfg.B₁ -ᵥ cfg.B)

theorem A₂_mem_circumsphere : cfg.A₂ ∈ cfg.triangleABC.circumsphere :=
  (Sphere.secondInter_mem _).2 cfg.A_mem_circumsphere

theorem B₂_mem_circumsphere : cfg.B₂ ∈ cfg.triangleABC.circumsphere :=
  (Sphere.secondInter_mem _).2 cfg.B_mem_circumsphere

theorem symm_A₂ : cfg.symm.A₂ = cfg.B₂ := by simp_rw [A₂, B₂, symm_triangleABC_circumsphere]; rfl

theorem QP_parallel_BA : line[ℝ, cfg.Q, cfg.P] ∥ line[ℝ, cfg.B, cfg.A] := by
  rw [Set.pair_comm cfg.Q, Set.pair_comm cfg.B]; exact cfg.PQ_parallel_AB

theorem A_ne_A₁ : cfg.A ≠ cfg.A₁ := by
  intro h
  have h' := cfg.not_collinear_ABC
  rw [h, Set.insert_comm] at h'
  exact h' cfg.wbtw_B_A₁_C.collinear

theorem collinear_PAA₁A₂ : Collinear ℝ ({cfg.P, cfg.A, cfg.A₁, cfg.A₂} : Set Pt) := by
  rw [A₂,
    (cfg.triangleABC.circumsphere.secondInter_collinear cfg.A cfg.A₁).collinear_insert_iff_of_ne
      (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) cfg.A_ne_A₁,
    Set.insert_comm]
  exact cfg.wbtw_A_P_A₁.collinear

theorem A₁_ne_C : cfg.A₁ ≠ cfg.C := by
  intro h
  have hsbtw := cfg.sbtw_Q_A₁_Q₁
  rw [h] at hsbtw
  have ha := hsbtw.angle₂₃₁_eq_zero
  rw [angle_CQ₁Q_eq_angle_CBA, angle_comm] at ha
  exact (angle_ne_zero_of_not_collinear cfg.not_collinear_ABC) ha

theorem B₁_ne_C : cfg.B₁ ≠ cfg.C :=
  cfg.symm.A₁_ne_C

theorem Q_not_mem_CB : cfg.Q ∉ line[ℝ, cfg.C, cfg.B] := by
  intro hQ
  have hQA₁ : line[ℝ, cfg.Q, cfg.A₁] ≤ line[ℝ, cfg.C, cfg.B] :=
    affineSpan_pair_le_of_mem_of_mem hQ cfg.wbtw_B_A₁_C.symm.mem_affineSpan
  have hQ₁ : cfg.Q₁ ∈ line[ℝ, cfg.C, cfg.B] := by
    rw [AffineSubspace.le_def'] at hQA₁
    exact hQA₁ _ cfg.sbtw_Q_A₁_Q₁.right_mem_affineSpan
  have hc : Collinear ℝ ({cfg.C, cfg.Q₁, cfg.Q} : Set Pt) :=
    haveI hc' : Collinear ℝ ({cfg.B, cfg.C, cfg.Q₁, cfg.Q} : Set Pt) := by
      rw [Set.insert_comm cfg.B, Set.insert_comm cfg.B, Set.pair_comm, Set.insert_comm cfg.C,
        Set.insert_comm cfg.C]
      exact collinear_insert_insert_of_mem_affineSpan_pair hQ₁ hQ
    hc'.subset (Set.subset_insert _ _)
  rw [collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi, cfg.angle_CQ₁Q_eq_angle_CBA,
    or_iff_right cfg.C_ne_Q₁, or_iff_right cfg.sbtw_Q_A₁_Q₁.left_ne_right, angle_comm] at hc
  exact cfg.not_collinear_ABC (hc.elim collinear_of_angle_eq_zero collinear_of_angle_eq_pi)

theorem Q_ne_B : cfg.Q ≠ cfg.B := by
  intro h
  have h' := cfg.Q_not_mem_CB
  rw [h] at h'
  exact h' (right_mem_affineSpan_pair _ _ _)

theorem sOppSide_CB_Q_Q₁ : line[ℝ, cfg.C, cfg.B].SOppSide cfg.Q cfg.Q₁ :=
  cfg.sbtw_Q_A₁_Q₁.sOppSide_of_notMem_of_mem cfg.Q_not_mem_CB cfg.wbtw_B_A₁_C.symm.mem_affineSpan

/- ### Relate the orientations of different angles in the configuration -/

section Oriented

variable [Module.Oriented ℝ V (Fin 2)]

theorem oangle_CQ₁Q_sign_eq_oangle_CBA_sign [Fact (finrank ℝ V = 2)] :
    (∡ cfg.C cfg.Q₁ cfg.Q).sign = (∡ cfg.C cfg.B cfg.A).sign := by
  rw [← cfg.sbtw_Q_A₁_Q₁.symm.oangle_eq_right,
    cfg.sOppSide_CB_Q_Q₁.oangle_sign_eq_neg (left_mem_affineSpan_pair ℝ cfg.C cfg.B)
      cfg.wbtw_B_A₁_C.symm.mem_affineSpan,
    ← Real.Angle.sign_neg, ← oangle_rev,
    cfg.wbtw_B_A₁_C.oangle_sign_eq_of_ne_right cfg.Q cfg.A₁_ne_C, oangle_rotate_sign,
    cfg.wbtw_B_Q_B₁.oangle_eq_right cfg.Q_ne_B,
    cfg.wbtw_A_B₁_C.symm.oangle_sign_eq_of_ne_left cfg.B cfg.B₁_ne_C.symm]

theorem oangle_CQ₁Q_eq_oangle_CBA [Fact (finrank ℝ V = 2)] :
    ∡ cfg.C cfg.Q₁ cfg.Q = ∡ cfg.C cfg.B cfg.A :=
  oangle_eq_of_angle_eq_of_sign_eq cfg.angle_CQ₁Q_eq_angle_CBA
    cfg.oangle_CQ₁Q_sign_eq_oangle_CBA_sign

end Oriented

/- ### More obvious configuration properties -/

section

variable [hd2 : Fact (finrank ℝ V = 2)]

theorem A₁_ne_B : cfg.A₁ ≠ cfg.B := by
  intro h
  have hwbtw := cfg.wbtw_A_P_A₁
  rw [h] at hwbtw
  have hPQ : line[ℝ, cfg.P, cfg.Q] = line[ℝ, cfg.A, cfg.B] := by
    rw [AffineSubspace.eq_iff_direction_eq_of_mem (left_mem_affineSpan_pair _ _ _)
      hwbtw.mem_affineSpan]
    exact cfg.PQ_parallel_AB.direction_eq
  haveI := someOrientation V
  have haQ : (2 : ℤ) • ∡ cfg.C cfg.B cfg.Q = (2 : ℤ) • ∡ cfg.C cfg.B cfg.A := by
    rw [Collinear.two_zsmul_oangle_eq_right _ cfg.A_ne_B cfg.Q_ne_B]
    rw [Set.pair_comm, Set.insert_comm]
    refine collinear_insert_of_mem_affineSpan_pair ?_
    rw [← hPQ]
    exact right_mem_affineSpan_pair _ _ _
  have ha : (2 : ℤ) • ∡ cfg.C cfg.B cfg.Q = (2 : ℤ) • ∡ cfg.C cfg.Q₁ cfg.Q := by
    rw [oangle_CQ₁Q_eq_oangle_CBA, haQ]
  have hn : ¬Collinear ℝ ({cfg.C, cfg.B, cfg.Q} : Set Pt) := by
    rw [collinear_iff_of_two_zsmul_oangle_eq haQ, Set.pair_comm, Set.insert_comm, Set.pair_comm]
    exact cfg.not_collinear_ABC
  have hc := cospherical_of_two_zsmul_oangle_eq_of_not_collinear ha hn
  have hBQ₁ : cfg.B ≠ cfg.Q₁ := by rw [← h]; exact cfg.sbtw_Q_A₁_Q₁.ne_right
  have hQQ₁ : cfg.Q ≠ cfg.Q₁ := cfg.sbtw_Q_A₁_Q₁.left_ne_right
  have hBQ₁Q : AffineIndependent ℝ ![cfg.B, cfg.Q₁, cfg.Q] :=
    hc.affineIndependent_of_mem_of_ne (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
      (Set.mem_insert_of_mem _
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))
      hBQ₁ cfg.Q_ne_B.symm hQQ₁.symm
  rw [affineIndependent_iff_not_collinear_set] at hBQ₁Q
  refine hBQ₁Q ?_
  rw [← h, Set.pair_comm, Set.insert_comm]
  exact cfg.sbtw_Q_A₁_Q₁.wbtw.collinear

theorem sbtw_B_A₁_C : Sbtw ℝ cfg.B cfg.A₁ cfg.C :=
  ⟨cfg.wbtw_B_A₁_C, cfg.A₁_ne_B, cfg.A₁_ne_C⟩

theorem sbtw_A_B₁_C : Sbtw ℝ cfg.A cfg.B₁ cfg.C :=
  cfg.symm.sbtw_B_A₁_C

theorem sbtw_A_A₁_A₂ : Sbtw ℝ cfg.A cfg.A₁ cfg.A₂ := by
  refine Sphere.sbtw_secondInter cfg.A_mem_circumsphere ?_
  convert cfg.sbtw_B_A₁_C.dist_lt_max_dist _
  change _ = max (dist (cfg.triangleABC.points 1) _) (dist (cfg.triangleABC.points 2) _)
  simp_rw [circumsphere_center, circumsphere_radius, dist_circumcenter_eq_circumradius, max_self]

theorem sbtw_B_B₁_B₂ : Sbtw ℝ cfg.B cfg.B₁ cfg.B₂ := by
  rw [← cfg.symm_A₂]; exact cfg.symm.sbtw_A_A₁_A₂

theorem A₂_ne_A : cfg.A₂ ≠ cfg.A :=
  cfg.sbtw_A_A₁_A₂.left_ne_right.symm

theorem A₂_ne_P : cfg.A₂ ≠ cfg.P :=
  (cfg.sbtw_A_A₁_A₂.trans_wbtw_left_ne cfg.wbtw_A_P_A₁).symm

theorem A₂_ne_B : cfg.A₂ ≠ cfg.B := by
  intro h
  have h₁ := cfg.sbtw_A_A₁_A₂
  rw [h] at h₁
  refine cfg.not_collinear_ABC ?_
  have hc : Collinear ℝ ({cfg.A, cfg.C, cfg.B, cfg.A₁} : Set Pt) :=
    collinear_insert_insert_of_mem_affineSpan_pair h₁.left_mem_affineSpan
      cfg.sbtw_B_A₁_C.right_mem_affineSpan
  refine hc.subset ?_
  rw [Set.pair_comm _ cfg.A₁, Set.insert_comm _ cfg.A₁, Set.insert_comm _ cfg.A₁, Set.pair_comm]
  exact Set.subset_insert _ _

theorem A₂_ne_C : cfg.A₂ ≠ cfg.C := by
  intro h
  have h₁ := cfg.sbtw_A_A₁_A₂
  rw [h] at h₁
  refine cfg.not_collinear_ABC ?_
  have hc : Collinear ℝ ({cfg.A, cfg.B, cfg.C, cfg.A₁} : Set Pt) :=
    collinear_insert_insert_of_mem_affineSpan_pair h₁.left_mem_affineSpan
      cfg.sbtw_B_A₁_C.left_mem_affineSpan
  refine hc.subset (Set.insert_subset_insert (Set.insert_subset_insert ?_))
  rw [Set.singleton_subset_iff]
  exact Set.mem_insert _ _

theorem B₂_ne_B : cfg.B₂ ≠ cfg.B := by rw [← symm_A₂]; exact cfg.symm.A₂_ne_A

theorem B₂_ne_Q : cfg.B₂ ≠ cfg.Q := by rw [← symm_A₂]; exact cfg.symm.A₂_ne_P

theorem B₂_ne_A₂ : cfg.B₂ ≠ cfg.A₂ := by
  intro h
  have hA : Sbtw ℝ (cfg.triangleABC.points 1) cfg.A₁ (cfg.triangleABC.points 2) := cfg.sbtw_B_A₁_C
  have hB : Sbtw ℝ (cfg.triangleABC.points 0) cfg.B₁ (cfg.triangleABC.points 2) := cfg.sbtw_A_B₁_C
  have hA' : cfg.A₂ ∈ line[ℝ, cfg.triangleABC.points 0, cfg.A₁] :=
    Sphere.secondInter_vsub_mem_affineSpan _ _ _
  have hB' : cfg.A₂ ∈ line[ℝ, cfg.triangleABC.points 1, cfg.B₁] := by
    rw [← h]; exact Sphere.secondInter_vsub_mem_affineSpan _ _ _
  exact (sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair (by decide) hA hB hA' hB').symm.not_rotate
    cfg.sbtw_A_A₁_A₂.wbtw

theorem wbtw_B_Q_B₂ : Wbtw ℝ cfg.B cfg.Q cfg.B₂ :=
  cfg.sbtw_B_B₁_B₂.wbtw.trans_left cfg.wbtw_B_Q_B₁

/- ### The first equality in the first angle chase in the solution -/

section Oriented

variable [Module.Oriented ℝ V (Fin 2)]

theorem two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_BAA₂ :
    (2 : ℤ) • ∡ cfg.Q cfg.P cfg.A₂ = (2 : ℤ) • ∡ cfg.B cfg.A cfg.A₂ := by
  refine two_zsmul_oangle_of_parallel cfg.QP_parallel_BA ?_
  convert AffineSubspace.Parallel.refl (k := ℝ) (P := Pt) _ using 1
  rw [cfg.collinear_PAA₁A₂.affineSpan_eq_of_ne (Set.mem_insert_of_mem _
    (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))
    (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) cfg.A₂_ne_A,
      cfg.collinear_PAA₁A₂.affineSpan_eq_of_ne (Set.mem_insert_of_mem _
    (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))
    (Set.mem_insert _ _) cfg.A₂_ne_P]

end Oriented

/- ### More obvious configuration properties -/

theorem not_collinear_QPA₂ : ¬Collinear ℝ ({cfg.Q, cfg.P, cfg.A₂} : Set Pt) := by
  haveI := someOrientation V
  rw [collinear_iff_of_two_zsmul_oangle_eq cfg.two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_BAA₂, ←
    affineIndependent_iff_not_collinear_set]
  have h : Cospherical ({cfg.B, cfg.A, cfg.A₂} : Set Pt) := by
    refine cfg.triangleABC.circumsphere.cospherical.subset ?_
    simp only [Set.insert_subset_iff, cfg.A_mem_circumsphere, cfg.B_mem_circumsphere,
      cfg.A₂_mem_circumsphere, Sphere.mem_coe, Set.singleton_subset_iff, and_true]
  exact h.affineIndependent_of_ne cfg.A_ne_B.symm cfg.A₂_ne_B.symm cfg.A₂_ne_A.symm

theorem Q₁_ne_A₂ : cfg.Q₁ ≠ cfg.A₂ := by
  intro h
  have h₁ := cfg.sbtw_Q_A₁_Q₁
  rw [h] at h₁
  refine cfg.not_collinear_QPA₂ ?_
  have hA₂ := cfg.sbtw_A_A₁_A₂.right_mem_affineSpan
  have hA₂A₁ : line[ℝ, cfg.A₂, cfg.A₁] ≤ line[ℝ, cfg.A, cfg.A₁] :=
    affineSpan_pair_le_of_left_mem hA₂
  have hQ : cfg.Q ∈ line[ℝ, cfg.A, cfg.A₁] := by
    rw [AffineSubspace.le_def'] at hA₂A₁
    exact hA₂A₁ _ h₁.left_mem_affineSpan
  exact collinear_triple_of_mem_affineSpan_pair hQ cfg.wbtw_A_P_A₁.mem_affineSpan hA₂

theorem affineIndependent_QPA₂ : AffineIndependent ℝ ![cfg.Q, cfg.P, cfg.A₂] :=
  affineIndependent_iff_not_collinear_set.2 cfg.not_collinear_QPA₂

theorem affineIndependent_PQB₂ : AffineIndependent ℝ ![cfg.P, cfg.Q, cfg.B₂] := by
  rw [← symm_A₂]; exact cfg.symm.affineIndependent_QPA₂

/-- `QPA₂` as a `Triangle`. -/
def triangleQPA₂ : Triangle ℝ Pt := ⟨_, cfg.affineIndependent_QPA₂⟩

/-- `PQB₂` as a `Triangle`. -/
def trianglePQB₂ : Triangle ℝ Pt := ⟨_, cfg.affineIndependent_PQB₂⟩

theorem symm_triangleQPA₂ : cfg.symm.triangleQPA₂ = cfg.trianglePQB₂ := by
  simp_rw [trianglePQB₂, ← symm_A₂]; ext i; fin_cases i <;> rfl

/-- `ω` is the circle containing `Q`, `P` and `A₂`, which will be shown also to contain `B₂`,
`P₁` and `Q₁`. -/
def ω : Sphere Pt := cfg.triangleQPA₂.circumsphere

theorem P_mem_ω : cfg.P ∈ cfg.ω := cfg.triangleQPA₂.mem_circumsphere 1

theorem Q_mem_ω : cfg.Q ∈ cfg.ω :=
  cfg.triangleQPA₂.mem_circumsphere 0

/- ### The rest of the first angle chase in the solution -/

section Oriented

variable [Module.Oriented ℝ V (Fin 2)]

theorem two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_QB₂A₂ :
    (2 : ℤ) • ∡ cfg.Q cfg.P cfg.A₂ = (2 : ℤ) • ∡ cfg.Q cfg.B₂ cfg.A₂ :=
  calc
    (2 : ℤ) • ∡ cfg.Q cfg.P cfg.A₂ = (2 : ℤ) • ∡ cfg.B cfg.A cfg.A₂ :=
      cfg.two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_BAA₂
    _ = (2 : ℤ) • ∡ cfg.B cfg.B₂ cfg.A₂ :=
      (Sphere.two_zsmul_oangle_eq cfg.B_mem_circumsphere cfg.A_mem_circumsphere
        cfg.B₂_mem_circumsphere cfg.A₂_mem_circumsphere cfg.A_ne_B cfg.A₂_ne_A.symm cfg.B₂_ne_B
        cfg.B₂_ne_A₂)
    _ = (2 : ℤ) • ∡ cfg.Q cfg.B₂ cfg.A₂ := by
      rw [cfg.wbtw_B_Q_B₂.symm.oangle_eq_left cfg.B₂_ne_Q.symm]

end Oriented

/- ### Conclusions from that first angle chase -/

theorem cospherical_QPB₂A₂ : Cospherical ({cfg.Q, cfg.P, cfg.B₂, cfg.A₂} : Set Pt) :=
  haveI := someOrientation V
  cospherical_of_two_zsmul_oangle_eq_of_not_collinear
    cfg.two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_QB₂A₂ cfg.not_collinear_QPA₂

theorem symm_ω_eq_trianglePQB₂_circumsphere : cfg.symm.ω = cfg.trianglePQB₂.circumsphere := by
  rw [ω, symm_triangleQPA₂]

theorem symm_ω : cfg.symm.ω = cfg.ω := by
  rw [symm_ω_eq_trianglePQB₂_circumsphere, ω]
  refine circumsphere_eq_of_cospherical hd2.out cfg.cospherical_QPB₂A₂ ?_ ?_
  · simp only [trianglePQB₂, Matrix.range_cons, Matrix.range_empty, Set.singleton_union,
      insert_empty_eq]
    rw [Set.insert_comm]
    refine Set.insert_subset_insert (Set.insert_subset_insert ?_)
    simp
  · simp only [triangleQPA₂, Matrix.range_cons, Matrix.range_empty, Set.singleton_union,
      insert_empty_eq]
    refine Set.insert_subset_insert (Set.insert_subset_insert ?_)
    simp

/- ### The second angle chase in the solution -/

section Oriented

variable [Module.Oriented ℝ V (Fin 2)]

theorem two_zsmul_oangle_CA₂A₁_eq_two_zsmul_oangle_CBA :
    (2 : ℤ) • ∡ cfg.C cfg.A₂ cfg.A₁ = (2 : ℤ) • ∡ cfg.C cfg.B cfg.A :=
  calc
    (2 : ℤ) • ∡ cfg.C cfg.A₂ cfg.A₁ = (2 : ℤ) • ∡ cfg.C cfg.A₂ cfg.A := by
      rw [cfg.sbtw_A_A₁_A₂.symm.oangle_eq_right]
    _ = (2 : ℤ) • ∡ cfg.C cfg.B cfg.A :=
      Sphere.two_zsmul_oangle_eq cfg.C_mem_circumsphere cfg.A₂_mem_circumsphere
        cfg.B_mem_circumsphere cfg.A_mem_circumsphere cfg.A₂_ne_C cfg.A₂_ne_A cfg.B_ne_C
        cfg.A_ne_B.symm

theorem two_zsmul_oangle_CA₂A₁_eq_two_zsmul_oangle_CQ₁A₁ :
    (2 : ℤ) • ∡ cfg.C cfg.A₂ cfg.A₁ = (2 : ℤ) • ∡ cfg.C cfg.Q₁ cfg.A₁ :=
  calc
    (2 : ℤ) • ∡ cfg.C cfg.A₂ cfg.A₁ = (2 : ℤ) • ∡ cfg.C cfg.B cfg.A :=
      cfg.two_zsmul_oangle_CA₂A₁_eq_two_zsmul_oangle_CBA
    _ = (2 : ℤ) • ∡ cfg.C cfg.Q₁ cfg.Q := by rw [oangle_CQ₁Q_eq_oangle_CBA]
    _ = (2 : ℤ) • ∡ cfg.C cfg.Q₁ cfg.A₁ := by rw [cfg.sbtw_Q_A₁_Q₁.symm.oangle_eq_right]

end Oriented

/- ### Conclusions from that second angle chase -/

theorem not_collinear_CA₂A₁ : ¬Collinear ℝ ({cfg.C, cfg.A₂, cfg.A₁} : Set Pt) := by
  haveI := someOrientation V
  rw [collinear_iff_of_two_zsmul_oangle_eq cfg.two_zsmul_oangle_CA₂A₁_eq_two_zsmul_oangle_CBA,
    Set.pair_comm, Set.insert_comm, Set.pair_comm]
  exact cfg.not_collinear_ABC

theorem cospherical_A₁Q₁CA₂ : Cospherical ({cfg.A₁, cfg.Q₁, cfg.C, cfg.A₂} : Set Pt) := by
  haveI := someOrientation V
  rw [Set.insert_comm cfg.Q₁, Set.insert_comm cfg.A₁, Set.pair_comm, Set.insert_comm cfg.A₁,
    Set.pair_comm]
  exact cospherical_of_two_zsmul_oangle_eq_of_not_collinear
    cfg.two_zsmul_oangle_CA₂A₁_eq_two_zsmul_oangle_CQ₁A₁ cfg.not_collinear_CA₂A₁

/- ### The third angle chase in the solution -/

section Oriented

variable [Module.Oriented ℝ V (Fin 2)]

theorem two_zsmul_oangle_QQ₁A₂_eq_two_zsmul_oangle_QPA₂ :
    (2 : ℤ) • ∡ cfg.Q cfg.Q₁ cfg.A₂ = (2 : ℤ) • ∡ cfg.Q cfg.P cfg.A₂ :=
  calc
    (2 : ℤ) • ∡ cfg.Q cfg.Q₁ cfg.A₂ = (2 : ℤ) • ∡ cfg.A₁ cfg.Q₁ cfg.A₂ := by
      rw [cfg.sbtw_Q_A₁_Q₁.symm.oangle_eq_left]
    _ = (2 : ℤ) • ∡ cfg.A₁ cfg.C cfg.A₂ :=
      (cfg.cospherical_A₁Q₁CA₂.two_zsmul_oangle_eq cfg.sbtw_Q_A₁_Q₁.right_ne cfg.Q₁_ne_A₂
        cfg.A₁_ne_C.symm cfg.A₂_ne_C.symm)
    _ = (2 : ℤ) • ∡ cfg.B cfg.C cfg.A₂ := by rw [cfg.sbtw_B_A₁_C.symm.oangle_eq_left]
    _ = (2 : ℤ) • ∡ cfg.B cfg.A cfg.A₂ :=
      (Sphere.two_zsmul_oangle_eq cfg.B_mem_circumsphere cfg.C_mem_circumsphere
        cfg.A_mem_circumsphere cfg.A₂_mem_circumsphere cfg.B_ne_C.symm cfg.A₂_ne_C.symm cfg.A_ne_B
        cfg.A₂_ne_A.symm)
    _ = (2 : ℤ) • ∡ cfg.Q cfg.P cfg.A₂ := cfg.two_zsmul_oangle_QPA₂_eq_two_zsmul_oangle_BAA₂.symm

end Oriented

/- ### Conclusions from that third angle chase -/

theorem Q₁_mem_ω : cfg.Q₁ ∈ cfg.ω :=
  haveI := someOrientation V
  Affine.Triangle.mem_circumsphere_of_two_zsmul_oangle_eq (by decide : (0 : Fin 3) ≠ 1)
    (by decide : (0 : Fin 3) ≠ 2) (by decide) cfg.two_zsmul_oangle_QQ₁A₂_eq_two_zsmul_oangle_QPA₂

theorem P₁_mem_ω : cfg.P₁ ∈ cfg.ω := by rw [← symm_ω]; exact cfg.symm.Q₁_mem_ω

theorem result : Concyclic ({cfg.P, cfg.Q, cfg.P₁, cfg.Q₁} : Set Pt) := by
  refine ⟨?_, coplanar_of_fact_finrank_eq_two _⟩
  rw [cospherical_iff_exists_sphere]
  refine ⟨cfg.ω, ?_⟩
  simp only [Set.insert_subset_iff, Set.singleton_subset_iff]
  exact ⟨cfg.P_mem_ω, cfg.Q_mem_ω, cfg.P₁_mem_ω, cfg.Q₁_mem_ω⟩

end

end Imo2019q2Cfg

end



theorem imo2019_p2 [Fact (finrank ℝ V = 2)] (A B C A₁ B₁ P Q P₁ Q₁ : Pt)
    (affine_independent_ABC : AffineIndependent ℝ ![A, B, C]) (wbtw_B_A₁_C : Wbtw ℝ B A₁ C)
    (wbtw_A_B₁_C : Wbtw ℝ A B₁ C) (wbtw_A_P_A₁ : Wbtw ℝ A P A₁) (wbtw_B_Q_B₁ : Wbtw ℝ B Q B₁)
    (PQ_parallel_AB : line[ℝ, P, Q] ∥ line[ℝ, A, B]) (P_ne_Q : P ≠ Q)
    (sbtw_P_B₁_P₁ : Sbtw ℝ P B₁ P₁) (angle_PP₁C_eq_angle_BAC : ∠ P P₁ C = ∠ B A C)
    (C_ne_P₁ : C ≠ P₁) (sbtw_Q_A₁_Q₁ : Sbtw ℝ Q A₁ Q₁)
    (angle_CQ₁Q_eq_angle_CBA : ∠ C Q₁ Q = ∠ C B A) (C_ne_Q₁ : C ≠ Q₁) :
    Concyclic ({P, Q, P₁, Q₁} : Set Pt) :=
  (⟨A, B, C, A₁, B₁, P, Q, P₁, Q₁, affine_independent_ABC, wbtw_B_A₁_C, wbtw_A_B₁_C, wbtw_A_P_A₁,
        wbtw_B_Q_B₁, PQ_parallel_AB, P_ne_Q, sbtw_P_B₁_P₁, angle_PP₁C_eq_angle_BAC, C_ne_P₁,
        sbtw_Q_A₁_Q₁, angle_CQ₁Q_eq_angle_CBA, C_ne_Q₁⟩ :
      Imo2019q2Cfg V Pt).result


end Imo2019P2

-- ═══ Imo2019P4 ═══

/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/





/-!
# International Mathematical Olympiad 2019, Problem 4

Determine all positive integers n,k that satisfy the equation

  k! = (2ⁿ - 2⁰)(2ⁿ - 2¹) ... (2ⁿ - 2ⁿ⁻¹).
-/

namespace Imo2019P4

open scoped Nat



/-
Proof sketch:
The idea of the proof is to count the factors of 2 on both sides. The LHS has less
than `k` factors of 2, and the RHS has exactly `n * (n - 1) / 2` factors of 2.
So we know that `n * (n - 1) / 2 < k`. Now for `n ≥ 6` we have
`RHS < 2 ^ (n ^ 2) < (n(n-1)/2)! < k!`. We then treat the cases `n < 6`
individually.
-/

theorem upper_bound {k n : ℕ} (hk : k > 0)
    (h : (k ! : ℤ) = ∏ i ∈ Finset.range n, ((2:ℤ) ^ n - (2:ℤ) ^ i)) : n < 6 := by
  have h2 : ∑ i ∈ Finset.range n, i < k := by
    suffices emultiplicity 2 (k ! : ℤ) = ↑(∑ i ∈ Finset.range n, i : ℕ) by
      rw [← Nat.cast_lt (α := ℕ∞), ← this]; change emultiplicity ((2 : ℕ) : ℤ) _ < _
      simp_rw [Int.natCast_emultiplicity, Nat.emultiplicity_two_factorial_lt hk.lt.ne.symm]
    rw [h, Finset.emultiplicity_prod Int.prime_two, Nat.cast_sum]
    apply Finset.sum_congr rfl; intro i hi
    rw [emultiplicity_sub_of_gt, emultiplicity_pow_self_of_prime Int.prime_two]
    rwa [emultiplicity_pow_self_of_prime Int.prime_two,
      emultiplicity_pow_self_of_prime Int.prime_two, Nat.cast_lt, ← Finset.mem_range]
  rw [← not_le]; intro hn
  apply _root_.ne_of_gt _ h
  calc ∏ i ∈ Finset.range n, ((2:ℤ) ^ n - (2:ℤ) ^ i) ≤ ∏ __ ∈ Finset.range n, (2:ℤ) ^ n := ?_
    _ < ↑ k ! := ?_
  · gcongr
    · intro i hi
      simp only [Finset.mem_range] at hi
      have : (2:ℤ) ^ i ≤ (2:ℤ) ^ n := by gcongr; norm_num
      lia
    · apply sub_le_self
      positivity
  norm_cast
  calc ∏ __ ∈ Finset.range n, 2 ^ n = 2 ^ (n * n) := by rw [Finset.prod_const, Finset.card_range, ← pow_mul]
    _ < (∑ i ∈ Finset.range n, i)! := ?_
    _ ≤ k ! := by gcongr
  clear h h2
  induction' n, hn using Nat.le_induction with n' hn' IH
  · decide
  let A := ∑ i ∈ Finset.range n', i
  have le_sum : ∑ i ∈ Finset.range 6, i ≤ A := by
    apply Finset.sum_le_sum_of_subset
    simpa using hn'
  calc 2 ^ ((n' + 1) * (n' + 1))
      ≤ 2 ^ (n' * n' + 4 * n') := by gcongr <;> linarith
    _ = 2 ^ (n' * n') * (2 ^ 4) ^ n' := by rw [← pow_mul, ← pow_add]
    _ < A ! * (2 ^ 4) ^ n' := by gcongr
    _ = A ! * (15 + 1) ^ n' := rfl
    _ ≤ A ! * (A + 1) ^ n' := by gcongr; exact le_sum
    _ ≤ (A + n')! := Nat.factorial_mul_pow_le_factorial
    _ = (∑ i ∈ Finset.range (n' + 1), i)! := by rw [Finset.sum_range_succ]



noncomputable def solution_set : Set (ℕ × ℕ) := { (1,1), (2,3) }

theorem imo2019_p4 (n k : ℕ) :
    (n, k) ∈ solution_set ↔
    0 < n ∧ 0 < k ∧
    (k ! : ℤ) = ∏ i ∈ Finset.range n, ((2:ℤ)^n - (2:ℤ)^i) := by
  constructor
  · intro nk
    simp only [Set.mem_insert_iff, Set.mem_singleton_iff, Prod.mk.injEq] at nk
    obtain ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ := nk <;> decide
  rintro ⟨npos, kpos, h⟩
  -- We know that n < 6.
  have := Imo2019P4.upper_bound kpos h
  interval_cases n
  -- n = 1
  · left; congr; norm_num at h
    exact Nat.le_antisymm h kpos
  -- n = 2
  · right; congr; norm_num [Finset.prod_range_succ] at h; norm_cast at h
    rwa [← Nat.factorial_inj']; norm_num

  all_goals exfalso; norm_num [Finset.prod_range_succ] at h; norm_cast at h
  -- n = 3
  · refine Nat.monotone_factorial.ne_of_lt_of_lt_nat 5 ?_ ?_ _ h <;> decide
  -- n = 4
  · refine Nat.monotone_factorial.ne_of_lt_of_lt_nat 7 ?_ ?_ _ h <;> decide
  -- n = 5
  · refine Nat.monotone_factorial.ne_of_lt_of_lt_nat 10 ?_ ?_ _ h <;> decide


end Imo2019P4

-- ═══ Imo2020P2 ═══

/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers, Yury Kudryashov
-/




/-!
# International Mathematical Olympiad 2020, Problem 2

The real numbers `a`, `b`, `c`, `d` are such that `a ≥ b ≥ c ≥ d > 0` and `a + b + c + d = 1`.
Prove that `(a + 2b + 3c + 4d) a^a b^b c^c d^d < 1`.
-/

open Real

theorem imo2020_q2 (a b c d : ℝ) (hd0 : 0 < d) (hdc : d ≤ c) (hcb : c ≤ b) (hba : b ≤ a)
    (h1 : a + b + c + d = 1) : (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d < 1 := by
  /-
  A solution is to eliminate the powers using weighted AM-GM and replace
  `1` by `(a+b+c+d)^3`, leaving a homogeneous inequality that can be
  proved in many ways by expanding, rearranging and comparing individual
  terms.  The version here using factors such as `a+3b+3c+3d` is from
  the official solutions.
  -/

  have hp : a ^ a * b ^ b * c ^ c * d ^ d ≤ a * a + b * b + c * c + d * d := by
    refine geom_mean_le_arith_mean4_weighted ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ h1 <;> linarith
  calc
    (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d =
        (a + 2 * b + 3 * c + 4 * d) * (a ^ a * b ^ b * c ^ c * d ^ d) := by ac_rfl
    _ ≤ (a + 2 * b + 3 * c + 4 * d) * (a * a + b * b + c * c + d * d) := by gcongr; linarith
    _ = (a + 2 * b + 3 * c + 4 * d) * a ^ 2 + (a + 2 * b + 3 * c + 4 * d) * b ^ 2
        + (a + 2 * b + 3 * c + 4 * d) * c ^ 2 + (a + 2 * b + 3 * c + 4 * d) * d ^ 2 := by ring
    _ ≤ (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2
        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2 := by
        gcongr ?_ * _ + ?_ * _ + ?_ * _ + ?_ * _ <;> linarith
    _ < (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2
        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2
        + (6 * a * b * c + 6 * a * b * d + 6 * a * c * d + 6 * b * c * d) :=
        (lt_add_of_pos_right _ (by apply_rules [add_pos, mul_pos, zero_lt_one] <;> linarith))
    _ = (a + b + c + d) ^ 3 := by ring
    _ = 1 := by simp [h1]

-- ═══ Imo2020P6 ═══

/-
Copyright (c) 2025 The Compfiles Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jovan Gerbscheid
-/




/-!
# International Mathematical Olympiad 2020, Problem 6

Consider an integer n > 1, and a set S of n points in the plane
such that the distance between any two points in S is at least 1.
Prove that there is a line l separating S such that the distance
from any point of S to l is at least Ω(n ^ (-1/3)).

(A line l separates a set of points S if some segment jointing
two points in S croses l.)
-/

namespace Imo2020P6

open Finset Module
open scoped RealInnerProductSpace

variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P]
variable [NormedAddTorsor V P] (dim : Nat) [Fact (finrank ℝ V = dim + 1)]



theorem exists_between_and_separated {ι : Type*} (S : Finset ι) (f : ι → ℝ) (n : Nat)
    (a b : ℝ) (hab : a < b) (hS : #{p ∈ S | f p ∈ Set.Ioo a b} < n) :
    ∃ x ∈ Set.Ioo a b, ∀ p ∈ S, (b - a) / (2 * n) ≤ |x - f p| := by
  -- make `n` defEq to `_ + 1`
  cases n with | zero => contradiction | succ n => _
  set n := n+1
  -- separate the interval `(0,1)` into `n` equally spaced intervals
  let interval (i : Fin n) : Set ℝ :=
    Set.Ioo (AffineMap.lineMap a b ((i : ℝ) / n)) (AffineMap.lineMap a b (((i : ℝ) + 1) / n))

  let rel (p : ι) (k : Fin n) : Prop :=
    f p ∈ interval k

  by_cases h : ∀ k ∈ Finset.univ, ∃ p ∈ ({p ∈ S | f p ∈ Set.Ioo a b} : Finset _), rel p k
  · -- show that the `n` intervals are disjoint
    have disjoint : Pairwise fun i j => Disjoint (interval i) (interval j) := by
      rw [pairwise_disjoint_on]
      intro i j hlt
      unfold interval
      rw [Set.Ioo_disjoint_Ioo]; apply le_sup_of_le_right; apply inf_le_of_left_le
      rw [lineMap_le_lineMap_iff_of_lt' hab]
      gcongr
      norm_cast
    -- use the pigeon hole principle on the disjoint intervals
    have := card_le_card_of_forall_subsingleton' rel h <| by
      simp only [mem_univ, true_and]
      intro p _
      unfold rel
      intro i hi j hj
      by_contra h
      replace disjoint : Disjoint (interval i) (interval j) := disjoint h
      rw [Set.disjoint_left] at disjoint
      exact disjoint hi hj
    rw [card_univ, Fintype.card_fin] at this
    lia
  push_neg at h; simp only [mem_univ, Set.mem_Ioo, mem_filter, and_imp, true_and] at h
  -- the `i`th interval in disjoint with `(f '' S) ∩ (a, b)`
  obtain ⟨i, h⟩ := h; unfold rel at h
  -- use the midpoint of the `i`th interval
  use AffineMap.lineMap a b (i / n + 1 / (2 * n) : ℝ)
  have ineq₁: (i / n : ℝ) ≤ 1 - 1 / n := by grw [Fin.is_le]; field_simp [n]; simp [n]
  have : b - a > 0 := sub_pos.mpr hab
  -- check that the point is in between `a` and `b`
  refine ⟨⟨?_, ?_⟩, ?_⟩
  · simp only [one_div, mul_inv_rev, AffineMap.lineMap_apply_ring', lt_add_iff_pos_left]
    positivity
  · rw [AffineMap.lineMap_apply_ring']
    have ineq₂: (1 / (2 * n) : ℝ) < 1 / n := by
      gcongr; norm_cast; lia
    linear_combination (ineq₁ + ineq₂) * (b - a)
  intro p hp
  -- the `i`th interval is disjoint with `f '' S`
  have : f p ∉ interval i := by
    by_cases ha : a < f p
    · by_cases hb : f p < b
      · exact h p hp ha hb
      · apply Set.notMem_Ioo_of_ge
        push_neg at hb
        rw [AffineMap.lineMap_apply_ring']
        linear_combination ineq₁ * (b - a) + hb
    · apply Set.notMem_Ioo_of_le
      push_neg at ha
      grw [ha]
      rw [AffineMap.lineMap_apply_ring', le_add_iff_nonneg_left]
      positivity
  simp only [interval, Set.mem_Ioo, not_and_or, not_lt] at this
  -- `y ∈ S` is either above or below the interval, either way we get the bound
  rcases this with h | h
  · grw [← le_abs_self, h]
    rw [AffineMap.lineMap_apply_ring', AffineMap.lineMap_apply_ring']
    ring_nf; rfl
  · rw [abs_sub_comm]
    grw [← le_abs_self, ← h]
    rw [AffineMap.lineMap_apply_ring', AffineMap.lineMap_apply_ring']
    ring_nf; rfl

/-- Computes "how far along" the segment from `a` to `b` the point `p` lies. -/
noncomputable def project (a b p : P) : ℝ := innerSL ℝ (a -ᵥ b) (a -ᵥ p) / ‖a -ᵥ b‖

@[simp] theorem project_self_left {a b : P} : project a b a = 0 := by simp [project]
@[simp] theorem project_self_right {a b : P} (h : a ≠ b) : project a b b = ‖a -ᵥ b‖ := by
  simp only [project, innerSL_apply_apply]
  rw [real_inner_self_eq_norm_sq, div_eq_iff, pow_two]
  · rwa [norm_ne_zero_iff, vsub_ne_zero]


theorem exists_affine_between_and_separated {ι : Type*} (S : Finset ι) (f : ι → P) (n : ℝ)
    (a b : P) (i j : ℝ) (hi : 0 ≤ i) (hij : i < j) (hj : j ≤ dist a b)
    (hS : #{p ∈ S | project a b (f p) ∈ Set.Ioo i j} ≤ n - 1)
    (hab : a ≠ b) :
    ∃ l : AffineSubspace ℝ P, finrank ℝ l.direction = dim ∧ l.SOppSide a b ∧
    ∀ p ∈ S, (j - i) / (2 * n) ≤ Metric.infDist (f p) l := by

  obtain ⟨x, x_ioo, hx⟩ := exists_between_and_separated S (project a b <| f ·) (⌊n-1⌋₊+1) i j hij
    (by
      rw [← Nat.cast_lt (α := ℝ)]; push_cast
      grw [hS]
      exact Nat.lt_floor_add_one (n - 1))

  use .mk' (AffineMap.lineMap a b (x / dist a b)) (LinearMap.ker (innerₛₗ ℝ (a -ᵥ b)))

  have : Nonempty (AffineSubspace.mk'
      (AffineMap.lineMap a b (x / dist a b)) (LinearMap.ker (innerₛₗ ℝ (a -ᵥ b)))) := by
    constructor
    use (AffineMap.lineMap a b (x / dist a b))
    apply AffineSubspace.self_mem_mk'

  constructor
  · -- The subspace has the required dimension
    have : LinearMap.ker ((innerₛₗ ℝ) (a -ᵥ b)) = (ℝ ∙ (a -ᵥ b))ᗮ := by
      ext x
      rw [Submodule.mem_orthogonal_singleton_iff_inner_right]; rfl
    rw [AffineSubspace.direction_mk', this]
    apply Submodule.finrank_orthogonal_span_singleton (by rwa [vsub_ne_zero])
  have : 0 < ‖a -ᵥ b‖ := by
    rwa [norm_pos_iff, vsub_ne_zero]
  constructor
  · refine Sbtw.sOppSide_of_notMem_of_mem ?_ ?_ (AffineSubspace.self_mem_mk' _ _)
    · simp [hab, lt_of_le_of_lt hi x_ioo.1, lt_of_lt_of_le x_ioo.2 hj, div_lt_one]
    · simp [hab, (lt_of_le_of_lt hi x_ioo.1).ne.symm]

  intro p hp
  -- we show that the distance between `p` and the plane corresponds to
  -- the distance between `project p` and `x`.
  specialize hx p hp
  rw [project, sub_div' (by positivity), abs_div, le_div_iff₀' (by positivity),
    abs_of_pos (by positivity)] at hx
  rw [Metric.infDist_eq_iInf]
  apply le_ciInf
  simp only [SetLike.coe_sort_coe, dist_eq_norm_vsub, Subtype.forall, AffineSubspace.mem_mk',
             LinearMap.mem_ker, innerₛₗ_apply_apply]
  intro y hy
  rw [← mul_le_mul_iff_right₀ this]
  calc
    _ ≤ ‖a -ᵥ b‖ * ((j - i) / (2 * ↑(⌊n - 1⌋₊ + 1))) := by
      gcongr
      · linarith only [hij]
      · push_cast; rw [← le_sub_iff_add_le]
        refine Nat.floor_le (by grw [← hS]; simp)
    _ ≤ |x * ‖a -ᵥ b‖ - ⟪a -ᵥ b, a -ᵥ f p⟫| := hx
    _ = |⟪a -ᵥ b, f p -ᵥ (AffineMap.lineMap a b) (x / ‖a -ᵥ b‖)⟫| := by
      congr 1
      rw [sub_eq_iff_eq_add', ← inner_add_right]
      simp only [vsub_add_vsub_cancel, AffineMap.left_vsub_lineMap]
      rw [inner_smul_right, real_inner_self_eq_norm_sq]
      field_simp
    _ = |⟪a -ᵥ b, f p -ᵥ y⟫| := by congr 1; rw [← sub_eq_zero, ← inner_sub_right]; simp; exact hy
    _ ≤ ‖a -ᵥ b‖ * ‖f p -ᵥ y‖ := abs_real_inner_le_norm ..


theorem card_le_of_separated {ι : Type*} (S : Finset ι) (f : ι → ℝ) {ε a b : ℝ} (hε : 0 < ε)
    (hab : a ≤ b) (h_sep : (S : Set ι).Pairwise fun x y => ε ≤ dist (f x) (f y))
    (hbound : ∀ x ∈ S, f x ∈ Set.Icc a b) : #S ≤ ⌊(b - a) / ε + 1⌋ := by
  suffices h : #S ≤ #(Icc 0 ⌊(b - a) / ε⌋) by
    have : 0 ≤ ⌊(b - a) / ε⌋ + 1 := by
      have := sub_nonneg_of_le hab
      positivity
    simpa [this] using h
  apply Finset.card_le_card_of_injOn fun x => ⌊(f x - a) / ε⌋
  · intro x hx
    rw [coe_Icc, Set.mem_Icc]; constructor
    · rw [Int.floor_nonneg]
      refine div_nonneg ?_ hε.le
      rw [sub_nonneg]
      exact (hbound x hx).1
    · apply Int.floor_le_floor
      rw [div_le_div_iff_of_pos_right hε, sub_le_sub_iff_right]
      exact (hbound x hx).2
  · intro x hx y hy h
    apply Int.abs_sub_lt_one_of_floor_eq_floor at h
    field_simp at h
    rw [sub_sub_sub_cancel_right, abs_div, abs_eq_self.mpr hε.le, div_lt_one hε] at h
    contrapose! h
    exact h_sep hx hy h

/--
In a strip of width `1/2`, if the points have pairwise distance at least `1`,
then we can bound the number of points.
-/
theorem card_le_of_separated_in_strip (eqv : P ≃ᵃⁱ[ℝ] EuclideanSpace ℝ (Fin 2)) (S : Finset P)
    (h_sep : (S.filter (eqv · 0 ∈ Set.Ioo 0 (1 / 2)) : Set P).Pairwise fun x y => 1 ≤ dist x y)
    {N : ℝ} (hN : 1 ≤ N) (h_bound : ∀ x ∈ S.filter (eqv · 0 ∈ Set.Ioo 0 (1 / 2)), |eqv x 1| ≤ N) :
    #(S.filter (eqv · 0 ∈ Set.Ioo 0 (1/2))) ≤ N*6-1 := by
  suffices h : #(S.filter (eqv · 0 ∈ Set.Ioo 0 (1/2))) ≤ ⌊(N - (-N)) / (1/2) + 1⌋ by
    rw [Int.le_floor, Int.cast_natCast] at h
    linarith only [h, hN]
  refine card_le_of_separated (S.filter (eqv · 0 ∈ Set.Ioo 0 (1/2))) (eqv · 1)
    (by norm_num) (by linarith only [hN]) ?_
    (fun x hx => ⟨neg_le_of_abs_le (h_bound x hx), le_of_abs_le (h_bound x hx)⟩)
  intro x hx y hy h_ne
  specialize h_sep hx hy h_ne
  dsimp only
  have := EuclideanSpace.dist_eq (eqv x) (eqv y)
  simp at this
  rw [this] at h_sep
  rw [Real.one_le_sqrt] at h_sep
  rw [← sq_le_sq₀ (by positivity) (by positivity)]
  suffices (dist (eqv x 0) (eqv y 0))^2 ≤ (1/2)^2 by
    linarith only [this, h_sep]
  rw [sq_le_sq₀ (by positivity) (by positivity), Real.dist_eq, abs_le]
  rw [coe_filter] at hx hy
  rcases hx with ⟨_, xl, xr⟩
  rcases hy with ⟨_, yl, yr⟩
  constructor
  · linear_combination xl + yr
  · linear_combination xr + yl



variable [Fact (Module.finrank ℝ V = 2)]

theorem imo2020_p6 : ∃ c : ℝ, 0 < c ∧ ∀ {n : ℕ}, 1 < n → ∀ {S : Finset P}, #S = n →
    ((S : Set P).Pairwise fun x y ↦ 1 ≤ dist x y) →
    ∃ l : AffineSubspace ℝ P, finrank ℝ l.direction = 1 ∧
      (∃ p₁ ∈ S, ∃ p₂ ∈ S, l.SOppSide p₁ p₂) ∧
      ∀ p ∈ S, c * (n : ℝ) ^ (-1 / 3 : ℝ) ≤ Metric.infDist p l := by
  let c : ℝ := 1/100
  use c, by norm_num
  intro n hn S hS one_le_dist
  -- There are two main cases: either there is or there isn't a large distance between two points.
  by_cases h_dist : ∃ᵉ (a ∈ S) (b ∈ S), (n : ℝ) ^ (2 / 3 : ℝ) ≤ dist a b
  · -- If there are points with distance at least `n^(2/3)`, then we can solve the problem by
    -- choosing the best perpendicular line though this segment.
    obtain ⟨a, ha, b, hb, hab⟩ := h_dist
    have : 0 < dist a b := lt_of_lt_of_le (by positivity) hab
    rw [dist_pos] at this
    obtain ⟨l, rank, sOpp, h⟩ := exists_affine_between_and_separated 1 S (·) (n*2) a b 0 (dist a b)
      le_rfl (dist_pos.mpr this) le_rfl (by
      rw [le_sub_iff_add_le]; norm_cast
      exact lt_of_le_of_lt (card_filter_le S _) (by lia)) this
    norm_num at h
    use l, rank
    refine ⟨⟨a, ha, b, hb, sOpp⟩, ?_⟩
    intro p hp
    specialize h p hp
    grw [← h, ← hab]
    rw [neg_div, Real.rpow_neg (by positivity)]
    field_simp
    rw [← Real.rpow_add (by positivity)]
    norm_num
    linarith only

  push_neg at h_dist
  -- If the points are closer than `n^(2/3)` together, then we can solve the problem by
  -- picking the furthest such points `a` and `b`, and choosing the best perpendiculer line
  -- through the segment of width `1/2` at the edge.
  obtain ⟨a, ha, b, hb, h_max⟩ : ∃ᵉ (a ∈ S) (b ∈ S), ∀ᵉ (x ∈ S) (y ∈ S), dist x y ≤ dist a b := by
    have : Nonempty S := Nonempty.to_subtype (Finset.card_pos.mp (by lia))
    obtain ⟨⟨⟨a, ha⟩, ⟨b, hb⟩⟩, _, hab⟩ :=
      Set.finite_univ.exists_maximalFor (fun xy : S × S => dist xy.1.val xy.2.val)
        Set.univ Set.univ_nonempty
    use a, ha, b, hb
    intro x hx y hy
    specialize hab (Set.mem_univ (⟨x, hx⟩, ⟨y, hy⟩))
    dsimp at hab
    contrapose! hab
    constructor <;> linarith only [hab]
  have h_ne : a ≠ b := by
    rintro rfl
    simp [← Finset.card_le_one] at h_max
    lia
  have : 0 < ‖b -ᵥ a‖ := by
    simp [h_ne.symm]

  have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ 1
  obtain ⟨basis, hbasis₀⟩: ∃ basis : OrthonormalBasis (Fin 2) ℝ V,
      ∀ i ∈ {i | i = 0}, basis i = ‖b -ᵥ a‖⁻¹ • (b -ᵥ a) := by
    refine Orthonormal.exists_orthonormalBasis_extension_of_card_eq ?_ ?_
    · simp [‹Fact (finrank ℝ V = 2)›.1]
    simp only [Fin.isValue, Set.setOf_eq_eq_singleton, Set.restrict_def]
    rw [orthonormal_iff_ite]
    simp only [Fin.isValue, Subtype.forall, Set.mem_singleton_iff, Fin.forall_fin_two, forall_true_left,
      one_ne_zero, IsEmpty.forall_iff, and_true, Subtype.mk.injEq, forall_eq, ↓reduceIte]
    rw [real_inner_smul_left, real_inner_smul_right, real_inner_self_eq_norm_mul_norm]
    field_simp
  simp at hbasis₀
  let eqv := (AffineIsometryEquiv.vaddConst ℝ a).symm.trans basis.repr.toAffineIsometryEquiv
  have h_iso_b : eqv b = EuclideanSpace.single 0 (dist a b) := by
    simp [eqv]
    ext i
    rw [OrthonormalBasis.repr_apply_apply]
    match i with
    | 0 =>
      simp [hbasis₀]
      rw [dist_eq_norm_vsub', real_inner_smul_left, real_inner_self_eq_norm_mul_norm]
      field_simp
    | 1 =>
      rw [eq_inv_smul_iff₀ (by positivity)] at hbasis₀
      rw [← hbasis₀, real_inner_smul_right]
      simp
  have project_eq_eqv (p) : project a b p = eqv p 0 := by
    simp [project, eqv]
    rw [OrthonormalBasis.repr_apply_apply, hbasis₀, real_inner_smul_left]
    rw [← neg_vsub_eq_vsub_rev b, ← neg_vsub_eq_vsub_rev p, inner_neg_neg, norm_neg]
    ring
  -- Compute a bound for the points lying in a strip on the edge
  have strip_bound (x) (hx : x ∈ S.filter (eqv · 0 ∈ Set.Ioo 0 (1/2))) :
      |eqv x 1| ≤ √(dist a b) := by
    apply Real.abs_le_sqrt
    rw [mem_filter] at hx
    obtain ⟨hx, h₁, h₂⟩ := hx
    specialize h_max x hx b hb
    have := EuclideanSpace.dist_eq (eqv x) (eqv b)
    simp at this; simp [h_iso_b] at this
    rw [this, Real.sqrt_le_left (by positivity), Real.dist_eq] at h_max
    have : 1 ≤ dist a b := one_le_dist ha hb h_ne
    rw [abs_eq_neg_self.mpr (by linarith only [this, h₂]), ← sub_nonneg] at h_max
    have : dist a b * eqv x 0 * 2 < dist a b := by
      rwa [mul_assoc, mul_lt_iff_lt_one_right, ← lt_div_iff₀] <;> positivity
    linarith only [this, h_max, sq_nonneg (eqv x 0)]

  have bound := by
    refine card_le_of_separated_in_strip eqv S ?_
      (Real.one_le_sqrt.mpr (one_le_dist ha hb h_ne)) strip_bound
    intro x hx y hy
    rw [coe_filter] at hx hy
    exact one_le_dist hx.1 hy.1
  simp_rw [← project_eq_eqv] at bound
  obtain ⟨l, rank, sOpp, h⟩ := exists_affine_between_and_separated 1 S (·) _ a b 0 (1/2) le_rfl
    (by norm_num) (by linarith only [one_le_dist ha hb h_ne]) bound h_ne
  use l, rank
  refine ⟨⟨a, ha, b, hb, sOpp⟩, ?_⟩
  intro p hp
  specialize h p hp
  grw [← h]
  rw [le_div_iff₀ (by simp [h_ne])]
  specialize h_dist a ha b hb
  grw [Real.sqrt_le_sqrt h_dist.le]
  rw [Real.sqrt_eq_rpow, ← Real.rpow_mul (by positivity)]
  rw [neg_div, Real.rpow_neg (by positivity)]
  ring_nf
  simp only [fieldLe, c]
  norm_num

end Imo2020P6

-- ═══ Imo2021P1 ═══

/-
Copyright (c) 2021 Mantas Bakšys. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mantas Bakšys
-/




/-!
# International Mathematical Olympiad 2021, Problem 1

Let `n≥100` be an integer. Ivan writes the numbers `n, n+1,..., 2n` each on different cards.
He then shuffles these `n+1` cards, and divides them into two piles. Prove that at least one
of the piles contains two cards such that the sum of their numbers is a perfect square.
-/

namespace Imo2021P1


open Finset

/-
# Solution

We show there exists a triplet `a, b, c ∈ [n , 2n]` with `a < b < c` and each of the sums `(a + b)`,
`(b + c)`, `(a + c)` being a perfect square. Specifically, we consider the linear system of
equations

    a + b = (2 * l - 1) ^ 2
    a + c = (2 * l) ^ 2
    b + c = (2 * l + 1) ^ 2

which can be solved to give

    a = 2 * l ^ 2 - 4 * l
    b = 2 * l ^ 2 + 1
    c = 2 * l ^ 2 + 4 * l

Therefore, it is enough to show that there exists a natural number l such that
`n ≤ 2 * l ^ 2 - 4 * l` and `2 * l ^ 2 + 4 * l ≤ 2 * n` for `n ≥ 100`.

Then, by the Pigeonhole principle, at least two numbers in the triplet must lie in the same pile,
which finishes the proof.
-/

-- We will later make use of the fact that there exists (l : ℕ) such that
-- n ≤ 2 * l ^ 2 - 4 * l and 2 * l ^ 2 + 4 * l ≤ 2 * n for n ≥ 100.
theorem exists_numbers_in_interval (n : ℕ) (hn : 100 ≤ n) :
    ∃ l : ℕ, n + 4 * l ≤ 2 * l ^ 2 ∧ 2 * l ^ 2 + 4 * l ≤ 2 * n := by
  have hn' : 1 ≤ Nat.sqrt (n + 1) := by
    rw [Nat.le_sqrt]
    lia
  have h₁ := Nat.sqrt_le' (n + 1)
  have h₂ := Nat.succ_le_succ_sqrt' (n + 1)
  have h₃ : 10 ≤ (n + 1).sqrt := by
    rw [Nat.le_sqrt]
    lia
  rw [← Nat.sub_add_cancel hn'] at h₁ h₂ h₃
  set l := (n + 1).sqrt - 1
  refine ⟨l, ?_, ?_⟩
  · calc n + 4 * l ≤ (l ^ 2 + 4 * l + 2) + 4 * l := by linarith only [h₂]
      _ ≤ 2 * l ^ 2 := by nlinarith only [h₃]
  · linarith only [h₁]

theorem exists_triplet_summing_to_squares (n : ℕ) (hn : 100 ≤ n) :
    ∃ a b c : ℕ, n ≤ a ∧ a < b ∧ b < c ∧ c ≤ 2 * n ∧
      (∃ k : ℕ, a + b = k ^ 2) ∧ (∃ l : ℕ, c + a = l ^ 2) ∧ ∃ m : ℕ, b + c = m ^ 2 := by
  obtain ⟨l, hl1, hl2⟩ := exists_numbers_in_interval n hn
  have p : 1 < l := by contrapose! hl1; interval_cases l <;> lia
  have h₁ : 4 * l ≤ 2 * l ^ 2 := by lia
  have h₂ : 1 ≤ 2 * l := by lia
  refine ⟨2 * l ^ 2 - 4 * l, 2 * l ^ 2 + 1, 2 * l ^ 2 + 4 * l, ?_, ?_, ?_,
    ⟨?_, ⟨2 * l - 1, ?_⟩, ⟨2 * l, ?_⟩, 2 * l + 1, ?_⟩⟩
  all_goals zify [h₁, h₂]; linarith

-- Since it will be more convenient to work with sets later on, we will translate the above claim
-- to state that there always exists a set B ⊆ [n, 2n] of cardinality at least 3, such that each
-- pair of pairwise unequal elements of B sums to a perfect square.
theorem exists_finset_3_le_card_with_pairs_summing_to_squares (n : ℕ) (hn : 100 ≤ n) :
    ∃ B : Finset ℕ,
      2 * 1 + 1 ≤ B.card ∧
      (∀ (a) (_ : a ∈ B) (b) (_ : b ∈ B), a ≠ b → ∃ k, a + b = k ^ 2) ∧
      ∀ c ∈ B, n ≤ c ∧ c ≤ 2 * n := by
  obtain ⟨a, b, c, hna, hab, hbc, hcn, h₁, h₂, h₃⟩ := exists_triplet_summing_to_squares n hn
  refine ⟨{a, b, c}, ?_, ?_, ?_⟩
  · suffices ({a, b, c} : Finset ℕ).card = 3 by rw [this]
    suffices a ∉ {b, c} ∧ b ∉ {c} by
      rw [Finset.card_insert_of_notMem this.1, Finset.card_insert_of_notMem this.2,
        Finset.card_singleton]
    · rw [Finset.mem_insert, Finset.mem_singleton, Finset.mem_singleton]
      push_neg
      exact ⟨⟨hab.ne, (hab.trans hbc).ne⟩, hbc.ne⟩
  · intro x hx y hy hxy
    simp only [Finset.mem_insert, Finset.mem_singleton] at hx hy
    grind
  · simp only [Finset.mem_insert, Finset.mem_singleton]
    lia



theorem imo2021_p1 :
    ∀ n : ℕ, 100 ≤ n → ∀ (A) (_ : A ⊆ Finset.Icc n (2 * n)),
    (∃ (a : _) (_ : a ∈ A) (b : _) (_ : b ∈ A), a ≠ b ∧ ∃ k : ℕ, a + b = k ^ 2) ∨
    ∃ (a : _) (_ : a ∈ Finset.Icc n (2 * n) \ A) (b : _) (_ : b ∈ Finset.Icc n (2 * n) \ A),
      a ≠ b ∧ ∃ k : ℕ, a + b = k ^ 2 := by
  intro n hn A hA
  -- For each n ∈ ℕ such that 100 ≤ n, there exists a pairwise unequal triplet {a, b, c} ⊆ [n, 2n]
  -- such that all pairwise sums are perfect squares. In practice, it will be easier to use
  -- a finite set B ⊆ [n, 2n] such that all pairwise unequal pairs of B sum to a perfect square
  -- noting that B has cardinality greater or equal to 3, by the explicit construction of the
  -- triplet {a, b, c} before.
  obtain ⟨B, hB, h₁, h₂⟩ := exists_finset_3_le_card_with_pairs_summing_to_squares n hn
  have hBsub : B ⊆ Finset.Icc n (2 * n) := by
    intro c hcB; simpa only [Finset.mem_Icc] using h₂ c hcB
  have hB' : 2 * 1 < (B ∩ (Finset.Icc n (2 * n) \ A) ∪ B ∩ A).card := by
    rw [←inter_union_distrib_left, sdiff_union_self_eq_union, union_eq_left.2 hA,
      inter_eq_left.2 hBsub]
    exact Nat.succ_le_iff.mp hB
  -- Since B has cardinality greater or equal to 3, there must exist a subset C ⊆ B such that
  -- for any A ⊆ [n, 2n], either C ⊆ A or C ⊆ [n, 2n] \ A and C has cardinality greater
  -- or equal to 2.
  obtain ⟨C, hC, hCA⟩ := Finset.exists_subset_or_subset_of_two_mul_lt_card hB'
  rw [Finset.one_lt_card] at hC
  rcases hC with ⟨a, ha, b, hb, hab⟩
  simp only [Finset.subset_iff, Finset.mem_inter] at hCA
  grind

end Imo2021P1

-- ═══ Imo2021P2 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Benpigchu
-/





/-!
# International Mathematical Olympiad 2021, Problem 2

Let n be a natural number, and let x₁, ..., xₙ be real numbers.
Show that

     ∑ᵢ∑ⱼ √|xᵢ - xⱼ| ≤ ∑ᵢ∑ⱼ √|xᵢ + xⱼ|.

-/

namespace Imo2021P2



universe u

def PiecewiseConcaveOn (s : Finset ℝ) (f : ℝ → ℝ) :=
  (∀ l r : ℝ, l ≤ r → (∀ t ∈ s, t ≤ l ∨ r ≤ t) → ConcaveOn ℝ (Set.Icc l r) f)

lemma piecewise_concave_add {s₁ s₂ : Finset ℝ} {f₁ f₂ : ℝ → ℝ}
    (h₁ : PiecewiseConcaveOn s₁ f₁) (h₂ : PiecewiseConcaveOn s₂ f₂)
    : PiecewiseConcaveOn (s₁ ∪ s₂) (f₁ + f₂) := by
  intro l r hlr hslr
  apply ConcaveOn.add
  · apply h₁ l r hlr
    intro t ht
    apply hslr
    apply Finset.mem_union_left
    exact ht
  · apply h₂ l r hlr
    intro t ht
    apply hslr
    apply Finset.mem_union_right
    exact ht

lemma piecewise_concave_sum {α : Type u} [DecidableEq α] (s : Finset α)
    (s' : α → Finset ℝ) (f' : α → ℝ → ℝ)
    (h : ∀ i ∈ s, PiecewiseConcaveOn (s' i) (f' i))
    : PiecewiseConcaveOn (s.biUnion s') (∑ i ∈ s, f' i) := by
  induction' s using Finset.cons_induction with i s'' his'' hs''
  · rw [Finset.sum_empty, Finset.biUnion_empty]
    intro l r hlr hlr'
    apply concaveOn_const
    apply convex_Icc
  · rw [Finset.sum_cons, Finset.cons_eq_insert, Finset.biUnion_insert]
    apply piecewise_concave_add
    · apply h
      apply Finset.mem_cons_self
    · apply hs''
      intro i' hi's'
      apply h
      apply Finset.mem_cons_of_mem hi's'

def UnboundedAtPosInfinity (f : ℝ → ℝ) :=
  (∀ y : ℝ, ∃ x : ℝ, ∀ t : ℝ, x ≤ t → y ≤ f t)

lemma unbounded_at_pos_infinity_add {f₁ f₂ : ℝ → ℝ}
    (h₁ : UnboundedAtPosInfinity f₁) (h₂ : UnboundedAtPosInfinity f₂)
    : UnboundedAtPosInfinity (f₁ + f₂) := by
  intro y
  rcases h₁ (y / 2) with ⟨x₁, hx₁⟩
  rcases h₂ (y / 2) with ⟨x₂, hx₂⟩
  use max x₁ x₂
  intro t ht
  rw [Pi.add_apply]
  rw [(by ring : y = y / 2 + y / 2)]
  grind

lemma unbounded_at_pos_infinity_sum {α : Type u} (s : Finset α) (hs : s.Nonempty)
    (f' : α → ℝ → ℝ)
    (h : ∀ i ∈ s, UnboundedAtPosInfinity (f' i))
    : UnboundedAtPosInfinity (∑ i ∈ s, f' i) := by
  induction' hs using Finset.Nonempty.cons_induction with i i s' his' hs' h'
  · rw [Finset.sum_singleton]
    apply h
    apply Finset.mem_singleton_self
  · rw [Finset.sum_cons]
    apply unbounded_at_pos_infinity_add
    · apply h
      apply Finset.mem_cons_self
    · apply h'
      intro i' hi's'
      apply h
      apply Finset.mem_cons_of_mem hi's'

def UnboundedAtNegInfinity (f : ℝ → ℝ) :=
  (∀ y : ℝ, ∃ x : ℝ, ∀ t : ℝ, t ≤ x → y ≤ f t)

lemma unbounded_at_neg_infinity_add {f₁ f₂ : ℝ → ℝ}
    (h₁ : UnboundedAtNegInfinity f₁) (h₂ : UnboundedAtNegInfinity f₂)
    : UnboundedAtNegInfinity (f₁ + f₂) := by
  intro y
  rcases h₁ (y / 2) with ⟨x₁, hx₁⟩
  rcases h₂ (y / 2) with ⟨x₂, hx₂⟩
  use min x₁ x₂
  intro t ht
  rw [Pi.add_apply]
  rw [(by ring : y = y / 2 + y / 2)]
  grind

lemma unbounded_at_neg_infinity_sum {α : Type u} (s : Finset α) (hs : s.Nonempty)
    (f' : α → ℝ → ℝ)
    (h : ∀ i ∈ s, UnboundedAtNegInfinity (f' i))
    : UnboundedAtNegInfinity (∑ i ∈ s, f' i) := by
  induction' hs using Finset.Nonempty.cons_induction with i i s' his' hs' h'
  · rw [Finset.sum_singleton]
    apply h
    apply Finset.mem_singleton_self
  · rw [Finset.sum_cons]
    apply unbounded_at_neg_infinity_add
    · apply h
      apply Finset.mem_cons_self
    · apply h'
      intro i' hi's'
      apply h
      apply Finset.mem_cons_of_mem hi's'

def PiecewiseConcavePlusOn (s : Finset ℝ) (f : ℝ → ℝ) :=
  PiecewiseConcaveOn s f
  ∧ UnboundedAtPosInfinity f
  ∧ UnboundedAtNegInfinity f

lemma piecewise_concave_plus_sum {α : Type u} [DecidableEq α] (s : Finset α) (hs : s.Nonempty)
    (s' : α → Finset ℝ) (f' : α → ℝ → ℝ)
    (h : ∀ i ∈ s, PiecewiseConcavePlusOn (s' i) (f' i))
    : PiecewiseConcavePlusOn (s.biUnion s') (∑ i ∈ s, f' i) := by
  rw [PiecewiseConcavePlusOn]
  constructorm* _ ∧ _
  · have h' : ∀ i ∈ s, PiecewiseConcaveOn (s' i) (f' i) := by
      intro i hi
      exact (h i hi).left
    exact piecewise_concave_sum s s' f' h'
  · have h' : ∀ i ∈ s, UnboundedAtPosInfinity (f' i) := by
      intro i hi
      exact (h i hi).right.left
    exact unbounded_at_pos_infinity_sum s hs f' h'
  · have h' : ∀ i ∈ s, UnboundedAtNegInfinity (f' i) := by
      intro i hi
      exact (h i hi).right.right
    exact unbounded_at_neg_infinity_sum s hs f' h'

def ExistsDecreaseOn (s : Finset ℝ) (f : ℝ → ℝ) :=
  ∀ t : ℝ, ∃ x ∈ s , f x ≤ f t

lemma exists_decrease_of_piecewise_concave_plus {s : Finset ℝ} {f : ℝ → ℝ}
    (h : PiecewiseConcavePlusOn s f) : ExistsDecreaseOn s f := by
  rcases h with ⟨h₁, h₂, h₃⟩
  intro t
  set l := {x ∈ s | x ≤ t }.max
  set r := {x ∈ s | t ≤ x }.min
  by_cases hlr : l = ⊥ ∧ r = ⊤
  · exfalso
    rcases hlr with ⟨hl, hr⟩
    simp only [l] at hl
    simp only [r] at hr
    rw [Finset.max_eq_bot] at hl
    rw [Finset.min_eq_top] at hr
    rw [Finset.eq_empty_iff_forall_notMem] at hl hr
    have hs : s = ∅ := by
      rw [Finset.eq_empty_iff_forall_notMem]
      intro x
      by_cases! hx : x ≤ t
      · contrapose! hl
        use x
        rw [Finset.mem_filter]
        exact ⟨hl, hx⟩
      · contrapose! hr
        use x
        rw [Finset.mem_filter]
        exact ⟨hr, le_of_lt hx⟩
    rcases h₂ (f t + 1) with ⟨r', hr'⟩
    rcases h₃ (f t + 1) with ⟨l', hl'⟩
    have hl'r' : min t l' ≤ max t r' := le_trans (min_le_left _ _) (le_max_left _ _)
    have hl'r's : ∀ x ∈ s, x ≤ min t l' ∨ max t r' ≤ x := by
      rw [hs]
      intro x hx
      contrapose! hx
      apply Finset.notMem_empty
    have h' := h₁ (min t l') (max t r') hl'r' hl'r's
    have ht : t ∈ Set.Icc (min t l') (max t r') := by
      rw [Set.mem_Icc]
      exact ⟨min_le_left _ _, le_max_left _ _⟩
    have h'' := ConcaveOn.min_le_of_mem_Icc h' (Set.left_mem_Icc.mpr hl'r') (Set.right_mem_Icc.mpr hl'r') ht
    contrapose! h''
    apply lt_of_lt_of_le (lt_add_of_pos_right _ (by norm_num : (0 : ℝ) < 1))
    apply le_min
    · apply hl'
      apply min_le_right
    · apply hr'
      apply le_max_right
  · by_cases hlr' : l ≠ ⊥ ∧ r ≠ ⊤
    · rcases hlr' with ⟨hl, hr⟩
      set l' := WithBot.unbot l hl with hl'
      set r' := WithTop.untop r hr with hr'
      rw [WithBot.eq_unbot_iff] at hl'
      rw [WithTop.eq_untop_iff] at hr'
      simp only [l] at hl'
      simp only [r] at hr'
      symm at hl' hr'
      have hl'' := Finset.mem_of_max hl'
      have hr'' := Finset.mem_of_min hr'
      rw [Finset.mem_filter] at hl'' hr''
      have hl'r' : l' ≤ r' := le_trans hl''.right hr''.right
      have hl'r's : ∀ x ∈ s, x ≤ l' ∨ r' ≤ x := by
        intro x hx
        by_cases! hx' : x ≤ t
        · left
          apply Finset.le_max_of_eq _ hl'
          rw [Finset.mem_filter]
          exact ⟨hx, hx'⟩
        · right
          apply Finset.min_le_of_eq _ hr'
          rw [Finset.mem_filter]
          exact ⟨hx, le_of_lt hx'⟩
      have h' := h₁ l' r' hl'r' hl'r's
      have ht : t ∈ Set.Icc l' r' := by
        rw [Set.mem_Icc]
        exact ⟨hl''.right, hr''.right⟩
      have h'' := ConcaveOn.min_le_of_mem_Icc h' (Set.left_mem_Icc.mpr hl'r') (Set.right_mem_Icc.mpr hl'r') ht
      rcases min_choice (f l') (f r') with hmin|hmin <;> rw [hmin] at h''
      · use l'
        rw [and_iff_left h'']
        exact hl''.left
      · use r'
        rw [and_iff_left h'']
        exact hr''.left
    · have hlr'' : (l = ⊥ ∧ r ≠ ⊤) ∨ (l ≠ ⊥ ∧ r = ⊤) := by tauto
      rcases hlr'' with ⟨hl, hr⟩|⟨hl, hr⟩
      · set r' := WithTop.untop r hr with hr'
        rw [WithTop.eq_untop_iff] at hr'
        simp only [l] at hl
        simp only [r] at hr'
        rw [Finset.max_eq_bot] at hl
        rw [Finset.eq_empty_iff_forall_notMem] at hl
        symm at hr'
        have hr'' := Finset.mem_of_min hr'
        rw [Finset.mem_filter] at hr''
        rcases h₃ (f t + 1) with ⟨l', hl'⟩
        have hl'r' : min t l' ≤ r' := le_trans (min_le_left _ _) (hr''.right)
        have hl'r's : ∀ x ∈ s, x ≤ min t l' ∨ r' ≤ x := by
          intro x hx
          by_cases! hx' : x ≤ t
          · contrapose! hl
            use x
            rw [Finset.mem_filter]
            exact ⟨hx, hx'⟩
          · right
            apply Finset.min_le_of_eq _ hr'
            rw [Finset.mem_filter]
            exact ⟨hx, le_of_lt hx'⟩
        have h' := h₁ (min t l') r' hl'r' hl'r's
        have ht : t ∈ Set.Icc (min t l') r' := by
          rw [Set.mem_Icc]
          exact ⟨min_le_left _ _, hr''.right⟩
        have h'' := ConcaveOn.min_le_of_mem_Icc h' (Set.left_mem_Icc.mpr hl'r') (Set.right_mem_Icc.mpr hl'r') ht
        rcases min_choice (f (min t l')) (f r') with hmin|hmin <;> rw [hmin] at h''
        · contrapose! hl'
          use min t l'
          rw [and_iff_right (min_le_right _ _)]
          exact lt_of_le_of_lt h'' (lt_add_one _)
        · use r'
          rw [and_iff_left h'']
          exact hr''.left
      · set l' := WithBot.unbot l hl with hl'
        rw [WithBot.eq_unbot_iff] at hl'
        simp only [l] at hl'
        simp only [r] at hr
        rw [Finset.min_eq_top] at hr
        rw [Finset.eq_empty_iff_forall_notMem] at hr
        symm at hl'
        have hl'' := Finset.mem_of_max hl'
        rw [Finset.mem_filter] at hl''
        rcases h₂ (f t + 1) with ⟨r', hr'⟩
        have hl'r' : l' ≤ (max t r') := le_trans (hl''.right) (le_max_left _ _)
        have hl'r's : ∀ x ∈ s, x ≤ l' ∨ (max t r') ≤ x := by
          intro x hx
          by_cases! hx' : x ≤ t
          · left
            apply Finset.le_max_of_eq _ hl'
            rw [Finset.mem_filter]
            exact ⟨hx, hx'⟩
          · contrapose! hr
            use x
            rw [Finset.mem_filter]
            exact ⟨hx, le_of_lt hx'⟩
        have h' := h₁ l' (max t r') hl'r' hl'r's
        have ht : t ∈ Set.Icc l' (max t r') := by
          rw [Set.mem_Icc]
          exact ⟨hl''.right, le_max_left _ _⟩
        have h'' := ConcaveOn.min_le_of_mem_Icc h' (Set.left_mem_Icc.mpr hl'r') (Set.right_mem_Icc.mpr hl'r') ht
        rcases min_choice (f l') (f (max t r')) with hmin|hmin <;> rw [hmin] at h''
        · use l'
          rw [and_iff_left h'']
          exact hl''.left
        · contrapose! hr'
          use (max t r')
          rw [and_iff_right (le_max_right _ _)]
          apply lt_of_le_of_lt h''
          exact lt_add_one (f t)

noncomputable def Finset.SumSqrtDist {α : Type u} (s : Finset α)
    (x : α → ℝ) (t : ℝ) := ∑ i ∈ s, √|x i - t|

lemma piecewise_concave_sqrt_dist (x : ℝ) :
    PiecewiseConcaveOn {x} (fun t ↦ √|x - t|) := by
  intro l r hlr hlr'
  have hx := hlr' x (Finset.mem_singleton_self x)
  set f := fun (t : ℝ) ↦ |x - t|
  set g := fun (t : ℝ) ↦ t ^ ((1 : ℝ) / 2)
  have h' : (fun t ↦ √|x - t|) = g ∘ f := by
    ext t
    simp only [Function.comp_apply, g, f]
    rw [Real.sqrt_eq_rpow]
  rw [h']
  have hf : f '' Set.Icc l r ⊆ Set.Ici 0 := by
    simp only [f]
    intro y hy
    rw [Set.mem_image] at hy
    rw [Set.mem_Ici]
    rcases hy with ⟨t, ht', ht⟩
    rw [← ht]
    positivity
  apply ConcaveOn.comp
  · simp only [g]
    have h'' := Real.concaveOn_rpow (by norm_num : (0 : ℝ) ≤ 1 / 2) (by norm_num : 1 / 2 ≤ (1 : ℝ))
    apply ConcaveOn.subset h'' hf
    rcases hx with (hx|hx)
    · have hf : f '' Set.Icc l r = (fun t ↦ -x + (1 : ℝ) • t) '' Set.Icc l r := by
        apply Set.image_congr
        intro t ht
        simp only [Set.mem_Icc] at ht
        simp only [f]
        rw [smul_eq_mul, (by ring : -x + (1 : ℝ) * t = -(x - t))]
        apply abs_of_nonpos
        rw [sub_nonpos]
        apply le_trans hx ht.left
      rw [hf]
      exact Convex.affinity (convex_Icc l r) (-x) (1 : ℝ)
    · have hf : f '' Set.Icc l r = (fun t ↦ x + (-1 : ℝ) • t) '' Set.Icc l r := by
        apply Set.image_congr
        intro t ht
        simp only [Set.mem_Icc] at ht
        simp only [f]
        rw [smul_eq_mul, (by ring : x + (-1 : ℝ) * t = x - t)]
        apply abs_of_nonneg
        rw [sub_nonneg]
        apply le_trans ht.right hx
      rw [hf]
      exact Convex.affinity (convex_Icc l r) x (-1 : ℝ)
  · rw [ConcaveOn, and_iff_right (convex_Icc _ _)]
    intro p hp q hq a b ha hb hab
    repeat rw [smul_eq_mul]
    simp only [f]
    apply le_of_eq
    have h' : x - (a * p + b * q) = a * (x - p) + b * (x - q) := by
      nth_rw 1 [← one_mul x]
      rw [← hab]
      ring
    rw [h']
    simp only [Set.mem_Icc] at hp hq
    rcases hx with (hx|hx)
    · have hpx : x - p ≤ 0 := by
        rw [sub_nonpos]
        apply le_trans hx hp.left
      have hqx : x - q ≤ 0 := by
        rw [sub_nonpos]
        apply le_trans hx hq.left
      have h'x : a * (x - p) + b * (x - q) ≤ 0 := by
        apply add_nonpos
        · apply mul_nonpos_of_nonneg_of_nonpos ha hpx
        · apply mul_nonpos_of_nonneg_of_nonpos hb hqx
      rw [abs_of_nonpos hpx, abs_of_nonpos hqx, abs_of_nonpos h'x]
      ring
    · have hpx : 0 ≤ x - p  := by
        rw [sub_nonneg]
        apply le_trans hp.right hx
      have hqx : 0 ≤ x - q := by
        rw [sub_nonneg]
        apply le_trans hq.right hx
      have h'x : 0 ≤ a * (x - p) + b * (x - q) := by
        apply add_nonneg
        · apply mul_nonneg ha hpx
        · apply mul_nonneg hb hqx
      rw [abs_of_nonneg hpx, abs_of_nonneg hqx, abs_of_nonneg h'x]
  · simp only [g]
    have h'' := Real.monotoneOn_rpow_Ici_of_exponent_nonneg (by norm_num : (0 : ℝ) ≤ 1 / 2)
    apply MonotoneOn.mono h'' hf

lemma unbounded_at_pos_infinity_sqrt_dist (x : ℝ) :
    UnboundedAtPosInfinity (fun t ↦ √|x - t|) := by
  intro y
  use (x + y ^ 2)
  intro t ht
  dsimp only
  rw [← le_sub_iff_add_le'] at ht
  apply Real.le_sqrt_of_sq_le
  rw [abs_sub_comm, abs_of_nonneg (le_trans (sq_nonneg _) ht)]
  exact ht

lemma unbounded_at_neg_infinity_sqrt_dist (x : ℝ) :
    UnboundedAtNegInfinity (fun t ↦ √|x - t|) := by
  intro y
  use (x - y ^ 2)
  intro t ht
  dsimp only
  rw [← le_sub_comm] at ht
  apply Real.le_sqrt_of_sq_le
  rw [abs_of_nonneg (le_trans (sq_nonneg _) ht)]
  exact ht

lemma piecewise_concave_plus_sqrt_dist (x : ℝ) :
    PiecewiseConcavePlusOn {x} (fun t ↦ √|x - t|) := by
  rw [PiecewiseConcavePlusOn]
  constructorm* _ ∧ _
  · exact piecewise_concave_sqrt_dist x
  · exact unbounded_at_pos_infinity_sqrt_dist x
  · exact unbounded_at_neg_infinity_sqrt_dist x

lemma piecewise_concave_plus_sum_sqrt_dist {α : Type u} [DecidableEq α] (s : Finset α) (hs : s.Nonempty) (x : α → ℝ) :
      PiecewiseConcavePlusOn (s.image x) (Finset.SumSqrtDist s x) := by
    have h' : ∀ i ∈ s, PiecewiseConcavePlusOn {x i} (fun t ↦ √|x i - t|) := by
      intro i hi
      exact piecewise_concave_plus_sqrt_dist (x i)
    have h := piecewise_concave_plus_sum s hs (fun i ↦ {x i}) (fun i ↦ fun t ↦ √|x i - t|) h'
    have hsum : ∑ i ∈ s, (fun t ↦ √|x i - t|) = Finset.SumSqrtDist s x := by
      ext t
      rw [Finset.SumSqrtDist]
      apply Finset.sum_apply
    rw [Finset.biUnion_singleton, hsum] at h
    exact h

lemma exists_decrease_sum_sqrt_dist {α : Type u} [DecidableEq α] (s : Finset α) (hs : s.Nonempty) (x : α → ℝ) :
    ExistsDecreaseOn (s.image x) (Finset.SumSqrtDist s x) := by
  apply exists_decrease_of_piecewise_concave_plus
  exact piecewise_concave_plus_sum_sqrt_dist s hs x

lemma exists_sum_sqrt_dist_le_sum_sqrt_dist {α : Type u} [DecidableEq α] (s : Finset α) (hs : s.Nonempty) (x : α → ℝ) :
  ∃ k ∈ s, ∑ i ∈ s, √|x i - x k| ≤ ∑ i ∈ s, √|x i| := by
  have h := exists_decrease_sum_sqrt_dist s hs x 0
  rcases h with ⟨xk, hxks, hxk⟩
  rw [Finset.mem_image] at hxks
  rcases hxks with ⟨k, hks, hk⟩
  use k
  rw [and_iff_right hks]
  rw [Finset.SumSqrtDist, Finset.SumSqrtDist, ← hk] at hxk
  ring_nf at hxk
  exact hxk

lemma decrease_sum {α : Type u} [DecidableEq α] (s : Finset α) (hs : s.Nonempty) (x : α → ℝ) :
  ∃ k ∈ s, ∃ l ∈ s, ∑ i ∈ s, ∑ j ∈ s, √|x i + x j - (x k + x l)| ≤ ∑ i ∈ s, ∑ j ∈ s, √|x i + x j| := by
  have h := exists_sum_sqrt_dist_le_sum_sqrt_dist (s ×ˢ s) (Finset.Nonempty.product hs hs) (fun (i,j) ↦ x i + x j)
  rcases h with ⟨⟨k, l⟩, hkls, hkl⟩
  simp [Finset.mem_product] at hkls
  simp [Finset.sum_product] at hkl
  use k
  rw [and_iff_right hkls.left]
  use l
  rw [and_iff_right hkls.right]
  exact hkl

theorem imo2021_p2_finset_version {α : Type u} [DecidableEq α] (s : Finset α) (x : α → ℝ) :
    ∑ i ∈ s, ∑ j ∈ s, √|x i - x j| ≤ ∑ i ∈ s, ∑ j ∈ s, √|x i + x j| := by
  induction' s using Finset.strongInductionOn with s h generalizing x
  by_cases! hs : ¬s.Nonempty
  · rw [Finset.not_nonempty_iff_eq_empty] at hs
    rw [hs, Finset.sum_empty, Finset.sum_empty]
  · rcases decrease_sum s hs x with ⟨k, hk, l, hl, hkl⟩
    apply le_trans' hkl
    by_cases! hkl' : k = l
    · rw [← hkl']
      set s' := s.erase k with hs'
      set x' := fun i ↦ x i - x k
      have h' := h s' (Finset.erase_ssubset hk) x'
      simp only [x'] at h'
      rw [← Finset.insert_erase hk]
      repeat rw [Finset.sum_insert (Finset.notMem_erase k s)]
      nth_rw 1 [Finset.sum_comm]
      nth_rw 2 [Finset.sum_comm]
      repeat rw [Finset.sum_insert (Finset.notMem_erase k s)]
      nth_rw 1 [Finset.sum_comm]
      nth_rw 2 [Finset.sum_comm]
      repeat rw [← hs']
      have hsum₁ : ∀ i ∈ s', √|x k - x i| = √|x i - x k| := by
        intro i hi
        rw [← abs_neg]
        ring_nf
      rw [Finset.sum_congr rfl hsum₁]
      ring_nf at ⊢ h'
      exact (add_le_add_iff_left _).mpr h'
    · set s' := s \ {k, l} with hs'
      set x' := fun i ↦ x i - (x k + x l) / 2
      have hkl'' : {k, l} ⊆ s := by
        rw [Finset.insert_subset_iff, Finset.singleton_subset_iff]
        exact ⟨hk, hl⟩
      have h' := h s' (Finset.sdiff_ssubset hkl'' (Finset.insert_nonempty _ _)) x'
      simp only [x'] at h'
      rw [← Finset.sdiff_union_of_subset hkl'']
      repeat rw [Finset.sum_union Finset.sdiff_disjoint, Finset.sum_pair hkl']
      nth_rw 1 [Finset.sum_comm]
      nth_rw 2 [Finset.sum_comm]
      repeat rw [Finset.sum_union Finset.sdiff_disjoint, Finset.sum_pair hkl']
      nth_rw 1 [Finset.sum_comm]
      nth_rw 2 [Finset.sum_comm]
      repeat rw [← hs']
      have hsum₁ : ∀ i ∈ s', √|x k - x i| = √|x i - x k| := by
        intro i hi
        rw [← abs_neg]
        ring_nf
      have hsum₂ : ∀ i ∈ s', √|x l - x i| = √|x i - x l| := by
        intro i hi
        rw [← abs_neg]
        ring_nf
      rw [Finset.sum_congr rfl hsum₁, Finset.sum_congr rfl hsum₂]
      ring_nf at ⊢ h'
      repeat rw [add_assoc]
      rw [add_comm]
      repeat rw [add_assoc]
      repeat rw [add_le_add_iff_left]
      exact h'



theorem imo2021_p2 (n : ℕ) (x : Fin n → ℝ) :
    ∑ i, ∑ j, √|x i - x j| ≤ ∑ i, ∑ j, √|x i + x j| := by
  exact imo2021_p2_finset_version Finset.univ x


end Imo2021P2

-- ═══ Imo2023P1 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Clayton Knittel
-/





/-!
# International Mathematical Olympiad 2023, Problem 1

Determine all composite integers n>1 that satisfy the following property:
if d₁,d₂,...,dₖ are all the positive divisors of n with
1 = d₁ < d₂ < ... < dₖ = n, then dᵢ divides dᵢ₊₁ + dᵢ₊₂ for every
1 ≤ i ≤ k - 2.
-/

namespace Imo2023P1

abbrev ConsecutiveFactors (n a b : ℕ) :=
  a ∣ n ∧ b ∣ n ∧ a < b ∧ ¬∃ c, (c ∣ n ∧ a < c ∧ c < b)

abbrev Dividable (n : ℕ) :=
  ∀ {a b c : ℕ},
    ConsecutiveFactors n a b ∧ ConsecutiveFactors n b c
    → a ∣ b + c



/-- Powers of distinct primes are never equal. -/
lemma PrimePow_ne {a b p q : ℕ} (p_prime : p.Prime) (q_prime : q.Prime) (p_ne_q : p ≠ q)
    (ha : ∃ k > 0, p ^ k = a) (hb : ∃ k > 0, q ^ k = b)
    : a ≠ b := by
  by_contra a_eq_b
  obtain ⟨_, k_ne_0, ha⟩ := ha
  obtain ⟨_, _, hb⟩ := hb
  let h := congrArg (Nat.factorization · p) (hb ▸ a_eq_b ▸ ha)
  dsimp at h
  rw [Nat.Prime.factorization_pow p_prime,
      Nat.Prime.factorization_pow q_prime,
      Finsupp.single_eq_same,
      Finsupp.single_eq_of_ne p_ne_q] at h
  exact k_ne_0.ne.symm h

/-- If a number divides some non-zero number, it is also nonzero. -/
lemma dvd_ne_zero {a b : ℕ} (hb : b ≠ 0) (h : a ∣ b) : 0 < a :=
  Nat.zero_lt_of_ne_zero (fun ha => hb (zero_dvd_iff.mp (ha ▸ h)))

/-- If a prime `p` divides `n`, then `n.factorization p ≠ 0`. -/
lemma dvd_n_fact_ne_zero {n p : ℕ} (n_ne_0 : n ≠ 0) (p_prime : p.Prime) (p_dvd_n : p ∣ n)
    : n.factorization p ≠ 0 := by
  by_contra h
  have := (Nat.factorization_eq_zero_iff n p).mp h
  apply not_or_intro ?_ (not_or_intro ?_ n_ne_0) this
  · exact not_not_intro p_prime
  · exact not_not_intro p_dvd_n

/-- Complementary factors are inversely ordered. -/
lemma mul_cmp_compl {a b x y : ℕ} (hab : a < b) (hy : 0 < y)
    (h : a * x = b * y) : y < x :=
  Nat.lt_of_mul_lt_mul_left
    (h ▸ Nat.mul_lt_mul_of_pos_right hab hy)

/-- Given prime `p`, the factorization of `p + 1` is `0` at `p`. -/
theorem p_succ_fact_zero {p : ℕ} (hp : p.Prime)
    : (p + 1).factorization p = 0 := by
  apply Nat.factorization_eq_zero_of_not_dvd
  exact hp.not_dvd_one ∘ Nat.dvd_add_self_left.mp

/-- If `p ^ e < c < p ^ (e + 1)`, then `∃ q` prime that divides `c`. -/
theorem not_pow_cons_factors_other_prime {p e c : ℕ} (hp : p.Prime)
    (c_gt_e : c > p ^ e) (c_lt_p_e_succ : c < p ^ (e + 1))
    : ∃ q ≠ p, q.Prime ∧ q ∣ c := by
  by_contra h
  have : ∃ c_e, c.factorization = Finsupp.single p c_e := by
    exists c.factorization p
    ext q
    by_cases hq : q = p
    · rw [hq, Finsupp.single_eq_same]
    · rw [Finsupp.single_eq_of_ne hq]
      have {q : ℕ} (q_ne_p : q ≠ p) : c.factorization q = 0 := by
        refine (em q.Prime).elim (fun q_prime => ?_) (Nat.factorization_eq_zero_of_not_prime c)
        by_contra h₂
        exact h ⟨q, q_ne_p, q_prime, Nat.dvd_of_factorization_pos h₂⟩
      exact this hq

  obtain ⟨c_e, hf⟩ := this

  let c_is_pow_p :=
    Nat.eq_of_factorization_eq
      (Nat.ne_zero_of_lt c_gt_e)
      (pow_ne_zero c_e hp.ne_zero)
      fun p => (congrArg (· p) (Nat.Prime.factorization_pow hp ▸ hf))

  have gt_e : c_e ≥ e + 1 :=
    (Nat.pow_lt_pow_iff_right hp.one_lt).mp (c_is_pow_p ▸ c_gt_e)
  have lt_e_succ : c_e < e + 1 :=
    (Nat.pow_lt_pow_iff_right hp.one_lt).mp (c_is_pow_p ▸ c_lt_p_e_succ)
  exact Nat.le_lt_asymm gt_e lt_e_succ

/-- The inverse factors of consecutive factors of `n` are themselves
 consecutive factors of `n`. -/
theorem inv_cons_factors {n a b x y : ℕ} (hn : 0 < n) (ha : n = a * x)
    (hb : n = b * y) (h : ConsecutiveFactors n a b)
    : ConsecutiveFactors n y x := by
  have div_n_ne_0 {a b : ℕ} (h : n = a * b) : 0 < b :=
    Nat.zero_lt_of_ne_zero ((Nat.mul_ne_zero_iff).mp (h ▸ hn.ne).symm).right

  obtain ⟨_, _, a_lt_b, no_c⟩ := h
  have y_lt_x := mul_cmp_compl a_lt_b (div_n_ne_0 hb) (ha ▸ hb)

  rw [Nat.mul_comm] at ha
  rw [Nat.mul_comm] at hb
  refine ⟨⟨b, hb⟩, ⟨a, ha⟩, y_lt_x, ?_⟩

  by_contra hc
  let ⟨c, ⟨z, hc⟩, y_lt_c, c_lt_x⟩ := hc
  apply no_c

  exists z
  exact ⟨
    ⟨c, Nat.mul_comm _ _ ▸ hc⟩,
    mul_cmp_compl c_lt_x (div_n_ne_0 ha) (hc ▸ ha),
    mul_cmp_compl y_lt_c (div_n_ne_0 hc) (hc ▸ hb.symm)
  ⟩

/-- If `n.factorization p ≠ 0`, then `p` is prime. -/
theorem factorization_prime {n p : ℕ} (h : n.factorization p ≠ 0) : p.Prime := by
  by_cases hp : p.Prime
  · exact hp
  · exact False.elim (h (Nat.factorization_eq_zero_of_not_prime n hp))

/-- If `n` is not a prime power, then its `ordCompl[p]` with respect to any `p`
 is `> 1`. -/
theorem ordCompl_of_non_prime_pow {n p : ℕ} (hn : 1 < n) (hp : ¬IsPrimePow n)
    : ordCompl[p] n > 1 := by
  -- Show by contradiction that if `ordCompl[p] n = 1`, then `n` is a prime
  -- power.
  have n_ne_0 := Nat.ne_zero_of_lt hn
  let c := ordCompl[p] n
  by_contra hc
  apply hp

  have c_eq_1 :=
    let hc := Nat.le_of_not_lt hc
    have c_ne_0 := (dvd_ne_zero n_ne_0 (Nat.ordCompl_dvd n p)).ne.symm
    (Nat.le_one_iff_eq_zero_or_eq_one.mp hc).resolve_left c_ne_0
  have c_fact_eq_0 (q : ℕ): c.factorization q = 0 := by
    dsimp [c]
    rw [c_eq_1, Nat.factorization_one]
    rfl

  -- We can take `p` prime and `p ∣ n`, since for non-prime p which does not
  -- divide `n`, `ordCompl[p] n = n` is trivially `> 1`.
  have p_prime :=
    Classical.byContradiction
      (hn.ne ∘ (c_eq_1 ▸ Nat.ordCompl_of_not_prime n p))
  have p_dvd_n : p ∣ n := by
    by_contra h
    have : c = n := by
      rw [← Nat.div_one n, ← Nat.pow_zero p, ← Nat.factorization_eq_zero_of_not_dvd h]
    exact (this ▸ hn).ne c_eq_1.symm

  have n_fact_p_ne_0 : n.factorization p ≠ 0 := dvd_n_fact_ne_zero n_ne_0 p_prime p_dvd_n

  -- Since `c = 1`, `n.factorization q` for `q ≠ p` is `= 0`.
  have (q : ℕ): n.factorization q = Finsupp.single p (n.factorization p) q := by
    if h : q = p then
      rw [h, Finsupp.single_eq_same]
    else
      let c_fact_q := congrArg (· q) (Nat.factorization_ordCompl n p)
      dsimp at c_fact_q
      rw [Finsupp.erase_ne h] at c_fact_q
      rw [← c_fact_q, Finsupp.single_eq_of_ne h]
      exact c_fact_eq_0 q
  -- So `n` is a prime power.
  have n_eq_p_pow :=
    Nat.eq_of_factorization_eq
      n_ne_0
      (pow_ne_zero _ p_prime.ne_zero)
      (Nat.Prime.factorization_pow p_prime ▸ this)

  exact ⟨p, _, p_prime.prime, Nat.zero_lt_of_ne_zero n_fact_p_ne_0, n_eq_p_pow.symm⟩

/-- If `n` is not a prime power, and `p` is its minimum factor, then the second
 smallest prime factor `q` is consecutive to `p` to some power `> 0`.

 This theorem is key to solving the `Dividable → PrimePower` direction of the
 problem. -/
theorem minFac_cons_factor {n : ℕ} (hn : 1 < n) (h : ¬IsPrimePow n)
    : ∃ q e,
      q.Prime ∧ q ≠ n.minFac ∧
      ConsecutiveFactors n (n.minFac ^ e) (n.minFac ^ (e + 1)) ∧
      ConsecutiveFactors n (n.minFac ^ (e + 1)) q := by
  have n_ne_0 := Nat.ne_zero_of_lt hn

  let p := n.minFac
  have p_prime : p.Prime := n.minFac_prime (Nat.ne_of_lt hn).symm

  let c := ordCompl[p] n
  have c_fact_def := fun r => congrArg (· r) (Nat.factorization_ordCompl n p)
  have c_dvd_n := Nat.ordCompl_dvd n p
  have c_gt_one : 1 < c := ordCompl_of_non_prime_pow hn h

  -- Take `q` to be the second smallest prime factor of `n`.
  let q := c.minFac
  have q_prime : q.Prime := c.minFac_prime (Nat.ne_of_lt c_gt_one).symm

  -- Since `q` is the second smallest prime factor of `n`, the only prime
  -- factor `< q` is `p`.
  have p_unique {r : ℕ} (r_lt_q : r < q) (r_ne_p : r ≠ p) : n.factorization r = 0 := by
    have c_fact_r := c_fact_def r
    rw [Finsupp.erase_ne r_ne_p] at c_fact_r
    rw [← c_fact_r]
    by_contra h
    refine Nat.le_lt_asymm (Nat.minFac_le_of_dvd ?_ ?_) r_lt_q
    · exact (factorization_prime h).one_lt
    · exact Nat.dvd_of_factorization_pos h

  have p_lt_q : p < q := by
    have q_dvd_c : q ∣ c := Nat.minFac_dvd c
    have q_dvd_n : q ∣ n := Nat.dvd_trans q_dvd_c c_dvd_n
    have c_fact_q_ne_0 :=
      dvd_n_fact_ne_zero (Nat.ne_zero_of_lt c_gt_one) q_prime q_dvd_c

    refine Nat.lt_of_le_of_ne ?_ ?_
    · exact Nat.minFac_le_of_dvd q_prime.one_lt q_dvd_n
    · by_contra h
      apply c_fact_q_ne_0
      rw [c_fact_def, h, Finsupp.erase_same]

  -- Find the largest power we can raise `p` to without exceeding `q` nor `p`'s
  -- multiplicity.
  let e_succ := min (n.factorization p) (p.log q)
  have e_succ_ne_0 : 0 < e_succ := by
    refine lt_min ?_ ?_
    · exact p_prime.factorization_pos_of_dvd n_ne_0 (Nat.minFac_dvd n)
    · simp [p_lt_q.le, p_prime.one_lt]
  -- Label its predecessor `e`.
  let ⟨e, he⟩ := Nat.exists_add_one_eq.mpr e_succ_ne_0

  exists q, e
  -- We have already shown `q` is prime, and `p ≠ q`.
  refine ⟨q_prime, (Nat.ne_of_lt p_lt_q).symm, ?_⟩

  -- Show that both `p ^ e` and `p ^ (e + 1)` divide `n`.
  have {e : ℕ} : e ≤ n.factorization p → p ^ e ∣ n :=
    Nat.multiplicity_eq_factorization p_prime n_ne_0
      ▸ pow_dvd_of_le_multiplicity
  have p_e_dvd_n : p ^ e ∣ n :=
    (he ▸ this ∘ Nat.le_of_add_right_le) (Nat.min_le_left _ _)
  have p_e_succ_dvd_n : p ^ (e + 1) ∣ n :=
    he ▸ this (Nat.min_le_left _ _)

  have p_e_succ_lt_q : p ^ (e + 1) < q := by
    rw [he]
    refine Nat.lt_of_le_of_ne ?_ ?_
    · exact Nat.pow_le_of_le_log q_prime.ne_zero (min_le_right _ _)
    · exact PrimePow_ne p_prime q_prime p_lt_q.ne
        ⟨e_succ, e_succ_ne_0, rfl⟩
        ⟨1, Nat.zero_lt_one, q.pow_one⟩

  have : ConsecutiveFactors n (p ^ e) (p ^ (e + 1)) := by
    -- Show these are consecutive factors by showing that any number between
    -- them must have a prime factor different from `p` and `< q`, which we
    -- know does not exist.
    refine ⟨p_e_dvd_n, p_e_succ_dvd_n, Nat.pow_lt_pow_succ p_prime.one_lt, ?_⟩
    by_contra hd
    obtain ⟨d, d_dvd_n, d_gt_p_e, d_lt_p_e_succ⟩ := hd
    obtain ⟨r, r_ne_p, r_prime, r_dvd_d⟩ :=
      not_pow_cons_factors_other_prime p_prime d_gt_p_e d_lt_p_e_succ

    apply dvd_n_fact_ne_zero n_ne_0 r_prime (r_dvd_d.trans d_dvd_n)
    refine p_unique ?_ r_ne_p
    exact Nat.lt_of_le_of_lt
      (Nat.le_of_dvd (dvd_ne_zero n_ne_0 d_dvd_n) r_dvd_d)
      (d_lt_p_e_succ.trans p_e_succ_lt_q)
  refine ⟨this, ?_⟩

  -- Show ConsecutiveFactors n (p ^ (e + 1)) q
  refine ⟨p_e_succ_dvd_n, c.minFac_dvd.trans c_dvd_n, p_e_succ_lt_q, ?_⟩
  -- By contradiction, assume `∃ d` between these two factors.
  by_contra h
  obtain ⟨d, d_dvd_n, d_gt_p_e_succ, d_lt_q⟩ := h

  have d_ne_0 := (Nat.ne_of_lt (dvd_ne_zero n_ne_0 d_dvd_n)).symm
  have d_fact_lt_n : d.factorization ≤ n.factorization :=
    (Nat.factorization_le_iff_dvd
      (dvd_ne_zero n_ne_0 d_dvd_n).ne.symm
      n_ne_0).mpr d_dvd_n

  -- d's factorization must only contain `p`, since `d < q`.
  have : ∃ d_e, d.factorization = Finsupp.single p d_e := by
    exists d.factorization p
    ext r
    if hr : r = p then
      rw [hr, Finsupp.single_eq_same]
    else
      rw [Finsupp.single_eq_of_ne hr]
      exact if r_ge_q : r ≥ q then
        Nat.factorization_eq_zero_of_lt (Nat.lt_of_lt_of_le d_lt_q r_ge_q)
      else
        Nat.le_zero.mp (p_unique (Nat.lt_of_not_ge r_ge_q) hr ▸ d_fact_lt_n r)
  obtain ⟨d_e, hd_e⟩ := this

  -- Therefore `d` is a power of `p`.
  have d_eq_p_e :=
    Nat.eq_of_factorization_eq
      d_ne_0
      (Nat.pow_pos (Nat.minFac_pos n)).ne.symm
      fun r => congrArg (· r) (Nat.Prime.factorization_pow p_prime ▸ hd_e)
  -- And its power is `> e + 1`.
  have d_e_gt_e_succ : d_e > e_succ := by
    apply (Nat.pow_lt_pow_iff_right p_prime.one_lt).mp
    rw [← d_eq_p_e, ← he]
    exact d_gt_p_e_succ

  -- Show that in both cases, `d` is too large, either having too high a
  -- multiplicity of `p`, or being larger than `q`.
  by_cases he_min : n.factorization p < p.log q
  · -- Show d_e > n.factorization p
    refine Nat.le_lt_asymm (?_ : d_e ≤ n.factorization p) ?_
    · rw [← (Finsupp.single_eq_same : _ = d_e), ← hd_e]
      exact d_fact_lt_n p
    · rw [← min_eq_left he_min.le]
      exact d_e_gt_e_succ
  · -- Show d = p ^ d_e > q
    have : q ≤ p ^ (Nat.log p q + 1) :=
      (Nat.lt_pow_succ_log_self p_prime.one_lt q).le
    apply Nat.lt_le_asymm d_lt_q ∘ this.trans
    rw [d_eq_p_e, ← min_eq_right (Nat.ge_of_not_lt he_min)]
    apply (Nat.pow_le_pow_iff_right p_prime.one_lt).mpr
    exact d_e_gt_e_succ

/-- The consecutive factors of prime powers of `p` are a factor `p` apart. -/
lemma PrimePow_cons_are_p_apart {x y p n : ℕ} (p_prime : p.Prime)
    (hn : ∃ k, 0 < k ∧ p ^ k = n) (h : ConsecutiveFactors n x y)
    : x * p = y := by
  obtain ⟨e, ⟨e_gt_0, n_eq_p_exp⟩⟩ := hn
  obtain ⟨hx, ⟨hy, ⟨x_lt_y, h⟩⟩⟩ := h
  let ⟨x_exp, ⟨_, x_eq_p_exp⟩⟩ :=
    (Nat.dvd_prime_pow p_prime).mp (n_eq_p_exp ▸ hx)
  let ⟨y_exp, ⟨_, y_eq_p_exp⟩⟩ :=
    (Nat.dvd_prime_pow p_prime).mp (n_eq_p_exp ▸ hy)

  have exp_lt : x_exp < y_exp := by
    apply (Nat.pow_lt_pow_iff_right p_prime.one_lt).mp
    rw [← x_eq_p_exp, ← y_eq_p_exp]
    exact x_lt_y

  have exp_eq : x_exp + 1 = y_exp := by
    by_contra ne
    apply h
    have lt := Nat.lt_of_le_of_ne exp_lt ne

    exists p ^ (x_exp + 1)
    refine And.intro ?_ ⟨
        x_eq_p_exp ▸ Nat.pow_lt_pow_succ p_prime.one_lt,
        y_eq_p_exp ▸ Nat.pow_lt_pow_of_lt p_prime.one_lt lt
      ⟩

    let ⟨b, n_eq⟩ := hy
    let ⟨k, y_eq⟩ := Nat.exists_eq_add_of_lt lt
    exists b * p ^ (k + 1)
    rw [n_eq, y_eq_p_exp, y_eq, add_assoc, Nat.pow_add, mul_assoc,
        mul_comm _ b]

  rw [x_eq_p_exp, y_eq_p_exp, ← exp_eq]
  exact rfl

/-- Proof that all prime powers are `Dividable`. -/
lemma PrimePow_is_dividable {n : ℕ} : IsPrimePow n → 1 < n ∧ Dividable n := by
  intro h
  refine ⟨h.one_lt, ?_⟩

  obtain ⟨p, e, hp, hpp⟩ := h
  intro _ _ _ ⟨xy_cons, yz_cons⟩
  let y_subs := PrimePow_cons_are_p_apart hp.nat_prime ⟨e, hpp⟩ xy_cons
  let z_subs := PrimePow_cons_are_p_apart hp.nat_prime ⟨e, hpp⟩ yz_cons
  rw [← z_subs, ← y_subs]
  exists p + p ^ 2
  linarith

/-- Proof that all `Dividable` numbers `> 1` are prime powers. -/
lemma dividable_is_PrimePow {n : ℕ} (h : 1 < n ∧ Dividable n)
    : IsPrimePow n := by
  obtain ⟨n_gt_1, hd⟩ := h
  let p := n.minFac
  let p_prime := (n.minFac_prime (Nat.ne_of_lt n_gt_1).symm)

  by_contra hn
  let ⟨q, e, q_prime, q_ne_p, cxy, cyz⟩ := minFac_cons_factor n_gt_1 hn
  let ⟨x_div_n, y_div_n, _⟩ := cxy
  let ⟨_, z_div_n, _⟩ := cyz
  obtain ⟨x, hx⟩ := x_div_n
  obtain ⟨y, hy⟩ := y_div_n
  obtain ⟨z, hz⟩ := z_div_n

  have h : p ^ (e + 1) ∣ q * (p + 1) := by
    let ⟨c, h⟩ :=
      have n_gt_0 := Nat.zero_lt_of_lt n_gt_1
      hd ⟨
        inv_cons_factors n_gt_0 hy hz cyz,
        inv_cons_factors n_gt_0 hx hy cxy
      ⟩
    let h := congrArg (p ^ (e + 1) * q * ·) h
    exists c

    have : Function.Injective (· * n) :=
      fun _ _ h => Nat.mul_right_cancel (Nat.zero_lt_of_lt n_gt_1) h
    apply_fun (· * n)
    dsimp

    rw [add_comm, mul_add, add_mul, mul_one]
    nth_rw 1 [hy]
    nth_rw 2 [hx]
    nth_rw 3 [hz]

    rw [mul_assoc, ← Nat.mul_add q, ← mul_assoc, ← Nat.pow_add_one',
        ← Nat.mul_add, ← mul_assoc, mul_comm q, mul_assoc _ c, mul_rotate' c,
        ← mul_assoc]
    exact h

  have : 0 < (p ^ (e + 1)).factorization p := by
    rw [p_prime.factorization_pow, Finsupp.single_eq_same]
    exact Nat.zero_lt_succ _
  apply Nat.not_le_of_gt this

  -- Show that `q * (p + 1)` is not divisible by `p`.
  have : (q * (p + 1)).factorization p = 0 := by
    rw [Nat.factorization_mul q_prime.ne_zero p.succ_ne_zero]
    dsimp
    rw [q_prime.factorization, Finsupp.single_eq_of_ne q_ne_p.symm,
        p_succ_fact_zero p_prime]
  refine this ▸ (Nat.factorization_le_iff_dvd ?_ ?_).mpr h p
  · exact (pow_ne_zero (e + 1) p_prime.ne_zero)
  · exact (Nat.mul_ne_zero q_prime.ne_zero p.succ_ne_zero)



noncomputable def solution_set : Set ℕ := { n | ¬n.Prime ∧ IsPrimePow n }

theorem imo2023_p1 : solution_set = { n | 1 < n ∧ ¬n.Prime ∧ Dividable n } := by
  ext x
  refine ⟨fun ⟨hx₁, hx₂⟩ ↦ ?_, fun ⟨hx₁, hx₂, hx₃⟩ ↦ ?_⟩
  · have ⟨hx₃, hx₄⟩ := PrimePow_is_dividable hx₂
    refine ⟨hx₃, hx₁, hx₄⟩
  · exact ⟨hx₂, dividable_is_PrimePow ⟨hx₁, hx₃⟩⟩

end Imo2023P1

-- ═══ Imo2023P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bolton Bailey, Benpigchu
-/




/-!
# International Mathematical Olympiad 2023, Problem 2

Let ABC be an acute-angled triangle with AB < AC.
Let Ω be the circumcircle of ABC.
Let S be the midpoint of the arc CB of Ω containing A.
The perpendicular from A to BC meets BS at D and meets Ω again at E ≠ A.
The line through D parallel to BC meets line BE at L.
Denote the circumcircle of triangle BDL by ω.
Let ω meet Ω again at P ≠ B.
Prove that the line tangent to ω at P meets line BS on the internal angle bisector of ∠BAC.
-/

open Affine Affine.Simplex EuclideanGeometry FiniteDimensional Module

open scoped Affine EuclideanGeometry Real InnerProductSpace

attribute [local instance] FiniteDimensional.of_fact_finrank_eq_two

variable (V : Type*) (Pt : Type*)

variable [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace Pt]

variable [NormedAddTorsor V Pt] [hd2 : Fact (finrank ℝ V = 2)]

variable [Module.Oriented ℝ V (Fin 2)]

namespace Imo2023P2



-- alternate version of Real.Angle.abs_toReal_add_abs_toReal_eq_pi_of_two_nsmul_add_eq_zero_of_sign_eq
lemma aux₁ {a b : Real.Angle} (h₁ : a.sign = b.sign) (h₂ : a.sign ≠ 0)
  (h : 2 • (a + b) = 0) : a + b = Real.pi := by
  rw [Real.Angle.two_nsmul_eq_zero_iff] at h
  rcases h with (h|h)
  · contrapose! h₂
    rw [add_comm, add_eq_zero_iff_eq_neg] at h
    rw [h, Real.Angle.sign_neg, SignType.self_eq_neg_iff] at h₁
    exact h₁
  · exact h

-- alternate version of Real.Angle.sign_pi_sub
lemma aux₂ {a b : Real.Angle} (h : a + b = Real.pi) : a.sign = b.sign := by
  rw [← eq_sub_iff_add_eq] at h
  rw [h]
  apply Real.Angle.sign_pi_sub

lemma aux₃ {a b : Real.Angle} (h : a + b = Real.pi) (h' : a.sign ≠ 0)
  : |a.toReal| + |b.toReal| = Real.pi := by
  have h₁ : 2 • (a + b) = 0 := by
    rw [h]
    exact Real.Angle.two_nsmul_coe_pi
  have h₂ := aux₂ h
  exact Real.Angle.abs_toReal_add_abs_toReal_eq_pi_of_two_zsmul_add_eq_zero_of_sign_eq
    h₁ h₂ h'

lemma aux₄ {a b c : Real.Angle}
  (ha : a.sign ≠ 0)
  (hc : c.sign ≠ 0)
  (h : a + b = c)
  (h' : |a.toReal| + |b.toReal| = |c.toReal|)
  : a.sign = c.sign := by
  wlog hc' : c.sign = -1
  · have h_neg_a : (-a).sign ≠ 0 := by
      rw [Real.Angle.sign_neg, SignType.neg_eq_zero_iff.ne]
      exact ha
    have h_neg_c : (-c).sign ≠ 0 := by
      rw [Real.Angle.sign_neg, SignType.neg_eq_zero_iff.ne]
      exact hc
    have h₁ : (-a) + (-b) = (-c) := by
      rw [← h]
      abel
    have h₂ : |(-a).toReal| + |(-b).toReal| = |(-c).toReal| := by simp [h']
    have h'' := SignType.trichotomy c.sign
    have h₃ : (-c).sign = -1 := by
      rw [Real.Angle.sign_neg, neg_eq_iff_eq_neg]
      tauto
    have h''' := this h_neg_a h_neg_c h₁ h₂ h₃
    rw [Real.Angle.sign_neg, Real.Angle.sign_neg, neg_inj] at h'''
    exact h'''
  rw [hc']
  rw [← Real.Angle.coe_toReal a] at h
  rw [← Real.Angle.coe_toReal b] at h
  rw [← Real.Angle.coe_toReal c] at h
  rw [← sub_eq_zero, ← Real.Angle.coe_add, ← Real.Angle.coe_sub, Real.Angle.coe_eq_zero_iff] at h
  rw [← Real.Angle.toReal_neg_iff_sign_neg] at hc' ⊢
  set a' := a.toReal with haa'
  set b' := b.toReal with hbb'
  set c' := c.toReal with hcc'
  rcases h with ⟨n, hn⟩
  by_contra! ha'
  rw [abs_of_neg hc', abs_of_nonneg ha'] at h'
  rw [le_iff_eq_or_lt] at ha'
  rcases ha' with (ha'|ha')
  · rw [haa'] at ha'
    symm at ha'
    rw [Real.Angle.toReal_eq_zero_iff] at ha'
    contrapose! ha
    rw [ha', Real.Angle.sign_zero]
  · rw [sub_eq_add_neg] at hn
    rw [← Left.neg_pos_iff] at hc'
    set c'' := -c' with hc'c''
    contrapose! hn
    by_cases! hn' : 0 < n
    · apply ne_of_gt
      calc a' + b' + c''
        ≤  a' + |b'| + c'' := by
            apply add_le_add_left
            apply add_le_add_right
            apply le_abs_self
      _ = (2 * c'') := by
          rw [h']
          ring
      _ < (2 * π) := by
          rw [mul_lt_mul_iff_of_pos_left (by norm_num)]
          rw [hc'c'', hcc']
          apply neg_lt_of_neg_lt
          apply Real.Angle.neg_pi_lt_toReal
      _ ≤ n • (2 * π) := by
            rw [← Int.add_one_le_iff, zero_add] at hn'
            rw [le_smul_iff_one_le_left (by positivity)]
            exact hn'
    · apply ne_of_lt
      calc n • (2 * π)
        ≤ 0 := by
            apply smul_nonpos_of_nonpos_of_nonneg hn'
            positivity
      _ < 2 * a' + (b' + |b'|) := by
            apply add_pos_of_pos_of_nonneg (by positivity)
            apply add_abs_nonneg
      _ = a' + b' + c'' := by
            rw [← h']
            ring

lemma aux₅ {a b c : Real.Angle}
  (h : a + b = c)
  (hac : a.sign = c.sign)
  (h' : |a.toReal| < |c.toReal|)
  : a.sign = b.sign := by
  by_cases! ha : a.sign = 0
  · rw [ha] at hac ⊢
    symm at h hac ⊢
    rw [Real.Angle.sign_eq_zero_iff] at hac ha ⊢
    rw [← sub_eq_iff_eq_add'] at h
    rcases hac with hc|hc <;> rcases ha with ha|ha
      <;> rw [ha, hc] at h <;> rw [← h] <;> simp
  · wlog ha' : a.sign = -1
    · have h₁ : (-a) + (-b) = (-c) := by
        rw [← h]
        abel
      have h_neg_ac : (-a).sign = (-c).sign := by
        rw [Real.Angle.sign_neg, Real.Angle.sign_neg, neg_inj]
        exact hac
      have h_neg_a : (-a).sign ≠ 0 := by
        rw [Real.Angle.sign_neg, SignType.neg_eq_zero_iff.ne]
        exact ha
      have h₂ : |(-a).toReal| < |(-c).toReal| := by simp [h']
      have h'' := SignType.trichotomy a.sign
      have h₃ : (-a).sign = -1 := by
        rw [Real.Angle.sign_neg, neg_eq_iff_eq_neg]
        tauto
      have h''' := this h₁ h_neg_ac h₂ h_neg_a h₃
      rw [Real.Angle.sign_neg, Real.Angle.sign_neg, neg_inj] at h'''
      exact h'''
    rw [ha'] at hac ⊢
    symm at h hac ⊢
    rw [← Real.Angle.coe_toReal a] at h
    rw [← Real.Angle.coe_toReal b] at h
    rw [← Real.Angle.coe_toReal c] at h
    rw [← sub_eq_zero, ← Real.Angle.coe_add, ← Real.Angle.coe_sub, Real.Angle.coe_eq_zero_iff] at h
    rw [← Real.Angle.toReal_neg_iff_sign_neg] at hac ha' ⊢
    set a' := a.toReal with haa'
    set b' := b.toReal with hbb'
    set c' := c.toReal with hcc'
    rw [abs_of_neg ha', abs_of_neg hac, neg_lt_neg_iff] at h'
    rcases h with ⟨n, hn⟩
    contrapose! hn
    by_cases! hn' : 0 ≤ n
    · apply ne_of_gt
      calc c' - (a' + b')
        = (c' - a') + -b' := by abel
      _ < 0 := by
            apply add_neg_of_neg_of_nonpos (sub_neg_of_lt h')
            apply neg_nonpos_of_nonneg hn
      _ ≤ n • (2 * π) := by positivity
    · apply ne_of_lt
      calc n • (2 * π)
        ≤ (- 1) • (2 * π) := by
            rw [← Int.le_sub_one_iff, zero_sub] at hn'
            rw [smul_le_smul_iff_of_pos_right (by positivity)]
            exact hn'
      _ = (- π) + 0 + (- π) := by
            ring
      _ < c' + (-a') + (-b') := by
            apply add_lt_add_of_lt_of_le
            · apply add_lt_add
              · exact Real.Angle.neg_pi_lt_toReal c
              · apply neg_pos_of_neg ha'
            · apply neg_le_neg
              apply Real.Angle.toReal_le_pi
      _ = c' - (a' + b') := by abel

lemma aux₆ {a b : Real.Angle} (h₁ : a.sign = b.sign) (h₂ : a.sign ≠ 0)
  (h : 2 • a = 2 • b) : a = b := by
  rw [Real.Angle.two_nsmul_eq_iff] at h
  rcases h with (h|h)
  · exact h
  · contrapose! h₂
    rw [← sub_eq_iff_eq_add] at h
    rw [← h, Real.Angle.sign_sub_pi, SignType.self_eq_neg_iff] at h₁
    exact h₁

lemma aux₇ {x y : ℝ} (h : ∃ k : ℤ, x = y * k)
  (hx : |x| < y)
  : x = 0 := by
    rcases h with ⟨k, hk⟩
    rw [hk]
    apply mul_eq_zero_of_right
    simp
    contrapose! hx
    rw [hk, abs_mul]
    have h₁ : (1 : ℝ) ≤ |↑k| := by
      rw [← Int.cast_one, ← Int.cast_abs, Int.cast_le]
      exact Int.one_le_abs hx
    calc y
        ≤ |y| := by exact le_abs_self y
      _ = |y| * 1 := by exact (mul_one |y|).symm
      _ ≤ |y| * |↑k| := by exact mul_le_mul_of_nonneg_left h₁ (abs_nonneg y)

lemma aux₈ {x y z : ℝ}
  (hx' : 0 ≤ x) (hy' : y ≤ 0)
  (hx : |x| < z) (hy : |y| < z)
  : |x + y| < z := by
    rw [abs_lt]
    constructor
    · calc -z
          _ < y := by exact (abs_lt.mp hy).left
          _ = 0 + y := by exact (zero_add y).symm
          _ ≤ x + y := by exact add_le_add_left hx' y
    · calc x + y
        _ ≤ x + 0 := by exact add_le_add_right hy' x
        _ = x := by exact add_zero x
        _ < z := by exact (abs_lt.mp hx).right

lemma aux₉ {x y z : ℝ} (h : |x + y| = z)
  (hx : |x| < z) (hy : |y| < z)
  : |x| + |y| = z := by
    symm
    rw [← h, abs_add_eq_add_abs_iff]
    contrapose! h
    apply ne_of_lt
    by_cases hx' : 0 ≤ x
    · have hy' := h.left hx'
      exact aux₈ hx' (le_of_lt hy') hx hy
    · push_neg at hx'
      have hy' := h.right (le_of_lt hx')
      rw [add_comm]
      exact aux₈ (le_of_lt hy') (le_of_lt hx') hy hx

lemma aux₁₀ {a b : Real.Angle} (h : 2 • a + 2 • b = Real.pi)
  (ha : |a.toReal| < Real.pi / 2) (hb : |b.toReal| < Real.pi / 2)
  : |a.toReal| + |b.toReal| = Real.pi / 2 := by
    rw [← Real.Angle.coe_toReal a, ← Real.Angle.coe_toReal b] at h
    set a' := a.toReal
    set b' := b.toReal
    rw [← smul_add] at h
    rw [Real.Angle.two_nsmul_eq_pi_iff, ← Real.Angle.coe_add] at h
    repeat rw [Real.Angle.angle_eq_iff_two_pi_dvd_sub] at h
    have h₁ : |a' + b'| < Real.pi := by
      calc |a' + b'|
          ≤ |a'| + |b'| := by exact abs_add_le a' b'
        _ < Real.pi / 2 + Real.pi / 2 := by exact add_lt_add ha hb
        _ = Real.pi := by ring
    have h₂ : 0 ≤ Real.pi / 2 := by
      apply div_nonneg Real.pi_nonneg
      norm_num
    have h₃ : |a' + b'| + |Real.pi / 2| < 2 * Real.pi := by
      calc |a' + b'| + |Real.pi / 2|
            < Real.pi + |Real.pi / 2| := by exact add_lt_add_left h₁ _
          _ = Real.pi + Real.pi / 2 := by exact (add_right_inj _).mpr (abs_eq_self.mpr h₂)
          _ ≤ Real.pi + Real.pi / 2 + Real.pi / 2 := by exact (le_add_iff_nonneg_right _).mpr h₂
          _ = 2 * Real.pi := by ring
    have h₄ : |a' + b'| = Real.pi / 2 := by
      rw [abs_eq h₂]
      rcases h with pos|neg
      · left
        apply eq_of_sub_eq_zero
        apply aux₇ pos
        calc |a' + b' - Real.pi / 2|
            ≤ |a' + b'| + |Real.pi / 2| := by exact abs_sub _ _
          _ < 2 * Real.pi := by exact h₃
      · right
        apply eq_of_sub_eq_zero
        rw [← neg_div]
        apply aux₇ neg
        rw [neg_div, sub_neg_eq_add]
        calc |a' + b' + Real.pi / 2|
            ≤ |a' + b'| + |Real.pi / 2| := by exact abs_add_le _ _
          _ < 2 * Real.pi := by exact h₃
    exact aux₉ h₄ ha hb

lemma angle_eq_of_oangle_eq {A₁ A₂ A₃ B₁ B₂ B₃ : Pt}
  (h : ∡ A₁ A₂ A₃ = ∡ B₁ B₂ B₃)
  (hA₁ : A₁ ≠ A₂) (hA₂ : A₃ ≠ A₂) (hB₁ : B₁ ≠ B₂) (hB₂ : B₃ ≠ B₂)
  : ∠ A₁ A₂ A₃ = ∠ B₁ B₂ B₃ := by
  rw [angle_eq_abs_oangle_toReal hA₁ hA₂, angle_eq_abs_oangle_toReal hB₁ hB₂, h]

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma angle_eq_of_cos_angle_eq {A₁ A₂ A₃ B₁ B₂ B₃ : Pt}
  (h : Real.cos (∠ A₁ A₂ A₃) = Real.cos (∠ B₁ B₂ B₃)) : ∠ A₁ A₂ A₃ = ∠ B₁ B₂ B₃ := by
  unfold EuclideanGeometry.angle at *
  rw [InnerProductGeometry.cos_angle, InnerProductGeometry.cos_angle] at h
  unfold InnerProductGeometry.angle at *
  rw [h]

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma eq_of_mem_sphere_of_collinear {A B C : Pt} {Ω : Sphere Pt}
  (hA : A ∈ Ω) (hB : B ∈ Ω) (hC : C ∈ Ω) (h : Collinear ℝ {A, B, C})
  : A = B ∨ B = C ∨ C = A := by
  by_cases! hAB : A = B
  · left
    exact hAB
  · right
    have hA' : A ∈ ({A, B, C} : Set Pt) := by simp
    have hB' : B ∈ ({A, B, C} : Set Pt) := by simp
    have hC' : C ∈ ({A, B, C} : Set Pt) := by simp
    have hC'' := Collinear.mem_affineSpan_of_mem_of_ne h hA' hB' hC' hAB
    rw [← Sphere.eq_or_eq_secondInter_iff_mem_of_mem_affineSpan_pair hA hC''] at hC
    rcases hC with hC|hC
    · right
      exact hC
    · have hB'' := right_mem_affineSpan_pair ℝ A B
      rw [← Sphere.eq_or_eq_secondInter_iff_mem_of_mem_affineSpan_pair hA hB''] at hB
      rcases hB with hB|hB
      · contrapose! hAB
        exact hB.symm
      · rw [← hC] at hB
        left
        exact hB

omit [Oriented ℝ V (Fin 2)] in
lemma eq_max_of_max_ne_top
  {A B : Submodule ℝ V}
  (hA : Module.finrank ℝ A = 1)
  (h : A ⊔ B ≠ ⊤) : A = A ⊔ B := by
  apply Submodule.eq_of_le_of_finrank_eq le_sup_left
  rw [hA]
  have hAB := Submodule.finrank_le (A ⊔ B)
  rw [hd2.out] at hAB
  have hAB' : 1 ≤ Module.finrank ℝ ↥(A ⊔ B) := by
    rw [← hA]
    exact Submodule.finrank_mono le_sup_left
  have hAB'' : Module.finrank ℝ ↥(A ⊔ B) ≠ 2 := by
    contrapose! h
    apply Submodule.eq_top_of_finrank_eq
    rw [hd2.out, h]
  lia

omit [Oriented ℝ V (Fin 2)] hd2 in
lemma affineSpan_pair_finrank {A B : Pt}
  (hAB : A ≠ B): Module.finrank ℝ (affineSpan ℝ {A, B}).direction = 1 := by
  rw [direction_affineSpan]
  have h := affineIndependent_of_ne ℝ hAB
  rw [← Matrix.range_cons_cons_empty]
  apply AffineIndependent.finrank_vectorSpan h
  simp

omit [Oriented ℝ V (Fin 2)] in
lemma inter_nonempty_of_not_parallel
  {A₁ A₂ B₁ B₂ : Pt}
  (hA : A₁ ≠ A₂) (hB : B₁ ≠ B₂)
  (h : ¬line[ℝ, A₁, A₂] ∥ line[ℝ, B₁, B₂]) :
  Set.Nonempty ((line[ℝ, A₁, A₂] : Set _) ∩ (line[ℝ, B₁, B₂] : Set Pt)) := by
  have hA' : (line[ℝ, A₁, A₂] : Set Pt).Nonempty := by
    use A₁
    apply mem_affineSpan
    simp
  have hB' : (line[ℝ, B₁, B₂] : Set Pt).Nonempty := by
    use B₁
    apply mem_affineSpan
    simp
  apply AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top hA' hB'
  contrapose! h
  rw [AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot]
  constructor
  · set A := (affineSpan ℝ {A₁, A₂}).direction
    set B := (affineSpan ℝ {B₁, B₂}).direction
    trans A ⊔ B
    · exact eq_max_of_max_ne_top V (affineSpan_pair_finrank V Pt hA) h
    · symm
      rw [sup_comm] at *
      exact eq_max_of_max_ne_top V (affineSpan_pair_finrank V Pt hB) h
  · rw [affineSpan_eq_bot, affineSpan_eq_bot]
    constructor <;> intro h' <;> contrapose! h' <;> simp

lemma oangle_eq_zero_of_collinear {P₁ P₂ P₃ : Pt} (h : Collinear ℝ {P₁, P₂, P₃})
  : ∡ P₂ P₁ P₃ = 0 ∨ ∡ P₂ P₃ P₁ = 0 := by
  have h' := h.wbtw_or_wbtw_or_wbtw
  casesm* _ ∨ _
  · left
    exact h'.oangle₂₁₃_eq_zero
  · left
    exact h'.oangle₁₃₂_eq_zero
  · right
    exact h'.oangle₃₁₂_eq_zero

lemma Sphere.IsTangentAt_of_two_zsmul_oangle_eq {s : Sphere Pt} {P P₁ P₂ Q : Pt}
  (hP : P ∈ s) (hP₁ : P₁ ∈ s) (hP₂ : P₂ ∈ s)
  (hPP₁ : P ≠ P₁) (hPP₂ : P ≠ P₂) (hP₁P₂ : P₁ ≠ P₂) (hPQ : P ≠ Q)
  (h : (2 : ℤ) • ∡ Q P P₁ = (2 : ℤ) • ∡ P P₂ P₁ )
  : s.IsTangentAt P (line[ℝ, P, Q]):= by
  apply EuclideanGeometry.Sphere.IsTangentAt_of_angle_eq_pi_div_two _ hP
  have h' := EuclideanGeometry.Sphere.two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi
    hP hP₂ hP₁ hPP₂.symm hP₁P₂.symm hPP₁
  have h_OP : s.center ≠ P := by
    contrapose! hPP₁ with h''
    rw [← h'']
    rw [← dist_eq_zero] at h'' ⊢
    rw [EuclideanGeometry.mem_sphere'.mp hP₁]
    rw [EuclideanGeometry.mem_sphere'.mp hP] at h''
    exact h''
  rw [← h, ← smul_add, add_comm, oangle_add hPQ.symm hPP₁.symm h_OP] at h'
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal hPQ.symm h_OP]
  rw [Real.Angle.abs_toReal_eq_pi_div_two_iff]
  rw [← Real.Angle.two_nsmul_eq_pi_iff]
  exact h'

-- reverse of EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius
omit hd2 [Oriented ℝ V (Fin 2)] in
lemma Sphere.dist_le_radius_of_sbtw {P₁ P₂ P₃ : Pt} {s : Sphere Pt}
  (h : Sbtw ℝ P₁ P₂ P₃)
  (hP₁ : P₁ ∈ s) (hP₃ : P₃ ∈ s)
  : dist P₂ s.center < s.radius := by
  have h := h.dist_lt_max_dist s.center
  rw [EuclideanGeometry.mem_sphere] at hP₁ hP₃
  rw [hP₁, hP₃, max_self] at h
  exact h

-- stronger version of Collinear.wbtw_or_wbtw_or_wbtw
omit hd2 [Oriented ℝ V (Fin 2)] in
lemma Collinear.sbtw_or_wbtw_or_wbtw {P₁ P₂ P₃ : Pt}
  (h : Collinear ℝ {P₁, P₂, P₃})
  : Sbtw ℝ P₁ P₂ P₃ ∨ Wbtw ℝ P₂ P₃ P₁ ∨ Wbtw ℝ P₃ P₁ P₂ := by
  rcases h.wbtw_or_wbtw_or_wbtw with (h'|h')
  · by_cases! h'' : Sbtw ℝ P₁ P₂ P₃
    · left
      exact h''
    · rw [Sbtw, not_and, not_and_or, not_ne_iff, not_ne_iff] at h''
      right
      rcases h'' h' with hX'|hX' <;> rw [hX']
      · right
        apply wbtw_self_right
      · left
        apply wbtw_self_left
  · right
    exact h'

-- eveb stronger version of Collinear.wbtw_or_wbtw_or_wbtw when P₂ ≠ P₃
omit hd2 [Oriented ℝ V (Fin 2)] in
lemma Collinear.sbtw_or_sbtw_or_wbtw_of_ne {P₁ P₂ P₃ : Pt}
  (h : Collinear ℝ {P₁, P₂, P₃}) (h₂₃ : P₂ ≠ P₃)
  : Sbtw ℝ P₁ P₂ P₃ ∨ Sbtw ℝ P₂ P₃ P₁ ∨ Wbtw ℝ P₃ P₁ P₂ := by
  have h' := h.wbtw_or_wbtw_or_wbtw
  by_contra! h''
  rw [Sbtw, not_and_or, not_and_or, not_ne_iff, not_ne_iff] at h''
  rw [Sbtw, not_and_or, not_and_or, not_ne_iff, not_ne_iff] at h''
  have h₁ : P₂ = P₁ → Wbtw ℝ P₃ P₁ P₂ := by
    intro h_eq
    rw [h_eq]
    apply wbtw_self_right
  have h₂ : P₃ = P₁ → Wbtw ℝ P₃ P₁ P₂ := by
    intro h_eq
    rw [h_eq]
    apply wbtw_self_left
  have h₂₃' := h₂₃.symm
  tauto

-- reverse of EuclideanGeometry.two_zsmul_oangle_of_parallel
lemma parallel_of_two_zsmul_oangle_eq {P₁ P₂ P₃ P₄ : Pt}
  (h₁₂ : P₁ ≠ P₂) (h₂₃ : P₂ ≠ P₃) (h₃₄ : P₃ ≠ P₄)
  (h : (2 : ℤ) • ∡ P₁ P₂ P₃ = (2 : ℤ) • ∡ P₄ P₃ P₂)
  : line[ℝ, P₁, P₂] ∥ line[ℝ, P₃, P₄] := by
  symm at h₂₃
  rw [← vsub_eq_zero_iff_eq.ne] at h₁₂ h₂₃ h₃₄
  rw [AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty]
  constructor
  · rw [oangle, oangle] at h
    rw [← neg_vsub_eq_vsub_rev P₃ P₂] at h
    rw [← Orientation.oangle_neg_left_eq_neg_right] at h
    rw [neg_vsub_eq_vsub_rev] at h
    rw [Orientation.oangle_rev, smul_neg, neg_eq_iff_add_eq_zero] at h
    rw [add_comm, ← smul_add, o.oangle_add h₃₄ h₂₃ h₁₂] at h
    rw [Real.Angle.two_zsmul_eq_zero_iff] at h
    rw [o.oangle_eq_zero_or_eq_pi_iff_right_eq_smul] at h
    rw [vectorSpan_pair, vectorSpan_pair]
    symm
    rw [Submodule.span_singleton_eq_span_singleton]
    rcases h with (h|h)
    · contrapose! h
      exact h₃₄
    · rcases h with ⟨x, hx⟩
      by_cases! hx' : x = 0
      · contrapose! hx
        rw [hx', zero_smul]
        exact h₁₂
      · use (Units.mk0 _ hx')
        rw [Units.smul_mk0]
        symm
        exact hx
  · constructor <;> intro h <;> contrapose! h <;> simp

structure SphereOrder (P₁ P₂ P₃ P₄ : Pt) where
  (cospherical : Cospherical {P₁, P₂, P₃, P₄})
  (sign_oangle₁₂₃_ne_zero : (∡ P₁ P₂ P₃).sign ≠ 0)
  (sign_oangle₁₂₃_eq_sign_oangle₃₄₁ : (∡ P₁ P₂ P₃).sign = (∡ P₃ P₄ P₁).sign)

def diag_inter_set (P₁ P₂ P₃ P₄ : Pt) := (line[ℝ, P₁, P₃] : Set Pt) ∩ line[ℝ, P₂, P₄]

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma mem_diag_inter_set_comm  {X P₁ P₂ P₃ P₄ : Pt}
  (h : X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄) : X ∈ diag_inter_set V Pt P₁ P₄ P₃ P₂ := by
  rw [diag_inter_set] at h
  constructor
  · exact h.left
  · rw [Set.pair_comm]
    exact h.right

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma diag_inter_set_comm (P₁ P₂ P₃ P₄ : Pt)
  : diag_inter_set V Pt P₁ P₂ P₃ P₄ = diag_inter_set V Pt P₁ P₄ P₃ P₂ := by
  ext X
  constructor <;> intro h <;> exact mem_diag_inter_set_comm V Pt h

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma mem_diag_inter_set_rotate  {X P₁ P₂ P₃ P₄ : Pt}
  (h : X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄) : X ∈ diag_inter_set V Pt P₂ P₃ P₄ P₁ := by
  rw [diag_inter_set] at h
  constructor
  · exact h.right
  · rw [Set.pair_comm]
    exact h.left

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma diag_inter_set_rotate (P₁ P₂ P₃ P₄ : Pt)
  : diag_inter_set V Pt P₁ P₂ P₃ P₄ = diag_inter_set V Pt P₂ P₃ P₄ P₁ := by
  ext X
  constructor <;> intro h
  · exact mem_diag_inter_set_rotate V Pt h
  · apply mem_diag_inter_set_rotate
    apply mem_diag_inter_set_rotate
    apply mem_diag_inter_set_rotate
    exact h

namespace SphereOrder

variable {P₁ P₂ P₃ P₄ : Pt}

lemma comm (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : SphereOrder V Pt P₁ P₄ P₃ P₂ := by
  constructor
  · rw [Set.pair_comm]
    nth_rw 2 [Set.insert_comm]
    rw [Set.pair_comm]
    exact h.cospherical
  · rw [EuclideanGeometry.oangle_rev, Real.Angle.sign_neg]
    rw [SignType.neg_eq_zero_iff.ne, ← h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    exact h.sign_oangle₁₂₃_ne_zero
  · rw [EuclideanGeometry.oangle_rev, Real.Angle.sign_neg]
    rw [← h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    exact oangle_swap₁₃_sign P₁ P₂ P₃

lemma P₁_ne_P₂ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₁ ≠ P₂ := by
  exact EuclideanGeometry.left_ne_of_oangle_sign_ne_zero h.sign_oangle₁₂₃_ne_zero

lemma P₁_ne_P₃ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₁ ≠ P₃ := by
  exact EuclideanGeometry.left_ne_right_of_oangle_sign_ne_zero h.sign_oangle₁₂₃_ne_zero

lemma P₂_ne_P₃ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₂ ≠ P₃ := by
  exact (EuclideanGeometry.right_ne_of_oangle_sign_ne_zero h.sign_oangle₁₂₃_ne_zero).symm

lemma sign_oangle₃₄₁_ne_zero (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : (∡ P₃ P₄ P₁).sign ≠ 0 := by
  rw [← h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
  exact h.sign_oangle₁₂₃_ne_zero

lemma P₁_ne_P₄ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₁ ≠ P₄ := by
  exact EuclideanGeometry.right_ne_of_oangle_sign_ne_zero h.sign_oangle₃₄₁_ne_zero

lemma P₃_ne_P₄ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₃ ≠ P₄ := by
  exact EuclideanGeometry.left_ne_of_oangle_sign_ne_zero h.sign_oangle₃₄₁_ne_zero

lemma P₂_ne_P₄ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : P₂ ≠ P₄ := by
  have h' := h.sign_oangle₁₂₃_ne_zero
  contrapose! h'
  have h'' := h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁
  rw [← h', EuclideanGeometry.oangle_rev P₁ P₂ P₃, Real.Angle.sign_neg, SignType.self_eq_neg_iff] at h''
  exact h''

lemma oangle₁₂₃_add_oangle₃₄₁_eq_pi (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : ∡ P₁ P₂ P₃ + ∡ P₃ P₄ P₁ = Real.pi := by
  have h' := h.cospherical
  rw [Set.pair_comm] at h'
  have h'' := EuclideanGeometry.Cospherical.two_zsmul_oangle_eq h'
    h.P₁_ne_P₂.symm h.P₂_ne_P₃ h.P₁_ne_P₄.symm h.P₃_ne_P₄.symm
  rw [← sub_eq_zero, ← smul_sub, sub_eq_add_neg, ← EuclideanGeometry.oangle_rev] at h''
  exact aux₁ h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁ h.sign_oangle₁₂₃_ne_zero h''

lemma oangle₂₃₄_add_oangle₄₁₂_eq_pi (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : ∡ P₂ P₃ P₄ + ∡ P₄ P₁ P₂ = Real.pi := by
  have h' := (EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi
    h.P₂_ne_P₃.symm h.P₁_ne_P₃ h.P₁_ne_P₂.symm).symm
  have h'' := (EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi
    h.P₁_ne_P₄ h.P₁_ne_P₃.symm h.P₃_ne_P₄.symm).symm
  rw [← sub_eq_iff_eq_add'] at h' h''
  have h''' := h.oangle₁₂₃_add_oangle₃₄₁_eq_pi
  rw [← h', ← h''] at h'''
  rw [← sub_eq_zero] at h''' ⊢
  rw [← neg_eq_zero, ← h''']
  rw [← EuclideanGeometry.oangle_add h.P₂_ne_P₃ h.P₁_ne_P₃ h.P₃_ne_P₄.symm]
  rw [← EuclideanGeometry.oangle_add h.P₁_ne_P₄.symm h.P₁_ne_P₃.symm h.P₁_ne_P₂.symm]
  abel

lemma rotate (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : SphereOrder V Pt P₂ P₃ P₄ P₁ := by
  constructor
  · rw [Set.pair_comm]
    nth_rw 2 [Set.insert_comm]
    nth_rw 1 [Set.insert_comm]
    exact h.cospherical
  · intro h'
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h'
    have h'' := h.cospherical
    rw [EuclideanGeometry.cospherical_iff_exists_sphere] at h''
    rcases h'' with ⟨Ω, hΩ⟩
    have hP₂ : P₂ ∈ Ω := by
      apply hΩ
      apply Set.mem_insert_of_mem
      apply Set.mem_insert
    have hP₃ : P₃ ∈ Ω := by
      apply hΩ
      apply Set.mem_insert_of_mem
      apply Set.mem_insert_of_mem
      apply Set.mem_insert
    have hP₄ : P₄ ∈ Ω := by
      apply hΩ
      apply Set.mem_insert_of_mem
      apply Set.mem_insert_of_mem
      apply Set.mem_insert_of_mem
      apply Set.mem_singleton
    have h'' := eq_of_mem_sphere_of_collinear V Pt hP₂ hP₃ hP₄ h'
    contrapose! h''
    constructorm* _ ∧ _
    · exact h.P₂_ne_P₃
    · exact h.P₃_ne_P₄
    · exact h.P₂_ne_P₄.symm
  · exact aux₂ h.oangle₂₃₄_add_oangle₄₁₂_eq_pi

lemma symm (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : SphereOrder V Pt P₃ P₄ P₁ P₂ := by
  exact h.rotate.rotate

lemma rotate' (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : SphereOrder V Pt P₄ P₁ P₂ P₃ := by
  exact h.rotate.rotate.rotate

lemma sign_oangle₂₃₄_ne_zero (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : (∡ P₂ P₃ P₄).sign ≠ 0 := by
  exact h.rotate.sign_oangle₁₂₃_ne_zero

lemma angle₁₂₄_add_angle₄₂₃_eq_angle₁₂₃ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : ∠ P₁ P₂ P₄ + ∠ P₄ P₂ P₃ = ∠ P₁ P₂ P₃ := by
  have h₁ := aux₃ h.oangle₁₂₃_add_oangle₃₄₁_eq_pi h.sign_oangle₁₂₃_ne_zero
  have h₂ := aux₃ h.oangle₂₃₄_add_oangle₄₁₂_eq_pi h.sign_oangle₂₃₄_ne_zero
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₂ h.P₂_ne_P₃.symm] at h₁
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₃_ne_P₄ h.P₁_ne_P₄] at h₁
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₂_ne_P₃ h.P₃_ne_P₄.symm] at h₂
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₄.symm h.P₁_ne_P₂.symm] at h₂
  have h₃ := (EuclideanGeometry.angle_add_angle_add_angle_eq_pi P₂ h.P₃_ne_P₄.symm).symm
  have h₄ := (EuclideanGeometry.angle_add_angle_add_angle_eq_pi P₄ h.P₁_ne_P₂.symm).symm
  rw [← sub_eq_iff_eq_add'] at h₃ h₄
  rw [← h₃, ← h₄, ← neg_inj, ← sub_eq_zero] at h₂
  ring_nf at h₂
  repeat rw [add_assoc] at h₂
  rw [neg_add_eq_zero] at h₂
  rw [h₂] at h₁
  nth_rw 1 [add_left_comm] at h₁
  nth_rw 2 [add_left_comm] at h₁
  rw [← add_assoc] at h₁
  have h₅ := EuclideanGeometry.angle_le_angle_add_angle P₂ P₃ P₄ P₁
  have h₆ := EuclideanGeometry.angle_le_angle_add_angle P₄ P₃ P₂ P₁
  rw [EuclideanGeometry.angle_comm P₃ P₂ P₁] at h₅
  rw [EuclideanGeometry.angle_comm P₃ P₂ P₄] at h₅
  rw [EuclideanGeometry.angle_comm P₄ P₂ P₁] at h₅
  rw [add_eq_add_iff_eq_and_eq h₅ h₆] at h₁
  symm
  rw [add_comm]
  exact h₁.left

lemma sign_oangle₁₂₃_eq_sign_oangle₂₃₄ (h : SphereOrder V Pt P₁ P₂ P₃ P₄) : (∡ P₁ P₂ P₃).sign = (∡ P₂ P₃ P₄).sign := by
  have h₁ := EuclideanGeometry.oangle_add h.P₁_ne_P₂ h.P₂_ne_P₄.symm h.P₂_ne_P₃.symm
  have h₂ := h.angle₁₂₄_add_angle₄₂₃_eq_angle₁₂₃
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₂ h.P₂_ne_P₄.symm] at h₂
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₂_ne_P₄.symm h.P₂_ne_P₃.symm] at h₂
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₂ h.P₂_ne_P₃.symm] at h₂
  rw [add_comm] at h₁ h₂
  have h'' : (∡ P₄ P₂ P₃).sign ≠ 0 := by
    rw [← EuclideanGeometry.oangle_rotate_sign]
    exact h.sign_oangle₂₃₄_ne_zero
  have h' := aux₄ h'' h.sign_oangle₁₂₃_ne_zero h₁ h₂
  rw [← h', ← EuclideanGeometry.oangle_rotate_sign]

lemma trans {P₅ : Pt} (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  (h' : SphereOrder V Pt P₃ P₄ P₅ P₁) : SphereOrder V Pt P₅ P₁ P₂ P₃ := by
  apply rotate
  constructor
  · rw [Set.pair_comm]
    apply EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear
    · rw [← EuclideanGeometry.Cospherical.two_zsmul_oangle_eq h'.cospherical
        h'.P₁_ne_P₂.symm h'.P₂_ne_P₄ h'.P₁_ne_P₃.symm h'.P₃_ne_P₄]
      have h'' := h.cospherical
      nth_rw 2 [Set.insert_comm] at h''
      nth_rw 1 [Set.insert_comm] at h''
      nth_rw 2 [Set.insert_comm] at h''
      rw [Set.pair_comm] at h''
      rw [← EuclideanGeometry.Cospherical.two_zsmul_oangle_eq h''
        h.P₂_ne_P₃ h.P₁_ne_P₂.symm h.P₃_ne_P₄.symm h.P₁_ne_P₄.symm]
    · have h'' := h'.cospherical
      rw [cospherical_iff_exists_sphere] at h''
      rcases h'' with ⟨s, hs⟩
      have h₃ : P₃ ∈ s := by
        apply hs
        simp
      have h₅ : P₅ ∈ s := by
        apply hs
        simp
      have h₁ : P₁ ∈ s := by
        apply hs
        simp
      intro h'''
      have h_eq := eq_of_mem_sphere_of_collinear V Pt h₃ h₅ h₁ h'''
      contrapose! h_eq
      constructorm* _ ∧ _
      · exact h'.P₁_ne_P₃
      · exact h'.P₃_ne_P₄
      · exact h'.P₁_ne_P₄.symm
  · rw [← EuclideanGeometry.oangle_rotate_sign]
    exact sign_oangle₃₄₁_ne_zero V Pt h'
  · rw [← EuclideanGeometry.oangle_rotate_sign]
    rw [h'.symm.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    rw [← EuclideanGeometry.oangle_rotate_sign]
    rw [h.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]

lemma trans' {P₅ : Pt} (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  (h' : SphereOrder V Pt P₃ P₄ P₅ P₁) : SphereOrder V Pt P₂ P₃ P₄ P₅ := by
  have h'' := h.trans V Pt h'
  exact h'.trans V Pt h''

lemma trans'' {P₅ : Pt} (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  (h' : SphereOrder V Pt P₃ P₄ P₅ P₁) : SphereOrder V Pt P₄ P₅ P₁ P₂ := by
  have h'' := h.trans V Pt h'
  have h''' := h.trans' V Pt h'
  exact h''.trans V Pt h'''

lemma exists_diag_inter (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  : ∃ X : Pt, X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄ := by
  apply inter_nonempty_of_not_parallel V Pt h.P₁_ne_P₃ h.P₂_ne_P₄
  intro h'
  have h'' := AffineSubspace.Parallel.refl (affineSpan ℝ {P₁, P₂})
  nth_rw 1 [Set.pair_comm] at h''
  nth_rw 1 [Set.pair_comm] at h'
  nth_rw 2 [Set.pair_comm] at h'
  have h_312_124 := EuclideanGeometry.two_zsmul_oangle_of_parallel h'' h'
  rw [EuclideanGeometry.oangle_rev, smul_neg, neg_eq_iff_add_eq_zero, ← smul_add] at h_312_124
  have h_312_124' : (∡ P₃ P₁ P₂).sign = (∡ P₁ P₂ P₄).sign := by
    rw [← EuclideanGeometry.oangle_rotate_sign]
    rw [← h.rotate'.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    rw [← EuclideanGeometry.oangle_rotate_sign]
  have h_312 : (∡ P₃ P₁ P₂).sign ≠ 0 := by
    rw [← EuclideanGeometry.oangle_rotate_sign]
    exact h.sign_oangle₁₂₃_ne_zero
  have h_312_124'' := Real.Angle.abs_toReal_add_abs_toReal_eq_pi_of_two_nsmul_add_eq_zero_of_sign_eq
    h_312_124 h_312_124' h_312
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₃.symm h.P₁_ne_P₂.symm] at h_312_124''
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal h.P₁_ne_P₂ h.P₂_ne_P₄.symm] at h_312_124''
  contrapose! h_312_124''
  have h_124 := (h.angle₁₂₄_add_angle₄₂₃_eq_angle₁₂₃).symm
  rw [← sub_eq_iff_eq_add] at h_124
  rw [← h_124, add_sub]
  have h''' := (EuclideanGeometry.angle_add_angle_add_angle_eq_pi P₂ h.P₁_ne_P₃).symm
  rw [← sub_eq_iff_eq_add] at h'''
  rw [← h''', sub_sub]
  apply ne_of_lt
  rw [sub_lt_self_iff]
  apply add_pos_of_nonneg_of_pos (EuclideanGeometry.angle_nonneg _ _ _)
  apply lt_of_le_of_ne (EuclideanGeometry.angle_nonneg _ _ _)
  symm
  rw [← (EuclideanGeometry.oangle_eq_zero_iff_angle_eq_zero h.P₂_ne_P₄.symm h.P₂_ne_P₃.symm).ne]
  intro h_423
  have h_423' : (∡ P₄ P₂ P₃).sign = 0 := by
    rw [h_423, Real.Angle.sign_zero]
  contrapose! h_423'
  rw [← EuclideanGeometry.oangle_rotate_sign]
  exact h.sign_oangle₂₃₄_ne_zero

lemma diag_inter_ne_P₁ (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  {X : Pt} (hX : X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄)
  : X ≠ P₁ := by
  intro h'
  have hX' := Set.mem_of_mem_inter_right hX
  rw [h'] at hX'
  have h'' := collinear_insert_of_mem_affineSpan_pair hX'
  have h''' := h.cospherical
  rw [EuclideanGeometry.cospherical_iff_exists_sphere] at h'''
  rcases h''' with ⟨s, hs⟩
  have h₁ : P₁ ∈ s := by
    apply hs
    apply Set.mem_insert
  have h₂ : P₂ ∈ s := by
    apply hs
    apply Set.mem_insert_of_mem
    apply Set.mem_insert
  have h₄ : P₄ ∈ s := by
    apply hs
    apply Set.mem_insert_of_mem
    apply Set.mem_insert_of_mem
    apply Set.mem_insert_of_mem
    apply Set.mem_singleton
  have h'''' := eq_of_mem_sphere_of_collinear V Pt h₁ h₂ h₄ h''
  contrapose! h''''
  constructorm* _ ∧ _
  · exact h.P₁_ne_P₂
  · exact h.P₂_ne_P₄
  · exact h.P₁_ne_P₄.symm

lemma diag_inter_sbtw (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  {X : Pt} (hX : X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄)
  : Sbtw ℝ P₁ X P₃ := by
  by_contra! h'
  have h_collinear : Collinear ℝ {P₁, X, P₃} := by
    rw [diag_inter_set, Set.mem_inter_iff] at hX
    rw [Set.insert_comm]
    apply collinear_insert_of_mem_affineSpan_pair
    exact hX.left
  have h'' := Collinear.sbtw_or_wbtw_or_wbtw V Pt h_collinear
  have h''' : Wbtw ℝ X P₃ P₁ ∨ Wbtw ℝ P₃ P₁ X := by
    tauto
  wlog h_wbtw : Wbtw ℝ X P₃ P₁ generalizing P₁ P₂ P₃ P₄
  · have h_wbtw' : Wbtw ℝ X P₁ P₃ := by
      rw [wbtw_comm]
      tauto
    rw [diag_inter_set_rotate, diag_inter_set_rotate] at hX
    rw [sbtw_comm] at h'
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm] at h_collinear
    nth_rw 1 [wbtw_comm] at h''
    nth_rw 2 [wbtw_comm] at h''
    rw [sbtw_comm] at h''
    nth_rw 2 [or_comm] at h''
    nth_rw 1 [wbtw_comm] at h'''
    nth_rw 2 [wbtw_comm] at h'''
    rw [or_comm] at h'''
    exact this h.symm hX h' h_collinear h'' h''' h_wbtw'
  have h_collinear' : Collinear ℝ {P₂, X, P₄} := by
    rw [diag_inter_set, Set.mem_inter_iff] at hX
    rw [Set.insert_comm]
    apply collinear_insert_of_mem_affineSpan_pair
    exact hX.right
  have h'''' := oangle_eq_zero_of_collinear V Pt h_collinear'
  wlog h_oangle : ∡ X P₂ P₄ = 0 generalizing P₁ P₂ P₃ P₄
  · have h_oangle' : ∡ X P₄ P₂ = 0 := by tauto
    rw [diag_inter_set_comm] at hX
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm] at h_collinear'
    rw [or_comm] at h''''
    exact this h.comm hX h' h_collinear h'' h''' h_wbtw h_collinear' h'''' h_oangle'
  have h_X_P₃ : X ≠ P₃ := by
    rw [diag_inter_set_rotate, diag_inter_set_rotate] at hX
    exact h.symm.diag_inter_ne_P₁ V Pt hX
  have h_sign := h_wbtw.oangle_sign_eq_of_ne_left P₂ h_X_P₃
  have h_X_P₂ : X ≠ P₂ := by
    rw [diag_inter_set_rotate] at hX
    exact h.rotate.diag_inter_ne_P₁ V Pt hX
  rw [← EuclideanGeometry.oangle_add h_X_P₂ h.P₂_ne_P₄.symm h.P₂_ne_P₃.symm] at h_sign
  rw [← EuclideanGeometry.oangle_add h_X_P₂ h.P₂_ne_P₄.symm h.P₁_ne_P₂] at h_sign
  rw [h_oangle, zero_add, zero_add] at h_sign
  rw [← EuclideanGeometry.oangle_rotate_sign P₄ P₂ P₃] at h_sign
  rw [← EuclideanGeometry.oangle_rotate_sign P₄ P₂ P₁] at h_sign
  rw [← EuclideanGeometry.oangle_swap₁₃_sign P₄ P₁ P₂] at h_sign
  rw [← h.rotate.sign_oangle₁₂₃_eq_sign_oangle₃₄₁, SignType.self_eq_neg_iff] at h_sign
  contrapose! h_sign
  exact h.sign_oangle₂₃₄_ne_zero

lemma diag_inter_sbtw' (h : SphereOrder V Pt P₁ P₂ P₃ P₄)
  {X : Pt} (hX : X ∈ diag_inter_set V Pt P₁ P₂ P₃ P₄)
  : Sbtw ℝ P₂ X P₄ := by
  rw [diag_inter_set_rotate] at hX
  exact h.rotate.diag_inter_sbtw V Pt hX

end SphereOrder

lemma sphereOrder_of_sbtw_diag_inter
  {P₁ P₂ P₃ P₄ X : Pt}
  (h : Cospherical {P₁, P₂, P₃, P₄}) (h₁₂ : P₁ ≠ P₂) (h₂₃ : P₂ ≠ P₃)
  (h₁₃ : Sbtw ℝ P₁ X P₃) (h₂₄ : Sbtw ℝ P₂ X P₄)
  : SphereOrder V Pt P₁ P₂ P₃ P₄ := by
  constructor
  · exact h
  · intro h'
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h'
    rw [cospherical_iff_exists_sphere] at h
    rcases h with ⟨s, hs⟩
    have hP₁ : P₁ ∈ s := by
      apply hs
      apply Set.mem_insert
    have hP₂ : P₂ ∈ s := by
      apply hs
      apply Set.mem_insert_of_mem
      apply Set.mem_insert
    have hP₃ : P₃ ∈ s := by
      apply hs
      apply Set.mem_insert_of_mem
      apply Set.mem_insert_of_mem
      apply Set.mem_insert
    have h'' := eq_of_mem_sphere_of_collinear V Pt hP₁ hP₂ hP₃ h'
    contrapose! h''
    constructorm* _ ∧ _
    · exact h₁₂
    · exact h₂₃
    · exact h₁₃.left_ne_right.symm
  · rw [EuclideanGeometry.oangle_rotate_sign]
    rw [← h₁₃.oangle_eq_left, EuclideanGeometry.oangle_rev, Real.Angle.sign_neg]
    rw [h₂₄.oangle_sign_eq, h₁₃.oangle_eq_left, EuclideanGeometry.oangle_swap₂₃_sign]

noncomputable def Sphere.antipode
  (s : Sphere Pt) (p : Pt) : Pt :=
  s.secondInter p (s.center -ᵥ p)

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma Sphere.antipode_mem_sphere {s : Sphere Pt} {p : Pt} (h : p ∈ s)
  : Sphere.antipode V Pt s p ∈ s := by
  rw [Sphere.antipode, EuclideanGeometry.Sphere.secondInter_mem]
  exact h

omit hd2 [Oriented ℝ V (Fin 2)] in
lemma Sphere.antipode_isDiameter {s : Sphere Pt} {p : Pt} (h : p ∈ s)
  : Sphere.IsDiameter s p (Sphere.antipode V Pt s p) := by
  rw [Sphere.antipode, EuclideanGeometry.Sphere.isDiameter_iff_mem_and_mem_and_wbtw]
  constructorm* _ ∧ _
  · exact h
  · rw [EuclideanGeometry.Sphere.secondInter_mem]
    exact h
  · apply EuclideanGeometry.Sphere.wbtw_secondInter h
    rw [dist_self]
    apply Sphere.radius_nonneg_of_mem h

structure Imo2023q2Cfg where
  (A B C D E L S P : Pt)
  (Ω ω : Sphere Pt)
  (perp_A_BC prll_D_BC tang_P_ω : AffineSubspace ℝ Pt)
  (h_ABC : AffineIndependent ℝ ![A, B, C])
  (h_acute_ABC : (⟨![A, B, C], h_ABC⟩ : Affine.Triangle _ _).AcuteAngled)
  (h_AB_lt_BC : dist A B < dist A C )
  (h_Ω : {A, B, C} ⊆ (Ω : Set Pt) )
  (h_S_Ω : dist S C = dist S B ∧ S ∈ (Ω : Set Pt))
  (h_S_A : (∡ C B S).sign = (∡ C B A).sign)
  (h_perp_A_BC : perp_A_BC.direction ⟂ line[ℝ, B, C].direction ∧ A ∈ perp_A_BC)
  (h_D : D ∈ (perp_A_BC : Set Pt) ∩ line[ℝ, B, S])
  (h_E : E ∈ (perp_A_BC : Set Pt) ∩ Ω )
  (h_E_ne_A : E ≠ A )
  (h_prll_D_BC : D ∈ prll_D_BC ∧ prll_D_BC ∥ line[ℝ, B, C])
  (h_L : L ∈ (prll_D_BC : Set Pt) ∩ line[ℝ, B, E])
  (h_ω : {B, D, L} ⊆ (ω : Set Pt))
  (h_P : P ∈ (ω : Set Pt) ∩ Ω)
  (h_P_ne_B : P ≠ B)
  (h_rank_tang_P_ω : Module.finrank ℝ tang_P_ω.direction = 1)
  (h_tang_P_ω : Sphere.IsTangentAt ω P tang_P_ω)

namespace Imo2023q2Cfg

variable (cfg : Imo2023q2Cfg V Pt)

def ABC : Affine.Triangle ℝ Pt :=
  ⟨![cfg.A, cfg.B, cfg.C], cfg.h_ABC⟩

lemma B_ne_A : cfg.B ≠ cfg.A := by
  exact cfg.h_ABC.injective.ne (by decide : (1 : Fin 3) ≠ 0)

lemma C_ne_A : cfg.C ≠ cfg.A := by
  exact cfg.h_ABC.injective.ne (by decide : (2 : Fin 3) ≠ 0)

lemma B_ne_C : cfg.B ≠ cfg.C := by
  exact cfg.h_ABC.injective.ne (by decide : (1 : Fin 3) ≠ 2)

lemma S_ne_B : cfg.S ≠ cfg.B := by
  have h := cfg.B_ne_C
  contrapose! h
  rw [← h]
  rw [← dist_eq_zero] at h ⊢
  rw [cfg.h_S_Ω.left]
  exact h

lemma S_ne_C : cfg.S ≠ cfg.C := by
  have h := cfg.B_ne_C
  contrapose! h
  rw [← h]
  rw [← dist_eq_zero] at h ⊢
  rw [cfg.h_S_Ω.left, dist_comm] at h
  exact h

lemma S_ne_A : cfg.S ≠ cfg.A := by
  have h' := cfg.h_S_Ω.left
  have h := cfg.h_AB_lt_BC
  contrapose! h
  apply le_of_eq
  rw [← h]
  exact h'

lemma A_in_Ω : cfg.A ∈ cfg.Ω := by
  have h := cfg.h_Ω
  rw [Set.insert_subset_iff] at h
  exact h.left

lemma B_in_Ω : cfg.B ∈ cfg.Ω := by
  have h := cfg.h_Ω
  rw [Set.insert_subset_iff, Set.insert_subset_iff] at h
  exact h.right.left

lemma C_in_Ω : cfg.C ∈ cfg.Ω := by
  have h := cfg.h_Ω
  rw [Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff] at h
  exact h.right.right

lemma A_opposite_BC : {cfg.B, cfg.C} = Set.range (cfg.ABC.faceOpposite 0).points := by
  ext X
  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_range]
  constructor
  · rintro (h|h)
    · use 0
      rw [Affine.Simplex.faceOpposite_point_eq_point_succAbove, h]
      norm_num
      simp [ABC]
    · use 1
      rw [Affine.Simplex.faceOpposite_point_eq_point_succAbove, h]
      norm_num
      simp [ABC]
  · rintro ⟨y, hy⟩
    rw [Affine.Simplex.faceOpposite_point_eq_point_succAbove] at hy
    fin_cases y <;> norm_num at hy <;> simp [ABC] at hy <;> rw [← hy]
    · left
      rfl
    · right
      rfl

lemma angle_BAC_acute : ∠ cfg.B cfg.A cfg.C < π / 2 := by
  have h := cfg.h_acute_ABC
  rw [Affine.Triangle.acuteAngled_iff_angle_lt] at h
  simp at h
  rw [angle_comm]
  exact h.right.right

lemma angle_ACB_acute : ∠ cfg.A cfg.C cfg.B < π / 2 := by
  have h := cfg.h_acute_ABC
  rw [Affine.Triangle.acuteAngled_iff_angle_lt] at h
  simp at h
  rw [angle_comm]
  exact h.right.left

lemma angle_CBA_acute : ∠ cfg.C cfg.B cfg.A < π / 2 := by
  have h := cfg.h_acute_ABC
  rw [Affine.Triangle.acuteAngled_iff_angle_lt] at h
  simp at h
  rw [angle_comm]
  exact h.left

lemma angle_ACB_lt_angle_CBA : ∠ cfg.A cfg.C cfg.B < ∠ cfg.C cfg.B cfg.A := by
  have h := cfg.h_ABC
  rw [affineIndependent_iff_not_collinear_set] at h
  rw [EuclideanGeometry.angle_comm cfg.C cfg.B cfg.A]
  rw [EuclideanGeometry.angle_lt_iff_dist_lt h]
  exact cfg.h_AB_lt_BC

lemma angle_CBS_eq_angle_SBC : ∠ cfg.C cfg.B cfg.S = ∠ cfg.S cfg.C cfg.B := by
  have h := EuclideanGeometry.angle_eq_angle_of_dist_eq cfg.h_S_Ω.left.symm
  rw [EuclideanGeometry.angle_comm]
  exact h

lemma oangle_BSC_eq_oangle_BAC :  ∡ cfg.B cfg.S cfg.C = ∡ cfg.B cfg.A cfg.C := by
  symm
  have h := EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.B_in_Ω cfg.A_in_Ω cfg.h_S_Ω.right cfg.C_in_Ω
    cfg.B_ne_A.symm cfg.C_ne_A.symm cfg.S_ne_B cfg.S_ne_C
  have h' := cfg.h_ABC
  rw [affineIndependent_iff_not_collinear_set] at h'
  rw [Set.insert_comm] at h'
  rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear, ← ne_eq] at h'
  apply aux₆ _ h' h
  rw [EuclideanGeometry.oangle_rotate_sign cfg.C cfg.B cfg.A]
  rw [EuclideanGeometry.oangle_rotate_sign cfg.C cfg.B cfg.S]
  exact cfg.h_S_A.symm

lemma angle_BSC_eq_angle_BAC :  ∠ cfg.B cfg.S cfg.C = ∠ cfg.B cfg.A cfg.C := by
  apply angle_eq_of_oangle_eq V Pt _ cfg.S_ne_B.symm cfg.S_ne_C.symm cfg.B_ne_A cfg.C_ne_A
  exact cfg.oangle_BSC_eq_oangle_BAC

lemma angle_CBS_eq : ∠ cfg.C cfg.B cfg.S = (∠ cfg.C cfg.B cfg.A + ∠ cfg.A cfg.C cfg.B) / 2 := by
  rw [eq_div_iff_mul_eq (by norm_num), mul_two]
  nth_rw 2 [angle_CBS_eq_angle_SBC]
  have h₁ := EuclideanGeometry.angle_add_angle_add_angle_eq_pi cfg.B cfg.S_ne_C.symm
  have h₂ := EuclideanGeometry.angle_add_angle_add_angle_eq_pi cfg.B cfg.C_ne_A
  nth_rw 2 [add_comm] at h₁ h₂
  rw [← eq_sub_iff_add_eq] at h₁ h₂
  rw [h₁, h₂, sub_right_inj]
  exact cfg.angle_BSC_eq_angle_BAC

lemma angle_CBS_lt_angle_CBA : ∠ cfg.C cfg.B cfg.S < ∠ cfg.C cfg.B cfg.A := by
  rw [cfg.angle_CBS_eq, div_lt_iff₀ (by norm_num), mul_two, add_lt_add_iff_left]
  exact cfg.angle_ACB_lt_angle_CBA

lemma sign_oangle_SBA_eq_sign_oangle_CBS
  : (∡ cfg.S cfg.B cfg.A).sign = (∡ cfg.C cfg.B cfg.S).sign := by
  have h := EuclideanGeometry.oangle_add cfg.B_ne_C.symm cfg.S_ne_B cfg.B_ne_A.symm
  have h' := cfg.angle_CBS_lt_angle_CBA
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.B_ne_C.symm cfg.S_ne_B] at h'
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.B_ne_C.symm cfg.B_ne_A.symm] at h'
  have h'' := cfg.h_S_A
  symm
  exact aux₅ h h'' h'

lemma sphereOrder_BASC : SphereOrder V Pt cfg.B cfg.A cfg.S cfg.C := by
  constructor
  · rw [EuclideanGeometry.cospherical_iff_exists_sphere]
    use cfg.Ω
    repeat rw [Set.insert_subset_iff]
    rw [Set.singleton_subset_iff]
    constructorm* _ ∧ _
    · exact cfg.B_in_Ω
    · exact cfg.A_in_Ω
    · exact cfg.h_S_Ω.right
    · exact cfg.C_in_Ω
  · intro h'
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h'
    have h'' := eq_of_mem_sphere_of_collinear V Pt cfg.B_in_Ω cfg.A_in_Ω cfg.h_S_Ω.right h'
    contrapose! h''
    constructorm* _ ∧ _
    · exact cfg.B_ne_A
    · exact cfg.S_ne_A.symm
    · exact cfg.S_ne_B
  · rw [EuclideanGeometry.oangle_rotate_sign]
    rw [cfg.sign_oangle_SBA_eq_sign_oangle_CBS]
    rw [EuclideanGeometry.oangle_rotate_sign]

noncomputable def M := Sphere.antipode V Pt cfg.Ω cfg.S

lemma M_in_Ω : cfg.M ∈ cfg.Ω := by
  apply Sphere.antipode_mem_sphere
  exact cfg.h_S_Ω.right

lemma isDiameter_SM : cfg.Ω.IsDiameter cfg.S cfg.M := by
  apply Sphere.antipode_isDiameter
  exact cfg.h_S_Ω.right

lemma Ω_radius_ne_zero : cfg.Ω.radius ≠ 0 := by
  have h := cfg.B_ne_A
  contrapose! h
  have h₁ := cfg.B_in_Ω
  have h₂ := cfg.A_in_Ω
  rw [EuclideanGeometry.mem_sphere, h, dist_eq_zero] at h₁ h₂
  rw [h₁, h₂]

lemma sbtw_SOM : Sbtw ℝ cfg.S cfg.Ω.center cfg.M := by
  exact cfg.isDiameter_SM.sbtw cfg.Ω_radius_ne_zero

lemma O_ne_A : cfg.Ω.center ≠ cfg.A := by
  have h := cfg.Ω_radius_ne_zero
  contrapose! h
  rw [← dist_eq_zero, dist_comm, EuclideanGeometry.mem_sphere.mp cfg.A_in_Ω] at h
  exact h

lemma S_ne_M : cfg.S ≠ cfg.M := by
  rw [EuclideanGeometry.Sphere.IsDiameter.left_ne_right_iff_radius_ne_zero cfg.isDiameter_SM]
  exact cfg.Ω_radius_ne_zero

lemma angle_SBM_eq : ∠ cfg.S cfg.B cfg.M = Real.pi / 2 := by
  rw [EuclideanGeometry.Sphere.thales_theorem cfg.isDiameter_SM]
  exact cfg.B_in_Ω

lemma angle_SCM_eq : ∠ cfg.S cfg.C cfg.M = Real.pi / 2 := by
  rw [EuclideanGeometry.Sphere.thales_theorem cfg.isDiameter_SM]
  exact cfg.C_in_Ω

lemma BM_eq_CM : dist cfg.B cfg.M = dist cfg.C cfg.M := by
  nth_rw 1 [dist_comm]
  nth_rw 2 [dist_comm]
  rw [← mul_self_inj (by positivity) (by positivity)]
  have h₁ := cfg.angle_SBM_eq
  have h₂ := cfg.angle_SCM_eq
  rw [← EuclideanGeometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two] at h₁ h₂
  rw [← sub_eq_iff_eq_add'] at h₁ h₂
  rw [← h₁, ← h₂, cfg.h_S_Ω.left]

lemma M_ne_B : cfg.M ≠ cfg.B := by
  have h := cfg.B_ne_C
  contrapose! h
  rw [← h]
  rw [← dist_eq_zero] at h ⊢
  rw [dist_comm, cfg.BM_eq_CM, dist_comm] at h
  exact h

lemma M_ne_C : cfg.M ≠ cfg.C := by
  have h := cfg.B_ne_C
  contrapose! h
  rw [← h]
  rw [← dist_eq_zero] at h ⊢
  rw [dist_comm, ← cfg.BM_eq_CM] at h
  exact h

lemma angle_CMS_lt : ∠ cfg.C cfg.M cfg.S < Real.pi / 2 := by
  apply EuclideanGeometry.angle_lt_pi_div_two_of_angle_eq_pi_div_two cfg.angle_SCM_eq
  exact cfg.M_ne_C

lemma angle_SMB_lt : ∠ cfg.S cfg.M cfg.B < Real.pi / 2 := by
  rw [angle_comm]
  apply EuclideanGeometry.angle_lt_pi_div_two_of_angle_eq_pi_div_two cfg.angle_SBM_eq
  exact cfg.M_ne_B

lemma oangle_CMS_eq_oangle_SMB :
    ∡ cfg.C cfg.M cfg.S = ∡ cfg.S cfg.M cfg.B := by
  have h₁ := EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.C_in_Ω cfg.M_in_Ω cfg.B_in_Ω cfg.h_S_Ω.right
    cfg.M_ne_C cfg.S_ne_M.symm cfg.B_ne_C cfg.S_ne_B.symm
  have h₂ := EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.h_S_Ω.right cfg.M_in_Ω cfg.C_in_Ω cfg.B_in_Ω
    cfg.S_ne_M.symm cfg.M_ne_B cfg.S_ne_C.symm cfg.B_ne_C.symm
  have h₃ := EuclideanGeometry.oangle_eq_oangle_of_dist_eq cfg.h_S_Ω.left
  have h : (2 : ℤ) • ∡ cfg.C cfg.M cfg.S = (2 : ℤ) • ∡ cfg.S cfg.M cfg.B := by
    rw [h₁, h₂, h₃]
  have h' := cfg.angle_CMS_lt
  have h'' := cfg.angle_SMB_lt
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.M_ne_C.symm cfg.S_ne_M] at h'
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.S_ne_M cfg.M_ne_B.symm] at h''
  rw [Real.Angle.two_zsmul_eq_iff_eq_of_abs_toReal_lt_pi_div_two h' h''] at h
  exact h

lemma sphereOrder_BSCM : SphereOrder V Pt cfg.B cfg.S cfg.C cfg.M := by
  apply SphereOrder.rotate'
  constructor
  · rw [EuclideanGeometry.cospherical_iff_exists_sphere]
    use cfg.Ω
    repeat rw [Set.insert_subset_iff]
    rw [Set.singleton_subset_iff]
    constructorm* _ ∧ _
    · exact cfg.h_S_Ω.right
    · exact cfg.C_in_Ω
    · exact cfg.M_in_Ω
    · exact cfg.B_in_Ω
  · intro h
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h
    apply eq_of_mem_sphere_of_collinear V Pt cfg.h_S_Ω.right cfg.C_in_Ω cfg.M_in_Ω at h
    contrapose! h
    constructorm* _ ∧ _
    · exact cfg.S_ne_C
    · exact cfg.M_ne_C.symm
    · exact cfg.S_ne_M.symm
  · rw [← EuclideanGeometry.oangle_rotate_sign cfg.S cfg.C cfg.M]
    rw [EuclideanGeometry.oangle_rotate_sign cfg.S cfg.M cfg.B]
    rw [cfg.oangle_CMS_eq_oangle_SMB]

lemma sphereOrder_BASM : SphereOrder V Pt cfg.B cfg.A cfg.S cfg.M := by
  exact (cfg.sphereOrder_BASC.trans V Pt cfg.sphereOrder_BSCM.rotate).rotate

lemma sphereOrder_BACM : SphereOrder V Pt cfg.B cfg.A cfg.C cfg.M := by
  exact (cfg.sphereOrder_BASC.trans'' V Pt cfg.sphereOrder_BSCM.rotate).symm

lemma M_ne_A : cfg.M ≠ cfg.A := by
  exact cfg.sphereOrder_BASM.P₂_ne_P₄.symm

def X_set := diag_inter_set V Pt cfg.B cfg.A cfg.S cfg.M

lemma exists_X : ∃ X : Pt, X ∈ cfg.X_set := by
  exact cfg.sphereOrder_BASM.exists_diag_inter

lemma X_ne_A
    {X : Pt} (hX : X ∈ cfg.X_set) :
    X ≠ cfg.A := by
  rw [X_set, diag_inter_set_rotate] at hX
  exact cfg.sphereOrder_BASM.rotate.diag_inter_ne_P₁ V Pt hX

lemma X_ne_S
    {X : Pt} (hX : X ∈ cfg.X_set) :
    X ≠ cfg.S := by
  rw [X_set, diag_inter_set_rotate, diag_inter_set_rotate] at hX
  exact cfg.sphereOrder_BASM.symm.diag_inter_ne_P₁ V Pt hX

lemma X_ne_M
    {X : Pt} (hX : X ∈ cfg.X_set) :
    X ≠ cfg.M := by
  rw [X_set, ← diag_inter_set_rotate] at hX
  exact cfg.sphereOrder_BASM.rotate'.diag_inter_ne_P₁ V Pt hX

lemma sbtw_AXM
    {X : Pt} (hX : X ∈ cfg.X_set) : Sbtw ℝ cfg.A X cfg.M := by
  exact cfg.sphereOrder_BASM.diag_inter_sbtw' V Pt hX

lemma sbtw_BXS
    {X : Pt} (hX : X ∈ cfg.X_set) : Sbtw ℝ cfg.B X cfg.S := by
  exact cfg.sphereOrder_BASM.diag_inter_sbtw V Pt hX

lemma X_ne_O
    {X : Pt} (hX : X ∈ cfg.X_set) :
    X ≠ cfg.Ω.center := by
  have h := cfg.sphereOrder_BASM.sign_oangle₂₃₄_ne_zero
  rw [← oangle_rotate_sign] at h
  rw [← (cfg.sbtw_AXM V Pt hX).symm.oangle_eq_right] at h
  rw [← cfg.sbtw_SOM.symm.oangle_eq_left] at h
  contrapose! h
  rw [h, oangle_self_left_right, Real.Angle.sign_zero]

lemma oangle_BAM_eq_oangle_MAC :
    ∡ cfg.B cfg.A cfg.M = ∡ cfg.M cfg.A cfg.C := by
  have h₁ := EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.B_in_Ω cfg.A_in_Ω cfg.C_in_Ω cfg.M_in_Ω
    cfg.B_ne_A.symm cfg.M_ne_A.symm cfg.B_ne_C.symm cfg.M_ne_C.symm
  have h₂ := EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.M_in_Ω cfg.A_in_Ω cfg.B_in_Ω cfg.C_in_Ω
    cfg.M_ne_A.symm cfg.C_ne_A.symm cfg.M_ne_B.symm cfg.B_ne_C
  have h_BM_CM := cfg.BM_eq_CM
  rw [dist_comm cfg.B cfg.M, dist_comm cfg.C cfg.M] at h_BM_CM
  have h₃ := EuclideanGeometry.oangle_eq_oangle_of_dist_eq h_BM_CM
  have h : (2 : ℤ) • ∡ cfg.B cfg.A cfg.M = (2 : ℤ) • ∡ cfg.M cfg.A cfg.C := by
    rw [h₁, h₂, h₃]
  have h' : (∡ cfg.B cfg.A (M V Pt cfg)).sign = (∡ (M V Pt cfg) cfg.A cfg.C).sign := by
    rw [EuclideanGeometry.oangle_rotate_sign cfg.M cfg.B cfg.A]
    rw [← EuclideanGeometry.oangle_rotate_sign cfg.M cfg.A cfg.C]
    exact cfg.sphereOrder_BACM.rotate'.sign_oangle₁₂₃_eq_sign_oangle₃₄₁
  have h'' : (∡ cfg.B cfg.A (M V Pt cfg)).sign ≠ 0 := by
    rw [EuclideanGeometry.oangle_rotate_sign cfg.M cfg.B cfg.A]
    exact cfg.sphereOrder_BACM.rotate'.sign_oangle₁₂₃_ne_zero
  apply aux₆ h' h'' h

lemma angle_BAM_eq_angle_MAC :
  ∠ cfg.B cfg.A cfg.M = ∠ cfg.M cfg.A cfg.C := by
  exact angle_eq_of_oangle_eq V Pt cfg.oangle_BAM_eq_oangle_MAC
    cfg.B_ne_A cfg.M_ne_A cfg.M_ne_A cfg.C_ne_A

lemma oangle_BAX_eq_oangle_XAC
    {X : Pt} (hX : X ∈ cfg.X_set) :
    ∡ cfg.B cfg.A X = ∡ X cfg.A cfg.C := by
  rw [← EuclideanGeometry.oangle_add cfg.B_ne_A cfg.M_ne_A (cfg.X_ne_A V Pt hX)]
  rw [← EuclideanGeometry.oangle_add (cfg.X_ne_A V Pt hX) cfg.M_ne_A cfg.C_ne_A]
  rw [cfg.oangle_BAM_eq_oangle_MAC, add_comm, add_right_cancel_iff]
  rw [EuclideanGeometry.oangle_rev]
  rw [Wbtw.oangle₂₁₃_eq_zero (cfg.sbtw_AXM V Pt hX).wbtw]
  norm_num

lemma angle_BAX_eq_angle_XAC
    {X : Pt} (hX : X ∈ cfg.X_set) :
    ∠ cfg.B cfg.A X = ∠ X cfg.A cfg.C := by
  exact angle_eq_of_oangle_eq V Pt (cfg.oangle_BAX_eq_oangle_XAC V Pt hX)
    cfg.B_ne_A (cfg.X_ne_A V Pt hX) (cfg.X_ne_A V Pt hX) cfg.C_ne_A

lemma angle_BAM_acute : ∠ cfg.B cfg.A cfg.M < π / 2 := by
  have h := cfg.angle_BAC_acute
  apply lt_of_lt_of_le' h
  have h' := cfg.sphereOrder_BACM.angle₁₂₄_add_angle₄₂₃_eq_angle₁₂₃
  rw [← h', le_add_iff_nonneg_right]
  apply angle_nonneg

lemma angle_BAM_eq_angle_BAX
  {X : Pt} (hX : X ∈ cfg.X_set) :
  ∠ cfg.B cfg.A cfg.M = ∠ cfg.B cfg.A X := by
  rw [angle_comm, EuclideanGeometry.angle_eq_iff_oangle_eq_or_wbtw cfg.M_ne_A (cfg.X_ne_A V Pt hX)]
  right
  right
  exact (cfg.sbtw_AXM V Pt hX).wbtw

lemma angle_BAM_eq : ∠ cfg.B cfg.A cfg.M = (π - ∠ cfg.C cfg.B cfg.A - ∠ cfg.A cfg.C cfg.B) / 2 := by
  have h := cfg.sphereOrder_BACM.angle₁₂₄_add_angle₄₂₃_eq_angle₁₂₃
  rw [← cfg.angle_BAM_eq_angle_MAC, ← mul_two, ← eq_div_iff_mul_eq (by norm_num)] at h
  rw [h]
  have h' := EuclideanGeometry.angle_add_angle_add_angle_eq_pi cfg.B cfg.C_ne_A
  rw [← eq_sub_iff_add_eq'] at h'
  rw [h']
  ring

lemma XO_lt_Ω_radius {X : Pt} (hX : X ∈ cfg.X_set)
  : dist X cfg.Ω.center < cfg.Ω.radius := by
  apply Sphere.dist_le_radius_of_sbtw V Pt (cfg.sbtw_AXM V Pt hX) cfg.A_in_Ω cfg.M_in_Ω

lemma P_in_Ω : cfg.P ∈ cfg.Ω := by
  have h := cfg.h_P
  rw [Set.mem_inter_iff] at h
  exact h.right

lemma B_in_ω : cfg.B ∈ cfg.ω := by
  have h := cfg.h_ω
  rw [Set.insert_subset_iff] at h
  exact h.left

lemma D_in_ω : cfg.D ∈ cfg.ω := by
  have h := cfg.h_ω
  rw [Set.insert_subset_iff, Set.insert_subset_iff] at h
  exact h.right.left

lemma L_in_ω : cfg.L ∈ cfg.ω := by
  have h := cfg.h_ω
  rw [Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff] at h
  exact h.right.right

lemma P_in_ω : cfg.P ∈ cfg.ω := by
  have h := cfg.h_P
  rw [Set.mem_inter_iff] at h
  exact h.left

lemma ω_radius_ne_zero : cfg.ω.radius ≠ 0 := by
  have h := cfg.h_P_ne_B
  contrapose! h
  have h₁ := cfg.B_in_ω
  have h₂ := cfg.P_in_ω
  rw [EuclideanGeometry.mem_sphere, h, dist_eq_zero] at h₁ h₂
  rw [h₁, h₂]

lemma P_ne_X {X : Pt} (hX : X ∈ cfg.X_set)
  : cfg.P ≠ X := by
  have h := cfg.XO_lt_Ω_radius V Pt hX
  contrapose! h
  apply le_of_eq
  have h' := cfg.P_in_Ω
  rw [EuclideanGeometry.mem_sphere] at h'
  rw [← h, h']

lemma perp_A_BC_eq_AE : cfg.perp_A_BC = line[ℝ, cfg.A, cfg.E] := by
  symm
  have h_E := cfg.h_E
  have h : line[ℝ, cfg.A, cfg.E] ≤ cfg.perp_A_BC := by
    apply affineSpan_le_of_subset_coe
    rw [Set.pair_subset_iff]
    constructor
    · exact cfg.h_perp_A_BC.right
    · rw [Set.mem_inter_iff] at h_E
      exact h_E.left
  apply AffineSubspace.eq_of_direction_eq_of_nonempty_of_le
  · apply Submodule.eq_of_le_of_finrank_eq (AffineSubspace.direction_le h)
    apply eq_of_le_of_ge (Submodule.finrank_mono (AffineSubspace.direction_le h))
    rw [affineSpan_pair_finrank V Pt cfg.h_E_ne_A.symm]
    have h' := cfg.h_perp_A_BC.left
    rw [Submodule.IsOrtho] at h'
    apply Submodule.finrank_mono at h'
    have h'' : finrank ℝ (affineSpan ℝ {cfg.B, cfg.C}).directionᗮ = 1 := by
      apply Submodule.finrank_add_finrank_orthogonal'
      rw [hd2.out, affineSpan_pair_finrank V Pt cfg.B_ne_C]
    rw [← h'']
    exact h'
  · rw [affineSpan_nonempty]
    apply Set.insert_nonempty
  · exact h

lemma E_in_Ω : cfg.E ∈ cfg.Ω := by
  have h := cfg.h_E
  rw [Set.mem_inter_iff] at h
  exact h.right

noncomputable def H : Pt := cfg.ABC.altitudeFoot 0

lemma collinear_HBC : Collinear ℝ {cfg.H, cfg.B, cfg.C} := by
  apply collinear_insert_of_mem_affineSpan_pair
  rw [cfg.A_opposite_BC]
  apply altitudeFoot_mem_affineSpan_faceOpposite

lemma angle_AHx_eq : ∀ x ∈ ({cfg.B, cfg.C} : Set _), ∠ cfg.A cfg.H x = Real.pi / 2 := by
  intro x hx
  rw [EuclideanGeometry.angle, ← InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two]
  rw [real_inner_comm]
  apply Submodule.IsOrtho.inner_eq (vectorSpan_isOrtho_altitude_direction cfg.ABC 0)
  · have h₁ := cfg.A_opposite_BC
    simp at h₁
    apply vsub_mem_vectorSpan_of_mem_affineSpan_of_mem_affineSpan
    · rw [← h₁]
      exact mem_affineSpan _ hx
    · rw [← h₁]
      exact Collinear.mem_affineSpan_of_mem_of_ne cfg.collinear_HBC (by simp:_) (by simp:_) (by simp:_) cfg.B_ne_C
  · apply vsub_mem_vectorSpan _ (mem_altitude cfg.ABC 0) (altitudeFoot_mem_altitude cfg.ABC 0)

lemma angle_AHC_eq : ∠ cfg.A cfg.H cfg.C = Real.pi / 2 := by
  apply angle_AHx_eq
  simp

lemma angle_AHB_eq : ∠ cfg.A cfg.H cfg.B = Real.pi / 2 := by
  apply angle_AHx_eq
  simp

lemma not_sbtw_BCH : ¬Sbtw ℝ cfg.B cfg.C cfg.H := by
  intro h
  have h₁ := h.angle₁₂₃_eq_pi
  contrapose! h₁
  apply ne_of_lt
  have h₂ := oangle_add cfg.B_ne_C cfg.C_ne_A.symm h.ne_right.symm
  have h₃ := angle_le_pi_div_two_of_angle_eq_pi_div_two cfg.angle_AHC_eq
  calc ∠ cfg.B cfg.C cfg.H
      ≤ ∠ cfg.B cfg.C cfg.A + ∠ cfg.H cfg.C cfg.A := by
        rw [angle_comm cfg.H cfg.C cfg.A]
        apply angle_le_angle_add_angle
    _ < Real.pi / 2 + Real.pi / 2 := by
      rw [angle_comm cfg.B cfg.C cfg.A]
      apply add_lt_add_of_lt_of_le cfg.angle_ACB_acute h₃
    _ = Real.pi := by ring

lemma not_sbtw_CBH : ¬Sbtw ℝ cfg.C cfg.B cfg.H := by
  intro h
  have h₁ := h.angle₁₂₃_eq_pi
  contrapose! h₁
  apply ne_of_lt
  have h₂ := oangle_add cfg.B_ne_C.symm cfg.B_ne_A.symm h.ne_right.symm
  have h₃ := angle_le_pi_div_two_of_angle_eq_pi_div_two cfg.angle_AHB_eq
  calc ∠ cfg.C cfg.B cfg.H
      ≤ ∠ cfg.C cfg.B cfg.A + ∠ cfg.H cfg.B cfg.A := by
        rw [angle_comm cfg.H cfg.B cfg.A]
        apply angle_le_angle_add_angle
    _ < Real.pi / 2 + Real.pi / 2 := by
      apply add_lt_add_of_lt_of_le cfg.angle_CBA_acute h₃
    _ = Real.pi := by ring

lemma wbtw_BHC : Wbtw ℝ cfg.B cfg.H cfg.C := by
  have h₁ := cfg.not_sbtw_BCH
  have h₂ := cfg.not_sbtw_CBH
  rw [sbtw_comm] at h₂
  have h := Collinear.sbtw_or_sbtw_or_wbtw_of_ne V Pt cfg.collinear_HBC cfg.B_ne_C
  rw [wbtw_comm]
  tauto

lemma H_ne_B : cfg.H ≠ cfg.B := by
  have h := cfg.angle_CBA_acute
  contrapose! h
  apply le_of_eq
  rw [← h, angle_comm, cfg.angle_AHC_eq]

lemma H_ne_C : cfg.H ≠ cfg.C := by
  have h := cfg.angle_ACB_acute
  contrapose! h
  apply le_of_eq
  rw [← h, cfg.angle_AHB_eq]

lemma sbtw_BHC : Sbtw ℝ cfg.B cfg.H cfg.C := by
  rw [Sbtw]
  constructorm* _ ∧ _
  · exact cfg.wbtw_BHC
  · exact cfg.H_ne_B
  · exact cfg.H_ne_C

lemma AE_eq_altitude : line[ℝ, cfg.A, cfg.E] = cfg.ABC.altitude 0 := by
  apply AffineSubspace.ext_of_direction_eq
  · rw [Affine.Simplex.direction_altitude]
    rw [← Affine.Simplex.range_faceOpposite_points, ← cfg.A_opposite_BC]
    have h₁ : vectorSpan ℝ (Set.range (ABC V Pt cfg).points) = ⊤ := by
      apply AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one cfg.ABC.independent
      rw [hd2.out, Fintype.card_fin]
    rw [h₁, inf_top_eq]
    have h₂ := cfg.h_perp_A_BC.left
    rw [cfg.perp_A_BC_eq_AE, Submodule.isOrtho_iff_le] at h₂
    rw [← direction_affineSpan]
    apply Submodule.eq_of_le_of_finrank_eq h₂
    apply eq_of_le_of_ge (Submodule.finrank_mono h₂)
    have h₃ := Submodule.finrank_add_finrank_orthogonal (affineSpan ℝ {cfg.B, cfg.C}).direction
    rw [affineSpan_pair_finrank V Pt cfg.h_E_ne_A.symm]
    rw [affineSpan_pair_finrank V Pt cfg.B_ne_C, hd2.out, Nat.one_add, Nat.succ_inj] at h₃
    rw [h₃]
  · use cfg.A
    apply Set.mem_inter
    · apply mem_affineSpan
      apply Set.mem_insert
    · have h := Affine.Simplex.mem_altitude cfg.ABC 0
      nth_rw 2 [ABC] at h
      simp at h
      exact h

lemma collinear_AHE : Collinear ℝ {cfg.A, cfg.H, cfg.E} := by
  rw [Set.insert_comm]
  apply collinear_insert_of_mem_affineSpan_pair
  rw [AE_eq_altitude]
  apply Affine.Simplex.altitudeFoot_mem_altitude

lemma HO_lt_Ω_radius
  : dist cfg.H cfg.Ω.center < cfg.Ω.radius := by
  apply Sphere.dist_le_radius_of_sbtw V Pt cfg.sbtw_BHC cfg.B_in_Ω cfg.C_in_Ω

lemma sbtw_AHE : Sbtw ℝ cfg.A cfg.H cfg.E := by
  apply EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius
    cfg.collinear_AHE cfg.A_in_Ω cfg.HO_lt_Ω_radius cfg.E_in_Ω cfg.h_E_ne_A.symm

lemma H_ne_A : cfg.H ≠ cfg.A := by
  exact cfg.sbtw_AHE.ne_left

lemma sphereOrder_BACE : SphereOrder V Pt cfg.B cfg.A cfg.C cfg.E := by
  apply sphereOrder_of_sbtw_diag_inter V Pt _ cfg.B_ne_A cfg.C_ne_A.symm
    cfg.sbtw_BHC cfg.sbtw_AHE
  rw [EuclideanGeometry.cospherical_iff_exists_sphere]
  use cfg.Ω
  repeat rw [Set.insert_subset_iff]
  rw [Set.singleton_subset_iff]
  constructorm* _ ∧ _
  · exact cfg.B_in_Ω
  · exact cfg.A_in_Ω
  · exact cfg.C_in_Ω
  · exact cfg.E_in_Ω

lemma sign_oangle_BAE_eq_sign_oangle_BAM
  : (∡ cfg.B cfg.A cfg.E).sign = (∡ cfg.B cfg.A cfg.M).sign := by
  rw [EuclideanGeometry.oangle_rotate_sign]
  rw [cfg.sphereOrder_BACE.rotate'.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
  rw [← cfg.sphereOrder_BACM.rotate'.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
  rw [← EuclideanGeometry.oangle_rotate_sign]

lemma angle_BAE_eq_BAH :
  ∠ cfg.B cfg.A cfg.E = ∠ cfg.B cfg.A cfg.H := by
  rw [angle_comm, EuclideanGeometry.angle_eq_iff_oangle_eq_or_wbtw cfg.h_E_ne_A cfg.sbtw_AHE.ne_left]
  right
  right
  exact (cfg.sbtw_AHE).wbtw

lemma angle_HBA_eq_CBA :
  ∠ cfg.H cfg.B cfg.A = ∠ cfg.C cfg.B cfg.A := by
  rw [angle_comm]
  symm
  rw [EuclideanGeometry.angle_eq_iff_oangle_eq_or_wbtw cfg.B_ne_C.symm cfg.sbtw_BHC.ne_left]
  right
  right
  exact (cfg.sbtw_BHC).wbtw

lemma angle_BAE_eq : ∠ cfg.B cfg.A cfg.E = π / 2 - ∠ cfg.C cfg.B cfg.A := by
  rw [angle_BAE_eq_BAH, ← angle_HBA_eq_CBA, eq_sub_iff_add_eq, add_comm]
  have h := EuclideanGeometry.angle_add_angle_add_angle_eq_pi cfg.A cfg.sbtw_BHC.ne_left.symm
  rw [← eq_sub_iff_add_eq] at h
  rw [h, cfg.angle_AHB_eq]
  ring

lemma angle_BAE_lt_angle_BAM : ∠ cfg.B cfg.A cfg.E < ∠ cfg.B cfg.A cfg.M := by
  rw [cfg.angle_BAM_eq, cfg.angle_BAE_eq, ← sub_pos]
  ring_nf
  rw [neg_div, mul_neg, ← sub_eq_add_neg, sub_pos, mul_lt_mul_iff_left₀ (by norm_num)]
  exact cfg.angle_ACB_lt_angle_CBA

lemma sign_oangle_EAM_eq_sign_oangle_BAE
  : (∡ cfg.E cfg.A cfg.M).sign = (∡ cfg.B cfg.A cfg.E).sign := by
  have h := EuclideanGeometry.oangle_add cfg.B_ne_A cfg.h_E_ne_A cfg.M_ne_A
  have h' := cfg.angle_BAE_lt_angle_BAM
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.h_E_ne_A] at h'
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.M_ne_A] at h'
  have h'' := cfg.sign_oangle_BAE_eq_sign_oangle_BAM
  symm
  exact aux₅ h h'' h'

lemma sphereOrder_BAME : SphereOrder V Pt cfg.B cfg.A cfg.M cfg.E := by
  apply SphereOrder.rotate
  constructor
  · rw [EuclideanGeometry.cospherical_iff_exists_sphere]
    use cfg.Ω
    repeat rw [Set.insert_subset_iff]
    rw [Set.singleton_subset_iff]
    constructorm* _ ∧ _
    · exact cfg.E_in_Ω
    · exact cfg.B_in_Ω
    · exact cfg.A_in_Ω
    · exact cfg.M_in_Ω
  · exact cfg.sphereOrder_BACE.rotate'.sign_oangle₁₂₃_ne_zero
  · rw [← EuclideanGeometry.oangle_rotate_sign]
    rw [← sign_oangle_EAM_eq_sign_oangle_BAE]
    rw [← EuclideanGeometry.oangle_rotate_sign]

lemma sphereOrder_BASE : SphereOrder V Pt cfg.B cfg.A cfg.S cfg.E := by
  exact (cfg.sphereOrder_BACE.symm.trans' V Pt cfg.sphereOrder_BASC).rotate

lemma sphereOrder_ASME : SphereOrder V Pt cfg.A cfg.S cfg.M cfg.E := by
  exact cfg.sphereOrder_BAME.symm.trans'' V Pt cfg.sphereOrder_BASM

lemma E_ne_S : cfg.E ≠ cfg.S := by
  exact cfg.sphereOrder_BASE.P₃_ne_P₄.symm

lemma E_ne_B : cfg.E ≠ cfg.B := by
  exact cfg.sphereOrder_BASE.P₁_ne_P₄.symm

lemma E_ne_C : cfg.E ≠ cfg.C := by
  exact cfg.sphereOrder_BACE.P₃_ne_P₄.symm

lemma E_ne_H : cfg.E ≠ cfg.H := by
  exact cfg.sbtw_AHE.ne_right.symm

lemma D_in_diag_inter_BASE : cfg.D ∈ diag_inter_set V Pt cfg.B cfg.A cfg.S cfg.E:= by
  have h := cfg.h_D
  constructor
  · exact h.right
  · rw [← cfg.perp_A_BC_eq_AE]
    exact h.left

lemma D_ne_B : cfg.D ≠ cfg.B := by
  exact cfg.sphereOrder_BASE.diag_inter_ne_P₁ V Pt cfg.D_in_diag_inter_BASE

lemma sbtw_BDS : Sbtw ℝ cfg.B cfg.D cfg.S := by
  exact cfg.sphereOrder_BASE.diag_inter_sbtw V Pt cfg.D_in_diag_inter_BASE

lemma sbtw_ADE : Sbtw ℝ cfg.A cfg.D cfg.E := by
  exact cfg.sphereOrder_BASE.diag_inter_sbtw' V Pt cfg.D_in_diag_inter_BASE

lemma D_ne_A : cfg.D ≠ cfg.A := by
  exact cfg.sbtw_ADE.ne_left

lemma D_ne_S : cfg.D ≠ cfg.S := by
  exact cfg.sbtw_BDS.ne_right

lemma E_ne_D : cfg.E ≠ cfg.D := by
  exact cfg.sbtw_ADE.ne_right.symm

lemma DO_lt_Ω_radius
  : dist cfg.D cfg.Ω.center < cfg.Ω.radius := by
  apply Sphere.dist_le_radius_of_sbtw V Pt cfg.sbtw_BDS cfg.B_in_Ω cfg.h_S_Ω.right

lemma P_ne_D : cfg.P ≠ cfg.D := by
  have h := cfg.DO_lt_Ω_radius
  contrapose! h
  apply le_of_eq
  have h' := cfg.P_in_Ω
  rw [EuclideanGeometry.mem_sphere] at h'
  rw [← h, h']

lemma L_ne_D : cfg.L ≠ cfg.D := by
  intro h
  have h_DBE := cfg.h_L
  rw [Set.mem_inter_iff] at h_DBE
  apply And.right at h_DBE
  rw [h] at h_DBE
  have h_DBS := cfg.h_D
  rw [Set.mem_inter_iff] at h_DBS
  apply And.right at h_DBS
  apply collinear_insert_of_mem_affineSpan_pair at h_DBE
  apply collinear_insert_of_mem_affineSpan_pair at h_DBS
  have hE := Collinear.mem_affineSpan_of_mem_of_ne h_DBE (by simp) (by simp)
    (by simp : cfg.E ∈ _) cfg.D_ne_B
  have hS := Collinear.mem_affineSpan_of_mem_of_ne h_DBS (by simp) (by simp)
    (by simp : cfg.S ∈ _) cfg.D_ne_B
  have h' := collinear_insert_insert_of_mem_affineSpan_pair hE hS
  have h_ESB : Collinear ℝ {cfg.E, cfg.S, cfg.B} := by
    apply h'.subset
    rw [Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
    simp
  have h'' := eq_of_mem_sphere_of_collinear V Pt cfg.E_in_Ω cfg.h_S_Ω.right cfg.B_in_Ω h_ESB
  contrapose! h''
  constructorm* _ ∧ _
  · exact cfg.E_ne_S
  · exact cfg.S_ne_B
  · exact cfg.E_ne_B.symm

lemma prll_D_BC_eq_LD : cfg.prll_D_BC = line[ℝ, cfg.L, cfg.D] := by
  have h_L := cfg.h_L
  symm
  have h : line[ℝ, cfg.L, cfg.D] ≤ cfg.prll_D_BC := by
    apply affineSpan_le_of_subset_coe
    rw [Set.pair_subset_iff]
    constructor
    · rw [Set.mem_inter_iff] at h_L
      exact h_L.left
    · exact cfg.h_prll_D_BC.left
  apply AffineSubspace.eq_of_direction_eq_of_nonempty_of_le
  · apply Submodule.eq_of_le_of_finrank_eq (AffineSubspace.direction_le h)
    apply eq_of_le_of_ge (Submodule.finrank_mono (AffineSubspace.direction_le h))
    rw [affineSpan_pair_finrank V Pt cfg.L_ne_D]
    have h' := AffineSubspace.Parallel.direction_eq cfg.h_prll_D_BC.right
    rw [h']
    rw [affineSpan_pair_finrank V Pt cfg.B_ne_C]
  · rw [affineSpan_nonempty]
    apply Set.insert_nonempty
  · exact h

lemma P_ne_S : cfg.P ≠ cfg.S := by
  intro h
  have h' := cfg.sbtw_BDS.wbtw.collinear
  rw [← h] at h'
  have h'' := eq_of_mem_sphere_of_collinear V Pt cfg.B_in_ω cfg.D_in_ω cfg.P_in_ω h'
  contrapose! h''
  constructorm* _ ∧ _
  · exact cfg.D_ne_B.symm
  · exact cfg.P_ne_D.symm
  · exact cfg.h_P_ne_B

lemma collinear_BLE : Collinear ℝ {cfg.B, cfg.L, cfg.E} := by
  have h_L := cfg.h_L
  rw [Set.mem_inter_iff] at h_L
  apply And.right at h_L
  apply collinear_insert_of_mem_affineSpan_pair at h_L
  rw [Set.insert_comm] at h_L
  exact h_L

lemma L_ne_E : cfg.L ≠ cfg.E := by
  have h₁ := cfg.h_perp_A_BC.left
  have h₂ := cfg.h_prll_D_BC.right
  rw [cfg.perp_A_BC_eq_AE] at h₁
  rw [cfg.prll_D_BC_eq_LD] at h₂
  have hD := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_ADE.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.h_E_ne_A.symm
  rw [← affineSpan_pair_eq_of_left_mem_of_ne hD cfg.E_ne_D.symm] at h₁
  by_contra! h
  rw [h, Set.pair_comm] at h₂
  apply AffineSubspace.Parallel.direction_eq at h₂
  rw [h₂, Submodule.isOrtho_self, ← Submodule.finrank_eq_zero] at h₁
  contrapose! h₁
  rw [affineSpan_pair_finrank V Pt cfg.B_ne_C]
  norm_num

lemma H_ne_D : cfg.H ≠ cfg.D := by
  have h := cfg.sphereOrder_BASC.sign_oangle₃₄₁_ne_zero
  contrapose! h
  rw [← oangle_rotate_sign]
  rw [← Sbtw.oangle_eq_left cfg.sbtw_BHC, ← Sbtw.oangle_eq_right cfg.sbtw_BDS]
  rw [h, oangle_self_left_right, Real.Angle.sign_zero]

lemma collinear_EHD :Collinear ℝ {cfg.E, cfg.H, cfg.D} := by
  have hH := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_AHE.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.H ∈ _) cfg.h_E_ne_A
  have hD := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_ADE.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.h_E_ne_A
  have hE := mem_affineSpan ℝ (by simp : cfg.E ∈ {cfg.E, cfg.A})
  exact collinear_triple_of_mem_affineSpan_pair hE hH hD

lemma sbtw_EHD : Sbtw ℝ cfg.E cfg.H cfg.D := by
  rcases Collinear.sbtw_or_wbtw_or_wbtw V Pt cfg.collinear_EHD with (h'|(h'|h'))
  · exact h'
  · exfalso
    have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.B h' cfg.H_ne_D
    contrapose! h''
    rw [Sbtw.oangle_eq_left cfg.sbtw_BHC]
    rw [Sbtw.oangle_eq_left cfg.sbtw_BHC, Sbtw.oangle_eq_right cfg.sbtw_BDS]
    rw [oangle_rotate_sign]
    rw [cfg.sphereOrder_BASC.symm.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    symm
    rw [← oangle_rotate_sign]
    rw [cfg.sphereOrder_BACE.comm.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    rw [← oangle_rotate_sign, ← oangle_swap₁₃_sign]
    rw [SignType.neg_eq_self_iff.ne]
    exact cfg.sphereOrder_BASC.rotate'.sign_oangle₁₂₃_ne_zero
  · exfalso
    have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.B h' cfg.E_ne_D.symm
    rw [← Wbtw.oangle_sign_eq_of_ne_right cfg.B h' cfg.E_ne_H] at h''
    contrapose! h''
    rw [Sbtw.oangle_eq_left cfg.sbtw_BDS, Sbtw.oangle_eq_right cfg.sbtw_BHC]
    rw [← oangle_rotate_sign]
    rw [cfg.sphereOrder_BASE.comm.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    rw [cfg.sphereOrder_BASC.comm.symm.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    symm
    rw [oangle_rotate_sign]
    rw [← cfg.sphereOrder_BACE.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    rw [oangle_rotate_sign, ← oangle_swap₁₃_sign]
    rw [SignType.neg_eq_self_iff.ne]
    exact cfg.sphereOrder_BASC.comm.rotate'.sign_oangle₁₂₃_ne_zero

lemma not_collinear_EBH : ¬Collinear ℝ {cfg.E, cfg.B, cfg.H} := by
    have hEHA := cfg.sbtw_BHC.wbtw.collinear
    rw [Set.pair_comm, Set.insert_comm] at hEHA
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at hEHA
    rw [Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_nsmul_eq_zero_iff] at hEHA
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    rw [Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_nsmul_eq_zero_iff]
    rw [← oangle_add cfg.E_ne_B cfg.B_ne_C.symm cfg.H_ne_B]
    rw [smul_add, hEHA, add_zero]
    rw [Real.Angle.two_nsmul_eq_zero_iff, ← Real.Angle.sign_eq_zero_iff]
    rw [oangle_rotate_sign]
    exact cfg.sphereOrder_BACE.sign_oangle₃₄₁_ne_zero

lemma oangle_LDE_eq_oangle_BHE : ∡ cfg.L cfg.D cfg.E = ∡ cfg.B cfg.H cfg.E := by
  symm
  apply EuclideanGeometry.oangle_eq_of_parallel
  · intro h
    apply collinear_insert_of_mem_affineSpan_pair at h
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm] at h
    contrapose! h
    exact cfg.not_collinear_EBH
  · exact Collinear.mem_affineSpan_of_mem_of_ne cfg.collinear_BLE
      (by simp) (by simp) (by simp : cfg.L ∈ _) cfg.E_ne_B.symm
  · apply mem_affineSpan
    simp
  · rw [← cfg.prll_D_BC_eq_LD, AffineSubspace.parallel_comm]
    have h := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_BHC.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.H ∈ _) cfg.B_ne_C
    rw [affineSpan_pair_eq_of_right_mem_of_ne h cfg.H_ne_B]
    exact cfg.h_prll_D_BC.right
  · have h := Collinear.mem_affineSpan_of_mem_of_ne cfg.collinear_EHD
      (by simp) (by simp) (by simp : cfg.H ∈ _) cfg.E_ne_D
    rw [affineSpan_pair_eq_of_right_mem_of_ne h cfg.E_ne_H.symm]

lemma oangle_ELD_eq_oangle_EBH : ∡ cfg.E cfg.L cfg.D = ∡ cfg.E cfg.B cfg.H := by
  symm
  apply EuclideanGeometry.oangle_eq_of_parallel
  · intro h
    apply collinear_insert_of_mem_affineSpan_pair at h
    rw [Set.insert_comm] at h
    contrapose! h
    exact cfg.not_collinear_EBH
  · apply mem_affineSpan
    simp
  · exact Collinear.mem_affineSpan_of_mem_of_ne cfg.collinear_EHD
      (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.E_ne_H
  · have h := Collinear.mem_affineSpan_of_mem_of_ne cfg.collinear_BLE
      (by simp) (by simp) (by simp : cfg.B ∈ _) cfg.L_ne_E.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h cfg.E_ne_B.symm]
  · rw [Set.pair_comm cfg.D cfg.L]
    rw [← cfg.prll_D_BC_eq_LD, AffineSubspace.parallel_comm, Set.pair_comm]
    have h := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_BHC.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.H ∈ _) cfg.B_ne_C
    rw [affineSpan_pair_eq_of_right_mem_of_ne h cfg.H_ne_B]
    exact cfg.h_prll_D_BC.right

lemma BE_lt_LE : dist cfg.B cfg.E < dist cfg.L cfg.E := by
  have hBHE := cfg.not_collinear_EBH
  have hLDE : ¬Collinear ℝ {cfg.E, cfg.L, cfg.D} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear, cfg.oangle_ELD_eq_oangle_EBH]
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    exact hBHE
  have h₁ := EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle hBHE
  have h₂ := EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle hLDE
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.H_ne_B.symm cfg.E_ne_H] at h₁
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.E_ne_B cfg.H_ne_B] at h₁
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.L_ne_D cfg.E_ne_D] at h₂
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.L_ne_E.symm cfg.L_ne_D.symm] at h₂
  rw [dist_comm] at h₁ h₂
  rw [h₁, h₂]
  rw [cfg.oangle_LDE_eq_oangle_BHE, cfg.oangle_ELD_eq_oangle_EBH]
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.H_ne_B.symm cfg.E_ne_H]
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.E_ne_B cfg.H_ne_B]
  apply div_lt_div_of_pos_right _ (EuclideanGeometry.sin_pos_of_not_collinear hBHE)
  rw [Set.insert_comm, Set.pair_comm] at hBHE
  have hBHE' := EuclideanGeometry.sin_pos_of_not_collinear hBHE
  apply mul_lt_mul_of_pos_right _ hBHE'
  rw [dist_comm cfg.D cfg.E,← cfg.sbtw_EHD.wbtw.dist_add_dist,dist_comm]
  apply lt_add_of_pos_right
  rw [dist_pos]
  exact cfg.H_ne_D

lemma not_wbtw_BLE : ¬ Wbtw ℝ cfg.B cfg.L cfg.E := by
  rw [← dist_lt_dist_add_dist_iff]
  apply lt_add_of_nonneg_of_lt (by positivity) cfg.BE_lt_LE

lemma LO_gt_Ω_radius
  : cfg.Ω.radius < dist cfg.L cfg.Ω.center := by
  have h := cfg.not_wbtw_BLE
  contrapose! h
  apply EuclideanGeometry.wbtw_of_collinear_of_dist_center_le_radius
    cfg.collinear_BLE cfg.B_in_Ω h cfg.E_in_Ω cfg.E_ne_B.symm

lemma L_ne_P : cfg.L ≠ cfg.P := by
  have h := cfg.LO_gt_Ω_radius
  contrapose! h
  apply le_of_eq
  have h' := cfg.P_in_Ω
  rw [EuclideanGeometry.mem_sphere] at h'
  rw [h, h']

lemma L_ne_B : cfg.L ≠ cfg.B := by
  have h := cfg.LO_gt_Ω_radius
  contrapose! h
  apply le_of_eq
  have h' := cfg.B_in_Ω
  rw [EuclideanGeometry.mem_sphere] at h'
  rw [h, h']

lemma collinear_LPS : Collinear ℝ {cfg.L, cfg.P, cfg.S} := by
  rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
  rw [Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_zsmul_eq_zero_iff]
  rw [← EuclideanGeometry.oangle_add cfg.L_ne_P cfg.h_P_ne_B.symm cfg.P_ne_S.symm]
  rw [smul_add]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.B_in_Ω cfg.P_in_Ω cfg.C_in_Ω cfg.h_S_Ω.right
    cfg.h_P_ne_B cfg.P_ne_S cfg.B_ne_C.symm cfg.S_ne_C.symm]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.L_in_ω cfg.P_in_ω cfg.D_in_ω cfg.B_in_ω
    cfg.L_ne_P.symm cfg.h_P_ne_B cfg.L_ne_D.symm cfg.D_ne_B]
  rw [EuclideanGeometry.oangle_rev cfg.S cfg.C cfg.B, smul_neg, ← sub_eq_add_neg, sub_eq_zero]
  rw [EuclideanGeometry.oangle_eq_oangle_of_dist_eq cfg.h_S_Ω.left]
  apply EuclideanGeometry.two_zsmul_oangle_of_parallel
  · rw [← cfg.prll_D_BC_eq_LD, Set.pair_comm]
    exact cfg.h_prll_D_BC.right
  · have h : line[ℝ, cfg.B, cfg.D] = line[ℝ, cfg.S, cfg.B] := by
      rw [Set.pair_comm]
      apply affineSpan_pair_eq_of_left_mem_of_ne _ cfg.D_ne_B
      apply Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_BDS.wbtw.collinear (by simp) (by simp) (by simp)
      exact cfg.S_ne_B
    rw [h]

noncomputable def F := Sphere.antipode V Pt cfg.Ω cfg.A

lemma F_in_Ω : cfg.F ∈ cfg.Ω := by
  apply Sphere.antipode_mem_sphere
  exact cfg.A_in_Ω

lemma isDiameter_AF : cfg.Ω.IsDiameter cfg.A cfg.F := by
  apply Sphere.antipode_isDiameter
  exact cfg.A_in_Ω

lemma sbtw_AOF : Sbtw ℝ cfg.A cfg.Ω.center cfg.F := by
  exact cfg.isDiameter_AF.sbtw cfg.Ω_radius_ne_zero

lemma F_ne_A : cfg.F ≠ cfg.A := by
  exact cfg.sbtw_AOF.left_ne_right.symm

lemma F_ne_O : cfg.F ≠ cfg.Ω.center := by
  exact cfg.sbtw_AOF.ne_right.symm

lemma F_ne_B : cfg.F ≠ cfg.B := by
  have h := cfg.angle_ACB_acute
  contrapose! h
  apply ge_of_eq
  have h' := cfg.isDiameter_AF
  rw [h] at h'
  rw [EuclideanGeometry.Sphere.angle_eq_pi_div_two_iff_mem_sphere_of_isDiameter h']
  exact cfg.C_in_Ω

lemma F_ne_C : cfg.F ≠ cfg.C := by
  have h := cfg.angle_CBA_acute
  contrapose! h
  apply ge_of_eq
  have h' := cfg.isDiameter_AF
  rw [h, Sphere.isDiameter_comm] at h'
  rw [EuclideanGeometry.Sphere.angle_eq_pi_div_two_iff_mem_sphere_of_isDiameter h']
  exact cfg.B_in_Ω

lemma angle_ASF_eq : ∠ cfg.A cfg.S cfg.F = Real.pi / 2 := by
  rw [EuclideanGeometry.Sphere.thales_theorem cfg.isDiameter_AF]
  exact cfg.h_S_Ω.right

lemma oangle_CAO_add_oangle_ABC : 2 • ∡ cfg.C cfg.A cfg.Ω.center + 2 • ∡ cfg.A cfg.B cfg.C = Real.pi := by
  apply Sphere.two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi
  · exact cfg.A_in_Ω
  · exact cfg.B_in_Ω
  · exact cfg.C_in_Ω
  · exact cfg.B_ne_A
  · exact cfg.B_ne_C
  · exact cfg.C_ne_A.symm

lemma acute_angle_CAO : ∠ cfg.C cfg.A cfg.Ω.center < Real.pi / 2 := by
  rw [angle_eq_abs_oangle_toReal cfg.C_ne_A cfg.O_ne_A]
  apply Sphere.abs_oangle_center_right_toReal_lt_pi_div_two
  · exact cfg.A_in_Ω
  · exact cfg.C_in_Ω

lemma angle_CAO_add_angle_ABC : ∠ cfg.C cfg.A cfg.Ω.center + ∠ cfg.A cfg.B cfg.C = Real.pi / 2 := by
  have h₁ := cfg.oangle_CAO_add_oangle_ABC
  have h₂ := cfg.acute_angle_CAO
  have h₃ := cfg.angle_CBA_acute
  rw [angle_comm] at h₃
  rw [angle_eq_abs_oangle_toReal cfg.C_ne_A cfg.O_ne_A] at *
  rw [angle_eq_abs_oangle_toReal cfg.B_ne_A.symm cfg.B_ne_C.symm] at *
  exact aux₁₀ h₁ h₂ h₃

lemma oangle_BAO_add_oangle_ACB : 2 • ∡ cfg.B cfg.A cfg.Ω.center + 2 • ∡ cfg.A cfg.C cfg.B = Real.pi := by
  apply Sphere.two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi
  · exact cfg.A_in_Ω
  · exact cfg.C_in_Ω
  · exact cfg.B_in_Ω
  · exact cfg.C_ne_A
  · exact cfg.B_ne_C.symm
  · exact cfg.B_ne_A.symm

lemma acute_angle_BAO : ∠ cfg.B cfg.A cfg.Ω.center < Real.pi / 2 := by
  rw [angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.O_ne_A]
  apply Sphere.abs_oangle_center_right_toReal_lt_pi_div_two
  · exact cfg.A_in_Ω
  · exact cfg.B_in_Ω

lemma angle_BAO_add_angle_ACB : ∠ cfg.B cfg.A cfg.Ω.center + ∠ cfg.A cfg.C cfg.B = Real.pi / 2 := by
  have h₁ := cfg.oangle_BAO_add_oangle_ACB
  have h₂ := cfg.acute_angle_BAO
  have h₃ := cfg.angle_ACB_acute
  rw [angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.O_ne_A] at *
  rw [angle_eq_abs_oangle_toReal cfg.C_ne_A.symm cfg.B_ne_C] at *
  exact aux₁₀ h₁ h₂ h₃

lemma angle_BAO_add_angle_OAC_eq_angle_BAC :
  ∠ cfg.B cfg.A cfg.Ω.center + ∠ cfg.Ω.center cfg.A cfg.C = ∠ cfg.B cfg.A cfg.C := by
  have h₁ := cfg.angle_CAO_add_angle_ABC
  have h₂ := cfg.angle_BAO_add_angle_ACB
  rw [← eq_sub_iff_add_eq] at h₁ h₂
  rw [angle_comm cfg.C cfg.A cfg.Ω.center, angle_comm cfg.A cfg.B cfg.C] at h₁
  rw [h₁, h₂]
  ring_nf
  rw [sub_eq_add_neg, ← neg_add, ← sub_eq_add_neg, sub_eq_iff_eq_add, ← add_assoc]
  symm
  apply angle_add_angle_add_angle_eq_pi
  exact cfg.B_ne_A.symm

lemma sign_oangle_BAO_ne_zero : (∡ cfg.B cfg.A cfg.Ω.center).sign ≠ 0 := by
  rw [cfg.sbtw_AOF.oangle_eq_right]
  intro h
  rw [oangle_sign_eq_zero_iff_collinear] at h
  have h' := eq_of_mem_sphere_of_collinear V Pt cfg.B_in_Ω cfg.A_in_Ω cfg.F_in_Ω h
  contrapose! h'
  constructorm* _ ∧ _
  · exact cfg.B_ne_A
  · exact cfg.F_ne_A.symm
  · exact cfg.F_ne_B

lemma sign_oangle_OAC_ne_zero : (∡ cfg.Ω.center cfg.A cfg.C).sign ≠ 0 := by
  rw [cfg.sbtw_AOF.oangle_eq_left]
  intro h
  rw [oangle_sign_eq_zero_iff_collinear] at h
  have h' := eq_of_mem_sphere_of_collinear V Pt cfg.F_in_Ω cfg.A_in_Ω cfg.C_in_Ω h
  contrapose! h'
  constructorm* _ ∧ _
  · exact cfg.F_ne_A
  · exact cfg.C_ne_A.symm
  · exact cfg.F_ne_C.symm

lemma sign_oangle_BAF_eq_sign_oangle_FAC
  : (∡ cfg.B cfg.A cfg.F).sign = (∡ cfg.F cfg.A cfg.C).sign := by
  rw [← cfg.sbtw_AOF.oangle_eq_right, ← cfg.sbtw_AOF.oangle_eq_left]
  have h₁ := oangle_add cfg.B_ne_A  cfg.O_ne_A cfg.C_ne_A
  have h₂ := cfg.angle_BAO_add_angle_OAC_eq_angle_BAC
  rw [angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.O_ne_A] at h₂
  rw [angle_eq_abs_oangle_toReal cfg.O_ne_A cfg.C_ne_A] at h₂
  rw [angle_eq_abs_oangle_toReal cfg.B_ne_A cfg.C_ne_A] at h₂
  have h_BAC := cfg.sphereOrder_BACE.sign_oangle₁₂₃_ne_zero
  rw [aux₄ cfg.sign_oangle_BAO_ne_zero h_BAC h₁ h₂]
  rw [add_comm] at h₁ h₂
  rw [aux₄ cfg.sign_oangle_OAC_ne_zero h_BAC h₁ h₂]

lemma sphereOrder_BACF : SphereOrder V Pt cfg.B cfg.A cfg.C cfg.F := by
  apply SphereOrder.rotate
  constructor
  · rw [EuclideanGeometry.cospherical_iff_exists_sphere]
    use cfg.Ω
    repeat rw [Set.insert_subset_iff]
    rw [Set.singleton_subset_iff]
    constructorm* _ ∧ _
    · exact cfg.F_in_Ω
    · exact cfg.B_in_Ω
    · exact cfg.A_in_Ω
    · exact cfg.C_in_Ω
  · rw [← oangle_rotate_sign, ← cfg.sbtw_AOF.oangle_eq_right]
    exact cfg.sign_oangle_BAO_ne_zero
  · rw [← oangle_rotate_sign, cfg.sign_oangle_BAF_eq_sign_oangle_FAC]
    rw [← oangle_rotate_sign]

lemma sphereOrder_ASCF : SphereOrder V Pt cfg.A cfg.S cfg.C cfg.F := by
  exact cfg.sphereOrder_BACF.symm.trans'' V Pt cfg.sphereOrder_BASC

lemma F_ne_S : cfg.F ≠ cfg.S := by
  exact cfg.sphereOrder_ASCF.P₂_ne_P₄.symm

lemma sphereOrder_ASFM : SphereOrder V Pt cfg.A cfg.S cfg.F cfg.M := by
  apply sphereOrder_of_sbtw_diag_inter V Pt _ cfg.S_ne_A.symm cfg.F_ne_S.symm cfg.sbtw_AOF cfg.sbtw_SOM
  rw [EuclideanGeometry.cospherical_iff_exists_sphere]
  use cfg.Ω
  repeat rw [Set.insert_subset_iff]
  rw [Set.singleton_subset_iff]
  constructorm* _ ∧ _
  · exact cfg.A_in_Ω
  · exact cfg.h_S_Ω.right
  · exact cfg.F_in_Ω
  · exact cfg.M_in_Ω

lemma sphereOrder_AFME : SphereOrder V Pt cfg.A cfg.F cfg.M cfg.E := by
  exact (cfg.sphereOrder_ASME.symm.trans V Pt cfg.sphereOrder_ASFM).rotate'

lemma F_ne_E : cfg.F ≠ cfg.E := by
  exact cfg.sphereOrder_AFME.P₂_ne_P₄

lemma oangle_BAE_eq_oangle_FAC : ∡ cfg.B cfg.A cfg.E = ∡ cfg.F cfg.A cfg.C := by
  rw [← cfg.sbtw_AOF.oangle_eq_left]
  apply oangle_eq_of_angle_eq_of_sign_eq
  · rw [cfg.angle_BAE_eq, sub_eq_iff_eq_add]
    rw [angle_comm cfg.Ω.center cfg.A cfg.C, angle_comm cfg.C cfg.B cfg.A]
    rw [cfg.angle_CAO_add_angle_ABC]
  · rw [cfg.sbtw_AOF.oangle_eq_left]
    rw [oangle_rotate_sign]
    rw [cfg.sphereOrder_BACE.rotate'.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    rw [cfg.sphereOrder_BACF.sign_oangle₁₂₃_eq_sign_oangle₂₃₄]
    rw [oangle_rotate_sign]

lemma oangle_SEF_eq_oangle_EFS : (2 : ℤ) • ∡ cfg.S cfg.E (F V Pt cfg) = (2 : ℤ) • ∡ cfg.E (F V Pt cfg) cfg.S := by
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.h_S_Ω.right cfg.E_in_Ω cfg.B_in_Ω cfg.F_in_Ω
    cfg.E_ne_S cfg.F_ne_E.symm cfg.S_ne_B.symm cfg.F_ne_B.symm]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.E_in_Ω cfg.F_in_Ω cfg.C_in_Ω cfg.h_S_Ω.right
    cfg.F_ne_E cfg.F_ne_S cfg.E_ne_C.symm cfg.S_ne_C.symm]
  rw [← oangle_add cfg.S_ne_B cfg.B_ne_C.symm cfg.F_ne_B]
  rw [← oangle_add cfg.E_ne_C cfg.B_ne_C cfg.S_ne_C]
  rw [smul_add, smul_add]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.C_in_Ω cfg.B_in_Ω cfg.A_in_Ω cfg.F_in_Ω
    cfg.B_ne_C cfg.F_ne_B.symm cfg.C_ne_A.symm cfg.F_ne_A.symm]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.E_in_Ω cfg.C_in_Ω cfg.A_in_Ω cfg.B_in_Ω
    cfg.E_ne_C.symm cfg.B_ne_C.symm cfg.h_E_ne_A.symm cfg.B_ne_A.symm]
  rw [oangle_rev cfg.F cfg.A cfg.C, oangle_rev cfg.B cfg.A cfg.E]
  rw [oangle_BAE_eq_oangle_FAC]
  rw [EuclideanGeometry.oangle_eq_oangle_of_dist_eq cfg.h_S_Ω.left.symm]
  abel

def K'_set := (cfg.prll_D_BC : Set Pt) ∩ (line[ℝ, cfg.S, cfg.F] : Set Pt)
def K_set := diag_inter_set V Pt cfg.A cfg.S cfg.C cfg.F

lemma K'_ne_D {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : K' ≠ cfg.D := by
  intro h
  rw [K'_set, Set.mem_inter_iff] at hK'
  have hSF := collinear_insert_of_mem_affineSpan_pair hK'.right
  rw [h] at hSF
  have hSB := cfg.sbtw_BDS.wbtw.collinear
  have hF : cfg.F ∈ affineSpan ℝ {cfg.S, cfg.D} :=
    Collinear.mem_affineSpan_of_mem_of_ne hSF (by simp) (by simp) (by simp) cfg.D_ne_S.symm
  have hB : cfg.B ∈ affineSpan ℝ {cfg.S, cfg.D} :=
    Collinear.mem_affineSpan_of_mem_of_ne hSB (by simp) (by simp) (by simp) cfg.D_ne_S.symm
  have hS : cfg.S ∈ affineSpan ℝ {cfg.S, cfg.D} := by
    apply mem_affineSpan
    simp
  have h' := collinear_triple_of_mem_affineSpan_pair hF hB hS
  have h'' := eq_of_mem_sphere_of_collinear V Pt cfg.F_in_Ω cfg.B_in_Ω cfg.h_S_Ω.right h'
  contrapose! h''
  constructorm* _ ∧ _
  · exact cfg.F_ne_B
  · exact cfg.S_ne_B.symm
  · exact cfg.F_ne_S.symm

lemma two_zsmul_oangle_ADK' {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : (2 : ℤ) • ∡ cfg.A cfg.D K' = Real.pi := by
  have h_K'LD := hK'.left
  rw [cfg.prll_D_BC_eq_LD] at h_K'LD
  have h_DAE : cfg.D ∈ affineSpan ℝ {cfg.A, cfg.E} :=
    cfg.sbtw_ADE.wbtw.collinear.mem_affineSpan_of_mem_of_ne
    (by simp) (by simp) (by simp) cfg.h_E_ne_A.symm
  have h_HAE : cfg.H ∈ affineSpan ℝ {cfg.A, cfg.E} :=
    cfg.sbtw_AHE.wbtw.collinear.mem_affineSpan_of_mem_of_ne
    (by simp) (by simp) (by simp) cfg.h_E_ne_A.symm
  have h_HBC : cfg.H ∈ affineSpan ℝ {cfg.B, cfg.C} :=
    cfg.sbtw_BHC.wbtw.collinear.mem_affineSpan_of_mem_of_ne
    (by simp) (by simp) (by simp) cfg.B_ne_C
  have h_ADK'_AHC : (2 : ℤ) • ∡ cfg.A cfg.D K' = (2 : ℤ) • ∡ cfg.A cfg.H cfg.C := by
    apply EuclideanGeometry.two_zsmul_oangle_of_parallel
    · rw [affineSpan_pair_eq_of_right_mem_of_ne h_DAE cfg.D_ne_A]
      rw [affineSpan_pair_eq_of_right_mem_of_ne h_HAE cfg.H_ne_A]
    · rw [affineSpan_pair_eq_of_left_mem_of_ne h_K'LD (cfg.K'_ne_D V Pt hK')]
      rw [← cfg.prll_D_BC_eq_LD, Set.pair_comm]
      rw [affineSpan_pair_eq_of_left_mem_of_ne h_HBC cfg.H_ne_C]
      exact cfg.h_prll_D_BC.right
  rw [h_ADK'_AHC, Real.Angle.two_zsmul_eq_pi_iff, ← Real.Angle.abs_toReal_eq_pi_div_two_iff]
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.H_ne_A.symm cfg.H_ne_C.symm]
  exact cfg.angle_AHC_eq

lemma K'_ne_A {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : K' ≠ cfg.A := by
  have h := cfg.two_zsmul_oangle_ADK' V Pt hK'
  contrapose! h
  rw [h, oangle_self_left_right, smul_zero]
  exact Real.Angle.pi_ne_zero.symm

lemma K'_ne_S {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : K' ≠ cfg.S := by
  intro h
  have h_K'LD := hK'.left
  rw [cfg.prll_D_BC_eq_LD, h] at h_K'LD
  have h_SLD := collinear_insert_of_mem_affineSpan_pair h_K'LD
  have hL : cfg.L ∈ affineSpan ℝ {cfg.S, cfg.D} :=
    Collinear.mem_affineSpan_of_mem_of_ne h_SLD (by simp) (by simp) (by simp) cfg.D_ne_S.symm
  have hSB := cfg.sbtw_BDS.wbtw.collinear
  have hB : cfg.B ∈ affineSpan ℝ {cfg.S, cfg.D} :=
    Collinear.mem_affineSpan_of_mem_of_ne hSB (by simp) (by simp) (by simp) cfg.D_ne_S.symm
  have hD : cfg.D ∈ affineSpan ℝ {cfg.S, cfg.D} := by
    apply mem_affineSpan
    simp
  have h' := collinear_triple_of_mem_affineSpan_pair hL hB hD
  have h'' := eq_of_mem_sphere_of_collinear V Pt cfg.L_in_ω cfg.B_in_ω cfg.D_in_ω h'
  contrapose! h''
  constructorm* _ ∧ _
  · exact cfg.L_ne_B
  · exact cfg.D_ne_B.symm
  · exact cfg.L_ne_D.symm

lemma cospherical_DASK' {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : Cospherical {cfg.A, cfg.D, cfg.S, K'} := by
  rw [K'_set, Set.mem_inter_iff] at hK'
  apply EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear
  · rw [cfg.two_zsmul_oangle_ADK' V Pt hK']
    rw [← oangle_add cfg.S_ne_A.symm cfg.F_ne_S (cfg.K'_ne_S V Pt hK')]
    rw [smul_add]
    have h_S := cfg.angle_ASF_eq
    rw [angle_eq_abs_oangle_toReal cfg.S_ne_A.symm cfg.F_ne_S] at h_S
    rw [Real.Angle.abs_toReal_eq_pi_div_two_iff, ← Real.Angle.two_zsmul_eq_pi_iff] at h_S
    rw [h_S, ← sub_eq_iff_eq_add', sub_self]
    symm
    rw [Real.Angle.two_zsmul_eq_zero_iff, oangle_eq_zero_or_eq_pi_iff_collinear]
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm]
    apply collinear_insert_of_mem_affineSpan_pair
    exact hK'.right
  · rw [← oangle_sign_eq_zero_iff_collinear, Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_zsmul_eq_zero_iff]
    rw [cfg.two_zsmul_oangle_ADK' V Pt hK']
    apply Real.Angle.pi_ne_zero

lemma K'_in_K_set {K' : Pt} (hK' : K' ∈ cfg.K'_set)
  : K' ∈ cfg.K_set := by
  rw [K_set, diag_inter_set, Set.mem_inter_iff]
  rw [K'_set, Set.mem_inter_iff] at hK'
  constructor
  · have h₁ := cfg.cospherical_DASK' V Pt hK'
    rw [Set.pair_comm] at h₁
    nth_rw 2 [Set.insert_comm] at h₁
    nth_rw 1 [Set.insert_comm] at h₁
    have h₂ := cfg.sphereOrder_BASC.cospherical
    nth_rw 2 [Set.insert_comm] at h₂
    nth_rw 1 [Set.insert_comm] at h₂
    have h_DSB : cfg.D ∈ affineSpan ℝ {cfg.S, cfg.B} :=
      cfg.sbtw_BDS.wbtw.collinear.mem_affineSpan_of_mem_of_ne
      (by simp) (by simp) (by simp) cfg.S_ne_B
    have h_K'LD := hK'.left
    rw [cfg.prll_D_BC_eq_LD] at h_K'LD
    have h_K'AC : Collinear ℝ {K', cfg.A, cfg.C} := by
      rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
      rw [Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_zsmul_eq_zero_iff]
      rw [← EuclideanGeometry.oangle_add (cfg.K'_ne_A V Pt hK') cfg.S_ne_A cfg.C_ne_A]
      rw [smul_add]
      rw [EuclideanGeometry.Cospherical.two_zsmul_oangle_eq h₁
        (cfg.K'_ne_A V Pt hK').symm cfg.S_ne_A.symm (cfg.K'_ne_D V Pt hK').symm cfg.D_ne_S]
      rw [← EuclideanGeometry.Cospherical.two_zsmul_oangle_eq h₂
        cfg.S_ne_B.symm cfg.B_ne_C cfg.S_ne_A.symm cfg.C_ne_A.symm]
      rw [← sub_neg_eq_add, ← smul_neg, ← oangle_rev, sub_eq_zero]
      apply EuclideanGeometry.two_zsmul_oangle_of_parallel
      · rw [affineSpan_pair_eq_of_left_mem_of_ne h_K'LD (cfg.K'_ne_D V Pt hK')]
        rw [← cfg.prll_D_BC_eq_LD, Set.pair_comm]
        exact cfg.h_prll_D_BC.right
      · rw [affineSpan_pair_eq_of_right_mem_of_ne h_DSB cfg.D_ne_S]
    apply h_K'AC.mem_affineSpan_of_mem_of_ne (by simp) (by simp) (by simp) cfg.C_ne_A.symm
  · exact hK'.right

lemma sbtw_AKC
    {K : Pt} (hK : K ∈ cfg.K_set) : Sbtw ℝ cfg.A K cfg.C := by
  exact cfg.sphereOrder_ASCF.diag_inter_sbtw V Pt hK

lemma KO_lt_Ω_radius {K : Pt} (hK : K ∈ cfg.K_set)
  : dist K cfg.Ω.center < cfg.Ω.radius := by
  apply Sphere.dist_le_radius_of_sbtw V Pt (cfg.sbtw_AKC V Pt hK) cfg.A_in_Ω cfg.C_in_Ω

lemma P_ne_F : cfg.P ≠ cfg.F := by
  have h := cfg.LO_gt_Ω_radius
  contrapose! h
  apply le_of_lt
  have hL : cfg.L ∈ cfg.K'_set := by
    rw [K'_set, Set.mem_inter_iff]
    constructor
    · rw [cfg.prll_D_BC_eq_LD]
      apply mem_affineSpan
      simp
    · rw [← h]
      exact cfg.collinear_LPS.mem_affineSpan_of_mem_of_ne
        (by simp) (by simp) (by simp) cfg.P_ne_S.symm
  apply cfg.K'_in_K_set at hL
  exact cfg.KO_lt_Ω_radius V Pt hL

lemma collinear_PDF : Collinear ℝ {cfg.P, cfg.D, cfg.F} := by
  rw [Set.insert_comm]
  have h_LPS := cfg.collinear_LPS
  have h_BLE := cfg.collinear_BLE
  rw [Set.pair_comm, Set.insert_comm] at h_BLE
  rw [← oangle_sign_eq_zero_iff_collinear] at h_LPS h_BLE ⊢
  rw [Real.Angle.sign_eq_zero_iff, ← Real.Angle.two_zsmul_eq_zero_iff] at h_LPS h_BLE ⊢
  rw [← oangle_add cfg.P_ne_D.symm cfg.L_ne_P cfg.P_ne_F.symm]
  rw [← oangle_add cfg.L_ne_P cfg.P_ne_S.symm cfg.P_ne_F.symm]
  rw [smul_add, smul_add, h_LPS, zero_add]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.D_in_ω cfg.P_in_ω cfg.B_in_ω cfg.L_in_ω
    cfg.P_ne_D cfg.L_ne_P.symm cfg.D_ne_B.symm cfg.L_ne_B.symm]
  rw [← oangle_add cfg.D_ne_B cfg.E_ne_B cfg.L_ne_B]
  rw [smul_add, h_BLE, add_zero]
  rw [cfg.sbtw_BDS.oangle_eq_left]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.h_S_Ω.right cfg.B_in_Ω cfg.F_in_Ω cfg.E_in_Ω
    cfg.S_ne_B.symm cfg.E_ne_B.symm cfg.F_ne_S cfg.F_ne_E]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.h_S_Ω.right cfg.P_in_Ω cfg.E_in_Ω cfg.F_in_Ω
    cfg.P_ne_S cfg.P_ne_F cfg.E_ne_S cfg.F_ne_E.symm]
  rw [oangle_rev, smul_neg, neg_add_eq_sub, sub_eq_zero]
  exact cfg.oangle_SEF_eq_oangle_EFS

lemma sbtw_PDF : Sbtw ℝ cfg.P cfg.D cfg.F := by
  apply EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius
    cfg.collinear_PDF cfg.P_in_Ω cfg.DO_lt_Ω_radius cfg.F_in_Ω cfg.P_ne_F

lemma F_ne_D : cfg.F ≠ cfg.D := by
  exact cfg.sbtw_PDF.ne_right.symm

lemma sphereOrder_PAFE : SphereOrder V Pt cfg.P cfg.A cfg.F cfg.E := by
  apply SphereOrder.rotate'
  apply sphereOrder_of_sbtw_diag_inter V Pt _ cfg.F_ne_A.symm cfg.F_ne_E cfg.sbtw_ADE cfg.sbtw_PDF.symm
  rw [EuclideanGeometry.cospherical_iff_exists_sphere]
  use cfg.Ω
  repeat rw [Set.insert_subset_iff]
  rw [Set.singleton_subset_iff]
  constructorm* _ ∧ _
  · exact cfg.A_in_Ω
  · exact cfg.F_in_Ω
  · exact cfg.E_in_Ω
  · exact cfg.P_in_Ω

lemma P_ne_A : cfg.P ≠ cfg.A := by
  exact cfg.sphereOrder_PAFE.P₁_ne_P₂

lemma sphereOrder_PAFM : SphereOrder V Pt cfg.P cfg.A cfg.F cfg.M := by
  exact cfg.sphereOrder_PAFE.rotate'.trans' V Pt cfg.sphereOrder_AFME

lemma P_ne_M : cfg.P ≠ cfg.M := by
  exact cfg.sphereOrder_PAFM.P₁_ne_P₄

lemma sphereOrder_PSFM : SphereOrder V Pt cfg.P cfg.S cfg.F cfg.M := by
  exact (cfg.sphereOrder_ASFM.trans' V Pt cfg.sphereOrder_PAFM.symm).rotate'

def Z_set := diag_inter_set V Pt cfg.P cfg.S cfg.F cfg.M

lemma exists_Z : ∃ Z : Pt, Z ∈ cfg.Z_set := by
  exact cfg.sphereOrder_PSFM.exists_diag_inter

lemma sbtw_PZF {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Sbtw ℝ cfg.P Z cfg.F := by
  exact cfg.sphereOrder_PSFM.diag_inter_sbtw V Pt hZ

lemma Z_ne_F {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Z ≠ cfg.F := by
  exact (cfg.sbtw_PZF V Pt hZ).ne_right

lemma sbtw_SZM {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Sbtw ℝ cfg.S Z cfg.M := by
  exact cfg.sphereOrder_PSFM.diag_inter_sbtw' V Pt hZ

lemma Z_ne_S {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Z ≠ cfg.S := by
  exact (cfg.sbtw_SZM V Pt hZ).ne_left

lemma Z_ne_D {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Z ≠ cfg.D := by
  have h := cfg.sphereOrder_BASM.symm.sign_oangle₁₂₃_ne_zero
  rw [oangle_rotate_sign] at h
  rw [← cfg.sbtw_BDS.symm.oangle_eq_left] at h
  rw [← (cfg.sbtw_SZM V Pt hZ).oangle_eq_right] at h
  exact (left_ne_right_of_oangle_sign_ne_zero h).symm

lemma Z_ne_O {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Z ≠ cfg.Ω.center := by
  have h := cfg.sphereOrder_PAFM.symm.sign_oangle₃₄₁_ne_zero
  rw [← oangle_rotate_sign] at h
  rw [← cfg.sbtw_AOF.symm.oangle_eq_left] at h
  rw [← (cfg.sbtw_PZF V Pt hZ).symm.oangle_eq_right] at h
  exact (left_ne_right_of_oangle_sign_ne_zero h).symm

lemma X_ne_D
    {X : Pt} (hX : X ∈ cfg.X_set) :
    X ≠ cfg.D := by
  have h := cfg.sphereOrder_BAME.sign_oangle₂₃₄_ne_zero
  rw [oangle_rotate_sign] at h
  rw [← cfg.sbtw_ADE.oangle_eq_left] at h
  rw [← (cfg.sbtw_AXM V Pt hX).oangle_eq_right] at h
  exact (left_ne_right_of_oangle_sign_ne_zero h).symm

lemma collinear_SXD {X : Pt} (hX : X ∈ cfg.X_set)
  : Collinear ℝ {cfg.S, X, cfg.D} := by
  have hS := mem_affineSpan ℝ (by simp : cfg.S ∈ {cfg.S, cfg.B})
  have hX := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_BXS V Pt hX).wbtw.collinear
    (by simp) (by simp) (by simp : X ∈ _) cfg.S_ne_B
  have hD := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_BDS.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.S_ne_B
  exact collinear_triple_of_mem_affineSpan_pair hS hX hD

lemma sbtw_SXD {X : Pt} (hX : X ∈ cfg.X_set)
  : Sbtw ℝ cfg.S X cfg.D := by
  rcases Collinear.sbtw_or_wbtw_or_wbtw V Pt (cfg.collinear_SXD V Pt hX) with (h'|(h'|h'))
  · exact h'
  · exfalso
    have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.A h' (cfg.X_ne_D V Pt hX)
    rw [cfg.sbtw_ADE.oangle_eq_right] at h''
    rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left] at h''
    rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left] at h''
    rw [← oangle_rotate_sign, ← oangle_swap₁₃_sign] at h''
    rw [← cfg.sphereOrder_AFME.sign_oangle₁₂₃_eq_sign_oangle₃₄₁] at h''
    rw [← oangle_rotate_sign] at h''
    rw [cfg.sphereOrder_ASFM.symm.sign_oangle₁₂₃_eq_sign_oangle₂₃₄] at h''
    rw [SignType.neg_eq_self_iff] at h''
    contrapose! h''
    exact cfg.sphereOrder_ASFM.rotate'.sign_oangle₁₂₃_ne_zero
  · exfalso
    have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.A h' cfg.D_ne_S
    rw [← Wbtw.oangle_sign_eq_of_ne_right cfg.A h' (cfg.X_ne_S V Pt hX).symm] at h''
    rw [cfg.sbtw_ADE.oangle_eq_left] at h''
    rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_right] at h''
    rw [cfg.sphereOrder_ASME.rotate'.sign_oangle₁₂₃_eq_sign_oangle₂₃₄] at h''
    rw [oangle_rotate_sign, ← oangle_swap₁₃_sign cfg.M cfg.A cfg.S] at h''
    rw [SignType.self_eq_neg_iff] at h''
    contrapose! h''
    exact cfg.sphereOrder_ASFM.rotate.sign_oangle₃₄₁_ne_zero

lemma S_ne_O : cfg.S ≠ cfg.Ω.center := by
  exact cfg.sbtw_SOM.ne_left.symm

lemma collinear_SOZ {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Collinear ℝ {cfg.S, cfg.Ω.center, Z} := by
  have hS := mem_affineSpan ℝ (by simp : cfg.S ∈ {cfg.S, cfg.M})
  have hO := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_SOM.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.Ω.center ∈ _) cfg.S_ne_M
  have hZ := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_SZM V Pt hZ).wbtw.collinear
    (by simp) (by simp) (by simp : Z ∈ _) cfg.S_ne_M
  exact collinear_triple_of_mem_affineSpan_pair hS hO hZ

lemma sbtw_SOZ {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : Sbtw ℝ cfg.S cfg.Ω.center Z := by
  rcases Collinear.sbtw_or_wbtw_or_wbtw V Pt (cfg.collinear_SOZ V Pt hZ) with (h'|(h'|h'))
  · exact h'
  · have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.F h' (cfg.Z_ne_O V Pt hZ).symm
    rw [cfg.sbtw_AOF.symm.oangle_eq_left] at h''
    rw [cfg.sbtw_AOF.symm.oangle_eq_left] at h''
    rw [(cfg.sbtw_PZF V Pt hZ).symm.oangle_eq_right] at h''
    rw [oangle_rotate_sign] at h''
    rw [cfg.sphereOrder_PAFM.sign_oangle₁₂₃_eq_sign_oangle₂₃₄] at h''
    rw [← oangle_rotate_sign] at h''
    rw [cfg.sphereOrder_ASFM.symm.sign_oangle₁₂₃_eq_sign_oangle₃₄₁] at h''
    rw [← oangle_swap₁₃_sign cfg.S cfg.F cfg.A, oangle_rotate_sign cfg.A cfg.S cfg.F] at h''
    rw [SignType.self_eq_neg_iff] at h''
    contrapose! h''
    exact cfg.sphereOrder_ASFM.sign_oangle₁₂₃_ne_zero
  · have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.F h' (cfg.Z_ne_S V Pt hZ)
    rw [← Wbtw.oangle_sign_eq_of_ne_right cfg.F h' cfg.S_ne_O] at h''
    rw [cfg.sbtw_AOF.symm.oangle_eq_right] at h''
    rw [(cfg.sbtw_PZF V Pt hZ).symm.oangle_eq_left] at h''
    rw [← oangle_rotate_sign, ← oangle_swap₁₃_sign] at h''
    rw [cfg.sphereOrder_PSFM.sign_oangle₁₂₃_eq_sign_oangle₂₃₄] at h''
    rw [← cfg.sphereOrder_ASFM.sign_oangle₁₂₃_eq_sign_oangle₂₃₄] at h''
    rw [oangle_rotate_sign cfg.A cfg.S (F V Pt cfg)] at h''
    rw [SignType.neg_eq_self_iff] at h''
    contrapose! h''
    exact cfg.sphereOrder_ASFM.sign_oangle₁₂₃_ne_zero

lemma oangle_MAE_eq_oangle_AMS
  : ∡ cfg.M cfg.A cfg.E = ∡ cfg.A cfg.M cfg.S := by
  apply aux₆
  · rw [← oangle_rotate_sign, ← oangle_swap₁₃_sign]
    rw [← cfg.sphereOrder_ASME.sign_oangle₁₂₃_eq_sign_oangle₃₄₁]
    rw [← oangle_rotate_sign, oangle_swap₁₃_sign]
  · rw [← oangle_rotate_sign, ← oangle_swap₁₃_sign]
    rw [SignType.neg_eq_zero_iff.ne]
    exact cfg.sphereOrder_ASME.sign_oangle₃₄₁_ne_zero
  · rw [← cfg.sbtw_SOM.symm.oangle_eq_right]
    have h : dist cfg.Ω.center cfg.A = dist cfg.Ω.center cfg.M := by
      rw [mem_sphere'.mp cfg.A_in_Ω]
      rw [mem_sphere'.mp cfg.M_in_Ω]
    rw [← EuclideanGeometry.oangle_eq_oangle_of_dist_eq h]
    rw [cfg.sbtw_AOF.oangle_eq_left]
    rw [← oangle_add cfg.M_ne_A cfg.B_ne_A cfg.h_E_ne_A]
    rw [← oangle_add cfg.F_ne_A cfg.C_ne_A cfg.M_ne_A]
    rw [cfg.oangle_BAE_eq_oangle_FAC]
    rw [oangle_rev cfg.M cfg.A cfg.C]
    rw [oangle_rev cfg.B cfg.A cfg.M]
    rw [cfg.oangle_BAM_eq_oangle_MAC]
    abel

lemma DX_to_XS_eq_DA_to_MS {X : Pt} (hX : X ∈ cfg.X_set)
  : dist cfg.D X / dist X cfg.S = dist cfg.D cfg.A / dist cfg.M cfg.S := by
  have hXS : dist X cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_S V Pt hX)
  have hOS : dist cfg.M cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_M.symm
  field_simp
  rw [dist_comm X cfg.S, dist_comm cfg.D cfg.A]
  have h₁ : ¬Collinear ℝ {cfg.D, X, cfg.A} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    rw [← oangle_rotate_sign]
    rw [cfg.sbtw_ADE.oangle_eq_right]
    rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left]
    rw [← oangle_rotate_sign]
    rw [← oangle_swap₁₃_sign, SignType.neg_eq_zero_iff]
    exact cfg.sphereOrder_ASME.sign_oangle₃₄₁_ne_zero
  have h₂ : ¬Collinear ℝ {cfg.S, X, cfg.M} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    rw [← oangle_rotate_sign]
    rw [(cfg.sbtw_AXM V Pt hX).symm.oangle_eq_left]
    rw [oangle_rotate_sign]
    rw [← oangle_swap₁₃_sign, SignType.neg_eq_zero_iff]
    exact cfg.sphereOrder_ASFM.rotate.sign_oangle₃₄₁_ne_zero
  rw [EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h₁]
  rw [EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h₂]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_A V Pt hX) cfg.D_ne_A]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_D V Pt hX).symm (cfg.X_ne_A V Pt hX).symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_M V Pt hX) cfg.S_ne_M]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_S V Pt hX).symm (cfg.X_ne_M V Pt hX).symm]
  rw [Sbtw.oangle_eq_left_right (cfg.sbtw_SXD V Pt hX).symm (cfg.sbtw_AXM V Pt hX)]
  rw [cfg.sbtw_ADE.oangle_eq_right]
  rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left]
  rw [(cfg.sbtw_AXM V Pt hX).symm.oangle_eq_left]
  rw [cfg.oangle_MAE_eq_oangle_AMS]
  ring

lemma AE_paralell_SM : line[ℝ, cfg.A, cfg.E] ∥ line[ℝ, cfg.S, cfg.M] := by
  rw [Set.pair_comm cfg.A cfg.E, Set.pair_comm cfg.S cfg.M]
  apply parallel_of_two_zsmul_oangle_eq V Pt cfg.h_E_ne_A cfg.M_ne_A.symm cfg.S_ne_M.symm
  rw [oangle_rev, oangle_MAE_eq_oangle_AMS, ← oangle_rev]

lemma oangle_OZF_eq_oangle_ADF {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : ∡ cfg.Ω.center Z cfg.F = ∡ cfg.A cfg.D cfg.F := by
  apply oangle_eq_of_parallel
  · intro h
    apply collinear_insert_of_mem_affineSpan_pair at h
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h
    rw [← oangle_rotate_sign] at h
    rw [cfg.sbtw_AOF.symm.oangle_eq_left] at h
    rw [(cfg.sbtw_PZF V Pt hZ).symm.oangle_eq_right] at h
    rw [oangle_rotate_sign] at h
    contrapose! h
    exact cfg.sphereOrder_PAFM.sign_oangle₁₂₃_ne_zero
  · exact Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_AOF.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.A ∈ _) cfg.F_ne_O.symm
  · exact right_mem_affineSpan_pair ℝ cfg.Ω.center (F V Pt cfg)
  · have h₁ := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_ADE.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.h_E_ne_A.symm
    have h₂ := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_SOM.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.Ω.center ∈ _) cfg.S_ne_M
    have h₃ := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_SZM V Pt hZ).wbtw.collinear
      (by simp) (by simp) (by simp : Z ∈ _) cfg.S_ne_M
    rw [affineSpan_pair_eq_of_right_mem_of_ne h₁ cfg.D_ne_A]
    rw [affineSpan_pair_eq_of_mem_of_mem_of_ne h₂ h₃ (cfg.Z_ne_O V Pt hZ).symm]
    exact cfg.AE_paralell_SM.symm
  · have h₁ := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_PDF.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.P_ne_F.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h₁ cfg.F_ne_D.symm]
    have h₂ := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_PZF V Pt hZ).wbtw.collinear
      (by simp) (by simp) (by simp : Z ∈ _) cfg.P_ne_F.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h₂ (cfg.Z_ne_F V Pt hZ)]

lemma ZO_to_OS_eq_DA_to_MS {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : dist Z cfg.Ω.center / dist cfg.Ω.center cfg.S = dist cfg.D cfg.A / dist cfg.M cfg.S := by
  have hOS : dist cfg.Ω.center cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_O.symm
  have hOS : dist cfg.M cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_M.symm
  field_simp
  rw [dist_comm Z cfg.Ω.center, dist_comm cfg.D cfg.A]
  have h₁ : ¬Collinear ℝ {cfg.A, cfg.D, cfg.F} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    rw [oangle_rotate_sign]
    rw [cfg.sbtw_ADE.oangle_eq_right]
    rw [← oangle_swap₁₃_sign, SignType.neg_eq_zero_iff]
    exact cfg.sphereOrder_AFME.rotate'.sign_oangle₁₂₃_ne_zero
  have h₂ : ¬Collinear ℝ {cfg.Ω.center, Z, cfg.F} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    rw [cfg.oangle_OZF_eq_oangle_ADF V Pt hZ]
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    exact h₁
  rw [EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h₁]
  rw [EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h₂]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.Z_ne_F V Pt hZ) cfg.F_ne_O.symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.Z_ne_O V Pt hZ).symm (cfg.Z_ne_F V Pt hZ).symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.F_ne_D.symm cfg.F_ne_A.symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.D_ne_A.symm cfg.F_ne_D]
  rw [cfg.sbtw_PDF.symm.oangle_eq_left]
  rw [(cfg.sbtw_PZF V Pt hZ).symm.oangle_eq_left]
  rw [cfg.sbtw_AOF.symm.oangle_eq_right]
  rw [cfg.oangle_OZF_eq_oangle_ADF V Pt hZ]
  rw [EuclideanGeometry.mem_sphere.mp cfg.F_in_Ω]
  rw [EuclideanGeometry.mem_sphere'.mp cfg.h_S_Ω.right]
  rw [cfg.isDiameter_AF.symm.dist_left_right]
  rw [cfg.isDiameter_SM.symm.dist_left_right]
  ring

lemma DX_to_XS_eq_ZO_to_OS {X : Pt} (hX : X ∈ cfg.X_set)
  {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : dist cfg.D X / dist X cfg.S = dist Z cfg.Ω.center / dist cfg.Ω.center cfg.S := by
  rw [cfg.DX_to_XS_eq_DA_to_MS V Pt hX, cfg.ZO_to_OS_eq_DA_to_MS V Pt hZ]

lemma DS_to_XS_eq_ZS_to_OS {X : Pt} (hX : X ∈ cfg.X_set)
  {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : dist cfg.D cfg.S / dist X cfg.S = dist Z cfg.S / dist cfg.Ω.center cfg.S := by
  rw [← (cfg.sbtw_SXD V Pt hX).symm.wbtw.dist_add_dist]
  rw [← (cfg.sbtw_SOZ V Pt hZ).symm.wbtw.dist_add_dist]
  have hOS : dist cfg.Ω.center cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_O.symm
  have hXS : dist X cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_S V Pt hX)
  rw [add_div, add_div, div_self hOS, div_self hXS]
  rw [cfg.DX_to_XS_eq_ZO_to_OS V Pt hX hZ]

lemma DZ_to_XO_eq_ZS_to_OS {X : Pt} (hX : X ∈ cfg.X_set)
  {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : dist cfg.D Z / dist X cfg.Ω.center = dist Z cfg.S / dist cfg.Ω.center cfg.S := by
  rw [← mul_self_inj_of_nonneg (by positivity) (by positivity)]
  have hOS : dist cfg.Ω.center cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_O.symm
  have hXO : dist X cfg.Ω.center ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_O V Pt hX)
  have hXS : dist X cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_S V Pt hX)
  have h := cfg.DS_to_XS_eq_ZS_to_OS V Pt hX hZ
  field_simp at h ⊢
  rw [pow_two, pow_two, pow_two, pow_two]
  rw [EuclideanGeometry.law_cos cfg.D cfg.S Z]
  rw [EuclideanGeometry.law_cos X cfg.S cfg.Ω.center]
  ring_nf
  rw [pow_two, pow_two, pow_two, pow_two]
  rw [angle_eq_abs_oangle_toReal cfg.D_ne_S (cfg.Z_ne_S V Pt hZ)]
  rw [angle_eq_abs_oangle_toReal (cfg.X_ne_S V Pt hX) cfg.S_ne_O.symm]
  rw [(cfg.sbtw_SOZ V Pt hZ).oangle_eq_right]
  rw [(cfg.sbtw_SXD V Pt hX).oangle_eq_left]
  rw [(by ring: dist cfg.Ω.center cfg.S * dist cfg.Ω.center cfg.S * dist cfg.D cfg.S
    = (dist cfg.D cfg.S * dist cfg.Ω.center cfg.S) * dist cfg.Ω.center cfg.S)]
  rw [(by ring: dist cfg.Ω.center cfg.S * dist cfg.Ω.center cfg.S * (dist cfg.D cfg.S * dist cfg.D cfg.S)
    = (dist cfg.D cfg.S * dist cfg.Ω.center cfg.S) * (dist cfg.D cfg.S * dist cfg.Ω.center cfg.S))]
  rw [h]
  ring

lemma angle_OXS_eq_angle_ZDS {X : Pt} (hX : X ∈ cfg.X_set)
  {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : ∠ cfg.Ω.center X cfg.S = ∠ Z cfg.D cfg.S := by
  apply angle_eq_of_cos_angle_eq
  have h₁ := EuclideanGeometry.law_cos cfg.Ω.center X cfg.S
  have h₂ := EuclideanGeometry.law_cos Z cfg.D cfg.S
  rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq'] at h₁ h₂
  have hOX : dist cfg.Ω.center X ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_O V Pt hX).symm
  have hSX : dist cfg.S X ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.X_ne_S V Pt hX).symm
  rw [mul_comm, ← eq_div_iff (by positivity)] at h₁
  have hSD : dist cfg.S cfg.D ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.D_ne_S.symm
  have hZD : dist Z cfg.D ≠ 0 := by
    rw [dist_ne_zero]
    exact (cfg.Z_ne_D V Pt hZ)
  rw [mul_comm, ← eq_div_iff (by positivity)] at h₂
  rw [h₁, h₂]
  have h₁ := cfg.DS_to_XS_eq_ZS_to_OS V Pt hX hZ
  rw [← cfg.DZ_to_XO_eq_ZS_to_OS V Pt hX hZ] at h₁
  rw [dist_comm cfg.D cfg.S, dist_comm X cfg.S] at h₁
  rw [dist_comm cfg.D Z, dist_comm X cfg.Ω.center] at h₁
  have hOS : dist cfg.Ω.center cfg.S ≠ 0 := by
    rw [dist_ne_zero]
    exact cfg.S_ne_O.symm
  have h₂ := cfg.DZ_to_XO_eq_ZS_to_OS V Pt hX hZ
  rw [dist_comm cfg.D Z, dist_comm X cfg.Ω.center] at h₂
  have h₃ := cfg.DS_to_XS_eq_ZS_to_OS V Pt hX hZ
  rw [dist_comm cfg.D cfg.S, dist_comm X cfg.S] at h₃
  field_simp at ⊢ h₁ h₂ h₃
  ring_nf
  rw [(by ring : dist cfg.S cfg.D * dist Z cfg.D * dist cfg.Ω.center X ^ 2
    = (dist cfg.S cfg.D * dist cfg.Ω.center X) * dist Z cfg.D * dist cfg.Ω.center X)]
  rw [(by ring :  dist cfg.S cfg.D ^ 2 * dist cfg.Ω.center X * dist cfg.S X
    = (dist cfg.S cfg.D * dist cfg.Ω.center X) * dist cfg.S cfg.D * dist cfg.S X)]
  rw [(by ring : dist cfg.S cfg.D * dist Z cfg.D * dist cfg.Ω.center cfg.S ^ 2
    = dist cfg.S cfg.D * dist cfg.Ω.center cfg.S * (dist Z cfg.D * dist cfg.Ω.center cfg.S))]
  rw [h₁, h₂, h₃]
  ring

lemma oangle_OXS_eq_oangle_ZDS {X : Pt} (hX : X ∈ cfg.X_set)
  {Z : Pt} (hZ : Z ∈ cfg.Z_set)
  : ∡ cfg.Ω.center X cfg.S = ∡ Z cfg.D cfg.S := by
  apply oangle_eq_of_angle_eq_of_sign_eq
  · exact cfg.angle_OXS_eq_angle_ZDS V Pt hX hZ
  · rw [← oangle_rotate_sign cfg.Ω.center X cfg.S, ← oangle_rotate_sign Z cfg.D cfg.S]
    rw [(cfg.sbtw_SXD V Pt hX).oangle_eq_left]
    rw [(cfg.sbtw_SOZ V Pt hZ).oangle_eq_right]

lemma XO_paralell_FP {X : Pt} (hX : X ∈ cfg.X_set)
  : line[ℝ, X, cfg.Ω.center] ∥ line[ℝ, cfg.P, cfg.F] := by
  rcases cfg.exists_Z with ⟨Z, hZ⟩
  have hD := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_PDF.wbtw.collinear
    (by simp) (by simp) (by simp : cfg.D ∈ _) cfg.P_ne_F
  have hZ' := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_PZF V Pt hZ).wbtw.collinear
    (by simp) (by simp) (by simp : Z ∈ _) cfg.P_ne_F
  rw [← affineSpan_pair_eq_of_mem_of_mem_of_ne hD hZ' (cfg.Z_ne_D V Pt hZ).symm]
  rw [Set.pair_comm]
  apply parallel_of_two_zsmul_oangle_eq V Pt (cfg.X_ne_O V Pt hX).symm (cfg.X_ne_D V Pt hX) (cfg.Z_ne_D V Pt hZ).symm
  rw [← oangle_add (cfg.X_ne_O V Pt hX).symm (cfg.X_ne_S V Pt hX).symm (cfg.X_ne_D V Pt hX).symm]
  rw [← oangle_add (cfg.Z_ne_D V Pt hZ) cfg.D_ne_S.symm (cfg.X_ne_D V Pt hX)]
  rw [smul_add, smul_add]
  have h₁ := (cfg.sbtw_SXD V Pt hX).wbtw.collinear
  have h₂ := (cfg.sbtw_SXD V Pt hX).wbtw.collinear
  rw [Set.pair_comm] at h₂
  rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear] at h₁ h₂
  rw [Real.Angle.sign_eq_zero_iff] at h₁ h₂
  rw [← Real.Angle.two_zsmul_eq_zero_iff] at h₁ h₂
  rw [h₁, h₂]
  rw [add_zero, add_zero]
  rw [cfg.oangle_OXS_eq_oangle_ZDS V Pt hX hZ]

def Y_set := diag_inter_set V Pt cfg.P cfg.A cfg.F cfg.M

lemma exists_Y : ∃ Y : Pt, Y ∈ cfg.Y_set := by
  exact cfg.sphereOrder_PAFM.exists_diag_inter

lemma Y_ne_P {Y : Pt} (hY : Y ∈ cfg.Y_set) : Y ≠ cfg.P := by
  exact cfg.sphereOrder_PAFM.diag_inter_ne_P₁ V Pt hY

lemma Y_ne_A {Y : Pt} (hY : Y ∈ cfg.Y_set) : Y ≠ cfg.A := by
  rw [Y_set, diag_inter_set_rotate] at hY
  exact cfg.sphereOrder_PAFM.rotate.diag_inter_ne_P₁ V Pt hY

lemma Y_ne_F {Y : Pt} (hY : Y ∈ cfg.Y_set) : Y ≠ cfg.F := by
  rw [Y_set, diag_inter_set_rotate, diag_inter_set_rotate] at hY
  exact cfg.sphereOrder_PAFM.symm.diag_inter_ne_P₁ V Pt hY

lemma sbtw_PYF {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : Sbtw ℝ cfg.P Y cfg.F := by
  exact cfg.sphereOrder_PAFM.diag_inter_sbtw V Pt hY

lemma sbtw_AYM {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : Sbtw ℝ cfg.A Y cfg.M := by
  exact cfg.sphereOrder_PAFM.diag_inter_sbtw' V Pt hY

lemma angle_APY_eq {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : ∠ cfg.A cfg.P Y = Real.pi / 2 := by
  rw [angle_eq_abs_oangle_toReal cfg.P_ne_A.symm (cfg.Y_ne_P V Pt hY)]
  rw [Real.Angle.abs_toReal_eq_pi_div_two_iff, ← Real.Angle.two_zsmul_eq_pi_iff]
  rw [(cfg.sbtw_PYF V Pt hY).oangle_eq_right]
  rw [Real.Angle.two_zsmul_eq_pi_iff, ← Real.Angle.abs_toReal_eq_pi_div_two_iff]
  rw [← angle_eq_abs_oangle_toReal cfg.P_ne_A.symm cfg.P_ne_F.symm]
  rw [EuclideanGeometry.Sphere.angle_eq_pi_div_two_iff_mem_sphere_of_isDiameter cfg.isDiameter_AF]
  exact cfg.P_in_Ω

lemma collinear_AXY {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  :  Collinear ℝ {cfg.A, X, Y} := by
  have h₁ := (cfg.sbtw_AXM V Pt hX).wbtw.collinear
  have h₂ := (cfg.sbtw_AYM V Pt hY).wbtw.collinear
  have hX : X ∈ affineSpan ℝ {cfg.A, cfg.M} :=
    Collinear.mem_affineSpan_of_mem_of_ne h₁ (by simp) (by simp) (by simp) cfg.M_ne_A.symm
  have hY : Y ∈ affineSpan ℝ {cfg.A, cfg.M} :=
    Collinear.mem_affineSpan_of_mem_of_ne h₂ (by simp) (by simp) (by simp) cfg.M_ne_A.symm
  have hA : cfg.A ∈ affineSpan ℝ {cfg.A, cfg.M} := by
    apply mem_affineSpan
    simp
  exact collinear_triple_of_mem_affineSpan_pair hA hX hY

lemma not_collinear_AXO {X : Pt} (hX : X ∈ cfg.X_set)
  : ¬Collinear ℝ {cfg.A, X, cfg.Ω.center} := by
  rw [Set.insert_comm]
  rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
  rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left]
  rw [cfg.sbtw_AOF.oangle_eq_right]
  rw [oangle_rotate_sign]
  exact cfg.sphereOrder_ASFM.sign_oangle₃₄₁_ne_zero

lemma oangle_AXO_eq_oangle_AYF {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : ∡ cfg.A X cfg.Ω.center = ∡ cfg.A Y cfg.F := by
  apply EuclideanGeometry.oangle_eq_of_parallel
  · have h := cfg.not_collinear_AXO V Pt hX
    contrapose! h
    rw [Set.insert_comm]
    exact collinear_insert_of_mem_affineSpan_pair h
  · exact left_mem_affineSpan_pair ℝ cfg.A cfg.Ω.center
  · exact Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_AOF.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.F ∈ _) cfg.O_ne_A.symm
  · have h₁ := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_AXM V Pt hX).wbtw.collinear
      (by simp) (by simp) (by simp : X ∈ _) cfg.M_ne_A.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h₁ (cfg.X_ne_A V Pt hX)]
    have h₂ := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_AYM V Pt hY).wbtw.collinear
      (by simp) (by simp) (by simp : Y ∈ _) cfg.M_ne_A.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h₂ (cfg.Y_ne_A V Pt hY)]
  · have h := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_PYF V Pt hY).wbtw.collinear
      (by simp) (by simp) (by simp : Y ∈ _) cfg.P_ne_F.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h (cfg.Y_ne_F V Pt hY)]
    rw [Set.pair_comm cfg.Ω.center X, Set.pair_comm cfg.F cfg.P]
    exact cfg.XO_paralell_FP V Pt hX

lemma oangle_XOA_eq_oangle_YFA {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : ∡ X cfg.Ω.center cfg.A = ∡ Y cfg.F cfg.A := by
  apply EuclideanGeometry.oangle_eq_of_parallel
  · have h := cfg.not_collinear_AXO V Pt hX
    contrapose! h
    rw [Set.pair_comm, Set.insert_comm, Set.pair_comm]
    exact collinear_insert_of_mem_affineSpan_pair h
  · exact Collinear.mem_affineSpan_of_mem_of_ne (cfg.collinear_AXY V Pt hX hY)
      (by simp) (by simp) (by simp : Y ∈ _) (cfg.X_ne_A V Pt hX)
  · exact right_mem_affineSpan_pair ℝ X cfg.A
  · have h := Collinear.mem_affineSpan_of_mem_of_ne (cfg.sbtw_PYF V Pt hY).wbtw.collinear
      (by simp) (by simp) (by simp : Y ∈ _) cfg.P_ne_F
    rw [affineSpan_pair_eq_of_left_mem_of_ne h (cfg.Y_ne_F V Pt hY)]
    exact cfg.XO_paralell_FP V Pt hX
  · have h := Collinear.mem_affineSpan_of_mem_of_ne cfg.sbtw_AOF.wbtw.collinear
      (by simp) (by simp) (by simp : cfg.Ω.center ∈ _) cfg.F_ne_A.symm
    rw [affineSpan_pair_eq_of_right_mem_of_ne h cfg.O_ne_A]

lemma AX_eq_AY_div_two {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : dist cfg.A X = dist cfg.A Y / 2 := by
  have h_AXO := cfg.not_collinear_AXO V Pt hX
  have h_AYF : ¬Collinear ℝ {cfg.A, Y, cfg.F} := by
    rw [← EuclideanGeometry.oangle_sign_eq_zero_iff_collinear, ← cfg.oangle_AXO_eq_oangle_AYF V Pt hX hY]
    rw [EuclideanGeometry.oangle_sign_eq_zero_iff_collinear]
    exact h_AXO
  have h₁ := EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h_AXO
  have h₂ := EuclideanGeometry.dist_eq_dist_mul_sin_angle_div_sin_angle h_AYF
  rw [h₁, h₂, div_right_comm]
  nth_rw 2 [mul_div_right_comm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_O V Pt hX) cfg.O_ne_A.symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.X_ne_A V Pt hX).symm (cfg.X_ne_O V Pt hX).symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.Y_ne_F V Pt hY) cfg.F_ne_A.symm]
  rw [EuclideanGeometry.angle_eq_abs_oangle_toReal (cfg.Y_ne_A V Pt hY).symm (cfg.Y_ne_F V Pt hY).symm]
  rw [← cfg.oangle_AXO_eq_oangle_AYF V Pt hX hY]
  rw [← cfg.oangle_XOA_eq_oangle_YFA V Pt hX hY]
  have h : dist cfg.Ω.center cfg.A = dist cfg.F cfg.A / 2 := by
    rw [EuclideanGeometry.Sphere.IsDiameter.dist_left_right cfg.isDiameter_AF.symm]
    rw [mul_div_cancel_left₀ _ (by norm_num)]
    rw [← EuclideanGeometry.mem_sphere']
    exact cfg.A_in_Ω
  rw [h]

lemma sbtw_AXY {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : Sbtw ℝ cfg.A X Y := by
  rcases Collinear.sbtw_or_wbtw_or_wbtw V Pt (cfg.collinear_AXY V Pt hX hY) with (h'|(h'|h'))
  · exact h'
  · exfalso
    have h := h'.dist_add_dist
    rw [dist_comm X cfg.A, dist_comm Y cfg.A, cfg.AX_eq_AY_div_two V Pt hX hY] at h
    rw [← sub_eq_zero] at h
    field_simp at h
    ring_nf at h
    symm at h
    rw [← add_zero (0 : ℝ), add_eq_add_iff_eq_and_eq (by positivity) (by positivity)] at h
    contrapose h
    rw [not_and_or]
    right
    rw [zero_eq_dist]
    exact (cfg.Y_ne_A V Pt hY).symm
  · exfalso
    have h'' := Wbtw.oangle_sign_eq_of_ne_left cfg.E h' (cfg.Y_ne_A V Pt hY)
    rw [← Wbtw.oangle_sign_eq_of_ne_right cfg.E h' (cfg.X_ne_A V Pt hX).symm] at h''
    contrapose! h''
    rw [← oangle_rotate_sign Y cfg.E cfg.A, oangle_rotate_sign X cfg.A cfg.E]
    rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_left, (cfg.sbtw_AYM V Pt hY).oangle_eq_right]
    rw [oangle_rev cfg.E cfg.A (M V Pt cfg), Real.Angle.sign_neg, SignType.self_eq_neg_iff.ne]
    rw [oangle_rotate_sign]
    exact cfg.sphereOrder_AFME.sign_oangle₃₄₁_ne_zero

lemma X_eq_midpoint_AY {X : Pt} (hX : X ∈ cfg.X_set)
  {Y : Pt} (hY : Y ∈ cfg.Y_set)
  : X = midpoint ℝ cfg.A Y := by
  have h := cfg.AX_eq_AY_div_two V Pt hX hY
  apply eq_midpoint_of_dist_eq_half
  · exact h
  · have h' := (cfg.sbtw_AXY V Pt hX hY).wbtw.dist_add_dist
    rw [h, ← eq_sub_iff_add_eq'] at h'
    rw [h']
    ring

lemma XP_eq_XA  {X : Pt} (hX : X ∈ cfg.X_set)
  : dist X cfg.P = dist X cfg.A := by
  rcases cfg.exists_Y with ⟨Y, hY⟩
  have h := cfg.angle_APY_eq V Pt hY
  rw [EuclideanGeometry.Sphere.angle_eq_pi_div_two_iff_mem_sphere_ofDiameter] at h
  rw [EuclideanGeometry.mem_sphere'] at h
  have h' : X = (Sphere.ofDiameter cfg.A Y).center := by
    rw [Sphere.ofDiameter]
    dsimp
    exact cfg.X_eq_midpoint_AY V Pt hX hY
  rw [h', h]
  symm
  rw [← EuclideanGeometry.mem_sphere']
  exact (EuclideanGeometry.Sphere.isDiameter_ofDiameter cfg.A Y).left_mem

lemma oangle_XPA_eq_oangle_PAX {X : Pt} (hX : X ∈ cfg.X_set)
  : ∡ X cfg.P cfg.A  = ∡ cfg.P cfg.A X := by
  apply EuclideanGeometry.oangle_eq_oangle_of_dist_eq (cfg.XP_eq_XA V Pt hX)

lemma two_zsmul_angle_SPM_eq : (2 : ℤ) • ∡ cfg.S cfg.P cfg.M = Real.pi := by
  rw [Real.Angle.two_zsmul_eq_pi_iff]
  rw [← Real.Angle.abs_toReal_eq_pi_div_two_iff]
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.P_ne_S.symm cfg.P_ne_M.symm]
  rw [EuclideanGeometry.Sphere.thales_theorem cfg.isDiameter_SM]
  exact cfg.P_in_Ω

lemma two_zsmul_angle_APF_eq : (2 : ℤ) • ∡ cfg.A cfg.P cfg.F = Real.pi := by
  rw [Real.Angle.two_zsmul_eq_pi_iff]
  rw [← Real.Angle.abs_toReal_eq_pi_div_two_iff]
  rw [← EuclideanGeometry.angle_eq_abs_oangle_toReal cfg.P_ne_A.symm cfg.P_ne_F.symm]
  rw [EuclideanGeometry.Sphere.thales_theorem cfg.isDiameter_AF]
  exact cfg.P_in_Ω

lemma oangle_XPD_eq_oangle_PBD {X : Pt} (hX : X ∈ cfg.X_set)
  : (2 : ℤ) • ∡ X cfg.P cfg.D  = (2 : ℤ) • ∡ cfg.P cfg.B cfg.D := by
  rw [← oangle_add (cfg.P_ne_X V Pt hX).symm cfg.P_ne_A.symm cfg.P_ne_D.symm]
  rw [smul_add, cfg.oangle_XPA_eq_oangle_PAX V Pt hX]
  rw [(cfg.sbtw_AXM V Pt hX).oangle_eq_right]
  rw [cfg.sbtw_BDS.oangle_eq_right]
  rw [← eq_sub_iff_add_eq']
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.P_in_Ω cfg.A_in_Ω cfg.h_S_Ω.right cfg.M_in_Ω
    cfg.P_ne_A.symm cfg.M_ne_A.symm cfg.P_ne_S.symm cfg.S_ne_M]
  rw [EuclideanGeometry.Sphere.two_zsmul_oangle_eq cfg.P_in_Ω cfg.B_in_Ω cfg.M_in_Ω cfg.h_S_Ω.right
    cfg.h_P_ne_B.symm cfg.S_ne_B.symm cfg.P_ne_M.symm cfg.S_ne_M.symm]
  rw [sub_eq_add_neg, ← smul_neg, ← oangle_rev, ← smul_add]
  have h := EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi
    cfg.P_ne_M.symm cfg.S_ne_M cfg.P_ne_S
  rw [← eq_sub_iff_add_eq] at h
  rw [h, smul_sub, two_zsmul_angle_SPM_eq]
  rw [cfg.sbtw_PDF.oangle_eq_right, two_zsmul_angle_APF_eq]
  abel

lemma PX_isTangentAt_ω {X : Pt} (hX : X ∈ cfg.X_set)
  : Sphere.IsTangentAt cfg.ω cfg.P line[ℝ, cfg.P, X] := by
  apply Sphere.IsTangentAt_of_two_zsmul_oangle_eq V Pt cfg.P_in_ω cfg.D_in_ω cfg.B_in_ω
    cfg.P_ne_D cfg.h_P_ne_B cfg.D_ne_B (cfg.P_ne_X V Pt hX) (cfg.oangle_XPD_eq_oangle_PBD V Pt hX)

lemma X_in_tang_P_ω {X : Pt} (hX : X ∈ cfg.X_set)
  : X ∈ cfg.tang_P_ω := by
  have h' : finrank ℝ cfg.tang_P_ω.direction + 1 = finrank ℝ V := by
    rw [cfg.h_rank_tang_P_ω, hd2.out]
  have h₁ := EuclideanGeometry.Sphere.IsTangentAt.eq_orthRadius_of_finrank_add_one_eq
    cfg.h_tang_P_ω cfg.ω_radius_ne_zero h'
  have h'' : finrank ℝ line[ℝ, cfg.P, X].direction + 1 = finrank ℝ V := by
    rw [hd2.out, Nat.add_one, Nat.succ_inj, affineSpan_pair_finrank V Pt (cfg.P_ne_X V Pt hX)]
  have h₂ := EuclideanGeometry.Sphere.IsTangentAt.eq_orthRadius_of_finrank_add_one_eq
    (cfg.PX_isTangentAt_ω V Pt hX) cfg.ω_radius_ne_zero h''
  rw [h₁, ← h₂]
  exact right_mem_affineSpan_pair ℝ cfg.P X

theorem result : ∃ X : Pt,
    X ∈ (cfg.tang_P_ω : Set Pt) ∩ line[ℝ, cfg.B, cfg.S]
    ∧ ∠ cfg.B cfg.A X = ∠ X cfg.A cfg.C
    ∧ ∠ cfg.B cfg.A X < π / 2 := by
  rcases cfg.exists_X with ⟨X, hX⟩
  use X
  constructor
  · constructor
    · exact cfg.X_in_tang_P_ω V Pt hX
    · exact Set.mem_of_mem_inter_left hX
  · constructor
    · exact cfg.angle_BAX_eq_angle_XAC V Pt hX
    · rw [← cfg.angle_BAM_eq_angle_BAX V Pt hX]
      exact cfg.angle_BAM_acute

end Imo2023q2Cfg



theorem imo2023_p1
  -- Points
  (A B C D E L S P : Pt)
  -- Circles
  (Ω ω : Sphere Pt)
  -- Lines
  (perp_A_BC prll_D_BC tang_P_ω : AffineSubspace ℝ Pt)
  -- Let ABC be an acute-angled triangle
  (h_ABC : AffineIndependent ℝ ![A, B, C])
  (h_acute_ABC : (⟨![A, B, C], h_ABC⟩ :Affine.Triangle _ _).AcuteAngled)
  -- with AB < AC.
  (h_AB_lt_BC : dist A B < dist A C)
  -- Let Ω be the circumcircle of ABC.
  (h_Ω : {A, B, C} ⊆ (Ω : Set Pt))
  -- Let S be the midpoint of the arc CB of Ω
  (h_S_Ω : dist S C = dist S B ∧ S ∈ (Ω : Set Pt))
  -- ... containing A.
  (h_S_A : (∡ C B S).sign = (∡ C B A).sign)
  -- The perpendicular from A to BC ...
  (h_perp_A_BC : perp_A_BC.direction ⟂ line[ℝ, B, C].direction ∧ A ∈ perp_A_BC)
  -- ... meets BS at D
  (h_D : D ∈ (perp_A_BC : Set Pt) ∩ line[ℝ, B, S])
  -- ... and meets Ω again at E ...
  (h_E : E ∈ (perp_A_BC : Set Pt) ∩ Ω)
  -- ... E ≠ A.
  (h_E_ne_A : E ≠ A)
  -- The line through D parallel to BC ...
  (h_prll_D_BC : D ∈ prll_D_BC ∧ prll_D_BC ∥ line[ℝ, B, C])
  --- ... meets line BE at L.
  (h_L : L ∈ (prll_D_BC : Set Pt) ∩ line[ℝ, B, E])
  -- Denote the circumcircle of triangle BDL by ω.
  (h_ω : {B, D, L} ⊆ (ω : Set Pt))
  -- Let ω meet Ω again at P ...
  (h_P : P ∈ (ω : Set Pt) ∩ Ω)
  -- P ≠ B.
  (h_P_ne_B : P ≠ B)
  -- Prove that the line tangent to ω at P ...
  (h_rank_tang_P_ω : Module.finrank ℝ tang_P_ω.direction = 1)
  (h_tang_P_ω : Sphere.IsTangentAt ω P tang_P_ω) :
  -- meets line BS on the internal angle bisector of ∠BAC.
  ∃ X : Pt,
    X ∈ (tang_P_ω : Set Pt) ∩ line[ℝ, B, S]
    ∧ ∠ B A X = ∠ X A C
    ∧ ∠ B A X < π / 2 := by
  set cfg : Imo2023q2Cfg V Pt := ⟨
    A, B, C, D, E, L, S, P,
    Ω, ω,
    perp_A_BC, prll_D_BC, tang_P_ω,
    h_ABC,
    h_acute_ABC,
    h_AB_lt_BC,
    h_Ω,
    h_S_Ω,
    h_S_A,
    h_perp_A_BC,
    h_D,
    h_E,
    h_E_ne_A,
    h_prll_D_BC,
    h_L,
    h_ω,
    h_P,
    h_P_ne_B,
    h_rank_tang_P_ω,
    h_tang_P_ω,
  ⟩
  exact cfg.result


end Imo2023P2

-- ═══ Imo2023P4 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# International Mathematical Olympiad 2023, Problem 4

Let x₁, x₂, ... x₂₀₂₃ be distinct positive real numbers.
Define

   aₙ := √((x₁ + x₂ + ... + xₙ)(1/x₁ + 1/x₂ + ... + 1/xₙ)).

Suppose that aₙ is an integer for all n ∈ {1,...,2023}.
Prove that 3034 ≤ a₂₀₂₃.
-/

namespace Imo2023P4

noncomputable def a (x : Finset.Icc 1 2023 → ℝ) (n : Finset.Icc 1 2023) : ℝ :=
  √((∑ i ∈ Finset.univ.filter (· ≤ n), x i) *
    (∑ i ∈ Finset.univ.filter (· ≤ n), (1 / x i)))



noncomputable def aa (m : ℕ)
    (x : Finset.Icc 1 (2 * m + 1) → ℝ) (n : Finset.Icc 1 (2 * m + 1)) : ℝ :=
  √((∑ i ∈ Finset.univ.filter (· ≤ n), x i) *
    (∑ i ∈ Finset.univ.filter (· ≤ n), (1 / x i)))

lemma cauchy_schwarz {x1 x2 x3 y1 y2 y3 : ℝ}
    (hx1 : 0 ≤ x1) (hx2 : 0 ≤ x2) (hx3 : 0 ≤ x3)
    (hy1 : 0 ≤ y1) (hy2 : 0 ≤ y2) (hy3 : 0 ≤ y3) :
    (√(x1 * y1) + √(x2 * y2) + √(x3 * y3))^2 ≤
      (x1 + x2 + x3) * (y1 + y2 + y3) := by
  let f : Fin 3 → ℝ
      | 0 => √x1
      | 1 => √x2
      | 2 => √x3

  let g : Fin 3 → ℝ
      | 0 => √y1
      | 1 => √y2
      | 2 => √y3

  have h1 := Real.sum_mul_le_sqrt_mul_sqrt Finset.univ f g
  simp only [f, g, Fin.sum_univ_three] at h1
  have h2 : 0 ≤ √(x1 *y1) + √(x2 * y2) + √(x3 * y3) := by positivity
  rw [Real.sq_sqrt hx1] at h1
  rw [Real.sq_sqrt hx2] at h1
  rw [Real.sq_sqrt hx3] at h1
  rw [Real.sq_sqrt hy1] at h1
  rw [Real.sq_sqrt hy2] at h1
  rw [Real.sq_sqrt hy3] at h1
  rw [←Real.sqrt_mul (show 0 ≤ x1 + x2 + x3 by positivity)] at h1
  rw [←Real.sqrt_mul hx1] at h1
  rw [←Real.sqrt_mul hx2] at h1
  rw [←Real.sqrt_mul hx3] at h1
  have h4 : (√((x1 + x2 + x3) * (y1 + y2 + y3)))^2 = (x1 + x2 + x3) * (y1 + y2 + y3) := by
    refine Real.sq_sqrt ?_
    positivity
  rw [←h4]
  exact pow_le_pow_left₀ h2 h1 2

lemma lemma1 (u : ℝ) (hu : u ≠ 1) (hp : 0 < u) : 2 < u + 1/u := by
  suffices H : 2 * u < (u + 1 / u) * u from
    (mul_lt_mul_iff_of_pos_right hp).mp H
  field_simp
  have h1 : u - 1 ≠ 0 := sub_ne_zero_of_ne hu
  have h2 : 0 < (u - 1)^2 := pow_two_pos_of_ne_zero h1
  linear_combination h2

theorem imo2023_p4_generalized
    (m : ℕ)
    (x : Finset.Icc 1 (2 * m + 1) → ℝ)
    (hxp : ∀ i, 0 < x i)
    (hxi : x.Injective)
    (hxa : ∀ i : Finset.Icc 1 (2 * m + 1), ∃ k : ℤ, aa m x i = k)
    : 3 * m + 1 ≤ aa m x ⟨2 * m + 1, by simp⟩ := by
  -- We follow the "induct-by-two" solution from
  -- https://web.evanchen.cc/exams/IMO-2023-notes.pdf
  induction m with
  | zero =>
    simp only [CharP.cast_eq_zero, mul_zero, zero_add, aa, Nat.mul_zero, Nat.reduceAdd,
               one_div, Real.one_le_sqrt]
    have h1 : Finset.filter (fun x ↦ x ≤ ⟨1, by simp⟩)
                            (Finset.univ (α := {x //x ∈ Finset.Icc 1 1}))
           = Finset.univ (α := {x // x ∈ Finset.Icc 1 1}) := by
      refine Finset.filter_true_of_mem ?h
      intro x hx
      obtain ⟨x, hx1⟩ := x
      rw [Finset.mem_Icc] at hx1
      obtain ⟨hx2, hx3⟩ := hx1
      exact Subtype.mk_le_mk.mpr hx3
    rw [h1]
    have h2 : Finset.univ (α := { x // x ∈ Finset.Icc 1 1 }) = { ⟨1, by simp⟩ } := by decide
    simp only [h2, Finset.sum_singleton, ge_iff_le]
    simp only [Nat.mul_zero, Nat.reduceAdd, Subtype.forall, Finset.Icc_self,
               Finset.mem_singleton] at hxp
    specialize hxp 1 (by simp)
    field_simp
    norm_num
  | succ m ih =>
    let n := 2 * m + 1
    have hn1 : n + 1 ∈ Finset.Icc 1 (2 * (m + 1) + 1) := by
      simp only [Finset.mem_Icc, le_add_iff_nonneg_left, zero_le,
                 add_le_add_iff_right, true_and, n]
      lia
    have hn2 : n + 2 ∈ Finset.Icc 1 (2 * (m + 1) + 1) := by
      simp only [Finset.mem_Icc, le_add_iff_nonneg_left, zero_le,
                 true_and, n]
      lia

    let u := √(x ⟨n + 1, hn1⟩ / x ⟨n + 2, hn2⟩)
    have hu : u ≠ 1 := by
      unfold u n
      intro hu
      rw [Real.sqrt_eq_one] at hu
      rw [(div_eq_one_iff_eq (ne_of_lt (hxp _)).symm)] at hu
      replace hu := hxi hu
      simp at hu
    have h1 : (aa (m + 1) x ⟨n + 2, hn2⟩)^2 =
       (√((∑ i ∈ Finset.univ.filter (· ≤ ⟨n + 2, hn2⟩), x i) *
        (∑ i ∈ Finset.univ.filter (· ≤ ⟨n + 2, hn2⟩), (1 / x i))))^2 := by
      unfold aa; rfl
    have h2 : 0 ≤ (∑ i ∈ Finset.univ.filter (· ≤ ⟨n + 2, hn2⟩), x i) *
        (∑ i ∈ Finset.univ.filter (· ≤ ⟨n + 2, hn2⟩), (1 / x i)) := by
      have h3 :
          0 ≤ ∑ i ∈ Finset.filter
                     (fun x ↦ x ≤ ⟨n + 2, hn2⟩) Finset.univ, x i := by
        refine Finset.sum_nonneg ?_
        intro i hi
        specialize hxp i
        exact le_of_lt hxp
      have h4 :
          0 ≤ ∑ i ∈ Finset.filter
                     (fun x ↦ x ≤ ⟨n + 2, hn2⟩) Finset.univ, 1 / x i := by
        refine Finset.sum_nonneg ?_
        intro i hi
        specialize hxp i
        positivity
      exact Left.mul_nonneg h3 h4
    rw [Real.sq_sqrt h2] at h1; clear h2
    have h5 : ⟨n + 2, hn2⟩ ∉
         Finset.filter (fun x ↦ x ≤ ⟨n + 1, hn1⟩)
            Finset.univ (α := Finset.Icc 1 (n + 2)) := by
      intro H
      simp_all only [Subtype.forall, Finset.mem_Icc, ne_eq, Real.sqrt_eq_one,
                     Finset.univ_eq_attach, one_div, Finset.mem_filter,
                     Finset.mem_attach, Subtype.mk_le_mk, add_le_add_iff_left,
                     Nat.not_ofNat_le_one, and_false, u, n]
    have h6 : Finset.filter (fun x ↦ x ≤ ⟨n + 2, hn2⟩)
                Finset.univ (α := Finset.Icc 1 (2 * (m + 1) + 1)) =
              Finset.cons _ (Finset.filter (fun x ↦ x ≤ ⟨n + 1, hn1⟩)
                 Finset.univ (α := Finset.Icc 1 (2 * (m + 1) + 1))) h5 := by
      clear ih
      ext y
      constructor
      · intro hy
        simp only [Finset.univ_eq_attach, Finset.mem_filter,
                   Finset.mem_attach, true_and] at hy
        simp only [Finset.univ_eq_attach, Finset.cons_eq_insert,
                   Finset.mem_insert, Finset.mem_filter,
                   Finset.mem_attach, true_and]
        obtain ⟨y, hy'⟩ := y
        simp only [Subtype.mk_le_mk] at hy
        simp only [Subtype.mk.injEq, Subtype.mk_le_mk]
        lia
      · intro hy
        simp only [Finset.univ_eq_attach, Finset.cons_eq_insert,
                   Finset.mem_insert, Finset.mem_filter,
                   Finset.mem_attach, true_and] at hy
        obtain ⟨y, hy'⟩ := y
        simp only [Subtype.mk.injEq, Subtype.mk_le_mk] at hy
        simp only [Finset.univ_eq_attach, Finset.mem_filter, Finset.mem_attach,
                   Subtype.mk_le_mk, true_and]
        lia
    simp only [h6] at h1
    simp only [Finset.cons_eq_insert, Finset.mem_filter,
               Subtype.mk_le_mk, add_le_add_iff_left,
               Nat.not_ofNat_le_one, and_false, not_false_eq_true,
               Finset.sum_insert, one_div] at h1

    have h7 : ⟨n + 1, hn1⟩ ∉
         Finset.filter (fun x ↦ x ≤ ⟨n, by simp [n]⟩)
            Finset.univ (α := Finset.Icc 1 (n + 2)) := by
      intro H
      simp_all only [Subtype.forall, Finset.mem_Icc, ne_eq, Real.sqrt_eq_one,
                     Finset.univ_eq_attach, Finset.cons_eq_insert,
                     Finset.mem_filter, Finset.mem_attach, Subtype.mk_le_mk,
                     add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero,
                     and_false, u, n]

    have h8 : Finset.filter (fun x ↦ x ≤ ⟨n + 1, hn1⟩)
                Finset.univ (α := Finset.Icc 1 (2 * (m + 1) + 1)) =
              Finset.cons _ (Finset.filter (fun x ↦ x ≤ ⟨n, by simp[n]⟩)
                 Finset.univ (α := Finset.Icc 1 (2 * (m + 1) + 1))) h7 := by
      clear ih
      ext y
      constructor
      · intro hy
        simp only [Finset.univ_eq_attach, Finset.mem_filter,
                   Finset.mem_attach, true_and] at hy
        simp only [Finset.univ_eq_attach, Finset.cons_eq_insert,
                   Finset.mem_insert, Finset.mem_filter,
                   Finset.mem_attach, true_and]
        obtain ⟨y, hy'⟩ := y
        simp only [Subtype.mk_le_mk] at hy
        simp only [Subtype.mk.injEq, Subtype.mk_le_mk]
        lia
      · intro hy
        simp only [Finset.univ_eq_attach, Finset.cons_eq_insert,
                   Finset.mem_insert, Finset.mem_filter,
                   Finset.mem_attach, true_and] at hy
        obtain ⟨y, hy'⟩ := y
        simp only [Subtype.mk.injEq, Subtype.mk_le_mk] at hy
        simp only [Finset.univ_eq_attach, Finset.mem_filter, Finset.mem_attach,
                   Subtype.mk_le_mk, true_and]
        lia

    simp only [h8] at h1
    clear h6 h8
    simp only [Finset.cons_eq_insert, Finset.mem_filter,
               Subtype.mk_le_mk, add_le_iff_nonpos_right,
               nonpos_iff_eq_zero, one_ne_zero, and_false, not_false_eq_true,
               Finset.sum_insert] at h1
    rw [←add_assoc, add_comm (x ⟨n + 2, hn2⟩)] at h1
    rw [←add_assoc] at h1
    have hx1 : 0 ≤ x ⟨n + 1, hn1⟩ := le_of_lt (hxp ⟨n + 1, hn1⟩)
    have hx2 : 0 ≤ x ⟨n + 2, hn2⟩ := le_of_lt (hxp ⟨n + 2, hn2⟩)
    have hx3 : 0 ≤ ∑ x_1 ∈ Finset.filter
                    (fun x ↦ x ≤ ⟨n, by simp[n]⟩)
                    Finset.univ, x x_1 := by
      refine Finset.sum_nonneg ?_
      rintro y -
      exact le_of_lt (hxp y)
    have hy1 : 0 ≤ (x ⟨n + 2, hn2⟩)⁻¹ := inv_nonneg_of_nonneg hx2
    have hy2 : 0 ≤ (x ⟨n + 1, hn1⟩)⁻¹ := inv_nonneg_of_nonneg hx1
    have hy3 : 0 ≤ ∑ x_1 ∈ Finset.filter (fun x ↦ x ≤ ⟨n, by simp[n]⟩) Finset.univ, (x x_1)⁻¹ := by
      refine Finset.sum_nonneg ?_
      rintro y hy
      simp only [Finset.mem_filter] at hy
      specialize hxp y
      positivity

    have h9 := cauchy_schwarz hx1 hx2 hx3 hy1 hy2 hy3
    clear hx1 hx2 hx3 hy1 hy2 hy3
    rw [←h1] at h9; clear h1
    let x' : { a // a ∈ Finset.Icc 1 (2 * m + 1) } → ℝ :=
      fun ⟨z, hz⟩ ↦ x ⟨z, by simp only [Finset.mem_Icc] at hz ⊢; lia⟩
    let e : { x // x ∈ Finset.Icc 1 (2 * m + 1) } →
            { x // x ∈ Finset.Icc 1 (2 * (m + 1) + 1) }
      | ⟨y, hy⟩ => ⟨y, by simp only [Finset.mem_Icc] at hy ⊢; lia⟩
    have hei : Function.Injective e := by
      intro a b hab
      simp only [e, Subtype.mk.injEq] at hab
      exact Subtype.ext hab
    have h20 {y : ℕ} (hy : y ∈ Finset.Icc 1 (2 * m + 1)) :
        Finset.map ⟨e, hei⟩ (Finset.filter (fun x ↦ x ≤ ⟨y, hy⟩) Finset.univ) =
          Finset.filter
           (fun x ↦ x ≤ ⟨y, by simp only [Finset.mem_Icc] at hy ⊢; lia⟩)
             Finset.univ := by
      ext a
      constructor
      · intro ha
        simp only [Finset.univ_eq_attach, Finset.mem_map, Finset.mem_filter,
                   Finset.mem_attach, true_and, Function.Embedding.coeFn_mk,
                   Subtype.exists, Subtype.mk_le_mk, Finset.mem_Icc,
                   exists_and_left] at ha
        simp only [Finset.univ_eq_attach, Finset.mem_filter, Finset.mem_attach,
                   true_and]
        obtain ⟨aa, haa, haa2, haa3⟩ := ha
        simp only [e] at haa3
        rw [← haa3, Subtype.mk_le_mk]
        exact haa
      · intro ha
        simp only [Finset.univ_eq_attach, Finset.mem_filter, Finset.mem_attach,
                   true_and] at ha
        simp only [Finset.univ_eq_attach, Finset.mem_map, Finset.mem_filter,
                   Finset.mem_attach, true_and, Function.Embedding.coeFn_mk,
                   Subtype.exists, Subtype.mk_le_mk, Finset.mem_Icc,
                   exists_and_left]
        use a
        obtain ⟨a, haa⟩ := a
        simp only [Finset.mem_Icc] at haa hy
        simp only [Subtype.mk_le_mk] at ha
        simp only [exists_prop, and_true, e]
        lia

    have h10 : √((∑ x_1 ∈ Finset.filter
                  (fun x ↦ x ≤ ⟨n, by simp [n]⟩) Finset.univ, x x_1) *
            ∑ x_1 ∈ Finset.filter (fun x ↦ x ≤ ⟨n, by simp[n]⟩) Finset.univ, (x x_1)⁻¹) = aa m x' ⟨n, by simp[n]⟩ := by
      clear h9 h5 h7
      have hn : n ∈ Finset.Icc 1 (2 * m + 1) := by
        simp only [Finset.mem_Icc, le_refl, and_true, n]
        exact Nat.le_add_left 1 (2 * m)
      unfold aa
      congr 2
      · rw [←h20 hn, Finset.sum_map]
        rfl
      · rw [←h20 hn, Finset.sum_map]
        apply Finset.sum_congr rfl
        intro ii hii
        simp [x', e]
    rw [h10] at h9; clear h10
    have hxp' : ∀ (i : { x // x ∈ Finset.Icc 1 (2 * m + 1) }), 0 < x' i := by
      rintro ⟨y, hy⟩
      simp only [x']
      have hy' : y ∈ Finset.Icc 1 (2 * (m + 1) + 1) := by
        simp only [Finset.mem_Icc] at hy ⊢
        lia
      exact hxp ⟨y, hy'⟩
    have hxi' : Function.Injective x' := by
      intro a b hab
      simp only [x'] at hab
      specialize hxi hab
      simp only [Subtype.mk.injEq] at hxi
      exact Subtype.ext hxi
    have hxa' : ∀ (i : { x // x ∈ Finset.Icc 1 (2 * m + 1) }),
                    ∃ k : ℤ, aa m x' i = ↑k := by
      rintro ⟨y, hy⟩
      have hy' : y ∈ Finset.Icc 1 (2 * (m + 1) + 1) := by
        simp only [Finset.mem_Icc] at hy ⊢
        lia
      specialize hxa ⟨y, hy'⟩
      obtain ⟨k, hk⟩ := hxa
      use k
      rw [←hk]
      clear h5 h7 h9
      unfold aa
      congr 2
      · rw [←h20 hy, Finset.sum_map]
        rfl
      · rw [←h20 hy, Finset.sum_map]
        rfl
    specialize ih x' hxp' hxi' hxa'
    have hup : 0 < u := by
      unfold u
      simp only [Real.sqrt_pos]
      exact div_pos (hxp ⟨n + 1, hn1⟩) (hxp ⟨n + 2, hn2⟩)
    have huu : 2 < u + 1/u := lemma1 u hu hup
    have h11 : √(x ⟨n + 1, hn1⟩ * (x ⟨n + 2, hn2⟩)⁻¹) +
               √(x ⟨n + 2, hn2⟩ * (x ⟨n + 1, hn1⟩)⁻¹) = u + 1 / u := by
      congr 1
      suffices H: √(x ⟨n + 2, hn2⟩ * (x ⟨n + 1, hn1⟩)⁻¹)  * u = 1 from
        eq_one_div_of_mul_eq_one_left H
      unfold u
      have hp1 : 0 < x ⟨n + 1, hn1⟩ := hxp ⟨n + 1, hn1⟩
      have hp2 : 0 < x ⟨n + 2, hn2⟩ := hxp ⟨n + 2, hn2⟩
      rw [←Real.sqrt_mul (by positivity)]
      field_simp
      norm_num
    rw [h11] at h9; clear h11
    replace h9 : aa m x' ⟨n, by simp[n]⟩ + 2 < aa (m + 1) x ⟨n + 2, hn2⟩ := by
      have h9' : u + 1/u + aa m x' ⟨n, by simp[n]⟩ ≤
          aa (m + 1) x ⟨n + 2, hn2⟩ := by
        have h12 : 0 ≤ aa (m + 1) x ⟨n + 2, hn2⟩ := by
          unfold aa
          exact Real.sqrt_nonneg _
        exact le_of_sq_le_sq h9 h12
      linarith
    simp_rw [show 2 * m + 1 = n from rfl] at ih
    replace h9 : 3 * ↑m + 3 < aa (m + 1) x ⟨n+ 2, hn2⟩ := by linarith
    simp_rw [show n + 2 = 2 * (m + 1) + 1 from rfl] at h9
    specialize hxa ⟨2 * (m + 1) + 1, hn2⟩
    obtain ⟨k, hk⟩ := hxa
    rw [hk] at h9 ⊢
    norm_cast at h9 ⊢



theorem imo2023_p4
    (x : Finset.Icc 1 2023 → ℝ)
    (hxp : ∀ i, 0 < x i)
    (hxi : x.Injective)
    (hxa : ∀ i : Finset.Icc 1 2023, ∃ k : ℤ, a x i = k)
    : 3034 ≤ a x ⟨2023, by simp⟩ := by
  have := imo2023_p4_generalized 1011 x hxp hxi hxa
  convert this
  norm_num

end Imo2023P4

-- ═══ Imo2024P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/





/-!
# International Mathematical Olympiad 2024, Problem 1

Determine all real numbers α such that, for every positive integer n, the
integer

     ⌊α⌋ + ⌊2α⌋ + ... + ⌊nα⌋

is a multiple of n.
-/

namespace Imo2024P1



def Condition (α : ℝ) : Prop := ∀ n : ℕ, 0 < n → (n : ℤ) ∣ ∑ i ∈ Finset.Icc 1 n, ⌊i * α⌋

lemma condition_two_mul_int (m : ℤ) : Condition (2 * m) := by
  rintro n -
  suffices (n : ℤ) ∣ ∑ i ∈ Finset.Icc 0 n, ⌊((i * (2 * m) : ℤ) : ℝ)⌋ by
    rw [← Finset.insert_Icc_succ_left_eq_Icc n.zero_le, Finset.sum_insert_zero (by norm_num)] at this
    exact_mod_cast this
  simp_rw [Int.floor_intCast, ← Finset.sum_mul, ← Finset.Ico_succ_right_eq_Icc, ← Finset.range_eq_Ico,
           ← mul_assoc]
  refine dvd_mul_of_dvd_left ?_ _
  rw [← Nat.cast_sum, ← Nat.cast_ofNat (n := 2), ← Nat.cast_mul, Finset.sum_range_id_mul_two]
  simp

lemma condition_sub_two_mul_int_iff {α : ℝ} (m : ℤ) : Condition (α - 2 * m) ↔ Condition α := by
  unfold Condition
  peel with n hn
  refine dvd_iff_dvd_of_dvd_sub ?_
  simp_rw [← Finset.sum_sub_distrib, mul_sub]
  norm_cast
  simp_rw [Int.floor_sub_intCast, sub_sub_cancel_left]
  convert condition_two_mul_int (-m) n hn
  norm_cast
  rw [Int.floor_intCast]
  simp

lemma condition_toIcoMod_iff {α : ℝ} :
    Condition (toIcoMod (by norm_num : (0 : ℝ) < 2) 0 α) ↔ Condition α := by
  rw [toIcoMod, zsmul_eq_mul, mul_comm, condition_sub_two_mul_int_iff]


namespace Condition

variable {α : ℝ} (hc : Condition α)

include hc in
lemma mem_Ico_one_of_mem_Ioo (h : α ∈ Set.Ioo 0 2) : α ∈ Set.Ico 1 2 := by
  rcases h with ⟨h0, h2⟩
  refine ⟨?_, h2⟩
  by_contra! hn
  have hr : 1 < ⌈α⁻¹⌉₊ := by
    rw [Nat.lt_ceil]
    exact_mod_cast (one_lt_inv₀ h0).2 hn
  replace hc := hc ⌈α⁻¹⌉₊ (zero_lt_one.trans hr)
  refine hr.ne' ?_
  suffices ⌈α⁻¹⌉₊ = (1 : ℤ) from mod_cast this
  refine Int.eq_one_of_dvd_one (Int.zero_le_ofNat _) ?_
  convert hc
  rw [← Finset.add_sum_Ico_eq_sum_Icc hr.le]
  convert (add_zero _).symm
  · rw [Int.floor_eq_iff]
    refine ⟨?_, ?_⟩
    · rw [Int.cast_one]
      calc 1 ≤ α⁻¹ * α := by simp [h0.ne']
        _ ≤ ⌈α⁻¹⌉₊ * α := by gcongr; exact Nat.le_ceil _
    · calc ⌈α⁻¹⌉₊ * α < (α⁻¹ + 1) * α := by gcongr; exact Nat.ceil_lt_add_one (inv_nonneg.2 h0.le)
        _ = 1 + α := by field_simp [h0.ne']
        _ ≤ (1 : ℕ) + 1 := by gcongr; norm_cast
  · refine Finset.sum_eq_zero ?_
    intro x hx
    rw [Int.floor_eq_zero_iff]
    refine ⟨by positivity, ?_⟩
    rw [Finset.mem_Ico, Nat.lt_ceil] at hx
    calc x * α < α⁻¹ * α := by gcongr; exact hx.2
      _ ≤ 1 := by simp [h0.ne']

include hc in
lemma mem_Ico_n_of_mem_Ioo (h : α ∈ Set.Ioo 0 2)
    {n : ℕ} (hn : 0 < n) : α ∈ Set.Ico ((2 * n - 1) / n : ℝ) 2 := by
  suffices ∑ i ∈ Finset.Icc 1 n, ⌊i * α⌋ = n ^ 2 ∧ α ∈ Set.Ico ((2 * n - 1) / n : ℝ) 2 from this.2
  induction' n, hn using Nat.le_induction with k kpos hk
  · obtain ⟨h1, h2⟩ := hc.mem_Ico_one_of_mem_Ioo h
    simp only [Finset.Icc_self, Finset.sum_singleton, Nat.cast_one, one_mul, one_pow,
               Int.floor_eq_iff, Int.cast_one, mul_one, div_one, Set.mem_Ico, tsub_le_iff_right]
    lia
  · rcases hk with ⟨hks, hkl, hk2⟩
    have hs : (∑ i ∈ Finset.Icc 1 (k + 1), ⌊i * α⌋) =
         ⌊(k + 1 : ℕ) * α⌋ + ((k : ℕ) : ℤ) ^ 2 := by
      have hn11 : k + 1 ∉ Finset.Icc 1 k := by
        rw [Finset.mem_Icc]
        lia
      rw [← Finset.insert_Icc_right_eq_Icc_add_one (Nat.le_add_left 1 k), Finset.sum_insert hn11, hks]
    replace hc := hc (k + 1) k.succ_pos
    rw [hs] at hc ⊢
    have hkl' : 2 * k ≤ ⌊(k + 1 : ℕ) * α⌋ := by
      rw [Int.le_floor]
      calc ((2 * k : ℤ) : ℝ) = ((2 * k : ℤ) : ℝ) + 0 := (add_zero _).symm
        _ ≤ ((2 * k : ℤ) : ℝ) + (k - 1) / k := by gcongr; norm_cast; positivity
        _ = (k + 1 : ℕ) * ((2 * (k : ℕ) - 1) / ((k : ℕ) : ℝ) : ℝ) := by
          push_cast
          field_simp
          ring
        _ ≤ (k + 1 : ℕ) * α := by gcongr
    have hk2' : ⌊(k + 1 : ℕ) * α⌋ < (k + 1 : ℕ) * 2 := by
      rw [Int.floor_lt]
      push_cast
      gcongr
    have hk : ⌊(k + 1 : ℕ) * α⌋ = 2 * k  ∨ ⌊(k + 1 : ℕ) * α⌋ = 2 * k + 1 := by lia
    have hk' : ⌊(k + 1 : ℕ) * α⌋ = 2 * k + 1 := by
      rcases hk with hk | hk
      · rw [hk] at hc
        have hc' : ((k + 1 : ℕ) : ℤ) ∣ ((k + 1 : ℕ) : ℤ) * ((k + 1 : ℕ) : ℤ) - 1 := by
          convert hc using 1
          push_cast
          ring
        rw [dvd_sub_right (dvd_mul_right _ _), ← isUnit_iff_dvd_one, Int.isUnit_iff] at hc'
        lia
      · exact hk
    rw [hk']
    refine ⟨?_, ?_, h.2⟩
    · push_cast
      ring
    · rw [Int.floor_eq_iff] at hk'
      rw [div_le_iff₀ (by norm_cast; lia), mul_comm α]
      convert hk'.1
      push_cast
      ring

end Condition

lemma not_condition_of_mem_Ioo {α : ℝ} (h : α ∈ Set.Ioo 0 2) : ¬Condition α := by
  intro hc
  let n : ℕ := ⌊(2 - α)⁻¹⌋₊ + 1
  have hn : 0 < n := by lia
  have hna := (hc.mem_Ico_n_of_mem_Ioo h hn).1
  rcases h with ⟨-, h2⟩
  have hna' : 2 - (n : ℝ)⁻¹ ≤ α := by
    convert hna using 1
    field_simp
  rw [sub_eq_add_neg, ← le_sub_iff_add_le', neg_le, neg_sub] at hna'
  rw [le_inv_comm₀ (by linarith) (mod_cast hn), ← not_lt] at hna'
  apply hna'
  exact_mod_cast Nat.lt_floor_add_one (_ : ℝ)

lemma condition_iff_of_mem_Ico {α : ℝ} (h : α ∈ Set.Ico 0 2) : Condition α ↔ α = 0 := by
  refine ⟨?_, ?_⟩
  · intro hc
    rcases Set.eq_left_or_mem_Ioo_of_mem_Ico h with rfl | ho
    · rfl
    · exact False.elim (not_condition_of_mem_Ioo ho hc)
  · rintro rfl
    convert condition_two_mul_int 0
    norm_num



noncomputable def solutionSet : Set ℝ := {α : ℝ | ∃ m : ℤ, α = 2 * m}

theorem imo2024_p1 (α : ℝ) :
  α ∈ solutionSet ↔
  ∀ n : ℕ, 0 < n → (n : ℤ) ∣ ∑ i ∈ Finset.Icc 1 n, ⌊i * α⌋ := by
  refine ⟨?_, fun h ↦ ?_⟩
  · rintro ⟨m, rfl⟩
    exact condition_two_mul_int m
  · change Condition α at h
    rw [← condition_toIcoMod_iff, condition_iff_of_mem_Ico (toIcoMod_mem_Ico' _ _),
        ← AddCommGroup.modEq_iff_toIcoMod_eq_left, AddCommGroup.modEq_iff_zsmul'] at h
    simp_rw [sub_zero] at h
    rcases h with ⟨m, rfl⟩
    rw [zsmul_eq_mul, mul_comm]
    simp [solutionSet]

end Imo2024P1

-- ═══ Imo2024P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/





/-!
# International Mathematical Olympiad 2024, Problem 2

Determine all pairs (a,b) of positive integers for which there exist positive integers
g and N such that

   gcd(aⁿ + b, bⁿ + a),   n = 1, 2, ...

holds for all integers n ≥ N.
-/

namespace Imo2024P2



/-
We consider the sequence modulo `ab+1`; if the exponent is `-1` modulo `φ(ab+1)`, the terms
are zero modulo `ab+1`, so `ab+1` divides `g`, and all sufficiently large terms, so all terms,
from which we conclude that `a=b=1`.
-/

open scoped Nat

/-- The condition of the problem. -/
def Condition (a b : ℕ) : Prop :=
  0 < a ∧ 0 < b ∧ ∃ g N : ℕ, 0 < g ∧ 0 < N ∧ ∀ n : ℕ, N ≤ n → Nat.gcd (a ^ n + b) (b ^ n + a) = g

lemma dvd_pow_iff_of_dvd_sub {a b d n : ℕ} {z : ℤ} (ha : a.Coprime d)
    (hd : (φ d : ℤ) ∣ (n : ℤ) - z) :
    d ∣ a ^ n + b ↔ (((ZMod.unitOfCoprime _ ha) ^ z : (ZMod d)ˣ) : ZMod d) + b = 0 := by
  obtain ⟨k, hk⟩ := hd
  rw [show z = n + (-k) * φ d by lia]
  rw [zpow_add, zpow_mul', ←ZMod.natCast_eq_zero_iff]
  simp

namespace Condition

variable {a b : ℕ} (h : Condition a b)

section
include h

lemma a_pos : 0 < a := h.1

lemma b_pos : 0 < b := h.2.1

/-- The value of `g` in the problem (determined by `a` and `b`). -/
noncomputable def g : ℕ := h.2.2.choose

lemma g_spec : ∃ N : ℕ, 0 < h.g ∧ 0 < N ∧ ∀ n : ℕ, N ≤ n → Nat.gcd (a ^ n + b) (b ^ n + a) = h.g :=
  h.2.2.choose_spec

/-- The value of `N` in the problem (any sufficiently large value). -/
noncomputable def N : ℕ := h.g_spec.choose

lemma N_spec : 0 < h.g ∧ 0 < h.N ∧ ∀ n : ℕ, h.N ≤ n → Nat.gcd (a ^ n + b) (b ^ n + a) = h.g :=
  h.g_spec.choose_spec

lemma g_pos : 0 < h.g := h.N_spec.1

lemma N_pos : 0 < h.N := h.N_spec.2.1

lemma gcd_eq_g {n : ℕ} (hn : h.N ≤ n) : Nat.gcd (a ^ n + b) (b ^ n + a) = h.g := h.N_spec.2.2 n hn

protected lemma symm : Condition b a := by
  refine ⟨h.b_pos, h.a_pos, h.g, h.N, h.g_pos, h.N_pos, fun n hn ↦ ?_⟩
  rw [Nat.gcd_comm]
  exact h.gcd_eq_g hn

lemma dvd_g_of_le_N_of_dvd {n : ℕ} (hn : h.N ≤ n) {d : ℕ} (hab : d ∣ a ^ n + b)
    (hba : d ∣ b ^ n + a) : d ∣ h.g := by
  rw [← h.gcd_eq_g hn, Nat.dvd_gcd_iff]
  exact ⟨hab, hba⟩

end

lemma a_coprime_ab_add_one : a.Coprime (a * b + 1) := by
  simp

/-- A sufficiently large value of n, congruent to `-1` mod `φ (a * b + 1)`. -/
noncomputable def large_n : ℕ := (max h.N h.symm.N + 1) * φ (a * b + 1) - 1

lemma symm_large_n : h.symm.large_n = h.large_n := by
  simp_rw [large_n]
  congr 2
  · rw [max_comm]
  · rw [mul_comm]

lemma N_le_large_n : h.N ≤ h.large_n := by
  have hp : 0 < φ (a * b + 1) := Nat.totient_pos.2 (Nat.add_pos_right _ zero_lt_one)
  rw [large_n, add_mul, one_mul, Nat.add_sub_assoc (Nat.one_le_of_lt hp)]
  suffices h.N ≤ h.N * φ (a * b + 1) + (φ (a * b + 1) - 1) by
    refine this.trans ?_
    gcongr
    simp
  exact Nat.le_add_right_of_le (Nat.le_mul_of_pos_right _ hp)

lemma dvd_large_n_sub_neg_one : (φ (a * b + 1) : ℤ) ∣ (h.large_n : ℤ) - (-1 : ℤ) := by
  simp [large_n]

/-- A sufficiently large value of n, congruent to `0` mod `φ (a * b + 1)`. -/
noncomputable def large_n_0 : ℕ := (max h.N h.symm.N) * φ (a * b + 1)

lemma symm_large_n_0 : h.symm.large_n_0 = h.large_n_0 := by
  simp_rw [large_n_0]
  congr 1
  · rw [max_comm]
  · rw [mul_comm]

lemma N_le_large_n_0 : h.N ≤ h.large_n_0 := by
  have hp : 0 < φ (a * b + 1) := Nat.totient_pos.2 (Nat.add_pos_right _ zero_lt_one)
  rw [large_n_0]
  suffices h.N ≤ h.N * φ (a * b + 1) by
    refine this.trans ?_
    gcongr
    simp
  exact Nat.le_mul_of_pos_right _ hp

lemma dvd_large_n_0_sub_zero : (φ (a * b + 1) : ℤ) ∣ (h.large_n_0 : ℤ) - (0 : ℤ) := by
  simp [large_n_0]

lemma ab_add_one_dvd_a_pow_large_n_add_b : a * b + 1 ∣ a ^ h.large_n + b := by
  rw [dvd_pow_iff_of_dvd_sub a_coprime_ab_add_one h.dvd_large_n_sub_neg_one, zpow_neg, zpow_one]
  suffices ((ZMod.unitOfCoprime _ a_coprime_ab_add_one : (ZMod (a * b + 1))ˣ) : ZMod (a * b + 1)) *
    ((((ZMod.unitOfCoprime _ a_coprime_ab_add_one)⁻¹ : (ZMod (a * b + 1))ˣ) :
      ZMod (a * b + 1)) + (b : ZMod (a * b + 1))) = 0 from
      (IsUnit.mul_right_eq_zero (ZMod.unitOfCoprime _ a_coprime_ab_add_one).isUnit).1 this
  rw [mul_add]
  norm_cast
  simp only [mul_inv_cancel, Units.val_one, ZMod.coe_unitOfCoprime]
  norm_cast
  convert ZMod.natCast_self (a * b + 1) using 2
  exact add_comm _ _

lemma ab_add_one_dvd_b_pow_large_n_add_a : a * b + 1 ∣ b ^ h.large_n + a := by
  convert h.symm.ab_add_one_dvd_a_pow_large_n_add_b using 1
  · rw [mul_comm]
  · rw [h.symm_large_n]

lemma ab_add_one_dvd_g : a * b + 1 ∣ h.g :=
  h.dvd_g_of_le_N_of_dvd h.N_le_large_n h.ab_add_one_dvd_a_pow_large_n_add_b
    h.ab_add_one_dvd_b_pow_large_n_add_a

lemma ab_add_one_dvd_a_pow_large_n_0_add_b : a * b + 1 ∣ a ^ h.large_n_0 + b := by
  refine h.ab_add_one_dvd_g.trans ?_
  rw [← h.gcd_eq_g h.N_le_large_n_0]
  exact Nat.gcd_dvd_left _ _

include h

lemma ab_add_one_dvd_b_add_one : a * b + 1 ∣ b + 1 := by
  rw [add_comm b]
  suffices a * b + 1 ∣ a ^ h.large_n_0 + b by
    rw [dvd_pow_iff_of_dvd_sub a_coprime_ab_add_one h.dvd_large_n_0_sub_zero, zpow_zero] at this
    rw [← ZMod.natCast_eq_zero_iff]
    push_cast
    norm_cast at this
  exact h.ab_add_one_dvd_a_pow_large_n_0_add_b

lemma a_eq_one : a = 1 := by
  have hle : a * b + 1 ≤ b + 1 := Nat.le_of_dvd (by lia) h.ab_add_one_dvd_b_add_one
  rw [add_le_add_iff_right] at hle
  suffices a ≤ 1 by
    have hp := h.a_pos
    lia
  have hle' : a * b ≤ 1 * b := by
    simpa using hle
  exact Nat.le_of_mul_le_mul_right hle' h.b_pos

lemma b_eq_one : b = 1 := h.symm.a_eq_one

end Condition



noncomputable def solutionSet : Set (ℕ+ × ℕ+) := {(1, 1)}

theorem imo2024_p2 (a b : ℕ+) :
    (a, b) ∈ solutionSet ↔
    ∃ g N : ℕ+,
      ∀ n : ℕ, N ≤ n → Nat.gcd (a^n + b) (b^n + a) = g := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · simp only [solutionSet, Set.mem_singleton_iff, Prod.mk.injEq] at h
    rcases h with ⟨rfl, rfl⟩
    refine ⟨2, 1, ?_⟩
    simp
  · simp only [solutionSet, Set.mem_singleton_iff, Prod.mk.injEq]
    obtain ⟨a, ha⟩ := a
    obtain ⟨b, hb⟩ := b
    have hc : Condition a b := by
      refine ⟨ha, hb, ?_⟩
      obtain ⟨g, N, HCm⟩ := h
      use g, N
      refine ⟨g.pos, N.pos, ?_⟩
      exact fun n a ↦ HCm n a
    constructor
    · exact PNat.coe_eq_one_iff.mp (hc.a_eq_one)
    · exact PNat.coe_eq_one_iff.mp (hc.b_eq_one)

end Imo2024P2

-- ═══ Imo2024P3 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/





/-!
# International Mathematical Olympiad 2024, Problem 3

Let a₁, a₂, a₃, ... be an infinite sequence of positive integers,
and let N be a positive integer. Suppose that, for each n > N,
aₙ is equal to the number of times aₙ₋₁ appears in the list
a₁, a₂, ..., aₙ₋₁.

Prove that at least one of the sequences a₁, a₃, a₅, ... and
a₂, a₄, a₆, ... is eventually periodic.
-/

namespace Imo2024P3

open scoped Finset

def Condition (a : ℕ → ℕ) (N : ℕ) : Prop :=
  (∀ i, 0 < a i) ∧ ∀ n, N < n → a n = #{i ∈ Finset.range n | a i = a (n - 1)}

def EventuallyPeriodic (b : ℕ → ℕ) : Prop :=
  ∃ p M, 0 < p ∧ ∀ m, M ≤ m → b (m + p) = b m



/-! ### Definitions and lemmas about the sequence that do not actually need the condition of
the problem -/

/-- A number greater than any of the initial terms `a 0` through `a N` (otherwise arbitrary). -/
def M (a : ℕ → ℕ) (N : ℕ) : ℕ := (Finset.range (N + 1)).sup a + 1

lemma M_pos (a : ℕ → ℕ) (N : ℕ) : 0 < M a N :=
  Nat.add_one_pos _

lemma one_le_M (a : ℕ → ℕ) (N : ℕ) : 1 ≤ M a N :=
  Nat.lt_iff_add_one_le.1 (M_pos a N)

lemma apply_lt_M_of_le_N (a : ℕ → ℕ) {N i : ℕ} (h : i ≤ N) : a i < M a N :=
  Nat.lt_add_one_iff.2 (Finset.le_sup (Finset.mem_range_succ_iff.2 h))

lemma N_lt_of_M_le_apply {a : ℕ → ℕ} {N i : ℕ} (h : M a N ≤ a i) : N < i := by
  by_contra! hi
  exact Nat.not_succ_le_self _ (h.trans (Finset.le_sup (Finset.mem_range_succ_iff.2 hi)))

lemma ne_zero_of_M_le_apply {a : ℕ → ℕ} {N i : ℕ} (h : M a N ≤ a i) : i ≠ 0 :=
  Nat.ne_zero_of_lt (N_lt_of_M_le_apply h)

lemma apply_lt_of_M_le_apply {a : ℕ → ℕ} {N i j : ℕ} (hi : M a N ≤ a i) (hj : j ≤ N) :
    a j < a i :=
  (apply_lt_M_of_le_N a hj).trans_le hi

lemma apply_ne_of_M_le_apply {a : ℕ → ℕ} {N i j : ℕ} (hi : M a N ≤ a i) (hj : j ≤ N) :
    a j ≠ a i :=
  (apply_lt_of_M_le_apply hi hj).ne

lemma toFinset_card_pos {a : ℕ → ℕ} {i : ℕ} (hf : {j | a j = a i}.Finite) : 0 < #hf.toFinset :=
  Finset.card_pos.mpr ((Set.Finite.toFinset_nonempty _).mpr ⟨i, rfl⟩)

lemma apply_nth_zero (a : ℕ → ℕ) (i : ℕ) : a (Nat.nth (a · = a i) 0) = a i :=
  Nat.nth_mem (p := (a · = a i)) 0 toFinset_card_pos

lemma map_add_one_range (p : ℕ → Prop) [DecidablePred p] (n : ℕ) (h0 : ¬ p 0) :
    {x ∈ Finset.range n | p (x + 1)}.map ⟨(· + 1), add_left_injective 1⟩ =
     {x ∈ Finset.range (n + 1) | p x } := by
  ext x
  simp only [Finset.mem_map]
  constructor
  · aesop
  · intro hx
    use x - 1
    cases x <;> simp_all

namespace Condition

/-! ### The basic structure of the sequence, eventually alternating small and large numbers -/

variable {a : ℕ → ℕ} {N : ℕ} (hc : Condition a N)
include hc

protected lemma pos (n : ℕ) : 0 < a n := hc.1 n

@[simp] lemma apply_ne_zero (n : ℕ) : a n ≠ 0 :=
  (hc.pos _).ne'

lemma one_le_apply (n : ℕ) : 1 ≤ a n :=
  Nat.one_le_iff_ne_zero.2 (hc.apply_ne_zero n)

lemma apply_eq_card {n : ℕ} (h : N < n) : a n = #{i ∈ Finset.range n | a i = a (n - 1)} :=
  hc.2 n h

lemma apply_add_one_eq_card {n : ℕ} (h : N ≤ n) :
    a (n + 1) = #{i ∈ Finset.range (n + 1) | a i = a n} := by
  rw [hc.apply_eq_card (Nat.lt_add_one_of_le h)]
  simp

@[simp] lemma nth_apply_eq_zero (n : ℕ) : Nat.nth (a · = 0) n = 0 := by
  convert Nat.nth_false _ with i
  simp only [(hc.pos i).ne']

lemma nth_apply_add_one_eq {n : ℕ} (h : N ≤ n) : Nat.nth (a · = a n) (a (n + 1) - 1) = n := by
  rw [hc.apply_add_one_eq_card h]
  nth_rw 5 [← Nat.nth_count (p := (a · = a n)) rfl]
  simp [Finset.range_add_one, Finset.filter_insert, Nat.count_eq_card_filter_range]

lemma apply_nth_add_one_eq {m n : ℕ} (hfc : ∀ hf : {i | a i = m}.Finite, n < #hf.toFinset)
    (hn : N ≤ Nat.nth (a · = m) n) : a (Nat.nth (a · = m) n + 1) = n + 1 := by
  rw [hc.apply_eq_card (Nat.lt_add_one_of_le hn), add_tsub_cancel_right,
    ← Nat.count_eq_card_filter_range, Nat.nth_mem n hfc, Nat.count_nth_succ hfc]

lemma apply_nth_add_one_eq_of_infinite {m n : ℕ} (hi : {i | a i = m}.Infinite)
    (hn : N ≤ Nat.nth (a · = m) n) : a (Nat.nth (a · = m) n + 1) = n + 1 :=
  hc.apply_nth_add_one_eq (fun hf ↦ absurd hf hi) hn

lemma apply_nth_add_one_eq_of_lt {m n : ℕ} (hn : N < Nat.nth (a · = m) n) :
    a (Nat.nth (a · = m) n + 1) = n + 1 := by
  refine hc.apply_nth_add_one_eq ?_ hn.le
  by_contra! hf
  have := Nat.nth_eq_zero.2 (.inr hf)
  lia

lemma lt_toFinset_card {j : ℕ} (h : M a N ≤ a (j + 1)) (hf : {i | a i = a j}.Finite) :
    M a N - 1 < #hf.toFinset := by
  rw [Nat.sub_lt_iff_lt_add' (M_pos _ _), Nat.lt_one_add_iff]
  exact (hc.apply_eq_card (N_lt_of_M_le_apply h) ▸ h).trans (Finset.card_le_card (by simp))

lemma nth_ne_zero_of_M_le_of_lt {i k : ℕ} (hi : M a N ≤ a i) (hk : k < a (i + 1)) :
    Nat.nth (a · = a i) k ≠ 0 :=
  Nat.nth_ne_zero_anti (apply_ne_of_M_le_apply hi (Nat.zero_le _)) (by lia)
    (hc.nth_apply_add_one_eq (N_lt_of_M_le_apply hi).le ▸ ne_zero_of_M_le_apply hi)

lemma apply_add_one_lt_of_apply_eq {i j : ℕ} (hi : N ≤ i) (hij : i < j) (ha : a i = a j) :
    a (i + 1) < a (j + 1) := by
  rw [hc.apply_add_one_eq_card hi, hc.apply_add_one_eq_card (by lia), ha]
  refine Finset.card_lt_card (Finset.ssubset_def.mp ⟨Finset.filter_subset_filter _
    (by simp [hij.le]), Finset.not_subset.mpr ⟨j, ?_⟩⟩)
  simpa using Order.add_one_le_iff.mpr hij

lemma apply_add_one_ne_of_apply_eq {i j : ℕ} (hi : N ≤ i) (hj : N ≤ j) (hij : i ≠ j)
    (ha : a i = a j) : a (i + 1) ≠ a (j + 1) :=
  hij.lt_or_gt.elim (fun h ↦ (hc.apply_add_one_lt_of_apply_eq hi h ha).ne) fun h ↦
    (hc.apply_add_one_lt_of_apply_eq hj h ha.symm).ne'

lemma exists_infinite_setOf_apply_eq : ∃ m, {i | a i = m}.Infinite := by
  by_contra hi
  have hr : (Set.range a).Infinite := by
    contrapose! hi with hr
    rw [← Set.finite_coe_iff] at hr
    obtain ⟨n, hn⟩ := Finite.exists_infinite_fiber (Set.rangeFactorization a)
    rw [Set.infinite_coe_iff, Set.preimage] at hn
    simp only [Set.mem_singleton_iff, Set.rangeFactorization, Subtype.ext_iff] at hn
    exact ⟨↑n, hn⟩
  simp only [not_exists, Set.not_infinite] at hi
  have hinj : Set.InjOn (fun i ↦ Nat.nth (a · = i) 0 + 1) (Set.range a \ Set.Ico 0 (M a N)) := by
    rintro _ ⟨⟨_, rfl⟩, hi⟩ _ ⟨⟨_, rfl⟩, hj⟩ h
    simp only [Set.mem_Ico, zero_le, true_and, not_lt] at hi hj
    simp only [add_left_inj] at h
    convert congr(a $h) using 1 <;> simp [apply_nth_zero]
  refine Set.not_infinite.2 (hi 1) (Set.infinite_of_injOn_mapsTo hinj (fun i hi ↦ ?_)
    (hr.diff (Set.finite_Ico _ _)))
  simp only [Set.mem_diff, Set.mem_range, Set.mem_Ico, zero_le, true_and, not_lt] at hi
  rcases hi with ⟨⟨_, rfl⟩, hi⟩
  exact hc.apply_nth_add_one_eq toFinset_card_pos
    (N_lt_of_M_le_apply (a := a) (by simp only [apply_nth_zero, hi])).le

lemma nonempty_setOf_infinite_setOf_apply_eq : {m | {i | a i = m}.Infinite}.Nonempty :=
  hc.exists_infinite_setOf_apply_eq

lemma injOn_setOf_apply_add_one_eq_of_M_le {n : ℕ} (h : M a N ≤ n) :
    Set.InjOn a {i | a (i + 1) = n} := by
  intro i hi j hj hij
  have hi' := hi ▸ hc.nth_apply_add_one_eq (Nat.lt_add_one_iff.mp (N_lt_of_M_le_apply (hi ▸ h)))
  have hj' := hj ▸ hc.nth_apply_add_one_eq (Nat.lt_add_one_iff.mp (N_lt_of_M_le_apply (hj ▸ h)))
  rw [← hi', ← hj', hij]

lemma empty_consecutive_apply_ge_M : {i | M a N ≤ a i ∧ M a N ≤ a (i + 1)} = ∅ := by
  rw [Set.eq_empty_iff_forall_notMem]
  intro i
  induction i using Nat.strong_induction_on with | h i ih =>
  -- Let i be the first index where both `a i` and `a (i + 1)` are at least M.
  rintro ⟨hi1, hi2⟩
  have hi : ∀ j < i, M a N ≤ a j → a (j + 1) < M a N := by simp_all
  -- t is the set of indices before an appearance of the integer (a i).  For each j ∈ t, (a j)
  -- is the (a i)th appearance of that value, so each such value before index i appears at least
  -- M times before that index; since (a i) is the (at least) Mth appearance of that value, there
  -- are at least M positive integers appearing M times before (a i), a contradiction because one of
  -- those must be at least M.
  let t : Finset ℕ := {j ∈ Finset.range i | a (j + 1) = a i}
  let t' : Finset ℕ := {j ∈ Finset.range (i + 1) | a j = a i}
  have t_map_eq_t' : t.map ⟨(· + 1), add_left_injective 1⟩ = t' := by
    refine map_add_one_range (a · = a i) i ?_
    intro H
    rw [←H, M] at hi1
    have a0_le : a 0 ≤ (Finset.range (N + 1)).sup a := Finset.le_sup (by simp)
    lia
  have card_t_eq_card_t' : #t = #t' := by simp [← t_map_eq_t', t]
  have htM : ∀ j ∈ t, a j < M a N := by
    intro j hj
    simp only [t, Finset.mem_filter, Finset.mem_range] at hj
    obtain ⟨hj, hji⟩ := hj
    by_contra! hjM
    exact (lt_self_iff_false _).mp ((hji ▸ hi j hj hjM).trans_le hi1)
  have N_le_i : N ≤ i := by
    unfold M at hi1
    by_contra! HH
    have i_in_range : i ∈ Finset.range (N + 1) := by rw [Finset.mem_range]; lia
    have ai_le_sup : a i ≤ (Finset.range (N + 1)).sup a := Finset.le_sup i_in_range
    lia
  have ht' : a (i + 1) = #t' := hc.apply_add_one_eq_card N_le_i
  rw [← card_t_eq_card_t'] at ht'
  have ht'inj : Set.InjOn a t := by
    refine (hc.injOn_setOf_apply_add_one_eq_of_M_le hi1).mono ?_
    simp_all [t, t']
  have card_image_eq_card_t : #(Finset.image a t) = #t := Finset.card_image_of_injOn ht'inj
  have card_image_lt_M : #(Finset.image a t) < M a N := by
    refine (Finset.card_le_card (t := Finset.Ico 1 (M a N)) ?_).trans_lt ?_
    · simp only [Finset.subset_iff, Finset.mem_image, Finset.mem_Ico, forall_exists_index, and_imp,
                 forall_apply_eq_imp_iff₂]
      exact fun j hj ↦ ⟨hc.pos _, htM j hj⟩
    · simpa using M_pos a N
  lia

lemma card_lt_M_of_M_le {n : ℕ} (h : M a N ≤ n) :
    ∃ hf : {i | a i = n}.Finite, #hf.toFinset < M a N := by
  have := empty_consecutive_apply_ge_M hc
  contrapose! this with hin
  use Nat.nth (a · = n) (M a N - 1)
  have hin' := fun hf ↦ Nat.sub_one_lt_of_le (M_pos a N) (hin hf)
  have ha : M a N ≤ a (Nat.nth (a · = n) (M a N - 1)) := (Nat.nth_mem _ hin').symm ▸ h
  refine ⟨ha, ?_⟩
  suffices H : a (Nat.nth (fun x ↦ a x = n) (M a N - 1) + 1) = M a N from Nat.le_of_eq H.symm
  convert hc.apply_nth_add_one_eq hin' (N_lt_of_M_le_apply ha).le using 1

lemma bddAbove_setOf_infinite_setOf_apply_eq : BddAbove {m | {i | a i = m}.Infinite} := by
  refine ⟨M a N, fun x hi ↦ ?_⟩
  by_contra hx
  exact hi (hc.card_lt_M_of_M_le (not_le.mp hx).le).1

lemma infinite_setOf_apply_eq_anti {j k : ℕ} (hj : 0 < j) (hk : {i | a i = k}.Infinite)
    (hjk : j ≤ k) : {i | a i = j}.Infinite := by
  have hk' : {i | a (i + 1) = k}.Infinite := by
    have hinj : Set.InjOn (· + 1) {i | a (i + 1) = k} := (add_left_injective _).injOn
    rw [← Set.infinite_image_iff hinj]
    have hk0 : ({i | a i = k} \ {0}).Infinite := hk.diff (Set.finite_singleton _)
    convert hk0 using 1
    ext i
    simp only [Set.mem_image, Set.mem_setOf_eq, Set.mem_diff, Set.mem_singleton_iff]
    refine ⟨?_, ?_⟩
    · rintro ⟨j, rfl, rfl⟩
      simp
    · rintro ⟨rfl, h⟩
      exact ⟨i - 1, by simp [(by lia : i - 1 + 1 = i)]⟩
  have hinj : Set.InjOn (fun x ↦ Nat.nth (a · = a x) (j - 1) + 1)
      ({i | a (i + 1) = k} \ Set.Ico 0 N) := by
    intro x hx y hy h
    simp only [Set.mem_diff, Set.mem_setOf_eq, Set.mem_Ico, zero_le, true_and, not_lt] at hx hy
    rcases hx with ⟨hxk, hNx⟩
    rcases hy with ⟨hyk, hNy⟩
    simp only [add_left_inj] at h
    have hxk' : Nat.nth (a · = a x) (k - 1) = x := by rw [← hxk, hc.nth_apply_add_one_eq hNx]
    have hyk' : Nat.nth (a · = a y) (k - 1) = y := by rw [← hyk, hc.nth_apply_add_one_eq hNy]
    have hjk' : j - 1 ≤ k - 1 := by lia
    apply_fun a at hxk' hyk'
    have hyj : a (Nat.nth (a · = a y) (j - 1)) = a y :=
      Nat.nth_mem_anti (p := (a · = a y)) hjk' hyk'
    rw [← h, Nat.nth_mem_anti (p := (a · = a x)) hjk' hxk'] at hyj
    by_contra hxy
    exact hc.apply_add_one_ne_of_apply_eq hNx hNy hxy hyj (hyk ▸ hxk)
  have hk'' : (_ \ Set.Ico 0 (N + 2)).Infinite :=
    ((Set.infinite_image_iff hinj).mpr (hk'.diff (Set.finite_Ico _ _))).diff (Set.finite_Ico _ _)
  refine hk''.mono fun _ hi ↦ ?_
  simp only [Set.mem_image, Set.mem_diff, Set.mem_setOf_eq, Set.mem_Ico, zero_le, true_and,
    not_lt] at hi
  rcases hi with ⟨⟨x, -, rfl⟩, _⟩
  rw [Set.mem_setOf_eq, hc.apply_nth_add_one_eq_of_lt (by lia), Nat.sub_add_cancel hj]

/-! ### The definitions of small, medium and big numbers and the eventual alternation -/

variable (a)

/-- The largest number to appear infinitely often. -/
noncomputable def k : ℕ := sSup {m | {i | a i = m}.Infinite}

/-- Small numbers are those that are at most `k` (that is, those that appear infinitely often). -/
def Small (j : ℕ) : Prop := j ≤ k a

variable {a}

lemma infinite_setOf_apply_eq_k : {i | a i = k a}.Infinite :=
  Nat.sSup_mem hc.nonempty_setOf_infinite_setOf_apply_eq hc.bddAbove_setOf_infinite_setOf_apply_eq

lemma infinite_setOf_apply_eq_iff_small {j : ℕ} (hj : 0 < j) :
    {i | a i = j}.Infinite ↔ Small a j :=
  ⟨fun h ↦ le_csSup hc.bddAbove_setOf_infinite_setOf_apply_eq h,
   fun h ↦ hc.infinite_setOf_apply_eq_anti hj hc.infinite_setOf_apply_eq_k h⟩

lemma finite_setOf_apply_eq_iff_not_small {j : ℕ} (hj : 0 < j) :
    {i | a i = j}.Finite ↔ ¬Small a j := by
  simpa only [Set.not_infinite] using (hc.infinite_setOf_apply_eq_iff_small hj).not

lemma finite_setOf_apply_eq_k_add_one : {i | a i = k a + 1}.Finite := by
  rw [hc.finite_setOf_apply_eq_iff_not_small (by lia), Small]
  lia

/-- There are only finitely many `m` that appear more than `k` times. -/
lemma finite_setOf_k_lt_card : {m | ∀ hf : {i | a i = m}.Finite, k a < #hf.toFinset}.Finite := by
  rw [← Set.finite_image_iff]
  · refine Set.Finite.of_diff (hc.finite_setOf_apply_eq_k_add_one.subset fun i hi ↦ ?_)
      (Set.finite_Iic N)
    simp only [Set.mem_diff, Set.mem_image, Set.mem_setOf_eq, Set.mem_Iic, not_le] at hi
    rcases hi with ⟨⟨j, hjf, rfl⟩, hNi⟩
    rw [Set.mem_setOf_eq, hc.apply_nth_add_one_eq hjf (by lia)]
  · intro i hi j hj hij
    simp only [add_left_inj] at hij
    apply_fun a at hij
    rwa [Nat.nth_mem _ hi, Nat.nth_mem _ hj] at hij

lemma bddAbove_setOf_k_lt_card : BddAbove {m | ∀ hf : {i | a i = m}.Finite, k a < #hf.toFinset} :=
  hc.finite_setOf_k_lt_card.bddAbove

lemma k_pos : 0 < k a := by
  by_contra! hn
  apply nonpos_iff_eq_zero.mp hn ▸ hc.infinite_setOf_apply_eq_k
  convert Set.finite_empty
  ext i
  simp [(hc.pos i).ne']

lemma small_one : Small a 1 := by
  by_contra hns
  simp only [Small, not_le, Nat.lt_one_iff, hc.k_pos.ne'] at hns

lemma infinite_setOf_apply_eq_one : {i | a i = 1}.Infinite :=
  (hc.infinite_setOf_apply_eq_iff_small (by decide)).mpr hc.small_one

variable (a)

/-- The largest number to appear more than `k` times. -/
noncomputable def l : ℕ := sSup {m | ∀ hf : {i | a i = m}.Finite, k a < #hf.toFinset}

/-- Medium numbers are those that are more than `k` but at most `l` (and include all numbers
appearing finitely often but more than `k` times). -/
def Medium (j : ℕ) : Prop := k a < j ∧ j ≤ l a

/-- Big numbers are those greater than `l` (thus, appear at most `k` times). -/
def Big (j : ℕ) : Prop := l a < j

variable {a}

lemma k_le_l : k a ≤ l a :=
  le_csSup hc.bddAbove_setOf_k_lt_card (fun hf ↦ absurd hf hc.infinite_setOf_apply_eq_k)

lemma k_lt_of_big {j : ℕ} (h : Big a j) : k a < j :=
  hc.k_le_l.trans_lt h

lemma pos_of_big {j : ℕ} (h : Big a j) : 0 < j :=
  (Nat.zero_le _).trans_lt (hc.k_lt_of_big h)

lemma not_small_of_big {j : ℕ} (h : Big a j) : ¬Small a j := by simp [Small, hc.k_lt_of_big h]

lemma exists_card_le_of_big {j : ℕ} (h : Big a j) :
    ∃ hf : {i | a i = j}.Finite, #hf.toFinset ≤ k a := by
  have hns := hc.not_small_of_big h
  rw [← hc.finite_setOf_apply_eq_iff_not_small (hc.pos_of_big h)] at hns
  use hns
  by_contra! hlt
  exact notMem_of_csSup_lt h hc.bddAbove_setOf_k_lt_card fun _ ↦ hlt

variable (a N)

/-- `N'aux` is such that, by position `N'aux`, every medium number has made all its appearances
and every small number has appeared more than max(k, N+1) times. -/
noncomputable def N'aux : ℕ :=
  sSup {i | Medium a (a i)} ⊔ sSup ((fun i ↦ Nat.nth (a · = i) (k a ⊔ (N + 1))) '' Set.Iic (k a))

/-- `N'` is such that, by position `N'`, every medium number has made all its appearances
and every small number has appeared more than max(k, N+1) times; furthermore, `a N'` is small
(which means that every subsequent big number is preceded by a small number). -/
noncomputable def N' : ℕ := by
  classical
  exact N'aux a N + (if Small a (a (N'aux a N + 1)) then 1 else 2)

variable {a N}

lemma not_medium_of_N'aux_lt {j : ℕ} (h : N'aux a N < j) : ¬Medium a (a j) := by
  let s : Set ℕ := ⋃ i ∈ Set.Ioc (k a) (l a), {j | a j = i}
  have hf : s.Finite := by
    refine (Set.finite_Ioc _ _).biUnion ?_
    rintro i ⟨hk, -⟩
    rwa [hc.finite_setOf_apply_eq_iff_not_small (by lia), Small, not_le]
  exact fun hm ↦ notMem_of_csSup_lt (le_sup_left.trans_lt h)
    (hf.subset fun i hi ↦ (by simpa [s] using hi)).bddAbove hm

lemma small_or_big_of_N'aux_lt {j : ℕ} (h : N'aux a N < j) : Small a (a j) ∨ Big a (a j) := by
  have _ := hc.not_medium_of_N'aux_lt h
  rw [Small, Medium, Big] at *
  lia

lemma small_or_big_of_N'_le {j : ℕ} (h : N' a N ≤ j) : Small a (a j) ∨ Big a (a j) := by
  refine hc.small_or_big_of_N'aux_lt ?_
  rw [N'] at h
  lia

omit hc

lemma nth_sup_k_N_add_one_le_N'aux_of_small {j : ℕ} (h : Small a j) :
    Nat.nth (a · = j) (k a ⊔ (N + 1)) ≤ N'aux a N := by
  by_contra! hn
  exact notMem_of_csSup_lt (le_sup_right.trans_lt hn) ((Set.finite_Iic _).image _).bddAbove
    ⟨j, h, rfl⟩

include hc

lemma nth_sup_k_le_N'aux_of_small {j : ℕ} (h : Small a j) :
    Nat.nth (a · = j) (k a) ≤ N'aux a N :=
  match j with
  | 0 => by simp only [hc.nth_apply_eq_zero, zero_le]
  | j + 1 => ((Nat.nth_le_nth ((hc.infinite_setOf_apply_eq_iff_small (Nat.zero_lt_succ j)).mpr h)).2
      le_sup_left).trans (nth_sup_k_N_add_one_le_N'aux_of_small h)

lemma nth_sup_N_add_one_le_N'aux_of_small {j : ℕ} (h : Small a j) :
    Nat.nth (a · = j) (N + 1) ≤ N'aux a N :=
  match j with
  | 0 => by simp only [hc.nth_apply_eq_zero, zero_le]
  | j + 1 => ((Nat.nth_le_nth ((hc.infinite_setOf_apply_eq_iff_small (Nat.zero_lt_succ j)).mpr h)).2
      le_sup_right).trans (nth_sup_k_N_add_one_le_N'aux_of_small h)

lemma N_lt_N'aux : N < N'aux a N :=
  Nat.add_one_le_iff.mp ((Nat.le_nth fun hf ↦ absurd hf hc.infinite_setOf_apply_eq_one).trans
    (hc.nth_sup_N_add_one_le_N'aux_of_small hc.small_one))

/-- `N` is less than `N'`. -/
lemma N_lt_N' : N < N' a N := hc.N_lt_N'aux.trans_le (Nat.le_add_right _ _)

lemma lt_card_filter_eq_of_small_nth_lt {i j t : ℕ} (hj0 : 0 < j) (h : Small a j)
    (ht : Nat.nth (a · = j) t < i) : t < #{m ∈ Finset.range i | a m = j} := by
  rw [← hc.infinite_setOf_apply_eq_iff_small hj0] at h
  rw [← Nat.count_eq_card_filter_range]
  exact (Nat.nth_lt_nth h).mp (ht.trans_le (Nat.le_nth_count h _))

lemma k_lt_card_filter_eq_of_small_of_N'aux_le {i j : ℕ} (hj0 : 0 < j) (h : Small a j)
    (hN'aux : N'aux a N < i) : k a < #{m ∈ Finset.range i | a m = j} :=
  hc.lt_card_filter_eq_of_small_nth_lt hj0 h ((hc.nth_sup_k_le_N'aux_of_small h).trans_lt hN'aux)

lemma N_add_one_lt_card_filter_eq_of_small_of_N'aux_le {i j : ℕ} (hj0 : 0 < j) (h : Small a j)
    (hN'aux : N'aux a N < i) : N + 1 < #{m ∈ Finset.range i | a m = j} :=
  hc.lt_card_filter_eq_of_small_nth_lt hj0 h
    ((hc.nth_sup_N_add_one_le_N'aux_of_small h).trans_lt hN'aux)

lemma N_add_one_lt_card_filter_eq_of_small_of_N'_le {i j : ℕ} (hj0 : 0 < j) (h : Small a j)
    (hN' : N' a N < i) : N + 1 < #{m ∈ Finset.range i | a m = j} := by
  refine hc.N_add_one_lt_card_filter_eq_of_small_of_N'aux_le hj0 h ?_
  rw [N'] at hN'
  exact Nat.lt_of_add_right_lt hN'

lemma apply_add_one_big_of_apply_small_of_N'aux_le {i : ℕ} (h : Small a (a i))
    (hN'aux : N'aux a N ≤ i) : Big a (a (i + 1)) := by
  have hN'' : N'aux a N < i + 1 := by lia
  suffices ¬Small a (a (i + 1)) by simpa [this] using hc.small_or_big_of_N'aux_lt hN''
  rw [hc.apply_add_one_eq_card (hc.N_lt_N'aux.le.trans hN'aux), Small, not_le]
  exact hc.k_lt_card_filter_eq_of_small_of_N'aux_le (hc.pos _) h hN''

lemma apply_add_one_big_of_apply_small_of_N'_le {i : ℕ} (h : Small a (a i)) (hN' : N' a N ≤ i) :
    Big a (a (i + 1)) :=
  hc.apply_add_one_big_of_apply_small_of_N'aux_le h ((Nat.le_add_right _ _).trans hN')

lemma apply_add_one_small_of_apply_big_of_N'aux_le {i : ℕ} (h : Big a (a i))
    (hN'aux : N'aux a N ≤ i) : Small a (a (i + 1)) := by
  obtain ⟨hf, hfc⟩ := hc.exists_card_le_of_big h
  rw [hc.apply_add_one_eq_card (hc.N_lt_N'aux.le.trans hN'aux)]
  exact (Finset.card_le_card (by simp)).trans hfc

lemma apply_add_one_small_of_apply_big_of_N'_le {i : ℕ} (h : Big a (a i)) (hN' : N' a N ≤ i) :
    Small a (a (i + 1)) :=
  hc.apply_add_one_small_of_apply_big_of_N'aux_le h ((Nat.le_add_right _ _).trans hN')

lemma apply_add_two_small_of_apply_small_of_N'_le {i : ℕ} (h : Small a (a i)) (hN' : N' a N ≤ i) :
    Small a (a (i + 2)) :=
  hc.apply_add_one_small_of_apply_big_of_N'_le (hc.apply_add_one_big_of_apply_small_of_N'_le h hN')
    (by lia)

/-- `a (N' a N)` is a small number. -/
lemma small_apply_N' : Small a (a (N' a N)) := by
  rw [N']
  split_ifs with hi
  · exact hi
  · have hb : Big a (a (N'aux a N + 1)) := by
      simpa [hi] using hc.small_or_big_of_N'aux_lt (Nat.lt_add_one (N'aux a N))
    exact hc.apply_add_one_small_of_apply_big_of_N'aux_le hb (by lia)

lemma small_apply_N'_add_iff_even {n : ℕ} : Small a (a (N' a N + n)) ↔ Even n := by
  induction n with
  | zero => simpa using hc.small_apply_N'
  | succ n ih =>
    by_cases he : Even n <;> rw [← add_assoc] <;> simp only [he, iff_true, iff_false] at ih
    · have hne : ¬ Even (n + 1) := by simp [Nat.not_even_iff_odd, he]
      simp only [hne, iff_false]
      exact hc.not_small_of_big (hc.apply_add_one_big_of_apply_small_of_N'_le ih (by grind))
    · have hb : Big a (a (N' a N + n)) := by
        simpa [ih] using hc.small_or_big_of_N'_le (j := N' a N + n) (by lia)
      simp [hc.apply_add_one_small_of_apply_big_of_N'_le hb (by lia), Nat.not_even_iff_odd.mp he]

lemma small_apply_add_two_mul_iff_small {n : ℕ} (m : ℕ) (hN' : N' a N ≤ n) :
    Small a (a (n + 2 * m)) ↔ Small a (a n) := by
  rw [show n = N' a N + (n - N' a N) by lia, add_assoc, hc.small_apply_N'_add_iff_even,
    hc.small_apply_N'_add_iff_even]
  simp [Nat.even_add]

lemma apply_sub_one_small_of_apply_big_of_N'_le {i : ℕ} (h : Big a (a i)) (hN' : N' a N ≤ i) :
    Small a (a (i - 1)) := by
  have h0i : 1 ≤ i := by
    have := hc.N_lt_N'
    lia
  have h' : N' a N ≤ i - 1 := by
    by_contra hi
    have hi' : i = N' a N := by lia
    exact hc.not_small_of_big (hi' ▸ h) hc.small_apply_N'
  exact (hc.small_or_big_of_N'_le h').elim id fun hb ↦
    False.elim (hc.not_small_of_big h (Nat.sub_add_cancel h0i ▸
      (hc.apply_add_one_small_of_apply_big_of_N'_le hb h')))

lemma apply_sub_one_big_of_apply_small_of_N'_lt {i : ℕ} (h : Small a (a i)) (hN' : N' a N < i) :
    Big a (a (i - 1)) := by
  have h0i : 1 ≤ i := by lia
  have h' : N' a N ≤ i - 1 := by lia
  exact (hc.small_or_big_of_N'_le h').elim (fun hs ↦ False.elim (hc.not_small_of_big
    (Nat.sub_add_cancel h0i ▸ hc.apply_add_one_big_of_apply_small_of_N'_le hs h') h)) id

lemma apply_sub_two_small_of_apply_small_of_N'_lt {i : ℕ} (h : Small a (a i)) (hN' : N' a N < i) :
    Small a (a (i - 2)) := by
  convert hc.apply_sub_one_small_of_apply_big_of_N'_le
    (hc.apply_sub_one_big_of_apply_small_of_N'_lt h hN') (by lia) using 1

lemma N_add_one_lt_apply_of_apply_big_of_N'_le {i : ℕ} (h : Big a (a i)) (hN' : N' a N ≤ i) :
    N + 1 < a i := by
  refine hc.apply_eq_card (hc.N_lt_N'.trans_le hN') ▸
    hc.N_add_one_lt_card_filter_eq_of_small_of_N'_le (hc.pos _)
      (hc.apply_sub_one_small_of_apply_big_of_N'_le h hN') ?_
  by_contra
  exact hc.not_small_of_big ((by lia : i = N' a N) ▸ h) hc.small_apply_N'

lemma setOf_apply_eq_of_apply_big_of_N'_le {i : ℕ} (h : Big a (a i)) (hN' : N' a N ≤ i) :
    {j | a j = a i} = {j | N < j ∧ Small a (a (j - 1)) ∧
      a i = #{t ∈ Finset.range j | a t = a (j - 1)}} := by
  have hs : {j | N < j ∧ Small a (a (j - 1)) ∧ a i = #{t ∈ Finset.range j | a t = a (j - 1)}} ⊆
      {j | a j = a i} := by
    rintro _ ⟨hNj, -, hj⟩
    exact hj ▸ hc.apply_eq_card hNj
  rcases hc.exists_card_le_of_big h with ⟨hf, hck⟩
  have hf' : {j | N < j ∧ Small a (a (j - 1)) ∧
    a i = #{t ∈ Finset.range j | a t = a (j - 1)}}.Finite := hf.subset hs
  suffices hf.toFinset = hf'.toFinset by simpa using this
  rw [← Set.Finite.toFinset_subset_toFinset (hs := hf') (ht := hf)] at hs
  refine (Finset.eq_of_subset_of_card_le hs (hck.trans ?_)).symm
  have hs : #((Finset.Icc 1 (k a)).image (fun t ↦ Nat.nth (a · = t) (a i - 1) + 1)) = k a := by
    convert Finset.card_image_of_injOn fun t ht u hu htu ↦ ?_
    · simp only [Nat.card_Icc, add_tsub_cancel_right]
    · simp only [add_left_inj] at htu
      simp only [Finset.coe_Icc, Set.mem_Icc] at ht hu
      rw [← Small, ← hc.infinite_setOf_apply_eq_iff_small (by lia)] at ht hu
      apply_fun a at htu
      rwa [Nat.nth_mem_of_infinite ht.2, Nat.nth_mem_of_infinite hu.2] at htu
  refine hs ▸ Finset.card_le_card (Finset.subset_iff.2 fun j hj ↦ ?_)
  simp only [Set.Finite.mem_toFinset, Set.mem_setOf_eq]
  simp only [Finset.mem_image, Finset.mem_Icc] at hj
  rcases hj with ⟨t, ⟨ht1, htk⟩, rfl⟩
  have hN1 : N < a i - 1 := by
    have := hc.N_add_one_lt_apply_of_apply_big_of_N'_le h hN'
    lia
  simp only [add_tsub_cancel_right]
  rw [← Small] at htk
  have htki := htk
  rw [← hc.infinite_setOf_apply_eq_iff_small (by lia)] at htki
  rw [Nat.nth_mem_of_infinite htki]
  simp only [htk, true_and]
  refine ⟨Nat.lt_add_one_iff.mpr ((Nat.le_nth (fun hf ↦ absurd hf htki)).trans
    ((Nat.nth_le_nth htki).2 hN1.le)), ?_⟩
  rw [← Nat.count_eq_card_filter_range, Nat.count_nth_succ_of_infinite htki]
  lia

lemma N_lt_of_apply_eq_of_apply_big_of_N'_le {i j : ℕ} (hj : a j = a i) (h : Big a (a i))
    (hN' : N' a N ≤ i) : N < j :=
  have hj' : j ∈ {t | a t = a i} := by simpa using hj
  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' ▸ hj').1

lemma small_apply_sub_one_of_apply_eq_of_apply_big_of_N'_le {i j : ℕ} (hj : a j = a i)
    (h : Big a (a i)) (hN' : N' a N ≤ i) : Small a (a (j - 1)) :=
  have hj' : j ∈ {t | a t = a i} := by simpa using hj
  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' ▸ hj').2.1

/-! ### The main lemmas leading to the required result -/

/-- Lemma 1 from the informal solution. -/
lemma apply_add_one_eq_card_small_le_card_eq {i : ℕ} (hi : N' a N < i) (hib : Big a (a i)) :
    a (i + 1) = #{m ∈ Finset.range (k a + 1) | a i ≤ #{j ∈ Finset.range i | a j = m}} := by
  rw [hc.apply_add_one_eq_card (hc.N_lt_N'.trans hi).le]
  convert Finset.card_image_of_injOn (f := fun j ↦ Nat.nth (a · = j) (a i - 1) + 1) ?_ using 1
  · congr
    ext j
    simp only [Finset.mem_filter, Finset.mem_range, Finset.mem_image]
    refine ⟨fun ⟨hj, hji⟩ ↦ ⟨a (j - 1), hji ▸ ?_⟩, fun ⟨t, ⟨hts, htr⟩, ht⟩ ↦ ?_⟩
    · have hjN : N < j := hc.N_lt_of_apply_eq_of_apply_big_of_N'_le hji hib hi.le
      refine ⟨⟨Nat.lt_add_one_iff.mpr (hc.small_apply_sub_one_of_apply_eq_of_apply_big_of_N'_le
        hji hib hi.le), ?_⟩, ?_⟩
      · rw [hc.apply_eq_card hjN]
        have : j ≤ i := by lia
        gcongr
      · have hj1 : j = j - 1 + 1 := by lia
        nth_rw 2 [hj1]
        rw [hc.nth_apply_add_one_eq (by lia), hj1.symm]
    · subst ht
      rw [Nat.lt_add_one_iff, ← Small] at hts
      have ht0 : 0 < t := by
        by_contra! h0
        simp [nonpos_iff_eq_zero.mp h0, hc.apply_ne_zero] at htr
      rw [← hc.infinite_setOf_apply_eq_iff_small ht0] at hts
      rw [← Nat.count_eq_card_filter_range] at htr
      constructor
      · rwa [add_lt_add_iff_right, ← Nat.lt_nth_iff_count_lt hts,
          Nat.sub_lt_iff_lt_add' (hc.one_le_apply _), Nat.lt_one_add_iff]
      · rw [hc.apply_nth_add_one_eq_of_infinite hts]
        · exact Nat.sub_add_cancel (hc.one_le_apply _)
        · refine (Nat.le_nth fun hf ↦ absurd hf hts).trans ((Nat.nth_le_nth hts).2 ?_)
          have := hc.N_add_one_lt_apply_of_apply_big_of_N'_le hib hi.le
          lia
  · intro t ht u hu htu
    simp only [Finset.coe_filter, Finset.mem_range, Set.mem_setOf_eq, Nat.lt_add_one_iff] at ht hu
    rw [← Small] at ht hu
    have ht0 : 0 < t := by
      by_contra! h0
      simp only [nonpos_iff_eq_zero] at h0
      simp [h0, hc.apply_ne_zero] at ht
    have hu0 : 0 < u := by
      by_contra! h0
      simp only [nonpos_iff_eq_zero] at h0
      simp [h0, hc.apply_ne_zero] at hu
    rw [← hc.infinite_setOf_apply_eq_iff_small ht0] at ht
    rw [← hc.infinite_setOf_apply_eq_iff_small hu0] at hu
    simp only [add_left_inj] at htu
    apply_fun a at htu
    rwa [Nat.nth_mem_of_infinite ht.1, Nat.nth_mem_of_infinite hu.1] at htu

/-- Similar to Lemma 1 from the informal solution, but with a `Small` hypothesis instead of `Big`
and considering a range one larger (the form needed for Lemma 2). -/
lemma apply_eq_card_small_le_card_eq_of_small {i : ℕ} (hi : N' a N + 1 < i)
    (his : Small a (a i)) :
    a i = #{m ∈ Finset.range (k a + 1) | a (i - 1) ≤ #{j ∈ Finset.range i | a j = m}} := by
  have hib : Big a (a (i - 1)) := hc.apply_sub_one_big_of_apply_small_of_N'_lt his (by lia)
  nth_rw 1 [show i = i - 1 + 1 by lia]
  rw [hc.apply_add_one_eq_card_small_le_card_eq (by lia) hib]
  congr 1
  ext j
  simp only [Finset.mem_filter, Finset.mem_range, and_congr_right_iff]
  intro hj
  convert Iff.rfl using 2
  congr 1
  ext t
  simp only [Finset.mem_filter, Finset.mem_range]
  refine ⟨fun ⟨hti, rfl⟩ ↦ ⟨?_, rfl⟩, fun ⟨_, rfl⟩ ↦ ⟨by lia, rfl⟩⟩
  by_contra hti1
  have htieq : t = i - 1 := by lia
  subst htieq
  exact hc.not_small_of_big hib (Nat.lt_add_one_iff.mp hj)

/-- Lemma 2 from the informal solution. -/
lemma exists_apply_sub_two_eq_of_apply_eq {i j : ℕ} (hi : N' a N + 2 < i) (hijlt : i < j)
    (his : Small a (a i)) (hijeq : a i = a j)
    (hij1 : ∀ t, Small a t → #{x ∈ Finset.Ico i j | a x = t} ≤ 1) :
    ∃ t, t ∈ Finset.Ico i j ∧ a (i - 2) = a t := by
  let I : Finset ℕ := {t ∈ Finset.range (k a + 1) | a (i - 1) ≤ #{u ∈ Finset.range i | a u = t}}
  let J : Finset ℕ := {t ∈ Finset.range (k a + 1) | a (j - 1) ≤ #{u ∈ Finset.range j | a u = t}}
  have hIc : a i = #I := hc.apply_eq_card_small_le_card_eq_of_small (by lia) his
  have hJc : a j = #J := hc.apply_eq_card_small_le_card_eq_of_small (by lia) (hijeq ▸ his)
  have hIJc : #I = #J := hIc ▸ hJc ▸ hijeq
  have := hc.N_lt_N'
  have hiju : Finset.range i ∪ Finset.Ico i j = Finset.range j := by
    rw [Finset.range_eq_Ico, Finset.Ico_union_Ico' (by lia) (by lia)]
    simp [hijlt.le]
  have hi2s : a (i - 2) < k a + 1 :=
    Nat.lt_add_one_iff.mpr (hc.apply_sub_two_small_of_apply_small_of_N'_lt his (by lia))
  have hiI : a (i - 2) ∈ I := by
    simp only [I, Finset.mem_filter, Finset.mem_range, hi2s, true_and]
    rw [hc.apply_eq_card (by lia), show i - 1 - 1 = i - 2 by lia]
    exact Finset.card_le_card (Finset.filter_subset_filter _  (by simp))
  have hj2s : a (j - 2) < k a + 1 :=
    Nat.lt_add_one_iff.mpr (hc.apply_sub_two_small_of_apply_small_of_N'_lt (hijeq ▸ his) (by lia))
  have hjJ : a (j - 2) ∈ J := by
    simp only [J, Finset.mem_filter, Finset.mem_range, hj2s, true_and]
    rw [hc.apply_eq_card (by lia), show j - 1 - 1 = j - 2 by lia]
    exact Finset.card_le_card (Finset.filter_subset_filter _  (by simp))
  have hjI : a (j - 2) ∈ I := by
    by_contra hjI
    have hjIf := hjI
    simp only [Finset.mem_filter, Finset.mem_range, hj2s, true_and, not_le, I,
      Nat.lt_iff_add_one_le] at hjIf
    have hjI' : a (j - 1) ≤ a (i - 1) := by
      calc a (j - 1) ≤ #{u ∈ Finset.range j | a u = a (j - 2)} :=
            (Finset.mem_filter.mp hjJ).2
        _ = #{u ∈ Finset.range i ∪ Finset.Ico i j | a u = a (j - 2)} := by rw [hiju]
        _ ≤ #{u ∈ Finset.range i | a u = a (j - 2)} + #{u ∈ Finset.Ico i j | a u = a (j - 2)} := by
            rw [Finset.filter_union]
            exact Finset.card_union_le _ _
        _ ≤ #{u ∈ Finset.range i | a u = a (j - 2)} + 1 := by
            gcongr
            exact hij1 _ (by rwa [Nat.lt_add_one_iff, ← Small] at hj2s)
        _ ≤ a (i - 1) := hjIf
    refine hjI (Finset.eq_of_subset_of_card_le (fun x hxI ↦ ?_) hIJc.symm.le ▸ hjJ)
    simp only [Finset.mem_filter, I, J] at *
    refine ⟨hxI.1, ?_⟩
    calc a (j - 1) ≤ a (i - 1) := hjI'
      _ ≤ #{u ∈ Finset.range i | a u = x} := hxI.2
      _ ≤ #{u ∈ Finset.range j | a u = x} :=
        Finset.card_le_card (Finset.filter_subset_filter _ (by simp [hijlt.le]))
  have hi1j1 : a (i - 1) + 1 ≤ a (j - 1) := by
    calc a (i - 1) + 1 ≤ #{u ∈ Finset.range i | a u = a (j - 2)} + 1 := by
          gcongr
          simp only [Finset.mem_filter, I] at hjI
          exact hjI.2
      _ ≤ #{u ∈ Finset.range i | a u = a (j - 2)} + #{u ∈ Finset.Ico i j | a u = a (j - 2)} := by
          gcongr
          simp only [Finset.one_le_card]
          refine ⟨j - 2, ?_⟩
          simp only [Finset.mem_filter, Finset.mem_Ico, and_true]
          refine ⟨?_, by lia⟩
          by_contra hj
          have hj' : j = i + 1 := by lia
          subst hj'
          exact hc.not_small_of_big (hc.apply_add_one_big_of_apply_small_of_N'_le his (by lia))
            (hijeq ▸ his)
      _ = #({u ∈ Finset.range i | a u = a (j - 2)} ∪ {u ∈ Finset.Ico i j | a u = a (j - 2)}) := by
          refine (Finset.card_union_of_disjoint ?_).symm
          simp only [Finset.disjoint_iff_ne, Finset.mem_filter, Finset.mem_range, Finset.mem_Ico,
            and_imp]
          rintro t hti - u hiu - -
          lia
      _ = #{u ∈ Finset.range j | a u = a (j - 2)} := by
          rw [← Finset.filter_union, hiju]
      _ = a (j - 1) := by
          rw [hc.apply_eq_card (show N < j - 1 by lia)]
          congr 1
          ext t
          simp only [Finset.mem_filter, Finset.mem_range]
          refine ⟨fun ⟨htj, htj'⟩ ↦ ⟨?_, by convert htj' using 1⟩,
            fun ⟨htj, htj'⟩ ↦ ⟨by lia, by convert htj' using 1⟩⟩
          by_contra htj''
          have ht1 : t = j - 1 := by lia
          subst ht1
          exact hc.not_small_of_big (htj' ▸ hc.apply_sub_one_big_of_apply_small_of_N'_lt
            (hijeq ▸ his) (by lia)) (hc.apply_sub_two_small_of_apply_small_of_N'_lt
            (hijeq ▸ his) (by lia))
  have hIJ : I = J := by
    refine (Finset.eq_of_subset_of_card_le (Finset.subset_iff.mp fun x hxJ ↦ ?_) hIJc.le).symm
    simp only [Finset.mem_filter, Finset.mem_range, I, J, Nat.lt_add_one_iff] at *
    refine ⟨hxJ.1, (add_le_add_iff_right 1).mp ?_⟩
    calc a (i - 1) + 1 ≤ a (j - 1) := hi1j1
       _ ≤ #{u ∈ Finset.range j | a u = x} := hxJ.2
       _ = #({u ∈ Finset.range i | a u = x} ∪ {u ∈ Finset.Ico i j | a u = x}) := by
           rw [← Finset.filter_union, hiju]
       _ ≤ #{u ∈ Finset.range i | a u = x} + #{u ∈ Finset.Ico i j | a u = x} :=
           Finset.card_union_le _ _
       _ ≤ #{u ∈ Finset.range i | a u = x} + 1 := by
           gcongr
           exact hij1 _ hxJ.1
  simp only [hIJ, J, Finset.mem_filter] at hiI
  have hiI' := hi1j1.trans hiI.2
  rw [hc.apply_eq_card (by lia), show i - 1 - 1 = i - 2 by lia, Nat.add_one_le_iff,
     ← not_le] at hiI'
  rcases Finset.not_subset.mp (mt Finset.card_le_card hiI') with ⟨t, htj, hti⟩
  simp only [Finset.mem_filter, Finset.mem_range] at htj hti
  simp only [htj.2, and_true, not_lt, tsub_le_iff_right] at hti
  refine ⟨t, Finset.mem_Ico.mpr ⟨?_, htj.1⟩, htj.2.symm⟩
  by_contra
  have hti' : t = i - 1 := by lia
  subst hti'
  exact hc.not_small_of_big (hc.apply_sub_one_big_of_apply_small_of_N'_lt his (by lia)) (htj.2 ▸
    (hc.apply_sub_two_small_of_apply_small_of_N'_lt his (by lia)))

variable (a)

/-- The indices, minus `n`, of small numbers appearing for the second or subsequent time at or
after `a n`. -/
def pSet (n : ℕ) : Set ℕ := {t | ∃ i ∈ Finset.Ico n (n + t), Small a (a i) ∧ a (n + t) = a i}

/-- The index, minus `n`, of the second appearance of the first small number to appear twice at
or after `a n`. This is only used for small `a n` with `N' a N + 2 < n`. -/
noncomputable def p (n : ℕ) : ℕ := sInf (pSet a n)

variable {a}

lemma nonempty_pSet (n : ℕ) : (pSet a n).Nonempty := by
  rcases hc.infinite_setOf_apply_eq_one.exists_gt n with ⟨i, hi1, hni⟩
  rcases hc.infinite_setOf_apply_eq_one.exists_gt i with ⟨j, hj1, hij⟩
  refine ⟨j - n, ?_⟩
  simp only [pSet, Finset.mem_Ico, Set.mem_setOf_eq]
  exact ⟨i, ⟨hni.le, by lia⟩, hi1 ▸ ⟨hc.small_one, hj1 ▸ (by congr; lia)⟩⟩

lemma exists_mem_Ico_small_and_apply_add_p_eq (n : ℕ) :
    ∃ i ∈ Finset.Ico n (n + p a n), Small a (a i) ∧ a (n + p a n) = a i :=
  csInf_mem (hc.nonempty_pSet _)

lemma p_pos (n : ℕ) : 0 < p a n := by
  by_contra! h
  have hn := hc.exists_mem_Ico_small_and_apply_add_p_eq n
  simp [h] at hn

lemma card_filter_apply_eq_Ico_add_p_le_one (n : ℕ) {j : ℕ} (hjs : Small a j) :
    #{i ∈ Finset.Ico n (n + p a n) | a i = j} ≤ 1 := by
  have h : IsLeast (pSet a n) (p a n) := isLeast_csInf (hc.nonempty_pSet n)
  simp only [IsLeast, pSet, Set.mem_setOf_eq, mem_lowerBounds, forall_exists_index, and_imp,
    Finset.mem_Ico] at h
  rw [Finset.card_le_one_iff]
  intro x y hx hy
  simp only [Finset.mem_filter, Finset.mem_Ico] at hx hy
  rcases lt_trichotomy x y with hxy | rfl | hxy
  · replace h := h.2 (y - n) x hx.1.1 (by lia) (hx.2 ▸ hjs)
    lia
  · rfl
  · replace h := h.2 (x - n) y hy.1.1 (by lia) (hy.2 ▸ hjs)
    lia

lemma apply_add_p_eq {n : ℕ} (hn : N' a N + 2 < n) (hs : Small a (a n)) : a (n + p a n) = a n := by
  rcases hc.exists_mem_Ico_small_and_apply_add_p_eq n with ⟨i, hiIco, his, hin⟩
  suffices i = n by rw [hin, this]
  simp only [Finset.mem_Ico] at hiIco
  by_contra hin'
  have hf (t : ℕ) (hts : Small a t) : #{x ∈ Finset.Ico i (n + p a n) | a x = t} ≤ 1 :=
    calc #{x ∈ Finset.Ico i (n + p a n) | a x = t} ≤ #{x ∈ Finset.Ico n (n + p a n) | a x = t} :=
        Finset.card_le_card (Finset.filter_subset_filter _ (Finset.Ico_subset_Ico hiIco.1 le_rfl))
      _ ≤ 1 := hc.card_filter_apply_eq_Ico_add_p_le_one _ hts
  obtain ⟨t, hti, hi2t⟩ := hc.exists_apply_sub_two_eq_of_apply_eq (j := n + p a n) (by lia)
    (by lia) his hin.symm hf
  have h1 := hc.card_filter_apply_eq_Ico_add_p_le_one n
    (hi2t ▸ hc.apply_sub_two_small_of_apply_small_of_N'_lt his (by lia))
  revert h1
  simp only [imp_false, not_le, Finset.one_lt_card_iff, Finset.mem_filter, Finset.mem_Ico, ne_eq,
    exists_and_left]
  simp only [Finset.mem_Ico] at hti
  refine ⟨i - 2, ⟨⟨?_, by lia⟩, hi2t⟩, t, by lia⟩
  by_contra hi2
  have hi1 : n = i - 1 := by lia
  subst hi1
  exact hc.not_small_of_big (hc.apply_sub_one_big_of_apply_small_of_N'_lt his (by lia)) hs

lemma even_p {n : ℕ} (hn : N' a N + 2 < n) (hs : Small a (a n)) : Even (p a n) := by
  have hna : n = N' a N + (n - (N' a N)) := by lia
  have hs' := hc.apply_add_p_eq hn hs ▸ hs
  rw [hna, hc.small_apply_N'_add_iff_even] at hs
  nth_rw 1 [hna] at hs'
  rw [add_assoc, hc.small_apply_N'_add_iff_even] at hs'
  simpa [Nat.even_add, hs] using hs'

lemma p_le_two_mul_k {n : ℕ} (hn : N' a N + 2 < n) (hs : Small a (a n)) : p a n ≤ 2 * k a := by
  by_contra hlt
  obtain ⟨x, hx, y, hy, hxyne, hxy⟩ : ∃ x ∈ Finset.range (k a + 1), ∃ y ∈ Finset.range (k a + 1),
      x ≠ y ∧ a (n + 2 * x) = a (n + 2 * y) := by
    convert Finset.exists_ne_map_eq_of_card_lt_of_maps_to (t := Finset.Icc 1 (k a)) ?_ ?_
    · simp
    · rintro i -
      simp only [Finset.coe_Icc, Set.mem_Icc]
      rw [← Small, hc.small_apply_add_two_mul_iff_small i (by lia)]
      simp [hs, hc.one_le_apply]
  have hs' : Small a (a (n + 2 * x)) := by rwa [hc.small_apply_add_two_mul_iff_small x (by lia)]
  have hj := hc.card_filter_apply_eq_Ico_add_p_le_one n hs'
  revert hj
  simp only [imp_false, not_le, Finset.one_lt_card_iff, Finset.mem_filter, Finset.mem_Ico, ne_eq,
    exists_and_left]
  simp only [Finset.mem_range] at hx hy
  exact ⟨n + 2 * x, by lia, n + 2 * y, by lia⟩

lemma p_apply_sub_two_le_p_apply {n : ℕ} (hn : N' a N + 4 < n) (hs : Small a (a n)) :
    p a (n - 2) ≤ p a n := by
  obtain ⟨t, hti, _⟩ := hc.exists_apply_sub_two_eq_of_apply_eq (j := n + p a n) (by lia)
    ((lt_add_iff_pos_right n).mpr (hc.p_pos n)) hs
    (hc.apply_add_p_eq (by lia) hs).symm (fun _ ↦ hc.card_filter_apply_eq_Ico_add_p_le_one _)
  by_contra
  have hn2 := (hc.apply_sub_two_small_of_apply_small_of_N'_lt hs (by lia))
  have : p a n ≤ p a (n - 2) - 2 := by
    obtain ⟨_, _⟩ := hc.even_p (by lia) hs
    obtain ⟨_, _⟩ := hc.even_p (by lia) hn2
    lia
  have h := hc.card_filter_apply_eq_Ico_add_p_le_one (n - 2) hn2
  revert h
  simp only [imp_false, not_le, Finset.one_lt_card_iff, Finset.mem_filter, Finset.mem_Ico,
    ne_eq, exists_and_left]
  simp only [Finset.mem_Ico] at hti
  exact ⟨n - 2, ⟨⟨le_rfl, by lia⟩, rfl⟩, t, by lia⟩

lemma p_apply_le_p_apply_add_two {n : ℕ} (hn : N' a N + 2 < n) (hs : Small a (a n)) :
    p a n ≤ p a (n + 2) :=
  hc.p_apply_sub_two_le_p_apply (n := n + 2) (by lia)
    (hc.apply_add_two_small_of_apply_small_of_N'_le hs (by lia))

variable (a N)

lemma exists_p_eq : ∃ b c, ∀ n, b < n → p a (N' a N + 2 * n) = c := by
  let c : ℕ := sSup (Set.range (fun i ↦ p a (N' a N + 2 * (2 + i))))
  have hk : 2 * k a ∈ upperBounds (Set.range (fun i ↦ p a (N' a N + 2 * (2 + i)))) := by
    simp only [mem_upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]
    exact fun i ↦ hc.p_le_two_mul_k (by lia) (hc.small_apply_N'_add_iff_even.mpr (by simp))
  have hlec : ∀ j ∈ Set.range (fun i ↦ p a (N' a N + 2 * (2 + i))), j ≤ c :=
    fun _ hj ↦ le_csSup ⟨_, hk⟩ hj
  obtain ⟨t, ht⟩ := Set.Nonempty.csSup_mem (Set.range_nonempty _) (BddAbove.finite ⟨2 * k a, hk⟩)
  have heqc (u : ℕ) : p a (N' a N + 2 * (2 + t + u)) = c := by
    induction u with
    | zero => simpa using ht
    | succ u ih =>
      refine le_antisymm ?_ (ih ▸ ?_)
      · simp only [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hlec
        exact add_assoc _ _ (u + 1) ▸ hlec (t + (u + 1))
      · have hs : Small a (a (N' a N + 2 * (2 + t + u))) := by
          rw [hc.small_apply_N'_add_iff_even]
          simp
        convert hc.p_apply_le_p_apply_add_two (by lia) hs using 1
  refine ⟨1 + t, c, fun n hn ↦ ?_⟩
  rw [show n = 2 + t + (n - (2 + t)) by lia]
  exact heqc _

lemma exists_a_apply_add_eq : ∃ b c, 0 < c ∧ ∀ n, b < n →
    a (N' a N + 2 * n + 2 * c) = a (N' a N + 2 * n) := by
  obtain ⟨b, c', hbc'⟩ := hc.exists_p_eq a N
  have hs (n : ℕ) : Small a (a (N' a N + 2 * n)) := hc.small_apply_N'_add_iff_even.mpr (by simp)
  refine ⟨b + 2, c' / 2, ?_, fun n hbn ↦ hbc' n (by lia) ▸ ?_⟩
  · have := hbc' (b + 2) (by lia)
    have := hc.p_pos (N' a N + 2 * (b + 2))
    rcases hc.even_p (by lia) (hs (b + 2)) with ⟨_, _⟩
    lia
  · convert hc.apply_add_p_eq (by lia) (hs n) using 3
    rcases hc.even_p (by lia) (hs n) with ⟨_, ht⟩
    simp [ht, ← two_mul]

variable {a N}

end Condition



theorem imo2024_p3 {a : ℕ → ℕ} {N : ℕ} (h : Condition a N) :
    EventuallyPeriodic (fun i ↦ a (2 * i)) ∨ EventuallyPeriodic (fun i ↦ a (2 * i + 1)) := by
  obtain ⟨b, c, hc, hbc⟩ := h.exists_a_apply_add_eq a N
  obtain ⟨t, _⟩ | ⟨t, _⟩ := Nat.even_or_odd (Condition.N' a N)
  · refine .inl ⟨c, Condition.N' a N / 2 + b + 1, hc, fun m hm ↦ ?_⟩
    convert hbc (m - t) (by lia) using 1 <;> dsimp only <;> congr <;> lia
  · refine .inr ⟨c, Condition.N' a N / 2 + b + 1, hc, fun m hm ↦ ?_⟩
    convert hbc (m - t) (by lia) using 1 <;> dsimp only <;> congr 1 <;> lia

end Imo2024P3

-- ═══ Imo2024P6 ═══

/-
Copyright (c) 2024 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers
-/





/-!
# International Mathematical Olympiad 2024, Problem 6

A function `f: ℚ → ℚ` is called *aquaesulian* if the following
property holds: for every `x, y ∈ ℚ`,
`f(x + f(y)) = f(x) + y` or `f(f(x) + y) = x + f(y)`.

Show that there exists an integer `c` such that for any aquaesulian function `f`
there are at most `c` different rational numbers of the form `f(r)+f(-r)` for
some rational number `r`, and find the smallest possible value of `c`.
-/

namespace Imo2024P6

def Aquaesulian (f : ℚ → ℚ) : Prop :=
  ∀ x y, f (x + f y) = f x + y ∨ f (f x + y) = x + f y

open scoped Cardinal



/-
We follow Solution 1 from the
[official solutions](https://www.imo2024.uk/s/IMO-2024-Paper-1-Solutions.pdf). A key observation
is that `f(-f(-x)) = x`. We then consider a pair of distinct nonzero values of `f(x)+f(-x)`,
and a series of manipulations together with the previous observation result in a contradiction,
so there are at most two values of `f(x)+f(-x)`. All this works over any `AddCommGroup`; over
`ℚ`, we then show that `⌊x⌋ - Int.fract x` achieves two different values of `f(x)+f(-x)`.
-/

namespace General

variable {G : Type*} [AddCommGroup G]

/-- The condition on functions in the problem (for a general `AddCommGroup` and in
symmetric form). -/
def Aquaesulian (f : G → G) : Prop := ∀ x y, f (f y + x) = f x + y ∨ f (f x + y) = f y + x

variable {f : G → G} (h : Aquaesulian f)
include h

lemma Aquaesulian.apply_apply_add (x : G) : f (f x + x) = f x + x := by
  rcases h x x with hx | hx <;> exact hx

lemma Aquaesulian.eq_of_apply_eq_inl {x₁ x₂ : G} (he : f x₁ = f x₂)
    (hc : f (f x₁ + x₂) = f x₂ + x₁) : x₁ = x₂ := by
  rw [he, h.apply_apply_add, add_right_inj] at hc
  exact hc.symm

lemma Aquaesulian.injective : Function.Injective f := by
  intro x₁ x₂ he
  rcases h x₁ x₂ with hc | hc
  · exact (h.eq_of_apply_eq_inl he.symm hc).symm
  · exact h.eq_of_apply_eq_inl he hc

@[simp]
lemma Aquaesulian.apply_zero : f 0 = 0 := by
  refine h.injective ?_
  convert h.apply_apply_add 0 using 1 <;> simp

lemma Aquaesulian.apply_neg_apply_add (x : G) : f (-(f x)) + x = 0 := by
  rcases h x (-(f x)) with hc | hc
  · rw [add_neg_cancel, ← h.apply_zero] at hc
    exact h.injective hc
  · rw [add_neg_cancel, h.apply_zero] at hc
    exact hc.symm

@[simp]
lemma Aquaesulian.apply_neg_apply (x : G) : f (-(f x)) = -x := by
  rw [← add_eq_zero_iff_eq_neg]
  exact h.apply_neg_apply_add x

lemma Aquaesulian.apply_neg_apply_neg (x : G) : f (-(f (-x))) = x := by
  simp [h]

lemma Aquaesulian.apply_neg_of_apply_eq {x₁ x₂ : G} (hx : f x₁ = x₂) : f (-x₂) = -x₁ := by
  rw [← hx]
  exact h.apply_neg_apply _

lemma Aquaesulian.apply_neg_eq_neg_iff {x₁ x₂ : G} : f (-x₂) = -x₁ ↔ f x₁ = x₂ := by
  refine ⟨fun hn ↦ ?_, h.apply_neg_of_apply_eq⟩
  convert h.apply_neg_of_apply_eq hn <;> rw [neg_neg]

lemma Aquaesulian.pair_lemma {x u v : G} (huv : u ≠ v) (hx : f x = u ∨ f u = x)
    (hy : f x = v ∨ f v = x) : f x = v ∨ f x = u := by
  rcases hx with hx | hx <;> rcases hy with hy | hy
  · exact (huv (hx.symm.trans hy)).elim
  · exact .inr hx
  · exact .inl hy
  · exact ((h.injective.ne huv) (hx.trans hy.symm)).elim

lemma Aquaesulian.g_two {x y u v : G} (huv : u ≠ v) (hx : f x + f (-x) = u)
    (hy : f y + f (-y) = v) :
    f (x + y) = -(f (-x)) + -(f (-y)) + v ∨ f (x + y) = -(f (-x)) + -(f (-y)) + u := by
  refine h.pair_lemma ?_ ?_ ?_
  · simp [huv]
  · convert h x (-(f (-y))) using 2
    · rw [h.apply_neg_apply_neg, add_comm]
    · rw [← hx]
      abel
    · rw [← hx]
      abel_nf
    · rw [h.apply_neg_apply_neg, add_comm]
  · convert h y (-(f (-x))) using 2
    · rw [h.apply_neg_apply_neg]
    · rw [← hy]
      abel
    · rw [← hy]
      abel_nf
    · rw [h.apply_neg_apply_neg]

lemma Aquaesulian.u_eq_zero {x y u v : G} (huv : u ≠ v) (hx : f x + f (-x) = u)
    (hy : f y + f (-y) = v) (hxyv : f (x + y) = -(f (-x)) + -(f (-y)) + v) : u = 0 := by
  rw [← eq_sub_iff_add_eq, ← h.apply_neg_eq_neg_iff, neg_sub] at hx
  rw [add_comm, ← eq_sub_iff_add_eq] at hy
  have hc := h (x + y) (f (-x) - u)
  rw [hx, hxyv, neg_add_cancel_left, hy] at hc
  rcases hc with hc | hc
  · abel_nf at hc
    simpa using hc
  · nth_rw 2 [← h.apply_neg_apply_neg y] at hc
    rw [h.injective.eq_iff, hy] at hc
    abel_nf at hc
    simp [add_comm, huv] at hc

lemma Aquaesulian.u_eq_zero_or_v_eq_zero {x y u v : G} (huv : u ≠ v) (hx : f x + f (-x) = u)
    (hy : f y + f (-y) = v) : u = 0 ∨ v = 0 := by
  rcases h.g_two huv hx hy with hxy' | hxy'
  · exact .inl (h.u_eq_zero huv hx hy hxy')
  · rw [add_comm x y, add_comm (-(f (-x))) (-(f (-y)))] at hxy'
    exact .inr (h.u_eq_zero huv.symm hy hx hxy')

lemma Aquaesulian.card_le_two : #(Set.range (fun x ↦ f x + f (-x))) ≤ 2 := by
  classical
  by_cases hf : ∀ x, f x + f (-x) = 0
  · simp [hf]
  · rw [not_forall] at hf
    rcases hf with ⟨x, hx⟩
    suffices #(Set.range (fun x ↦ f x + f (-x))) ≤ (2 : ℕ) from mod_cast this
    rw [Cardinal.mk_le_iff_forall_finset_subset_card_le]
    intro s hs
    simp_rw [Set.subset_def, Set.mem_range] at hs
    refine (Finset.card_le_card_of_surjOn (fun x ↦ f x + f (-x)) ?_).trans
      (Finset.card_le_two (a := 0) (b := x))
    intro y hy
    rcases hs y hy with ⟨t, ht⟩
    simp only [Finset.coe_insert, Finset.coe_singleton, Set.mem_image, Set.mem_insert_iff,
               Set.mem_singleton_iff, exists_eq_or_imp, neg_zero, exists_eq_left, h.apply_zero,
               add_zero]
    by_cases h0 : y = 0
    · simp [h0]
    · refine .inr ?_
      by_contra hxy
      have huv := h.u_eq_zero_or_v_eq_zero hxy rfl ht
      simp [hx, h0] at huv

end General

lemma aquaesulian_iff_general {f : ℚ → ℚ} : Aquaesulian f ↔ General.Aquaesulian f := by
  rw [Aquaesulian, General.Aquaesulian]
  refine forall_congr' (fun x ↦ forall_congr' (fun y ↦ ?_))
  rw [add_comm x]

lemma Aquaesulian.card_le_two {f : ℚ → ℚ} (h : Aquaesulian f) :
    #(Set.range (fun x ↦ f x + f (-x))) ≤ 2 := by
  rw [aquaesulian_iff_general] at h
  exact h.card_le_two

/-- An example of a function achieving the maximum number of values of `f(r)+f(-r)`. -/
def fExample (x : ℚ) : ℚ := ⌊x⌋ - Int.fract x

lemma fExample_add (x y : ℚ) : fExample x + y = ⌊x⌋ + ⌊y⌋ + (Int.fract y - Int.fract x) := by
  rw [fExample]
  nth_rw 1 [← Int.floor_add_fract y]
  abel

lemma add_fExample (x y : ℚ) : x + fExample y = ⌊x⌋ + ⌊y⌋ + (Int.fract x - Int.fract y) := by
  rw [add_comm, fExample_add]
  abel

lemma fExample_int_add (x : ℤ) (y : ℚ) : fExample (x + y) = x + fExample y := by
  simp_rw [fExample, Int.floor_intCast_add, Int.fract_intCast_add, ← add_sub_assoc]
  exact_mod_cast rfl

lemma fExample_of_mem_Ico {x : ℚ} (h : x ∈ Set.Ico 0 1) : fExample x = -x := by
  rw [fExample, Int.fract_eq_self.2 h, Int.floor_eq_zero_iff.2 h]
  simp

lemma apply_fExample_add_apply_of_fract_le {x y : ℚ} (h : Int.fract y ≤ Int.fract x) :
    fExample (x + fExample y) = fExample x + y := by
  rw [← sub_nonneg] at h
  have h₁ : Int.fract x - Int.fract y < 1 :=
    (sub_le_self (Int.fract x) (Int.fract_nonneg y)).trans_lt (Int.fract_lt_one x)
  rw [fExample_add, add_fExample, add_assoc, fExample_int_add, fExample_int_add,
      fExample_of_mem_Ico ⟨h, h₁⟩]
  abel

lemma aquaesulian_fExample : Aquaesulian fExample := by
  intro x y
  rcases lt_or_ge (Int.fract x) (Int.fract y) with h | h
  · rw [add_comm (fExample x), add_comm x]
    exact .inr (apply_fExample_add_apply_of_fract_le h.le)
  · exact .inl (apply_fExample_add_apply_of_fract_le h)

lemma fract_fExample (x : ℚ) :
    Int.fract (fExample x) = if Int.fract x = 0 then 0 else 1 - Int.fract x := by
  by_cases h : Int.fract x = 0
  · simp [fExample, h]
  · simp [fExample, h, sub_eq_add_neg, Int.fract_neg]

lemma floor_fExample (x : ℚ) :
    ⌊fExample x⌋ = if Int.fract x = 0 then x else ⌊x⌋ - 1 := by
  by_cases h : Int.fract x = 0
  · simp only [h, if_true, fExample, sub_zero, Int.floor_intCast]
    rw [Int.fract, sub_eq_zero] at h
    exact h.symm
  · simp only [h, if_false, fExample, sub_eq_add_neg, Int.floor_intCast_add, Int.cast_add,
               add_right_inj]
    suffices ⌊-Int.fract x⌋ = -1 from mod_cast this
    rw [Int.floor_eq_iff]
    simp [(Int.fract_nonneg x).lt_of_ne' h, (Int.fract_lt_one x).le]

lemma card_range_fExample : #(Set.range (fun x ↦ fExample x + fExample (-x))) = 2 := by
  have h : Set.range (fun x ↦ fExample x + fExample (-x)) = {0, -2} := by
    ext x
    simp only [Set.mem_range, Set.mem_insert_iff, Set.mem_singleton_iff]
    refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
    · rcases h with ⟨y, rfl⟩
      rw [← Int.floor_add_fract (fExample y), ← Int.floor_add_fract (fExample (-y))]
      by_cases h : Int.fract y = 0
      · simp [fract_fExample, floor_fExample, h]
      · refine .inr ?_
        simp only [fract_fExample, floor_fExample, h, if_false, sub_add_sub_cancel,
                   Int.fract_neg_eq_zero]
        rw [Int.fract_neg h, Int.floor_neg, Int.cast_neg, Int.ceil_eq_add_one_sub_fract h,
            ← Int.self_sub_fract]
        abel_nf
        simp
    · rcases h with rfl | rfl
      · refine ⟨0, by simp [fExample]⟩
      · refine ⟨1 / 2, ?_⟩
        rw [(by norm_num : (-(1 / 2) : ℚ) = (-1 : ℤ) + (1 / 2 : ℚ)), fExample_int_add,
            fExample_of_mem_Ico ⟨by norm_num, by norm_num⟩]
        norm_num
  rw [h]
  simp


noncomputable def solution : ℕ := 2

theorem imo2024_p6 :
    (∀ f, Aquaesulian f → #(Set.range (fun x ↦ f x + f (-x))) ≤ solution) ∧
    ∀ c : ℕ,
      (∀ f, Aquaesulian f → #(Set.range (fun x ↦ f x + f (-x))) ≤ c) →
        solution ≤ c := by
  refine ⟨fun _ ↦ Aquaesulian.card_le_two, fun c h ↦ ?_⟩
  replace h := h fExample aquaesulian_fExample
  rw [card_range_fExample] at h
  exact_mod_cast h

end Imo2024P6

-- ═══ Imo2025P3 ═══

/-
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reuven Peleg (Problem statement) , Shahar Blumentzvaig
-/




/-!
# International Mathematical Olympiad 2025, Problem 3

Let N denote the set of positive integers.

A function f : N → N is said to be bonza if f(a) divides b ^ a − f(b) ^ f(a) for
all positive integers a and b.

Determine the smallest real constant c such that f(n) ⩽ cn for all bonza functions f
and all positive integers n.
-/
open Int



lemma fermat_little_theorem: ∀p:ℕ+, (Nat.Prime (p:ℕ)) → (∀a:ℕ, (a^(p:ℕ)≡a [MOD p])) := by
  intro p hp a
  by_cases h1:(p:ℕ)∣a
  · rw [←Nat.modEq_zero_iff_dvd] at h1
    have h2: a ^ (p:ℕ) ≡ 0 ^ (p:ℕ) [MOD p] := by
      exact Nat.ModEq.pow (p:ℕ) h1
    simp at h2
    apply Nat.ModEq.symm at h1
    exact Nat.ModEq.trans h2 h1
  · have h2 : (p:ℕ).Coprime a := (Nat.Prime.coprime_iff_not_dvd hp).mpr h1
    apply Nat.Coprime.symm at h2
    have h3 := Nat.ModEq.pow_totient h2
    rw [Nat.totient_prime hp] at h3
    have h4 : a≡a [MOD p] := Nat.ModEq.rfl
    have h5 := Nat.ModEq.mul h3 h4
    simp at h5
    exact h5

lemma fermat_little_theorem2: ∀p:ℕ+, (Nat.Prime (p:ℕ)) → (∀a:ℕ, ∀k:ℕ, (a^((p:ℕ)^k)≡a [MOD p])) := by
  intro p hp a k
  induction k with
  | zero => 
    simp
    rfl
  | succ d hd => 
    rw [Nat.pow_add,Nat.mul_comm,Nat.pow_mul]
    simp
    have g1 := fermat_little_theorem p hp a
    have g2 := Nat.ModEq.pow ((p:ℕ) ^ d) g1
    exact Nat.ModEq.trans g2 hd

lemma int_dvd_to_nat_dvd : ∀a:ℕ+, ∀ b:ℕ , (a:ℤ)∣(b:ℤ) → (a:ℕ)∣b := by
  intro a b h1
  exact ofNat_dvd.mp h1



def Bonza (f : ℕ+ → ℕ+) : Prop :=
  ∀ a b : ℕ+,
    (f a : Int) ∣ ((b : Int) ^ (a: ℕ) - (f b : Int) ^ ((f a): ℕ))

def is_valid_c (c : ℝ) : Prop :=
  ∀ (f : ℕ+ → ℕ+), Bonza f → ∀ n, (f n : ℝ) ≤ c * (n : ℝ)

noncomputable def answer : ℝ := 4

theorem imo2025_p3 :
  IsLeast {c: ℝ | is_valid_c c} answer := by
    unfold answer
    unfold IsLeast
    constructor
    · simp
      unfold is_valid_c
      intro f hf
      unfold Bonza at hf
      intro n

      have h1 : ∀ a:ℕ+, (f a : Int) ∣ (a^(a :ℕ)) := by
        intro a
        specialize hf a a
        have g1 : (f a : Int) ∣ (f a : Int) ^ (f a : ℕ) := by
          simp
        have g2 := dvd_add hf g1
        simp at g2
        exact g2

      by_cases h2 : ∀b:ℕ+, f b <= b
      · specialize h2 n
        have g2 : (f n : ℝ) ≤ (n : ℝ) := by
          simp
          exact h2
        have g3 : (n : ℝ) ≤ 4*(n : ℝ) := by
          simp
        exact le_trans g2 g3
      · have h3 : ∀p:ℕ+, (Nat.Prime (p:ℕ)) → (∃ k ≤ ↑p, (f p) = p ^ (k:ℕ)) := by
          intro p hp
          specialize h1 p
          have g1 : (f p : ℕ) ∣ (p : ℕ)^(p:ℕ) := by
            have r1 := int_dvd_to_nat_dvd (f p) ((p:ℕ)^(p:ℕ))
            simp at r1
            apply r1 at h1
            exact h1
          rw[Nat.dvd_prime_pow hp] at g1
          obtain ⟨k,hk⟩ := g1
          use k
          constructor
          · exact hk.1
          · exact PNat.coe_inj.mp hk.2

        have h4 : ∀p:ℕ+, (Nat.Prime (p:ℕ)) → (f p = 1 ∨ p ∣ f p) := by
          intro p hp
          specialize h3 p hp
          obtain ⟨i,hi⟩ := h3
          induction i with
          | zero =>
            simp at hi
            exact Or.inl hi
          | succ d hd =>
            have hi2 := hi.2
            apply Or.inr
            rw [hi2]
            simp

        have h5 : ∃N:ℕ+, ∀p:ℕ+, (p>N ∧ Nat.Prime (p : ℕ)) → (f p = 1) := by
          push_neg at h2
          obtain ⟨b,hb⟩ := h2
          use (f b - b)
          intro p hp
          obtain ⟨hp1,hp2⟩ := hp
          specialize hf p b
          by_contra hnp
          specialize h4 p hp2
          rcases h4 with r1|r1
          · exact hnp r1
          · have r2 : (p:ℤ) ∣ (f p : ℤ) := by
              obtain ⟨x,hx⟩ := r1
              use x
              rw [hx]
              simp

            have r3 := dvd_trans r2 hf

            have r4 := r3
            rw [←Nat.cast_pow,←Nat.cast_pow] at r4
            rw [←Nat.modEq_iff_dvd] at r4

            have r5 := fermat_little_theorem p hp2 (b:ℕ)

            have r6 := Nat.ModEq.trans r4 r5

            specialize h3 p hp2
            obtain ⟨k,hk⟩ := h3
            obtain ⟨hk1,hk2⟩ := hk
            rw [hk2] at r6
            simp at r6

            have r7 : (f b :ℕ) ^ (p:ℕ) ^ k ≡ (f b) [MOD ↑p] := by
              exact fermat_little_theorem2 p hp2 (↑(f b)) k
            rw [Nat.ModEq.comm] at r7
            have r8 := Nat.ModEq.trans r7 r6
            rw [Nat.modEq_iff_dvd] at r8
            have r9 : (p:ℤ) ∣ (f b : ℤ) - (b:ℤ) := dvd_sub_comm.mp r8
            have g1 : (f b : ℤ) - (b:ℤ)≥0 := by
              simp
              exact Nat.le_of_lt hb
            have g2: (f b : ℤ) - (b:ℤ) < (p:ℤ) := by
              simp at hp1
              rw [←PNat.coe_lt_coe] at hp1
              have t : (b:ℕ) ≤ (f b :ℕ) := by
                linarith
              rw [←Nat.cast_sub t]
              simp
              have g2' := PNat.sub_coe (f b) b
              rw [if_pos hb] at g2'
              rw [g2'] at hp1
              exact hp1
            have g3 := Int.eq_zero_of_dvd_of_nonneg_of_lt g1 g2 r9
            have g4 : (f b : ℤ) = (b : ℤ) := by lia
            simp at g4
            rw [g4] at hb
            simp at hb

        have h6 : ∀p:ℕ+, (Nat.Prime p) ∧ (p≠2) → f p = 1 := by
          intro p hp
          obtain ⟨hp1,hp2⟩ := hp

          have r1 : IsUnit ((2:ℕ) : ZMod p) := by
            rw [ZMod.isUnit_iff_coprime 2 (p:ℕ)]
            simp
            have hp3 : (p:ℕ)≠2 := by
              by_contra y1
              have y2 : 2=((2:ℕ+):ℕ) := by
                simp
              rw [y2] at y1
              rw [PNat.coe_inj] at y1
              exact hp2 y1
            exact Nat.Prime.odd_of_ne_two hp1 hp3

          have r2 := Nat.infinite_setOf_prime_and_eq_mod (a := (2 : ZMod p)) r1
          obtain ⟨x,hx⟩ := h5
          have r3 := Set.Infinite.exists_gt r2 x
          obtain ⟨q2,htq⟩ := r3
          obtain ⟨htq1,htq2⟩ := htq
          simp at htq1
          obtain ⟨htq1,htq3⟩ := htq1
          have r4 : 0<q2 := by
            exact Nat.zero_lt_of_lt htq2
          let q :ℕ+ := ⟨q2,r4⟩
          have hq1 : Nat.Prime q := by
            unfold q
            simp
            exact htq1
          have hq2 : x < q := by
            unfold q
            exact htq2
          have hq3 : (q:ZMod p)=2 := by
            unfold q
            simp
            exact htq3
          clear htq1 htq2 htq3 r1 r2

          specialize hx q

          have r5 : (q > x ∧ Nat.Prime (q:ℕ)) := by
            exact And.intro hq2 hq1
          apply hx at r5

          specialize hf p q
          specialize h4 p hp1
          rcases h4 with h4|h4
          · exact h4
          · exfalso
            have r6 : (p:ℤ) ∣ (f p : ℤ) := by
              apply Nat.cast_dvd_cast
              exact PNat.dvd_iff.mp h4
            have r7 := Int.dvd_trans r6 hf
            rw [←Nat.cast_pow,←Nat.cast_pow] at r7
            rw [←Nat.modEq_iff_dvd] at r7
            rw [r5] at r7
            simp at r7
            have r8 := fermat_little_theorem p hp1 (q:ℕ)
            have r9 := Nat.ModEq.trans r7 r8
            have r10 : 2 ≡ ↑q [MOD ↑p] := by
              exact (ZMod.natCast_eq_natCast_iff 2 ↑q ↑p).mp (id (Eq.symm hq3))
            rw [Nat.ModEq.comm] at r10
            have r11 := Nat.ModEq.trans r9 r10
            rw [Nat.modEq_iff_dvd] at r11
            simp at r11
            apply int_dvd_to_nat_dvd p 1 at r11
            apply Nat.Prime.not_dvd_one hp1 at r11
            exact r11

        have h7 : ∀a:ℕ+, ∀p:ℕ+, (Nat.Prime p) ∧ (p∣f a) → p=2 := by
          intro a p hp
          obtain ⟨hp1,hp2⟩ := hp
          by_contra r1
          push_neg at r1
          specialize h6 p (And.intro hp1 r1)
          specialize hf a p
          rw [h6] at hf
          simp at hf
          have r2 : (p:ℤ) ∣ (f a :ℤ) := by
            apply Nat.cast_dvd_cast
            exact PNat.dvd_iff.mp hp2
          have r3 := Int.dvd_trans r2 hf
          have r4 : (p:ℤ) ∣ (p:ℤ) ^ (a:ℕ) := by
            simp
          have r5 := Int.dvd_sub r4 r3
          simp at r5
          apply int_dvd_to_nat_dvd p 1 at r5
          exact Nat.Prime.not_dvd_one hp1 r5

        have h8 : ∀a:ℕ+, ∃k:ℕ, (f a:ℕ) = 2^k := by
          intro a
          specialize h7 a
          have s := Nat.factorization (f a)
          use (f a:ℕ).factorization 2

          have r1 : ∀ (p : ℕ), Nat.Prime p ∧ p ∣ (f a :ℕ) → p = 2 := by
            intro p hp
            obtain ⟨hp1,hp2⟩ := hp
            have hppos : p>0 := by
              exact Nat.zero_lt_of_ne_zero (Nat.Prime.ne_zero hp1)
            let q :ℕ+ := ⟨p,hppos⟩
            have hq1 : Nat.Prime (q:ℕ) := by
              unfold q
              simp
              exact hp1
            have hq2 : q ∣ f a := by
              unfold q
              exact PNat.dvd_iff.mpr hp2
            clear hp1 hp2
            specialize h7 q (And.intro hq1 hq2)
            unfold q at h7
            rw [←PNat.coe_inj] at h7
            simp at h7
            exact h7
          have r2 : (f a : ℕ).factorization.support ⊆ {2} := by
            intro q hq
            simp at hq
            exact Finset.mem_singleton.mpr (r1 q hq)
          have r3 := Nat.factorization_prod_pow_eq_self (Nat.ne_zero_iff_zero_lt.2 (f a).2)
          symm at r3
          have r4 := Finsupp.prod_of_support_subset ((f a :ℕ).factorization) r2 (fun x1 x2 => x1 ^ x2)
          simp at r4
          exact r4

        have h9 : f 3 = 1 := by
          specialize h4 3 (by decide)
          rcases h4 with h4|h4
          · exact h4
          · specialize h7 3 3 (And.intro (by decide) h4)
            exfalso
            simp at h7

        have h10 : ∀a:ℕ+, (Even (a:ℕ)) → ((f a :ℕ).factorization 2 ≤ (a:ℕ).factorization 2 + 2) := by
          intro a ha
          specialize hf a 3
          rw [h9] at hf
          simp at hf
          have g1 : (f a:ℕ) ≠ 0 := by
            simp
          have g2 : (a:ℕ) ≠ 0 := by
            simp
          rw [←Nat.multiplicity_eq_factorization (by decide) g1]
          rw [←Nat.multiplicity_eq_factorization (by decide) g2]
          clear g1 g2
          have r1 : emultiplicity 2 (f a:ℕ) = multiplicity 2 (f a:ℕ) := by
            apply FiniteMultiplicity.emultiplicity_eq_multiplicity
            apply Nat.finiteMultiplicity_iff.mpr
            simp
          have r2 : emultiplicity 2 (a:ℕ) = multiplicity 2 (a:ℕ) := by
            apply FiniteMultiplicity.emultiplicity_eq_multiplicity
            apply Nat.finiteMultiplicity_iff.mpr
            simp
          have r3 : emultiplicity 2 (f a:ℕ) ≤ emultiplicity 2 (a:ℕ) + 2 := by
            have g1 : emultiplicity 2 (f a :ℕ) ≤ emultiplicity 2 (3 ^ (a:ℕ) - 1) := by
              have y1 : (f a :ℕ) ∣ 3 ^ (a:ℕ) - 1 := by
                have t : (f a : ℤ) ∣ ((3 ^ (a:ℕ) - 1 : ℕ):ℤ) := by
                  simp
                  exact hf
                exact int_dvd_to_nat_dvd (f a) (3 ^ (a:ℕ) - 1) t
              exact emultiplicity_le_emultiplicity_of_dvd_right y1

            have y1 : 2∣3-1 := by decide
            have y2 : ¬2∣3 := by decide
            have g2 := Nat.two_pow_sub_pow y1 y2 ha

            simp at g2
            clear y1 y2

            have g3 : emultiplicity 2 2 = 1 := by
              apply FiniteMultiplicity.emultiplicity_self
              rw [Nat.finiteMultiplicity_iff]
              simp
            have g4 : emultiplicity 2 4 = 2 := by
              have y1 : 4=2^2 := by decide
              rw [y1]
              rw [Nat.Prime.emultiplicity_pow_self (by decide)]
              simp
            rw [g3,g4] at g2
            have g5 : emultiplicity 2 (3 ^ (a:ℕ) - 1) = emultiplicity 2 (a:ℕ) + 2 := by
              have y1 : FiniteMultiplicity 2 (3 ^ (a:ℕ) - 1) := by
                apply Nat.finiteMultiplicity_iff.mpr
                simp
              have y2 : FiniteMultiplicity 2 (a:ℕ) :=
                finiteMultiplicity_of_emultiplicity_eq_natCast r2
              rw [FiniteMultiplicity.emultiplicity_eq_multiplicity y1,FiniteMultiplicity.emultiplicity_eq_multiplicity y2] at g2
              rw [FiniteMultiplicity.emultiplicity_eq_multiplicity y1,FiniteMultiplicity.emultiplicity_eq_multiplicity y2]
              have y3 : 1 = ((1:ℕ):ENat) := by
                simp
              have y4 : 2 = ((2:ℕ):ENat) := by
                simp
              rw [y3,y4] at g2
              rw [←ENat.coe_add,←ENat.coe_add,←ENat.coe_add] at g2
              rw [ENat.coe_inj] at g2
              rw [y4]
              rw [←ENat.coe_add]
              rw [ENat.coe_inj]
              grind
            exact le_of_le_of_eq g1 g5
          rw [r1,r2] at r3
          exact ENat.coe_le_coe.mp r3

        have h11 : ∀ (a : ℕ+), Even (a:ℕ) → (f a:ℤ) ≤ 4*(a:ℤ) := by
          intro a ha
          specialize h10 a ha
          specialize h8 a
          obtain ⟨k,hk⟩ := h8
          rw [hk] at h10
          simp at h10
          rw [Nat.Prime.factorization_self (by decide)] at h10
          simp at h10
          rw [hk]
          simp
          have r1 : 2^k ≤ 2^((a:ℕ).factorization 2 + 2) := by
            have g1 : 2>0 := by decide
            exact Nat.pow_le_pow_right g1 h10
          have r2 : 2 ^ (Nat.factorization (a:ℕ) 2) ∣ (a:ℕ) := Nat.ordProj_dvd (a:ℕ) 2
          have g2 : (a:ℕ)>0 := by
            simp
          have r3 := Nat.le_of_dvd g2 r2
          lia

        have h12 : ∀ (a : ℕ+), Odd (a:ℕ) → f a = 1 := by
          intro a ha
          specialize h1 a
          specialize h8 a
          obtain ⟨k,hk⟩ := h8
          rw [hk] at h1
          by_contra y1
          push_neg at y1
          have g1 : k≠0 := by
            by_contra y2
            rw [y2] at hk
            simp at hk
            exact y1 hk
          have g2 : 2 ∣ (((2:ℕ)^k):ℤ) := Dvd.dvd.pow (by decide) g1
          simp at h1
          have g3 := Int.dvd_trans g2 h1
          have g4 : 2 ∣ (a:ℕ) ^ (a:ℕ) := by
            obtain ⟨x,hx⟩ := g3
            use x.toNat
            have y2 : x = ((x.toNat):ℤ) :=by
              grind
            have y3 : 2 = ((2:ℕ):ℤ) :=by
              simp
            rw [y2,y3] at hx
            rw [←Nat.cast_mul] at hx
            grind
          apply Nat.Prime.dvd_of_dvd_pow (by decide) at g4
          rw [←Nat.not_even_iff_odd] at ha
          rw [←even_iff_two_dvd] at g4
          exact ha g4

        have h13 : ∀ (a : ℕ+), Odd (a:ℕ) → (f a:ℝ) ≤4*(a:ℝ) := by
          intro a ha
          specialize h12 a ha
          rw [h12]
          simp
          have r1 : a≥1 := by
            simp
          have r2 : 4≤4*(a:ℝ) := by
            simp
            exact r1
          have r3 : (1:ℝ)≤(4:ℝ) := by
            simp
          exact le_trans r3 r2

        by_cases r : Even (n:ℕ)
        · specialize h11 n r
          have g1 : ((f n : ℤ):ℝ)≤((4*n:ℤ):ℝ) := cast_le.mpr h11
          simp at g1
          exact g1
        · rw [Nat.not_even_iff_odd] at r
          exact h13 n r

    · unfold lowerBounds
      simp
      intro c hc
      unfold is_valid_c at hc
      let f (n : ℕ+) : ℕ+ :=
        if n = 4 then 16
        else if Odd (n:ℕ) then 1
        else 2
      specialize hc f
      have h : Bonza f := by
        unfold Bonza
        intro a b
        by_cases r1: a = 4
        · have g1 : f a = 16 := if_pos r1
          by_cases t1: b = 4
          · have g2 : f b = 16 := if_pos t1
            rw [g1,g2,r1,t1]
            decide
          · by_cases t2: Odd (b:ℕ)
            · have g2 : f b = 1 := by grind
              rw [g1,g2,r1]
              simp
              have y1 : Odd (b:ℤ) := (odd_coe_nat ↑b).mpr t2
              have y2 := Int.eight_dvd_sq_sub_one_of_odd y1
              have y3 : Even ((b:ℕ)^2+1) := by
                apply Odd.add_one
                exact Odd.pow t2
              obtain ⟨x,hx⟩ := y2
              obtain ⟨y,hy⟩ := y3
              use x*y
              symm
              calc
                16*((x:ℤ)*y) = (8*(x:ℤ))*(y+y) := by ring
                _ = ((b:ℤ)^2-1)*(y+y) := by rw [hx]
                _ = ((b:ℤ)^2-1)*((y:ℕ)+y:ℕ) := by grind
                _ = ((b:ℤ)^2-1)*((b:ℤ)^2+1) := by
                  rw [←hy]
                  simp
                _ = ((b:ℤ)^4-1) := by ring
            · have g2 : f b = 2 := by grind
              rw [g1,g2,r1]
              simp
              rw [Nat.not_odd_iff_even] at t2
              obtain ⟨x,hx⟩ := t2
              have y1 : x+x=2*x := by
                exact Eq.symm (Nat.two_mul x)
              rw [y1] at hx
              rw [hx]
              simp
              have y2 : (2*(x:ℤ))^4 = 2^4*(x:ℤ)^4 := by
                grind
              lia
        · by_cases r2: Odd (a:ℕ)
          · have g1 : f a = 1 := by grind
            rw [g1]
            simp
          · have g1 : f a = 2 := by grind
            by_cases t1: b = 4
            · have g2 : f b = 16 := by grind
              rw [g1,g2,t1]
              simp
              have y1 : (2:ℤ) ∣ 4^(a:ℕ) := by
                apply Dvd.dvd.pow
                · decide
                · simp
              have y2 : (2:ℤ)∣ 256 := by
                decide
              exact Int.dvd_sub y1 y2
            · by_cases t2: Odd (b:ℕ)
              · have g2 : f b = 1 := by lia
                rw [g1,g2]
                simp
                have y1 : Odd (b:ℤ) := (odd_coe_nat _).mpr t2
                have y2 : Odd ((b:ℤ)^(a:ℕ)) := Odd.pow y1
                have y4 : Even ((b:ℤ)^(a:ℕ)-1) := by
                  apply even_sub_one.mpr
                  rw [not_even_iff_odd]
                  exact y2
                exact even_iff_two_dvd.mp y4

              · have g2 : f b = 2 := by lia
                rw [g1,g2]
                simp
                rw [Nat.not_odd_iff_even] at t2

                obtain ⟨x,hx⟩ := t2
                have y1 : x+x=2*x := by
                  exact Eq.symm (Nat.two_mul x)
                rw [y1] at hx
                rw [hx]
                simp
                have y2 : 2∣(2*(x:ℤ))^(a:ℕ) := by
                  apply Dvd.dvd.pow
                  · simp
                  · simp
                have y3 : (2:ℤ)∣4 := by
                  decide
                exact Int.dvd_sub y2 y3
      apply hc at h
      specialize h 4
      unfold f at h
      simp at h
      have y : (16:ℝ)=4*4 := by norm_num
      rw [y] at h
      simp at h
      exact h

-- ═══ India1998P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
Indian Mathematical Olympiad 1998, problem 1

(a) Show that the product of two numbers of the form a² + 3b² is again of that form.
(b) If an integer n is such that 7n is of the form a² + 3b², prove that n is also of that form.
-/

namespace India1998P1

theorem india1998_p1a (a₁ a₂ b₁ b₂ : ℤ) :
    (∃ a₃ b₃, (a₁^2 + 3 * b₁^2) * (a₂^2 + 3 * b₂^2) = (a₃^2 + 3 * b₃^2)) :=
  ⟨a₁ * a₂ + 3 * b₁ * b₂, ⟨a₁ * b₂ - b₁ * a₂, by ring⟩⟩

theorem india1998_p1b (n a b : ℤ) (hn : a^2 + 3 * b^2 = 7 * n) :
    (∃ a b : ℤ, a^2 + 3 * b^2 = n) := by
  let az : ZMod 7 := a
  let bz : ZMod 7 := b

  have h1 := calc az ^ 2 + 3 * bz ^ 2
        = (((a^2 + 3 * b^2) : ℤ) : ZMod 7) := by push_cast; rfl
      _ = 0 := by rw [hn, Int.cast_mul]; exact zero_mul _

  have h2 : (3 : ZMod 7) = -4 := rfl
  rw [h2] at h1
  have h9 : az^2 = (2 * bz)^2 := by linear_combination h1
  have : Fact (Nat.Prime 7) := ⟨by norm_num⟩
  have h22 : (7:ℤ) * 7 ≠ 0 := by norm_num
  obtain (hep : az = 2 * bz) | (hen : az = - (2 * bz)) := eq_or_eq_neg_of_sq_eq_sq _ _ h9
  · have h11 : 2 * az + 3 * bz = 0 := by rw [h2]; linear_combination 2 * hep
    have h13 : 7 ∣ (2 * a + 3 * b) := by
      have h50 : (((2 * a + 3 * b):ℤ) : ZMod 7) = 0 := by
        dsimp [az,bz] at h11; norm_cast at h11
      exact (ZMod.intCast_zmod_eq_zero_iff_dvd _ 7).mp h50

    obtain ⟨m1, hm1⟩ := exists_eq_mul_right_of_dvd h13
    have h15 : (az + (- 2) * bz) = 0 := by rw [hep]; ring_nf
    have h16 : 7 ∣ (a + (-2) * b) := by
      have h50 : (((a + (-2) * b):ℤ) : ZMod 7) = 0 := by
        dsimp [az, bz] at h15; norm_cast at h15
      exact (ZMod.intCast_zmod_eq_zero_iff_dvd _ 7).mp h50
    obtain ⟨m2, hm2⟩ := exists_eq_mul_right_of_dvd h16
    use m1; use m2
    have h20 : (7 * m1) ^ 2 + 3 * (7 * m2) ^ 2 = 7 * 7 * n := by
      rw [←hm1, ←hm2]; linear_combination 7 * hn

    exact (mul_right_inj' h22).mp (by linear_combination h20)

  · have h11 : 2 * az + (-3) * bz = 0 := by rw [h2]; linear_combination 2 * hen
    have h13 : 7 ∣ (2 * a + (-3) * b) := by
      have h50 : (((2 * a + (-3) * b):ℤ) : ZMod 7) = 0 := by
        dsimp [az, bz] at h11; norm_cast at h11
      exact (ZMod.intCast_zmod_eq_zero_iff_dvd _ 7).mp h50

    obtain ⟨m1, hm1⟩ := exists_eq_mul_right_of_dvd h13
    have h15 : az + 2 * bz = 0 := by rw [hen]; ring_nf
    have h16 : 7 ∣ (a + 2 * b) := by
      have h50 : (((a + 2 * b):ℤ) : ZMod 7) = 0 := by
        dsimp [az, bz] at h15; norm_cast at h15
      exact (ZMod.intCast_zmod_eq_zero_iff_dvd _ 7).mp h50

    obtain ⟨m2, hm2⟩ := exists_eq_mul_right_of_dvd h16
    use m1; use m2
    have h20 : (7 * m1) ^ 2 + 3 * (7 * m2) ^ 2 = 7 * 7 * n := by
      rw [←hm1, ←hm2]; linear_combination 7 * hn

    exact (mul_right_inj' h22).mp (by linear_combination h20)


end India1998P1

-- ═══ IntegersInACircle ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
There are 101 positive integers arranged in a circle.
Suppose that the integers sum to 300.
Prove that there exists a contiguous subarray that sums to 200.

https://mathstodon.xyz/@alexdbolton/110292738044661739
https://math.stackexchange.com/questions/282589/101-positive-integers-placed-on-a-circle
-/

namespace IntegersInACircle



lemma lemma1 {a : ℤ} (h1 : a % 100 = 0) (h2 : 0 < a) (h3 : a < 300) :
    a = 200 ∨ a = 100 := by
  lia

lemma lemma2 {f : ZMod 101 → ℤ} (y : ZMod 101)
    : ∑ z : ZMod 101, f z = ∑ i ∈ Finset.range 101, f (y + i) := by
  let g := λ (i:ℕ) ↦ y + (i:ZMod 101)
  have hg: ∀ (x : ℕ),
      x ∈ Finset.range 101 → ∀ (y : ℕ), y ∈ Finset.range 101 → g x = g y → x = y := by
    intro a ha b hb hgab
    dsimp [g] at hgab
    have h5 : (a : ZMod 101) = (b : ZMod 101) := by linear_combination hgab
    have h8: a % 101 = b % 101 := Iff.mp (ZMod.natCast_eq_natCast_iff' a b 101) h5
    rw [Finset.mem_range] at ha hb
    rwa [Nat.mod_eq_of_lt ha, Nat.mod_eq_of_lt hb] at h8
  replace hg : Set.InjOn g (Finset.range 101) := hg
  rw [←Finset.sum_image hg]
  have h3 : Finset.image g (Finset.range 101) = Finset.univ := by
     rw [Finset.eq_univ_iff_forall]
     intro a
     rw [Finset.mem_image]
     use (a - y).val
     constructor
     · exact Finset.mem_range.mpr (ZMod.val_lt (a - y))
     · simp [g]
  rw[h3]



theorem integers_in_a_circle
    (a : ZMod 101 → ℤ)
    (ha : ∀ i, 1 ≤ a i)
    (ha_sum : ∑ i : ZMod 101, a i = 300)
    : ∃ j : ZMod 101, ∃ n : ℕ, ∑ i ∈ Finset.range n, a (j + i) = 200 := by
  -- informal solution (from the math.stackexchange link above)
  -- Start at any position and form sums of subsequences of length 0, 1, ... 100
  -- starting at that position.

  let f : ZMod 101 → ℤ := λ x ↦ ∑ i ∈ Finset.range x.val, a i

  -- By the pigeonhole principle, two of these sums are equivalent mod 100.
  obtain ⟨x,y,hxy',hfxy⟩ := Fintype.exists_ne_map_eq_of_card_lt (Int.cast ∘ f)
            (Nat.lt_add_one (Fintype.card (ZMod 100)))

  dsimp only [Function.comp_apply] at hfxy
  rw[ZMod.intCast_eq_intCast_iff] at hfxy

  wlog hxy : x.val < y.val with H
  · obtain he | hle := Iff.mp le_iff_eq_or_lt (Nat.not_lt.mp hxy)
    · exact (hxy'.symm (Fin.ext he)).elim
    · exact H a ha ha_sum y x hxy'.symm hfxy.symm hle

  have h1 : 0 < ∑ i ∈ Finset.Ico x.val y.val, a ↑i := by
    refine Finset.sum_pos ?_ (Finset.nonempty_Ico.mpr hxy)
    aesop

  have h8 : (Finset.Ico x.val y.val).card < 101 := by
     rw [Nat.card_Ico]
     have hy': y.val - x.val ≤ y.val := Nat.sub_le _ _
     exact lt_of_le_of_lt hy' y.prop

  have h7 :
    ((Finset.Ico x.val y.val).image
     (λ (i:ℕ) ↦ (i : ZMod 101))).card < (@Finset.univ (ZMod 101)).card :=
    calc _ ≤ (Finset.Ico x.val y.val).card := Finset.card_image_le
         _ < 101 := h8

  have h4 : ∑ i ∈ Finset.Ico x.val y.val, a ↑i < 300 := by
    have h10 : ∀ a ∈ Finset.Ico x.val y.val,
               ∀ b ∈ Finset.Ico x.val y.val, (a : ZMod 101) = b → a = b := by
      intro a ha b hb hab
      have h13 : a % 101 = b % 101 := (ZMod.natCast_eq_natCast_iff' a b 101).mp hab
      rw [Finset.mem_Ico] at ha hb
      rwa [Nat.mod_eq_of_lt (ha.2.trans y.prop),
           Nat.mod_eq_of_lt (hb.2.trans y.prop)] at h13
    replace h10 : Set.InjOn Nat.cast _ := h10
    rw [←Finset.sum_image h10, ←ha_sum]
    have h9 : (Finset.Ico x.val y.val).image (λ i:ℕ ↦ (i : ZMod 101)) ⊂ Finset.univ := by
      rw [Finset.ssubset_univ_iff]
      intro hn
      rw [hn] at h7
      lia
    rw [Finset.ssubset_iff] at h9
    obtain ⟨z, hzn, _⟩ := h9
    exact Finset.sum_lt_sum_of_subset (Finset.subset_univ _)
      (Finset.mem_univ z) hzn (ha z) (λ j _ _ ↦ Int.le_of_lt (ha j))

  -- The difference between those sums is either 100 or 200.

  have h3 : (∑ i ∈ Finset.Ico x.val y.val, a ↑i) ≡ 0 [ZMOD 100] := by
     have h4 : x.val ≤ y.val := LT.lt.le hxy
     rw [Finset.sum_Ico_eq_sub _ h4, Int.modEq_zero_iff_dvd]
     exact Int.ModEq.dvd hfxy

  have h12 : ∀ k, k ∈ Finset.range (y.val - x.val) → a ↑(x.val + k) = a (x + ↑k) := by
      intro k hk
      congr
      have h15: k < 101 := by
         rw [Finset.mem_range] at hk
         calc k < y.val - x.val := hk
              _ ≤ y.val := Nat.sub_le _ _
              _ < 101 := y.prop
      exact (Nat.mod_eq_of_lt h15).symm

  -- If it's 200, then we choose that subsequence.
  -- If it's 100, then we choose its complement.
  obtain h200 | h100 := lemma1 h3 h1 h4
  · use x
    use y.val - x.val
    rw [Finset.sum_Ico_eq_sum_range] at h200
    rwa [Finset.sum_congr rfl h12] at h200
  · use y.val
    use 101 - (y.val - x.val)
    rw [Finset.sum_Ico_eq_sum_range, Finset.sum_congr rfl h12] at h100
    rw [lemma2 x] at ha_sum
    have h20 : 101 = ((y.val - x.val) + (101 - (y.val - x.val))) := by
      have : y.val - x.val ≤ 101 :=
           calc _ ≤ y.val := Nat.sub_le _ _
                _ ≤ 101 := le_of_lt y.prop
      rw [add_comm]
      exact Iff.mp (Nat.sub_eq_iff_eq_add this) rfl

    have h18 : Finset.range 101 =
        Finset.range ((y.val - x.val) + (101 - (y.val - x.val))) := by congr
    have h19 := Finset.sum_range_add (λi ↦ a (x + i)) (y.val - x.val) (101 - (y.val - x.val))
    rw [h100, ←h18, ha_sum] at h19
    have h21 : ∀ i ∈ Finset.range (101 - (y.val - x.val)),
          a (x + ↑(y.val - x.val + i)) = a (↑(ZMod.val y) + ↑i) := by
      intro i _
      apply congr_arg
      have h22 : x + ↑(y.val - x.val + i) = ↑(x.val + (y.val - x.val + i)) :=
        by have : x = (x.val : ZMod 101) := Eq.symm (ZMod.natCast_zmod_val x)
           nth_rewrite 1 [this]
           norm_cast
      rw [h22]
      norm_cast
      rw [←Nat.add_assoc, add_comm x.val _, Nat.sub_add_cancel (le_of_lt hxy)]

    rw [Finset.sum_congr rfl h21] at h19
    lia


end IntegersInACircle

-- ═══ Iran1998P3 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# Iranian Mathematical Olympiad 1998, problem 3

Let x₁, x₂, x₃, x₄ be positive real numbers such that

  x₁ ⬝ x₂ ⬝ x₃ ⬝ x₄ = 1.

Prove that
  x₁³ + x₂³ + x₃³ + x₄³ ≥ max(x₁ + x₂ + x₃ + x₄, 1/x₁ + 1/x₂ + 1/x₃ + 1/x₄).

-/

namespace Iran1998P3



lemma cube_root_cube (x : ℝ) (h : 0 ≤ x) : (x^(3:ℝ)) ^ ((1:ℝ)/3) = x := by
  rw [←Real.rpow_mul h, mul_div_cancel₀ (1 : ℝ) three_ne_zero]
  exact Real.rpow_one x



theorem iran1998_p3
    (x : ℕ → ℝ)
    (x_positive : ∀ i, 0 < x i)
    (h : ∏ i ∈ Finset.range 4, x i = 1)
    : max (∑ i ∈ Finset.range 4, x i) (∑ i ∈ Finset.range 4, 1 / x i)
     ≤ ∑ i ∈ Finset.range 4, (x i)^(3 : ℝ) := by
  -- Follows the proof in _Mathematical Olympiads 1998-1999_
  -- by Titu Andreescu and Zuming Feng

  rw [max_le_iff]
  constructor
  · have amgm' := Real.geom_mean_le_arith_mean_weighted
                    (Finset.range 4)
                    (fun ii ↦ (1:ℝ)/4)
                    x
                    (by intro i _; norm_num)
                    (by simp)
                    (by intro j _; exact le_of_lt (x_positive j))
    have xnonneg : ∀ i ∈ Finset.range 4, 0 ≤ x i := by
      intro i _; exact le_of_lt (x_positive i)
    rw [Real.finset_prod_rpow (Finset.range 4) x xnonneg, h, Real.one_rpow] at amgm'
    dsimp at amgm'
    rw [←Finset.mul_sum] at amgm'

    let C := 1/4 * ∑ i ∈ Finset.range 4, x i
    have hcp' : 0 ≤ ∑ i ∈ Finset.range 4, x i := Finset.sum_nonneg xnonneg
    have hcp : 0 ≤ C := mul_nonneg (by norm_num) hcp'
    have hccp : 0 ≤ C * C := mul_nonneg hcp hcp

    have hCC : C * C * C = C^(3:ℝ) := by norm_cast; ring
    have hC := calc C
                ≤ C * C := le_mul_of_one_le_left hcp amgm'
              _ ≤ C * C * C := le_mul_of_one_le_right hccp amgm'
              _ = C^(3 : ℝ) := hCC

    have h13 : (1:ℝ) ≤ 3 := by norm_num
    have holder := Real.rpow_sum_le_const_mul_sum_rpow (Finset.range 4) x h13

    have habs : ∀ i ∈ Finset.range 4, |x i| = x i := by
      intro i _; exact abs_of_pos (x_positive i)
    rw [Finset.sum_congr rfl habs] at holder

    have habs3 : ∀ i ∈ Finset.range 4, |x i| ^ (3:ℝ) = x i ^ (3:ℝ) := by
      intro i hi; have := habs i hi; exact congr_fun (congr_arg _ this) 3
    rw [Finset.sum_congr rfl habs3] at holder
    have hccc: (4:ℝ) * C =  ∑ i ∈ Finset.range 4, x i := by simp [C]
    rw [←hccc] at holder

    rw [Real.mul_rpow zero_le_four hcp] at holder

    rw [Finset.card_range 4] at holder

    have hss: C ^ (3:ℝ) ≤ ((1:ℝ) / 4) * ∑ i ∈ Finset.range 4, x i ^ (3:ℝ) := by
      have h32 : (3:ℝ) - 1 = 2 := by norm_num
      rw [h32] at holder
      -- clear_except holder
      have hknn : (0:ℝ) ≤ (4:ℝ) ^ (-3 : ℝ) := by norm_num1
      have hh := mul_le_mul_of_nonneg_left holder hknn
      rw [←mul_assoc] at hh
      have h4mm: (4:ℝ) ^ (-3: ℝ) * (4:ℝ) ^ (3:ℝ) = 1 := by norm_num1
      rw [h4mm, one_mul, ←mul_assoc] at hh
      have h4mm': (4:ℝ) ^ (-3: ℝ) * ((4:ℕ):ℝ) ^ (2:ℝ) = 1/4 := by norm_num1
      rw [h4mm'] at hh
      exact hh

    have htrans := le_trans hC hss
    have hm4 : 4 * C ≤ 4 * ((1/4) * ∑ i ∈ Finset.range 4, x i ^ (3:ℝ)) :=
      mul_le_mul_of_nonneg_left htrans zero_le_four

    rw [hccc] at hm4
    have hro : 4 * (1 / 4 * ∑ i ∈ Finset.range 4, x i ^ (3:ℝ)) =
                    ∑ i ∈ Finset.range 4, x i ^ (3:ℝ) := by
      field_simp

    rw [hro] at hm4
    exact hm4

  · let A := ∑ i ∈ Finset.range 4, (x i)^(3:ℝ)
    let B : ℕ → ℝ := fun j ↦ (∑ i ∈ (Finset.range 4).erase j, (x i)^(3:ℝ))
    have hab : A = (1/3) * (∑ i ∈ Finset.range 4, B i) := by
      simp (config := {decide := true}) [Finset.sum_range_succ, A, B]; ring
    have h2 : ∀ j ∈ (Finset.range 4), ∏ i ∈ (Finset.range 4).erase j, x i ≤ (1/3) * B j := by
      intro j hj
      have hcard1 : (Finset.range 4).card = 4 := Finset.card_range 4
      have hcard : ((Finset.range 4).erase j).card = (Finset.range 4).card - 1 :=
        Finset.card_erase_of_mem hj
      rw [hcard1] at hcard
      norm_num at hcard

      have amgm := Real.geom_mean_le_arith_mean_weighted
                    ((Finset.range 4).erase j)
                    (fun ii ↦ (1:ℝ)/3)
                    (fun ii ↦ x ii ^ (3:ℝ))
                    (by intro i _; positivity)
                    (by simp [hcard])
                    (by intro i _; exact Real.rpow_nonneg (le_of_lt (x_positive i)) 3)
      have hr : ∀ i ∈ ((Finset.range 4).erase j),
                   (fun (ii : ℕ) ↦ x ii ^ (3:ℝ)) i ^ (fun (ii : ℕ) ↦ (1:ℝ) / 3) i = x i := by
        intro i _; exact cube_root_cube _ (le_of_lt (x_positive i))
      rw [Finset.prod_congr rfl hr] at amgm
      have hs : ∀ i ∈ ((Finset.range 4).erase j),
        (fun (ii : ℕ) ↦ (1:ℝ) / 3) i * (fun (ii : ℕ) ↦ x ii ^ (3:ℝ)) i =
         ((1:ℝ)/3) * x i ^ (3:ℝ) := by simp
      rw [Finset.sum_congr rfl hs, ←Finset.mul_sum] at amgm
      exact amgm
    have h3 : ∀ j ∈ (Finset.range 4), ∏ i ∈ (Finset.range 4).erase j, x i = 1 / x j := by
      intro j hj
      rw [←h, ←Finset.prod_erase_mul _ _ hj]
      have : x j ≠ 0 := ne_of_gt (x_positive j)
      field_simp
    have h4 : ∀ j ∈ Finset.range 4, 1 / x j ≤ 1 / 3 * B j := by
      intro j hj
      have h2j := h2 j hj
      rw [h3 j hj] at h2j
      exact h2j
    have h5 : ∑ i ∈ Finset.range 4, 1 / x i ≤ A := by
      have h5': ∑ i ∈ Finset.range 4, 1 / x i ≤ ∑ i ∈ Finset.range 4, (1 / 3) * B i :=
        Finset.sum_le_sum h4
      rw [←Finset.mul_sum] at h5'
      rw [hab]
      exact h5'
    exact h5


end Iran1998P3

-- ═══ Iran1998P9 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/






/-!
# Iranian Mathematical Olympiad 1998, Problem 9

Let x,y,z > 1 and 1/x + 1/y + 1/z = 2. Prove that

  √(x + y + z) ≥ √(x - 1) + √(y - 1) + √(z - 1).

-/

namespace Iran1998P9



lemma compute_norm (v : EuclideanSpace ℝ (Fin 3)) : ‖v‖ = Real.sqrt (∑i : Fin 3, (v i)^2) := by
  rw[EuclideanSpace.norm_eq v]
  congr; ext
  rw [Real.norm_eq_abs, sq_abs]



theorem iran1998_p9
    (x y z : ℝ)
    (hx : 1 < x)
    (hy : 1 < y)
    (hz : 1 < z)
    (h : 1/x + 1/y + 1/z = 2) :
    √(x - 1) + √(y - 1) + √(z - 1) ≤ √(x + y + z) := by
  -- Follows the proof in _Mathematical Olympiads 1998-1999_
  -- by Titu Andreescu and Zuming Feng

  -- By cauchy schwarz,
  -- √(x + y + z) √((x-1)/x + (y-1)/y + (z-1)/z) ≥ √(x - 1) + √(y - 1) + √(z - 1).
  --
  -- On the other hand, by hypothesis,
  -- (x-1)/x + (y-1)/y + (z-1)/z = 1.
  --
  -- The desired result follows.

  have hx0 : 0 ≤ x := by positivity
  have hy0 : 0 ≤ y := by positivity
  have hz0 : 0 ≤ z := by positivity

  have hx1 : 0 ≤ x - 1 := by linarith
  have hy1 : 0 ≤ y - 1 := by linarith
  have hz1 : 0 ≤ z - 1 := by linarith

  let v₁ : EuclideanSpace ℝ (Fin 3) := !₂[Real.sqrt x, Real.sqrt y, Real.sqrt z]
  let v₂ : EuclideanSpace ℝ (Fin 3) :=
      !₂[Real.sqrt ((x - 1)/x), Real.sqrt ((y-1)/y), Real.sqrt ((z-1)/z)]

  have cauchy_schwarz := abs_real_inner_le_norm v₁ v₂

  have hv₁ : ‖v₁‖ = Real.sqrt (x + y + z) := by
    have hn := compute_norm v₁
    rw [Fin.sum_univ_three] at hn
    have hv1 : v₁ 0 = Real.sqrt x := rfl
    have hv2 : v₁ 1 = Real.sqrt y := rfl
    have hv3 : v₁ 2 = Real.sqrt z := rfl
    rw [hv1, hv2, hv3] at hn
    have hxx : (Real.sqrt x) ^ 2 = x := Real.sq_sqrt hx0
    have hyy : (Real.sqrt y) ^ 2 = y := Real.sq_sqrt hy0
    have hzz : (Real.sqrt z) ^ 2 = z := Real.sq_sqrt hz0

    rwa [hxx, hyy, hzz] at hn

  have hv₂ : ‖v₂‖ = 1 := by
    have hn := compute_norm v₂
    rw [Fin.sum_univ_three] at hn
    have hv1 : v₂ 0 = Real.sqrt ((x-1)/x) := rfl
    have hv2 : v₂ 1 = Real.sqrt ((y-1)/y) := rfl
    have hv3 : v₂ 2 = Real.sqrt ((z-1)/z) := rfl
    rw [hv1, hv2, hv3] at hn
    have hxx : 0 ≤ (x-1)/x := div_nonneg hx1 hx0
    have hxx' : Real.sqrt (((x - 1) / x)) ^2 = (x - 1) / x := Real.sq_sqrt hxx

    have hyy : 0 ≤ (y-1)/y := div_nonneg hy1 hy0
    have hyy' : Real.sqrt (((y - 1) / y)) ^2 = (y - 1) / y := Real.sq_sqrt hyy

    have hzz : 0 ≤ (z-1)/z := div_nonneg hz1 hz0
    have hzz' : Real.sqrt (((z - 1) / z)) ^2 = (z - 1) / z := Real.sq_sqrt hzz

    rw[hxx', hyy', hzz'] at hn
    have hfs: (x - 1) / x + (y - 1) / y + (z - 1) / z = 3 - (1/x + 1/y + 1/z) := by
      field_simp; ring
    rw[hfs, h] at hn
    have ha: (3: ℝ) - 2 = 1 := by norm_num
    rw[hn, ha]
    exact Real.sqrt_one

  rw [hv₁, hv₂, mul_one] at cauchy_schwarz

  have hinner :=
    calc ((inner _ v₁ v₂): ℝ)
          = ((inner _ v₂ v₁): ℝ) := real_inner_comm _ _
        _ = ∑ i : Fin 3, v₁ i * v₂ i := rfl
        _ = v₁ 0 * v₂ 0 + v₁ 1 * v₂ 1 + v₁ 2 * v₂ 2 := Fin.sum_univ_three _
        _ = Real.sqrt x * Real.sqrt ((x - 1) / x) +
            Real.sqrt y * Real.sqrt ((y - 1) / y) +
            Real.sqrt z * Real.sqrt ((z - 1) / z) := rfl

  have hxxx : x * ((x - 1) / x) = x - 1 := by field_simp
  have hyyy : y * ((y - 1) / y) = y - 1 := by field_simp
  have hzzz : z * ((z - 1) / z) = z - 1 := by field_simp

  rw [←Real.sqrt_mul hx0 ((x - 1) / x),
      ←Real.sqrt_mul hy0 ((y - 1) / y),
      ←Real.sqrt_mul hz0 ((z - 1) / z),
      hxxx, hyyy, hzzz] at hinner

  rw [hinner] at cauchy_schwarz
  exact le_of_abs_le cauchy_schwarz


end Iran1998P9

-- ═══ KolmogorovStreams ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!

Puzzle referenced from this tweet: https://twitter.com/sigfpe/status/1474173467016589323

From the book _Out of their Minds: The Lives and Discoveries of 15 Great Computer Scientists_
by Dennis Shasha and Cathy Lazere.


Problem: Suppose each (finite) word is either "decent" or "indecent". Given an infinite
sequence of characters, can you always break it into finite words so that all of them
except perhaps the first one belong to the same class?

-/

namespace KolmogorovStreams
open scoped Stream'

variable {α : Type}

def break_into_words :
   (Stream' ℕ) → -- word lengths
   (Stream' α) → -- original sequence
   (Stream' (List α)) -- sequence of words
 := Function.curry
     (Stream'.corec
       (fun ⟨lengths, a'⟩ ↦ a'.take lengths.head)
       (fun ⟨lengths, a'⟩ ↦ ⟨lengths.tail, a'.drop lengths.head⟩))



--#eval ((break_into_words id id).take 10 )

/--
Dropping the first word is equivalent to dropping `first_length` symbols of the original stream.
-/
lemma break_into_words_cons
    (lengths : Stream' ℕ)
    (first_length : ℕ)
    (a : Stream' α) :
    (break_into_words (first_length::lengths) a).tail =
           break_into_words lengths (a.drop first_length) := by
  simp [break_into_words, Stream'.corec, Stream'.tail_map, Stream'.tail_iterate]

lemma break_into_words_closed_form
    (lengths : Stream' ℕ)
    (a : Stream' α)
   : break_into_words lengths a =
      (fun i ↦ Stream'.take (lengths i) (Stream'.drop (∑ j ∈ Finset.range i, lengths j) a)) := by
  funext n
  convert_to ((Stream'.corec (fun x ↦ Stream'.take (x.fst.head) x.snd)
                 (fun x ↦ ⟨x.fst.tail, Stream'.drop (x.fst.head) x.snd⟩)) :
                  Stream' ℕ × Stream' α → Stream' (List α)) ⟨lengths, a⟩ n =
             Stream'.take (lengths n) (Stream'.drop (∑ j ∈ Finset.range n, lengths j) a)
  rw [Stream'.corec_def,Stream'.map]
  congr
  · revert a lengths
    induction n with
    | zero => intro a b; rfl
    | succ pn hpn =>
      intro a b
      rw [Stream'.get_succ, Stream'.iterate_eq, Stream'.tail_cons, hpn]
      rfl
  · revert a lengths
    induction n with
    | zero => intro a b; rfl
    | succ pn hpn =>
      intro a b
      rw [Stream'.get_succ, Stream'.iterate_eq, Stream'.tail_cons, hpn,
          Stream'.drop_drop, Finset.sum_range_succ']
      rw [Nat.add_comm]
      congr


def all_prefixes (p : List α → Prop) (a : Stream' α) : Prop := a.inits.All p

lemma take_prefix
    (is_decent : List α → Prop)
    (a : Stream' α)
    (ha : all_prefixes is_decent a)
    (n : ℕ)
    (hn : 0 < n) : is_decent (a.take n) := by
  cases n with
  | zero => exfalso; exact Nat.lt_asymm hn hn
  | succ n =>
    have ht := ha n
    rwa [Stream'.get_inits] at ht

structure decent_word (a : Stream' α) (is_decent : List α → Prop) : Type where
  (start : ℕ)
  (length : ℕ)
  (nonempty : 0 < length)
  (h : is_decent ((a.drop start).take length))

structure decent_accumulator (a : Stream' α) (is_decent : List α → Prop) : Type where
  (start : ℕ)
  (prefix_decent : all_prefixes is_decent (a.drop start))

noncomputable def choose_decent_words
    (is_decent : List α → Prop)
    (a : Stream' α)
    (hinit : all_prefixes is_decent a)
    (hnot : ∀ (n : ℕ), ∃ (k : ℕ), 0 < k ∧
            all_prefixes is_decent (a.drop (n + k)))
     : Stream' (decent_word a is_decent) :=
  Stream'.corec (fun (acc: decent_accumulator a is_decent) ↦
                  let new_word_length := Classical.choose (hnot acc.start)
                  let new_word_nonempty := (Classical.choose_spec (hnot acc.start)).1
                  ⟨acc.start, new_word_length, new_word_nonempty,
                   take_prefix
                    is_decent _ acc.prefix_decent new_word_length new_word_nonempty⟩)
             (fun acc ↦ ⟨acc.start + Classical.choose (hnot acc.start),
                         (Classical.choose_spec (hnot acc.start)).2⟩)
             ⟨0, hinit⟩

lemma chosen_decent_closed_form
    (is_decent : List α → Prop)
    (a : Stream' α)
    (hinit : all_prefixes is_decent a)
    (hnot : ∀ (n : ℕ), ∃ (k : ℕ), 0 < k ∧
            all_prefixes is_decent (a.drop (n + k)))
    : ∀ n : ℕ, (((choose_decent_words is_decent a hinit hnot).get n).start =
              ∑ j ∈ Finset.range n, ((choose_decent_words is_decent a hinit hnot).get j).length)
            := by
  intro n
  induction n with
  | zero => rfl
  | succ n pn => rw [Finset.sum_range_succ, ← pn]; rfl

lemma check_decent_words
    (is_decent : List α → Prop)
    (a : Stream' α)
    (hinit : all_prefixes is_decent a)
    (hnot : ∀ (n : ℕ), ∃ (k : ℕ), 0 < k ∧
             all_prefixes is_decent (a.drop (n + k)))
    : Stream'.All
      is_decent
      (break_into_words
          (fun i ↦ ((choose_decent_words is_decent a hinit hnot).get i).length) a) := by
  rw [break_into_words_closed_form]
  simp_rw [←chosen_decent_closed_form]
  intro j
  exact ((choose_decent_words is_decent a hinit hnot).get j).h

structure indecent_word (a : Stream' α) (is_decent : List α → Prop) : Type where
  (start : ℕ)
  (length : ℕ)
  (nonempty : 0 < length)
  (h : ¬is_decent ((a.drop start).take length))

lemma not_all_prefixes
    (is_decent : List α → Prop)
    (a : Stream' α)
    (h : ¬ all_prefixes is_decent a) :
    ∃ n, ¬ is_decent (a.take (Nat.succ n)) := by
  simp[all_prefixes, Stream'.all_def] at h
  exact h

/-
 accumulator is: n, the number of symbols consumed so far
-/
noncomputable def choose_indecent_words
    (is_decent : List α → Prop)
    (a : Stream' α)
    (h : ∀ (k : ℕ), ¬all_prefixes is_decent (a.drop k))
     : Stream' (indecent_word a is_decent) :=
Stream'.corec (fun n ↦ let hd := not_all_prefixes is_decent (a.drop n) (h n)
                       let new_word_length := Nat.succ (Classical.choose hd)
                       let hh := (Classical.choose_spec hd)
                       ⟨n, new_word_length, Nat.succ_pos _, hh⟩
              )
              (fun n ↦ let hd := not_all_prefixes is_decent (a.drop n) (h n)
                       let new_word_length := Nat.succ (Classical.choose hd)
                       n + new_word_length)
              0

lemma chosen_indecent_closed_form
    (is_decent : List α → Prop)
    (a : Stream' α)
    (h : ∀ (k : ℕ), ¬all_prefixes is_decent (a.drop k))
    : ∀ n : ℕ, (((choose_indecent_words is_decent a h).get n).start =
                ∑ j ∈ Finset.range n, ((choose_indecent_words is_decent a h).get j).length)
             := by
  intro n
  induction n with
  | zero => rfl
  | succ n pn =>
    rw [Finset.sum_range_succ, ← pn]
    rfl

lemma check_indecent_words
    (is_decent : List α → Prop)
    (a : Stream' α)
    (h : ∀ (k : ℕ), ¬all_prefixes is_decent (a.drop k))
    : Stream'.All
      (fun x ↦ ¬ is_decent x)
      (break_into_words
          (fun i ↦ ((choose_indecent_words is_decent a h).get i).length)
          a) := by
  rw [break_into_words_closed_form]
  simp_rw [←chosen_indecent_closed_form]
  intro j
  exact ((choose_indecent_words is_decent a h).get j).h



def all_same_class
    (is_decent : List α → Prop)
    (b : Stream' (List α))
    : Prop :=
  b.All is_decent ∨ b.All (fun w ↦ ¬is_decent w)

theorem kolmogorov_streams
    (is_decent : List α → Prop)
    (a : Stream' α)
    : (∃ (lengths : Stream' ℕ),
       (lengths.All (0 < ·) ∧
        all_same_class is_decent (break_into_words lengths a).tail)) := by
  let p : Prop :=
     (∃ (n : ℕ), ∀ (k : ℕ), 0 < k → ¬all_prefixes is_decent (a.drop (n + k)))

  obtain h | hnot := Classical.em p
  · obtain ⟨n, hn⟩ := h
    let a' := a.drop (n + 1)
    have hn' : ∀ (k : ℕ), ¬all_prefixes is_decent (a'.drop k) := by
      intro k
      have hnk := hn (k + 1) (Nat.succ_pos _)
      rwa [Stream'.drop_drop, Nat.add_right_comm]
    let d := choose_indecent_words is_decent a' hn'
    use n.succ::(fun i ↦ (d.get i).length)
    constructor
    · intro i
      cases i with
      | zero => exact Nat.succ_pos n
      | succ i => exact (d.get i).nonempty
    · right
      rw [break_into_words_cons]
      exact check_indecent_words is_decent a' hn'

  · unfold p at hnot; push_neg at hnot
    obtain ⟨k, hkp, hinit⟩ := hnot 0
    have hdka : a.drop (0 + k) = a.drop k := by { rw [←Stream'.drop_drop]; rfl }
    rw [hdka] at hinit
    let a' := a.drop k
    have hnot' : ∀ (n : ℕ), ∃ (k : ℕ), 0 < k ∧ all_prefixes is_decent (a'.drop (n + k)) := by
      intro n'
      obtain ⟨k', hk0', hk'⟩ := hnot (k + n')
      use k'
      constructor
      · exact hk0'
      · have hd: (a.drop (k + n' + k')) = (a'.drop (n' + k')) := by
          rw [Stream'.drop_drop]
          ring_nf
        rwa [←hd]
    let d := choose_decent_words is_decent a' hinit hnot'
    use k::(fun i ↦ (d.get i).length)
    constructor
    · intro i
      cases i with
      | zero => exact hkp
      | succ i => exact (d.get i).nonempty
    · left
      rw [break_into_words_cons]
      exact check_decent_words is_decent a' hinit hnot'


end KolmogorovStreams

-- ═══ Poland1998P4 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
Polish Mathematical Olympiad 1998, Problem 4

Prove that the sequence {a_n} defined by a_1 = 1 and

     a_n = a_{n - 1} + a_{⌊n/2⌋}        n = 2,3,4,...

contains infinitely many integers divisible by 7.

-/

namespace Poland1998P4

def a : ℕ → ℕ
| 0 => 1 -- unused dummy value
| 1 => 1
| Nat.succ n =>
    have _ : (n.succ / 2) < n.succ := Nat.div_lt_self' n 0
    a n + a (n.succ / 2)



lemma a_recurrence (n : ℕ) (hn : 2 ≤ n) : a n = a (n - 1) + a (n / 2) := by
  cases n with
  | zero => exact (Nat.not_succ_le_zero _ hn).elim
  | succ n =>
    cases n
    · exact (Nat.not_succ_le_self _ hn).elim
    · simp only [a, Nat.succ_sub_succ_eq_sub, tsub_zero]

def a' : ℕ → ZMod 7
| n => ⟨(a n) % 7, Nat.mod_lt _ (by norm_num)⟩

lemma a'_recurrence (n : ℕ) (hn : 2 ≤ n) : a' n = a' (n - 1) + a' (n / 2) := by
  have : (a' n).val = (a' (n - 1) + a' (n / 2)).val := by
    rw [ZMod.val_add]
    simp_rw [a', a_recurrence n hn]
    rw [ZMod.val]
    simp
  exact ZMod.val_injective 7 this

lemma lemma3
    (N0 : ℕ)
    (k : ZMod 7)
    (hk : k ≠ 0)
    (hN : ∀ i : ℕ, i < 7 → a' (N0 + i) = a' N0 + k * i) :
    (∃ i : ℕ, i < 7 ∧ a' (N0 + i) = 0) := by
  have hp : Fact (Nat.Prime 7) := ⟨by norm_num⟩
  let ii := - (a' N0) / k
  use ii.val
  constructor
  · exact ZMod.val_lt ii
  · have := hN ii.val (ZMod.val_lt ii)
    rw [this, ZMod.natCast_val, ZMod.cast_id', id_def, mul_div_cancel₀ _ hk]
    exact add_neg_cancel (a' N0)

lemma can_get_a_later_one_zmod :
    (∀ N : ℕ, a' N = 0 → (∃ M : ℕ, N < M ∧ a' M = 0)) := by
  intro n hn

  obtain (hlt : n < 2) | (hlte : 2 ≤ n) := lt_or_ge n 2
  · exact ⟨5, Nat.le.step <| Nat.le.step <| Nat.le.step hlt, by simp [a', a]⟩

  let n1 : ℕ := 2 * (n - 1) + 1

  -- a' (2 * n - 1), a' (2 * n), and a' (2 * n + 1) are all equal

  have hn1v : n1 = 2 * n - 1 := by lia
  have hn2 : 2 ≤ n1 + 1 := Nat.succ_le_succ le_add_self

  let an1 := a' n1

  have hn1 : (n1 + 1) = 2 * n := by lia

  have ha1 : a' (n1 + 1) = an1 + a' n := by
    have haa : a' (n1 + 1) = a' n1 + a' (n1.succ / 2) := a'_recurrence (n1 + 1) hn2
    have h2n1 : 2 * n / 2 = n := by norm_num
    have h2n1' : (n1 + 1) / 2 = n := by rw [hn1, h2n1]
    rw [haa, h2n1']

  have ha2 : a' (n1 + 2) = a' (n1 + 1) +  a' n := by
    have haa : a' (n1 + 2) = a' (n1 + 1) + a' (n1.succ.succ / 2) :=
      a'_recurrence (n1 + 2) le_add_self
    have h1 : (2 * n + 1) / 2 = n := by lia
    have hn1v' : 2 * n = n1 + 1 := hn1.symm
    rw [haa]
    congr
    have : n1.succ.succ = (n1 + 1 + 1) := rfl
    rw [this, ←hn1v', h1]

  have ha1' : a' (n1 + 1) = a' n1 := by grind
  have ha2' : a' (n1 + 2) = a' n1 := by grind

  clear ha1 ha2

  -- then the seven elements beginning with a (4 * n - 3) will all have different
  -- residues mod 7.

/-

  let n4 := 4 * n - 3,
  -- a (n4 + 1) = a n4 + a n1
  -- a (n4 + 2) = a (n4 + 1) + a n1
  -- a (n4 + 3) = a (n4 + 2) + a (n1 + 1)
  -- a (n4 + 4) = a (n4 + 3) + a (n1 + 1)
  -- a (n4 + 5) = a (n4 + 4) + a (n1 + 2)
  -- a (n4 + 6) = a (n4 + 5) + a (n1 + 2)

-/

  -- n2 = 4 * n - 3
  --   = 4 * (n - 1) + 1
  let n2 : ℕ := 4 * (n - 1) + 1

  have hii : ∀ i, i < 6 → a' (n2 + i + 1) = a' (n2 + i) + a' n1 := by
    intro i hi
    have hn2ge2 : 2 ≤ n2 + i + 1 := by lia
    have hr := a'_recurrence (n2 + i + 1) hn2ge2
    grind

  have hik : ∀ i, i < 7 → a' (n2 + i) = a' n2 + a' n1 * i := by
    intro i
    induction' i with p hp
    · simp
    · intro hpi7
      have hpi6 : p < 6 := Nat.succ_lt_succ_iff.mp hpi7
      have hinc := hii p hpi6
      have hadd : n2 + p + 1 = n2 + p.succ := rfl
      have hi6 : p < 7 := Nat.lt_succ_of_lt hpi6
      have hpp := hp hi6
      have hp1: (p.succ : ZMod 7) = (p : ZMod 7) + 1 := Nat.cast_succ p
      rw [←hadd, hinc, hpp, hp1]
      ring

  obtain (haez : a' n1 = 0) | (hanez : ¬ a' n1 = 0) := em (a' n1 = 0)
  · use n1
    constructor
    · lia
    · exact haez

  · have := lemma3 n2 (a' n1) hanez hik
    obtain ⟨ii, _, hia'⟩ := this
    use (n2 + ii)
    constructor
    · lia
    · assumption

lemma can_get_a_later_one : (∀ N : ℕ, 7 ∣ a N → (∃ M : ℕ, N < M ∧ 7 ∣ a M)) := by
  intro n hn
  have ha' : a' n = 0 := by
    have : a' n = ⟨a n % 7, Nat.mod_lt _ (Nat.succ_pos _)⟩ := by simp[a']
    rw [this]
    simp only [Nat.mod_eq_zero_of_dvd hn, Fin.mk_zero]
  obtain ⟨m, hmgt, hm7⟩ := can_get_a_later_one_zmod n ha'
  use m
  use hmgt
  exact Fin.natCast_eq_zero.mp hm7

lemma strengthen
    {P : ℕ → Prop}
    (h : ∀ N : ℕ, P N → (∃ M : ℕ, N < M ∧ P M))
    (he : ∃ N : ℕ, P N) :
    (∀ N : ℕ, ∃ M : ℕ, N < M ∧ P M) := by
  obtain ⟨N0, hn0⟩ := he
  intro N
  induction' N with pn hpn
  · obtain ⟨M, left, right⟩ := h N0 hn0
    exact ⟨M, pos_of_gt left, right⟩
  · obtain ⟨m, hm, hmp⟩ := hpn
    obtain ⟨M, left, right⟩ := h m hmp
    exact ⟨M, by lia, right⟩

theorem poland1998_p4' : (∀ N : ℕ, ∃ M : ℕ, N < M ∧ 7 ∣ a M) := by
  have he : 7 ∣ a 5 := by simp [a]
  exact strengthen can_get_a_later_one ⟨5, he⟩



theorem poland1998_p4 : Set.Infinite { n | 7 ∣ a n } := by
  apply Set.infinite_of_not_bddAbove
  intro h
  rw [bddAbove_def] at h
  obtain ⟨x, hx⟩ := h
  obtain ⟨y, hy1, hy2⟩ := poland1998_p4' x
  exact Nat.lt_le_asymm hy1 (hx y hy2)


end Poland1998P4

-- ═══ Poland2016S1P8 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Kurkiewicz
-/





/-!
Polish Mathematical Olympiad 2016, Stage 1, Problem 8
Author of the problem: Nguyen Hung Son
Source of the problem: https://om.sem.edu.pl/static/app_main/problems/om68_1r.pdf

Let a, b, c be integers. Show that there exists a positive integer n, such that

  n³ + an² + bn + c

is not a square of any integer.
-/

namespace Poland2016S1P8



lemma even_of_add {a b : ℤ} (ha : Even a) (hb : Even (a + b)) : Even b := by
  rw [show b = a + b - a by ring]
  exact Even.sub hb ha

lemma div_4_mul_of_both_even {a b : ℤ } (H : Even a ∧ Even b) : 4 ∣ a * b := by
  obtain ⟨k, Hk⟩ := H.left
  obtain ⟨l, Hl⟩ := H.right
  use k * l
  rw[Hk]
  rw[Hl]
  ring



theorem poland2016_s1_p8 (a b c : ℤ) : ∃ n : ℤ, n > 0 ∧ ¬ IsSquare (n^3 + a * n^2 + b * n + c) := by
  apply not_forall_not.mp
  intro H
  apply H 1
  refine ⟨by positivity, ?_⟩
  rintro ⟨k, H1⟩
  apply H 2
  refine ⟨by positivity, ?_⟩
  rintro ⟨l, H2⟩
  apply H 3
  refine ⟨by positivity, ?_⟩
  rintro ⟨m, H3⟩
  apply H 4
  refine ⟨by positivity, ?_⟩
  rintro ⟨n, H4⟩
  have m_square_minus_k_square : m * m - k * k = 2 * (13 + 4 * a + b) := by lia
  have n_square_minus_l_square : n * n - l * l = 2 * (28 + 6 * a + b) := by lia
  have difference_m_square_k_square_as_product : m * m - k * k = (m + k) * (m - k) := by ring
  have difference_n_square_l_square_as_product : n * n - l * l = (n + l) * (n - l) := by ring
  have even_m_square_minus_k_square : Even ((m + k) * (m - k)) := by
    use 13 + 4 * a + b
    rw [← difference_m_square_k_square_as_product, m_square_minus_k_square]
    ring
  have even_n_square_minus_l_square : Even ((n + l) * (n - l)) := by
    use 28 + 6 * a + b
    rw [← difference_n_square_l_square_as_product, n_square_minus_l_square]
    ring
  have four_divides_m_square_minus_k_square : 4 ∣ (m + k) * (m - k) := by
    have both_factors_even_m_k : Even (m + k) ∧ Even (m - k) := by
      have either_even : (Even (m + k) ∨ Even (m - k)) :=
        Int.even_mul.mp even_m_square_minus_k_square
      obtain m_plus_k_even | m_minus_k_even := either_even
      · have : Even ((m + k) + (m - k)) := by
          use m
          ring
        have m_minus_k_even : Even (m - k) := even_of_add m_plus_k_even this
        constructor
        · exact m_plus_k_even
        · exact m_minus_k_even
      · have : Even ((m - k) + (m + k)) := by
          use m
          ring
        have m_plus_k_even : Even (m + k) := even_of_add m_minus_k_even this
        constructor
        · exact m_plus_k_even
        · exact m_minus_k_even
    exact div_4_mul_of_both_even both_factors_even_m_k
  have four_divides_n_square_minus_l_square : 4 ∣ (n + l) * (n - l) := by
    have both_factors_even_n_l : Even (n + l) ∧ Even (n - l) := by
      have either_even : (Even (n + l) ∨ (Even (n - l))) :=
        Int.even_mul.mp even_n_square_minus_l_square
      obtain n_plus_l_even | n_minus_l_even := either_even
      · have : Even ((n + l) + (n - l)) := by
          use n
          ring
        have n_minus_l_even : Even (n - l) := even_of_add n_plus_l_even this
        constructor
        · exact n_plus_l_even
        · exact n_minus_l_even
      · have : Even ((n - l) + (n + l)) := by
          use n
          ring
        have n_plus_l_even : Even (n + l) := even_of_add n_minus_l_even this
        constructor
        · exact n_plus_l_even
        · exact n_minus_l_even
    exact div_4_mul_of_both_even both_factors_even_n_l
  lia

end Poland2016S1P8

-- ═══ Romania1998P12 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# Romanian Mathematical Olympiad 1998, Problem 12

Find all functions u : ℝ → ℝ for which there exists a strictly monotonic
function f : ℝ → ℝ such that

  ∀ x,y ∈ ℝ, f(x + y) = f(x)u(y) + f(y)
-/

namespace Romania1998P12



/-
# Solution

f(x) = eᵏˣ for some k : ℝ.
-/

lemma extend_function_mono
   (u : ℝ → ℝ)
   (f : ℝ → ℝ)
   (u_mono : Monotone u)
   (f_cont : Continuous f)
   (h : ∀ x : ℚ, u x = f x) :
   ∀ x : ℝ, u x = f x := by
  -- suppose not.
  by_contra! hn

  -- then there is y such that u y ≠ f y
  obtain ⟨y, hy⟩ := hn
  let ε : ℝ := |u y - f y|
  have hε : 0 < ε := abs_sub_pos.mpr hy

  -- then find a δ such that for all z, |z-y| < δ implies that
  -- |f z - f y| < ε.
  obtain ⟨δ, hδ0, hδ⟩ := Metric.continuous_iff.mp f_cont y ε hε

  obtain h1 | h2 | h3 := lt_trichotomy (u y) (f y)
  · -- pick a rational point less than y that's in the ball s,
    have : ∃ z : ℚ, (z:ℝ) < y ∧ dist (z:ℝ) y < δ := by
      have hyδ : y - δ < y := sub_lt_self y hδ0
      obtain ⟨z, hz1, hz2⟩ := exists_rat_btwn hyδ
      refine ⟨z, hz2, ?_⟩
      rw [Real.dist_eq, abs_sub_comm, abs_of_pos (sub_pos.mpr hz2)]
      exact sub_lt_comm.mp hz1

    obtain ⟨z, h_z_lt_y, hyz⟩ := this
    -- then dist (f z) (f y) < ε.
    have hbzb := hδ z hyz
    rw [←h z] at hbzb
    have huzuy : u y < u z := by
      have hufp : u y - f y < 0 := by linarith
      have hua : ε = -(u y - f y) := abs_of_neg hufp
      rw [hua, Real.dist_eq] at hbzb
      obtain h5 | h6 := em (f y < u z)
      · linarith
      · have : u z - f y ≤ 0 := by linarith
        rw[abs_eq_neg_self.mpr this] at hbzb
        linarith
    -- so u(z) < u(y), contradicting u_mono.
    have h_y_le_z := le_of_lt  h_z_lt_y
    have := u_mono h_y_le_z
    linarith
  · exact hy h2

  · -- pick a rational point z greater than y that's in the ball s,
    have : ∃ z : ℚ, y < z ∧ dist (z:ℝ) y < δ := by
      have hyδ : y < y + δ := lt_add_of_pos_right y hδ0
      obtain ⟨z, hz1, hz2⟩ := exists_rat_btwn hyδ
      refine ⟨z, hz1, ?_⟩
      rw [Real.dist_eq, abs_of_pos (sub_pos.mpr hz1)]
      exact sub_left_lt_of_lt_add hz2
    obtain ⟨z, h_y_lt_z, hyz⟩ := this
    -- then dist (f z) (f y) < ε.
    have hbzb := hδ z hyz
    rw [←h z] at hbzb
    have huzuy : u z < u y := by
      have hufp : 0 < u y - f y := by linarith
      have hua : ε = u y - f y := abs_of_pos hufp
      rw [hua, Real.dist_eq] at hbzb
      cases em (f y < u z)
      · have : 0 ≤ u z - f y := by linarith
        rw[abs_eq_self.mpr this] at hbzb
        linarith
      · linarith
    -- so u(z) < u(y), contradicting u_mono.
    have h_y_le_z := le_of_lt h_y_lt_z
    have := u_mono h_y_le_z
    linarith

lemma extend_function_anti
   (u : ℝ → ℝ)
   (f : ℝ → ℝ)
   (u_anti : Antitone u)
   (f_cont : Continuous f)
   (h : ∀ x : ℚ, u x = f x) :
   ∀ x : ℝ, u x = f x := by
  -- suppose not.
  by_contra! hn

  -- then there is y such that u y ≠ f y
  obtain ⟨y, hy⟩ := hn
  let ε : ℝ := |u y - f y|
  have hε : 0 < ε := abs_sub_pos.mpr hy

  -- then find a δ such that for all z, |z-y| < δ implies that
  -- |f z - f y| < ε.
  obtain ⟨δ, hδ0, hδ⟩ := Metric.continuous_iff.mp f_cont y ε hε

  obtain h1 | h2 | h3 := lt_trichotomy (u y) (f y)
  · -- pick a rational point z greater than y that's in the ball s,
    have : ∃ z : ℚ, y < z ∧ dist (z:ℝ) y < δ := by
      have hyδ : y < y + δ := lt_add_of_pos_right y hδ0
      obtain ⟨z, hz1, hz2⟩ := exists_rat_btwn hyδ
      refine ⟨z, hz1, ?_⟩
      rw [Real.dist_eq, abs_of_pos (sub_pos.mpr hz1)]
      exact sub_left_lt_of_lt_add hz2

    obtain ⟨z, h_y_lt_z, hyz⟩ := this
    -- then dist (f z) (f y) < ε.
    have hbzb := hδ z hyz
    rw [← h z] at hbzb
    have huzuy : u y < u z := by
      have hufp : u y - f y < 0 := by linarith
      have hua : ε = -(u y - f y) := abs_of_neg hufp
      rw [hua, Real.dist_eq] at hbzb
      cases em (f y < u z)
      · linarith
      · have : u z - f y ≤ 0 := by linarith
        rw[abs_eq_neg_self.mpr this] at hbzb
        linarith
    have h_y_le_z := le_of_lt h_y_lt_z
    have := u_anti h_y_le_z
    linarith
  · exact hy h2
  · -- pick a rational point less than y that's in the ball s,
    have : ∃ z : ℚ, (z:ℝ) < y ∧ dist (z:ℝ) y < δ := by
      have hyδ : y - δ < y := sub_lt_self y hδ0
      obtain ⟨z, hz1, hz2⟩ := exists_rat_btwn hyδ
      refine ⟨z, hz2, ?_⟩
      rw [Real.dist_eq, abs_sub_comm, abs_of_pos (sub_pos.mpr hz2)]
      exact sub_lt_comm.mp hz1

    obtain ⟨z, h_z_lt_y, hyz⟩ := this
    -- then dist (f z) (f y) < ε.
    have hzb : (↑z) ∈ Metric.ball y δ := Metric.mem_ball.mpr hyz
    have hbzb := hδ z hzb
    rw[← h z] at hbzb
    have huzuy : u z < u y := by
      have hufp : 0 < u y - f y := by linarith
      have hua : ε = u y - f y := abs_of_pos hufp
      rw [hua, Real.dist_eq] at hbzb
      obtain h5 | h6 := em (f y < u z)
      · have : 0 ≤ u z - f y := by linarith
        rw[abs_eq_self.mpr this] at hbzb
        linarith
      · linarith only [h3, h6]
    have h_z_le_y := le_of_lt h_z_lt_y
    have := u_anti h_z_le_y
    linarith
  -- in either case, we end up contradicting u_anti.

lemma int_dichotomy (z : ℤ) : ∃ n : ℕ, (n:ℤ) = z ∨ -(n:ℤ) = z := by
  cases z with
  | ofNat z => use z; left; simp only [Int.ofNat_eq_natCast]
  | negSucc z =>  use z + 1; right; rfl

lemma exp_characterization
    (u : ℝ → ℝ)
    (hu : ∀ x y : ℝ, u (x + y) = u x * u y)
    (hu0 : u 0 = 1)
    (hm : StrictMono u ∨ StrictAnti u) :
    (∃ k : ℝ, ∀ x : ℝ, u x = Real.exp (k * x)) := by
  -- We have u(nx) = u(x)ⁿ for all n ∈ ℤ, x ∈ ℝ.
  have h1 : ∀ n : ℕ, ∀ x : ℝ, u (n * x) = (u x) ^ n := by
    intro n
    induction' n with pn hpn
    · intro x
      simp only [CharP.cast_eq_zero, zero_mul]
      exact hu0
    · intro x
      have hp1: ↑(pn.succ) * x = ↑pn * x + x := by
        have : ↑pn * x + x = (↑pn + 1) * x := by ring
        rw[this, Nat.cast_succ]
      rw[hp1, hu (↑pn * x) x, hpn x, mul_comm]
      exact (pow_succ' (u x) pn).symm

  have h2 : ∀ x, (u x) * u (-x) = 1 := by
    intro x
    have := hu x (-x)
    rw [add_neg_cancel] at this
    rw [←this]
    exact hu0

  have hunz : ∀ x, 0 < u x := fun x ↦ by
    by_contra! H
    obtain hlt | heq | hgt := lt_trichotomy x 0
    · have h10 := h2 x
      have hx0 : 0 < -x := neg_pos.mpr hlt
      obtain hm | hm := hm <;> nlinarith[hm hx0, hm hlt]
    · rw [heq, hu0] at H; linarith
    · have h10 := h2 x
      have hx0 : -x < 0 := neg_lt_zero.mpr hgt
      obtain hm | hm := hm <;> nlinarith [hm hx0, hm hgt]

  have h3 : ∀ x, u (-x) = 1 / (u x) :=
    fun x ↦ eq_one_div_of_mul_eq_one_right (h2 x)

  have h4 : ∀ z : ℤ, ∀ x : ℝ, u (z * x) = (u x) ^ z := by
    intro z x
    obtain ⟨n, hn⟩ := int_dichotomy z
    rcases hn with rfl | hn
    · have := h1 n x
      norm_cast at this
    · have h10 := h1 n x
      rw [←hn]
      have h11: ↑(-((↑n):ℤ)) * x = - (n * x) := by norm_num
      rw [h11, h3 _]
      rw [h10, one_div]
      simp

  -- Let eᵏ = u(1);
  obtain ⟨k, hk⟩ : ∃ k, Real.exp k = u 1 := by
    use Real.log (u 1); exact Real.exp_log (hunz 1)

  -- then u(n) = eᵏⁿ for all n ∈ ℕ
  have hnexp : ∀ n : ℕ, u n = Real.exp (k * n) := by
    intro n
    have h10 := h4 n 1
    rw [←hk, mul_one] at h10
    norm_cast at h10
    rw [h10, mul_comm]
    exact (Real.exp_nat_mul _ _).symm

  -- and u(p/q) = (u(p))^(1/q) = e^(k(p/q))
  -- for all p ∈ ℤ, q ∈ ℕ, so u(x) = e^(kx) for all x ∈ ℚ.
  have hzexp : ∀ z : ℤ, u z = Real.exp (k * z) := by
    intro z
    obtain ⟨n, hn⟩ := int_dichotomy z
    rcases hn with rfl | rfl
    · norm_cast
      exact hnexp n
    · have := h4 (-↑n) 1
      rw[mul_one] at this
      rw[this, ←hk]
      rw [Real.exp_mul]
      exact (Real.rpow_intCast _ _).symm

  have hp : ∀ p : ℕ, 0 < p → ∀ x : ℝ, u (x / p) = (u x) ^ (1 / (p:ℝ)) := by
    intro p hp x
    cases p with
    | zero => exfalso; exact Nat.lt_asymm hp hp
    | succ p =>
    have h12: ∀ n : ℕ, (u (x / p.succ))^n = u (x * n / p.succ) := by
      intro n
      induction' n with pn hpn
      · simp [hu0.symm]
      · have h10: x * ↑(pn.succ) / ↑(p.succ) = x * ↑pn / ↑(p.succ) + x / ↑(p.succ) := by
          simp [field]
        rw [h10]
        have h11 := hu (x * ↑pn / ↑(p.succ)) (x / ↑(p.succ))
        rw [h11, ← hpn]
        norm_cast
    replace h12 := h12 p.succ
    have h13 : x * ↑(p.succ) / ↑(p.succ) = x := mul_div_cancel_of_invertible _ _
    rw [h13] at h12
    rw [← h12]
    have h14: u (x / ↑(p.succ)) ^ p.succ = u (x / ↑(p.succ)) ^ (p.succ:ℝ) := by norm_cast
    rw [h14]
    have h15 := le_of_lt (hunz (x / ↑(p.succ)))
    rw [←Real.rpow_mul h15 _]
    field_simp
    simp

  have hq : ∀ q : ℚ, u q = Real.exp (k * q) := fun q ↦ by
    rw [Rat.cast_def q, hp q.den q.pos q.num, hzexp q.num, ←Real.exp_mul]
    ring_nf

  use k

  -- Since u in monotonic and the rationals are dense in ℝ, we have u(x) = e^(kx) for all x ∈ ℝ.
  -- Therefore all solutions of the form u(x) = e^(kx), k ∈ ℝ.
  let f := fun x ↦ Real.exp (k * x)
  have hf : ∀ q : ℚ, u q = f q := fun q ↦ hq q
  have hfm : Continuous f := by continuity
  obtain hm | hm := hm
  · have hmu : Monotone u := StrictMono.monotone hm
    exact extend_function_mono u f hmu hfm hf
  · have hau : Antitone u := StrictAnti.antitone hm
    exact extend_function_anti u f hau hfm hf


lemma exp_strict_mono' (k x y : ℝ) (hkp : 0 < k) (h : x < y) :
    Real.exp (k * x) < Real.exp (k * y) :=
  Real.exp_lt_exp.mpr ((mul_lt_mul_iff_right₀ hkp).mpr h)

lemma exp_strict_anti' (k x y : ℝ) (hkp : k < 0) (h : x < y) :
    Real.exp (k * y) < Real.exp (k * x) :=
  Real.exp_lt_exp.mpr (mul_lt_mul_of_neg_left h hkp)

lemma romania1998_p12_mp (u : ℝ → ℝ) :
    (∃ f : ℝ → ℝ, (StrictMono f ∨ StrictAnti f)
        ∧ ∀ x y : ℝ, f (x + y) = f x * u y + f y) →
    (∃ k : ℝ, ∀ x : ℝ, u x = Real.exp (k * x)) := by
  intro h
  obtain ⟨f, hm, hf⟩ := h
  -- First, letting y = 0, we obtain f(x) = f(x)u(0) + f(0) for all x ∈ ℝ,
  have hy0 : ∀ x : ℝ, f x = f x * u 0 + f 0 := by
    intro x; have := hf x 0; rw [add_zero] at this; exact this

  -- thus u(0) ≠ 1 would imply f(x) = f(0) / (1 - u(0)) for all x,
  have h0 : (u 0 ≠ 1) → ∀ x : ℝ, f x = f 0 / (1 - u 0) := by
    intro hu0 x
    have hy0x1 :=
                calc f 0 = f x - f x * u 0 := (sub_eq_of_eq_add' (hy0 x)).symm
                _ = f x * (1 - u 0) := by ring
    rw[hy0x1]
    have : 1 - u 0 ≠ 0 := sub_ne_zero.mpr hu0.symm
    field_simp

  -- which implies that f is constant, which we know is not the case
  have h0' : (u 0 ≠ 1) → False := by
    intro hu0
    have hu0' := h0 hu0
    obtain hm | hm := hm <;>
    · have hu00 := hu0' 0
      have hu01 := hu0' 1
      have hm0 := @hm 0 1 (by norm_num)
      linarith

  -- so we must have u(0) = 1
  have h00 : u 0 = 1 := not_not.mp h0'
  clear h0 h0'
  rw [h00] at hy0

  -- and f(0) = 0.
  have hf0 : f 0 = 0 := by have := hy0 0; linarith

  -- Then f(x) ≠ 0 for all x ≠ 0.
  have hfx0 : ∀ x, x ≠ 0 → f x ≠ 0 := by
    intro x hx
    obtain hm1 | hm2 := hm
    · obtain h1 | h2 | h3 := lt_trichotomy x 0
      · rw [←hf0];
        exact ne_of_lt (hm1 h1)
      · exfalso; exact hx h2
      · rw [←hf0]
        exact (ne_of_lt (hm1 h3)).symm
    · obtain h1 | h2 | h3 := lt_trichotomy x 0
      · have := hm2 h1
        rw [hf0] at this
        exact (ne_of_lt this).symm
      · exfalso; exact hx h2
      · have := hm2 h3
        rw [hf0] at this
        exact (ne_of_lt this)

  -- Next, we have
  -- f(x)u(y) + f(y) = f (x + y) = f(x) + f(y)u(x)
  have h1 : ∀ x y : ℝ, f x * u y + f y = f x + f y * u x := by
    intro x y
    rw [←hf, add_comm]
    linarith[hf y x]

  -- so f(x)(u(y) - 1) = f(y)(u(x) - 1) for all x,y ∈ ℝ.
  have h2 : ∀ x y : ℝ, f x * (u y - 1) = f y * (u x - 1) := by
    intro x y; linarith [h1 x y]

  -- Thus for any x ≠ 0, y ≠ 0, we have (u(x) - 1) / f(x) = (u(y) - 1) / f(y).
  have h3 : ∀ x y : ℝ, x ≠ 0 → y ≠ 0 → (u x - 1) / f x =  (u y - 1) / f y := by
    intro x y hx hy
    have hx1 := hfx0 x hx
    have hy1 := hfx0 y hy
    have := h2 x y
    field_simp
    linarith

  -- So there exists C ∈ ℝ such that (u(x) - 1) / f(x) = C for all x ≠ 0.
  have h4: ∃ C : ℝ, ∀ x : ℝ, x ≠ 0 → (u x - 1) / f x = C := by
    use (u 1 - 1) / f 1
    intro x hx
    exact h3 x 1 hx one_ne_zero
  obtain ⟨C, hC⟩ := h4

  -- So u(x) = 1 + C f(x) for x ≠ 0;
  have h5 : ∀ x : ℝ, x ≠ 0 → u x = 1 + C * f x := by
    intro x hx
    have hc1 := hC x hx
    have hx1 := hfx0 x hx
    field_simp at hc1
    linarith

  -- since u(0) = 1, f(0) = 0, this equation also holds for x = 0.
  have h6 : ∀ x : ℝ, u x = 1 + C * f x := by
    intro x
    rcases em (x = 0) with rfl | hnz
    · rw [hf0, h00]; ring
    · exact h5 x hnz

  -- If C = 0, then u(x) = 1 for all x and we are done.
  obtain hCz | hCnz := em (C = 0)
  · use 0
    intro x
    rw [zero_mul, Real.exp_zero]
    have := h6 x
    rwa [hCz, zero_mul, add_zero] at this

  -- Otherwise, observe
  --     u(x + y) = 1 + C f(x + y)
  --              = 1 + C f(x) u(y) + f(y)
  --              = u(y) + C f(x) u(y)
  --              = u(x) u(y)
  -- for all x,y ∈ ℝ.
  have h7 : ∀ x y : ℝ, u (x + y) = u x * u y := by
    intro x y
    calc u (x + y) = 1 + C * f (x + y) := h6 (x + y)
         _         = 1 + C * (f x * u y  + f y) := by rw [hf x y]
         _         = u y + C * f x * u y := by rw [h6 y]; ring
         _         = u y * (1 + C * f x) := by ring
         _         = u y * u x := by rw [h6 x]
         _         = u x * u y := mul_comm (u y) (u x)

  have hum : (StrictMono u ∨ StrictAnti u) := by
    obtain hm | hm := hm
    · obtain h1 | h2 | h3 := lt_trichotomy C 0
      · right; intro x y hxy; nlinarith [hm hxy, h6 x, h6 y]
      · rw [h2] at hCnz; exfalso; apply hCnz; rfl
      · left; intro x y hxy; nlinarith [hm hxy, h6 x, h6 y]
    · obtain h1 | h2 | h3 := lt_trichotomy C 0
      · left; intro x y hxy; nlinarith [hm hxy, h6 x, h6 y]
      · rw [h2] at hCnz; exfalso; apply hCnz; rfl
      · right; intro x y hxy; nlinarith [hm hxy, h6 x, h6 y]

  exact exp_characterization u h7 h00 hum

lemma romania1998_p12_mpr (u : ℝ → ℝ) :
 (∃ k : ℝ, ∀ x : ℝ, u x = Real.exp (k * x)) →
    (∃ f : ℝ → ℝ, (StrictMono f ∨ StrictAnti f)
        ∧ ∀ x y : ℝ, f (x + y) = f x * u y + f y) := by
  rintro ⟨k, hk⟩
  obtain rfl | hknz := eq_or_ne k 0
  · -- k = 0
    use id
    constructor
    · left; exact strictMono_id
    · intro x y
      rw [hk y, zero_mul, Real.exp_zero, mul_one, id_def, id_def, id_def]
  · -- k ≠ 0
    let f : ℝ → ℝ := fun x ↦ Real.exp (k * x) - 1
    have hfm : (StrictMono f ∨ StrictAnti f) := by
      by_cases hkp : 0 < k
      · left
        intro x y hxy
        have := exp_strict_mono' k x y hkp hxy
        exact sub_lt_sub_right this 1
      · right
        intro x y hxy
        have hkn' : k < 0 := by
          simp only [not_lt] at *
          exact Ne.lt_of_le hknz hkp
        have := exp_strict_anti' k x y hkn' hxy
        exact sub_lt_sub_right this 1
    use f
    use hfm
    intro x y
    rw [hk y]
    calc Real.exp (k * (x + y)) - 1
             = Real.exp (k * x + k * y) - 1 := by rw [mul_add]
           _ = Real.exp (k * x) * Real.exp (k * y) - 1 := by rw [Real.exp_add]
           _ = (Real.exp (k * x) - 1) * Real.exp (k * y) +
                  (Real.exp (k * y) - 1) := by ring



noncomputable def solution_set : Set (ℝ → ℝ) :=
  { u | ∃ k : ℝ, ∀ x : ℝ, u x = Real.exp (k * x) }

theorem romania1998_p12 (u : ℝ → ℝ) :
    (∃ f : ℝ → ℝ, (StrictMono f ∨ StrictAnti f)
          ∧ ∀ x y : ℝ, f (x + y) = f x * u y + f y) ↔
    u ∈ solution_set :=
⟨romania1998_p12_mp u, romania1998_p12_mpr u⟩


end Romania1998P12

-- ═══ Russia1995P10 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Maximiliano Onofre Martínez
-/





/-!
# Russian Mathematical Olympiad 1995, problem 10

Let m, n be positive integers such that

gcd(m, n) + lcm(m, n) = m + n.

Show that one of the two numbers is divisible by the other.
-/

namespace Russia1995P10

theorem russia1995_p10 {m n : ℕ} (h₀ : n ≠ 0 ∧ m ≠ 0)
  (h : gcd m n + lcm m n = m + n) :
  m ∣ n ∨ n ∣ m := by
  let g := gcd m n
  have h₁ : g + m * n / g = m + n := by aesop
  have h₂ : m * n + g^2 = g * (m + n) := by
    rw [← h₁]
    rw [Nat.left_distrib]
    rw [← pow_two]
    rw [Nat.mul_div_cancel']
    · rw [Nat.add_comm]
    exact dvd_trans (Nat.gcd_dvd_left m n) (Nat.dvd_mul_right m n)
  have h₃ : (m - g) * (n - g) = 0 := by zify at h₂; grind
  rw [Nat.mul_eq_zero] at h₃
  rcases h₃ with hm | hn
  · left
    have h_eq : m = g := by
      rw [Nat.sub_eq_zero_iff_le] at hm
      have h_div : g ∣ m := Nat.gcd_dvd_left m n
      have h_le : g ≤ m := Nat.le_of_dvd (Nat.pos_of_ne_zero h₀.2) h_div
      exact le_antisymm hm h_le
    rw [h_eq]
    exact Nat.gcd_dvd_right m n
  right
  have h_eq : n = g := by
    rw [Nat.sub_eq_zero_iff_le] at hn
    have h_div : g ∣ n := Nat.gcd_dvd_right m n
    have h_le : g ≤ n := Nat.le_of_dvd (Nat.pos_of_ne_zero h₀.1) h_div
    exact le_antisymm hn h_le
  rw [h_eq]
  exact Nat.gcd_dvd_left m n

end Russia1995P10

-- ═══ UK2024R1P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: short_c1rcuit
-/




/-!
# British Mathematical Olympiad 2024, Round 1, Problem 1

An unreliable typist can guarantee that when they try to type a word with
different letters, every letter of the word will appear exactly once in what
they type, and each letter will occur at most one letter late (though it may
occur more than one letter early). Thus, when trying to type MATHS, the
typist may type MATHS, MTAHS or TMASH, but not ATMSH.

Determine, with proof, the number of possible spellings of OLYMPIADS
that might be typed.
-/

namespace UK2024R1P1


/-
The basic idea of this proof is that the first letter can only go in the first
or second position. In both cases the spellings of the other letters is
equivalent to a valid spelling of an eight letter word. So the number of valid
spellings for nine letters is two times that for eight letters. Similar logic
gets the same relation for eight and seven letter words. This recurses down
until we reach one letter, which only has one spelling. Thus, OLYMPIADS has
2*2*2*2*2*2*2*2*1 = 2^8 = 256 valid spellings.

Most of this proof is defining the mapping between spellings of k + 2 letters
where the first letter goes to position m and spellings of k + 1 letters. This
is done by removing that first letter and shifting the letters after it over
to fill in the gap. Then we show that if m is one of the first two positions,
the spellings the mapping creates are valid and the mapping itself is
bijective. Thus the two sets of spellings have the same size.
-/

variable {k : ℕ} {m : Fin (k + 2)}

def S (k : ℕ) := {f : Equiv.Perm (Fin k) | ∀ n, (f n).castSucc ≤ n.succ}
def S' (k : ℕ) (m : Fin (k + 2)) := {f | f ∈ S (k + 2) ∧ f 0 = m}

lemma g_nonzero_ne_m {g : Equiv.Perm (Fin (k + 2))}
    (hg : g ∈ (S' k m)) (n : Fin (k + 2)) (hn : n ≠ 0) : g n ≠ m := by
  contrapose! hn
  rwa [←Equiv.apply_eq_iff_eq g, hg.2]

def f_toFun (g : Equiv.Perm (Fin (k + 2))) (hg : g ∈ (S' k m)) (n : Fin (k + 1)) : Fin (k + 1) :=
  if hg' : g n.succ ≤ m then
    (g n.succ).castPred (by
      replace hg' := lt_iff_le_and_ne.2 ⟨hg', g_nonzero_ne_m hg n.succ (Fin.succ_ne_zero n)⟩
      exact Fin.ne_last_of_lt hg'
    )
  else
    (g n.succ).pred (by
      push_neg at hg'
      exact Fin.ne_zero_of_lt hg'
    )

def f_invFun (g : Equiv.Perm (Fin (k + 2))) (hg : g ∈ (S' k m)) (n : Fin (k + 1)) : Fin (k + 1) :=
  if hg' : n.castSucc < m then
    (g.symm n.castSucc).pred (by
      contrapose! hg'
      rw [le_iff_lt_or_eq]
      right
      rw [←hg.2, ←hg', Equiv.apply_symm_apply]
    )
  else
    (g.symm n.succ).pred (by
      contrapose! hg'
      rw [Equiv.symm_apply_eq, hg.2] at hg'
      simp only [←hg', Fin.castSucc_lt_succ_iff, le_refl]
    )

lemma f_left_inv (g : Equiv.Perm (Fin (k + 2))) (hg : g ∈ (S' k m)) :
    Function.LeftInverse (f_invFun g hg) (f_toFun g hg) := by
  intro n
  simp [f_invFun, f_toFun]
  obtain hg' | hg' := em (g n.succ ≤ m)
  · simp only [hg']
    replace hg' := lt_iff_le_and_ne.2 ⟨hg', g_nonzero_ne_m hg n.succ (Fin.succ_ne_zero n)⟩
    simp [hg']
  · simp only [hg', reduceDIte, Fin.succ_pred, Equiv.symm_apply_apply, Fin.pred_succ]
    apply dif_neg
    intro hg''
    apply hg'
    push_neg at hg'
    rwa [←Fin.lt_castPred_iff (Fin.ne_last_of_lt hg'), Fin.pred_lt_castPred_iff] at hg''

lemma f_right_inv (g : Equiv.Perm (Fin (k + 2))) (hg : g ∈ (S' k m)) :
    Function.RightInverse (f_invFun g hg) (f_toFun g hg) := by
  intro n
  simp [f_invFun, f_toFun]
  obtain hg' | hg' := em (n.castSucc < m)
  · simp only [hg']
    replace hg' := le_of_lt hg'
    simp [hg']
  · simp only [hg', reduceDIte, Fin.succ_pred, Equiv.apply_symm_apply, Fin.pred_succ]
    apply dif_neg
    intro hg''
    apply hg'
    exact hg''

def f (g : Equiv.Perm (Fin (k + 2))) (hg : g ∈ (S' k m)) :=
  Equiv.mk (f_toFun g hg) (f_invFun g hg) (f_left_inv g hg) (f_right_inv g hg)

def f'_toFun (g : Equiv.Perm (Fin (k + 1))) (m : Fin (k + 2)) (n : Fin (k + 2)) : Fin (k + 2) :=
  if hn : n = 0 then
    m
  else
    if (g (n.pred hn)).castSucc < m then
      (g (n.pred hn)).castSucc
    else
      (g (n.pred hn)).succ

def f'_invFun (g : Equiv.Perm (Fin (k + 1))) (m : Fin (k + 2)) (n : Fin (k + 2)) : Fin (k + 2) :=
  if hn : n = m then
    0
  else
    if hn' : n < m then
      (g.symm (n.castPred (Fin.ne_last_of_lt hn'))).succ
    else
      (g.symm (n.pred (Fin.ne_zero_of_lt (lt_iff_le_and_ne.2 ⟨le_of_not_gt hn', Ne.symm hn⟩)))).succ

lemma f'_left_inv (g : Equiv.Perm (Fin (k + 1))) :
    Function.LeftInverse (f'_invFun g m) (f'_toFun g m) := by
  intro n
  simp only [f'_invFun, f'_toFun]
  obtain hn | hn := em (n = 0) <;> simp [hn]
  obtain hg | hg := em ((g (n.pred hn)).castSucc < m)
  · simp only [hg, reduceIte, ne_of_lt, reduceDIte, Fin.castPred_castSucc,
               Equiv.symm_apply_apply, Fin.succ_pred]
  · simp [hg]
    push_neg at hg
    simp only [hg, Fin.le_castSucc_iff.mp, ne_of_gt, reduceIte, not_lt_of_gt, reduceDIte]

lemma f'_right_inv (g : Equiv.Perm (Fin (k + 1))) :
    Function.RightInverse (f'_invFun g m) (f'_toFun g m) := by
  intro n
  simp only [f'_invFun, f'_toFun]
  obtain hn | hn := em (n = m) <;> simp [hn]
  obtain hg | hg := em (n < m)
  · simp only [hg, reduceDIte, Fin.pred_succ, Equiv.apply_symm_apply, Fin.castSucc_castPred,
               Fin.succ_ne_zero, reduceIte]
  · simp_rw [hg, reduceDIte, Fin.succ_ne_zero, reduceDIte, Fin.pred_succ,
             Equiv.apply_symm_apply, Fin.succ_pred]
    apply dif_neg
    push_neg at *
    rw [Fin.le_castSucc_pred_iff]
    exact lt_iff_le_and_ne.2 ⟨hg, Ne.symm hn⟩

def f' (m : Fin (k + 2)) (g : Equiv.Perm (Fin (k + 1))) :=
  Equiv.mk (f'_toFun g m) (f'_invFun g m) (f'_left_inv g) (f'_right_inv g)

lemma f'_in_S'_k (hm : m ≤ 1) {g : Equiv.Perm (Fin (k + 1))} (hg : g ∈ S (k + 1)) :
    f' m g ∈ S' k m := by
  constructor
  · intro n
    simp [f', f'_toFun]
    obtain hn | hn := em (n = 0) <;> simp [hn]
    · exact hm
    · obtain hn' | hn' := em ((g (n.pred hn)).castSucc < m) <;>
        simp only [hn', ↓reduceIte ]
      · apply le_trans (Fin.castSucc_le_castSucc_iff.2 (hg (n.pred hn)))
        rw [Fin.succ_pred]
        exact le_of_lt Fin.castSucc_lt_succ
      · rw [←Fin.succ_castSucc]
        apply le_trans (Fin.succ_le_succ_iff.2 (hg (n.pred hn)))
        rw [Fin.succ_pred]
  · simp [f', f'_toFun]

lemma f_f'_left_inv {g : Equiv.Perm (Fin (k + 2))} (hg : g ∈ S' k m) : f' m (f g hg) = g := by
  apply Equiv.ext
  intro x
  simp [f', f'_toFun, f, f_toFun]
  obtain hx | hx := em (x = 0) <;> simp [hx, hg.2]
  obtain hx' | hx' := em (g x ≤ m)
  · simp only [hx', reduceDIte, Fin.castSucc_castPred]
    exact dif_pos (lt_iff_le_and_ne.2 ⟨hx', g_nonzero_ne_m hg x hx⟩)
  · simp only [hx', reduceDIte, Fin.succ_pred]
    apply dif_neg
    push_neg at *
    rwa [Fin.le_castSucc_pred_iff]

lemma f_f'_right_inv (hm : m ≤ 1) {g : Equiv.Perm (Fin (k + 1))} (hg : g ∈ S (k + 1)) :
    f (f' m g) (f'_in_S'_k hm hg) = g := by
  apply Equiv.ext
  intro x
  simp [f, f_toFun, f', f'_toFun, Fin.succ_ne_zero]
  obtain hx | hx := em ((g x).castSucc < m)
  · simp only [hx, reduceIte, Fin.castPred_castSucc]
    exact dif_pos (le_of_lt hx)
  · simp_rw [hx, reduceIte, Fin.pred_succ]
    apply dif_neg
    contrapose! hx
    rwa [Fin.castSucc_lt_iff_succ_le]

lemma S'_k_card_eq_S_succ_k_card (hm : m ≤ 1) : (S' k m).ncard = (S (k + 1)).ncard := by
    apply Set.ncard_congr f
    · intro a ha
      simp [S, f, f_toFun]
      intro n
      obtain h | h := em (a n.succ ≤ m)
      · simp only [h, reduceDIte, Fin.castSucc_castPred]
        exact le_trans (le_trans h hm) (Fin.succ_pos n)
      · simp [h]
        replace ha := ha.1 n.succ
        rw [Fin.castSucc_pred_eq_pred_castSucc]
        apply le_trans (Fin.pred_le_pred_iff.2 ha)
        rw [Fin.pred_succ]
        exact n.succ.succ_ne_zero
    · intro a b ha hb hab
      rw [←f_f'_left_inv ha, ←f_f'_left_inv hb, hab]
    · intro b hb
      exact ⟨f' m b, ⟨f'_in_S'_k hm hb, f_f'_right_inv hm hb⟩⟩

lemma S_succ_succ_k_card_eq_two_mul_S_succ_k_card : (S (k + 2)).ncard = (S (k + 1)).ncard * 2 := by
    let S₁ := S' k 0
    let S₂ := S' k 1
    have h1 : S₁.ncard = (S (k + 1)).ncard := by exact S'_k_card_eq_S_succ_k_card (by norm_num)
    have h2 : S₂.ncard = (S (k + 1)).ncard := by exact S'_k_card_eq_S_succ_k_card (by norm_num)
    have h3 : Disjoint S₁ S₂ := by {
      rw [Set.disjoint_left]
      rintro f ⟨_, hf⟩
      simp only [S', Set.mem_setOf_eq, not_and, S₂]
      intro
      rw [hf]
      aesop
    }
    have h4 : S (k + 2) = S₁ ∪ S₂ := by
      apply Set.ext
      intro x
      constructor <;> intro hx
      · have hx' : (x 0) ≤ 1 := by
          rw [←Fin.val_fin_le, Fin.val_one]
          exact hx 0
        obtain hx' | hx' := le_iff_lt_or_eq.mp hx'
        · left
          replace hx' : x 0 = 0 := by
            rw [←Fin.val_eq_val, Fin.val_zero, ←Nat.lt_one_iff]
            rwa [Fin.lt_def, Fin.val_one] at hx'
          exact ⟨hx, hx'⟩
        · right
          exact ⟨hx, hx'⟩
      · obtain hx | hx := hx <;> exact hx.1
    rw [h4, Set.ncard_union_eq h3, h1, h2, mul_two]

lemma S_succ_k_card_eq_two_pow_k {k : ℕ} :
    (S (k + 1)).ncard = 2 ^ k := by
  induction k with
  | zero =>
      simp
      let f : Equiv.Perm (Fin 1) := Equiv.mk id id (by decide) (by decide)
      use f
      apply Set.ext
      intro g
      constructor <;> simp [S]
      · rw [Equiv.ext_iff]
        lia
      · intro h
        simp [h, f, Fin.eq_zero]
  | succ n hn =>
      rw [Nat.pow_succ, ←hn, S_succ_succ_k_card_eq_two_mul_S_succ_k_card]


noncomputable def solution_value : ℕ := 256

/-
Since OLYMPIADS has no duplicate letters, then the set of spellings is just a
subset of the permutations of 9 elements.
-/
theorem uk2024_r1_p1 :
  {f : Equiv.Perm (Fin 9) | ∀ k, (f k : ℕ) ≤ k + 1}.ncard = solution_value := by
    change (S 9).ncard = solution_value
    rw [S_succ_k_card_eq_two_pow_k]
    norm_num


end UK2024R1P1

-- ═══ Usa1972P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shalev Wengrowsky
-/





/-!
# USA Mathematical Olympiad 1972, Problem 1

Let (a, b, ... , k) denote the greatest common divisor of the integers a, b, ... k
and [a, b, ... , k] denote their least common multiple.

Show that for any positive integers a, b, c we have
(a, b, c)² [a, b] [b, c] [c, a] = [a, b, c]² (a, b) (b, c) (c, a).
-/

namespace Usa1972P1

open Nat


/-
  implementation of the proof from https://prase.cz/kalva/usa/usoln/usol721.html

  If we express a, b, c as a product of primes then the gcd has each prime
  to the smallest power and the lcm has each prime to the largest power.

  So the equation given is equivalent to showing that
    2 * min(r, s, t) + max(r, s) + max(s, t) + max(t, r) = 2 * max(r, s, t) + min(r, s) + min(s, t) + min(t, r)
  for non-negative integers r, s, t. Assume r ≤ s ≤ t. Then each side is 2r + s + 2t.
-/


theorem usa1972_p1 (a b c : ℕ) :
  (gcd a (gcd b c)) ^ 2 * lcm a b * lcm b c * lcm c a =
  (lcm a (lcm b c)) ^ 2 * gcd a b * gcd b c * gcd c a := by
  -- if any of a, b, c are 0 the problem becomes trivial
  by_cases a_pos : a = 0
  · simp [a_pos]
  by_cases b_pos : b = 0
  · simp [b_pos]
  by_cases c_pos : c = 0
  · simp [c_pos]
  apply Nat.eq_of_factorization_eq (by simp; tauto) (by simp; tauto)
  intro p
  let r := a.factorization p
  let s := b.factorization p
  let t := c.factorization p
  repeat rw [factorization_mul (by simp; tauto) (by simp; tauto)]
  simp
  repeat rw [factorization_lcm (by simp; lia) (by simp; tauto)]
  repeat rw [factorization_gcd (by simp; lia) (by simp; tauto)]
  simp
  grind

end Usa1972P1

-- ═══ Usa1973P4 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shalev Wengrowsky
-/





/-!
# USA Mathematical Olympiad 1973, Problem 4

Find all complex numbers x, y, z which satisfy
  x + y + z = x² + y² + z² = x³ + y³ + z³ = 3.
-/

namespace Usa1973P4

noncomputable def solution_set : Set (ℂ × ℂ × ℂ) := { ⟨1, 1, 1⟩ }

theorem usa1973_p4 (x y z : ℂ) :
    x + y + z = 3 ∧
    x ^ 2 + y ^ 2 + z ^ 2 = 3 ∧
    x ^ 3 + y ^ 3 + z ^ 3 = 3 ↔ ⟨x,y,z⟩ ∈ solution_set := by
  constructor
  · intro
    ext <;> grind
  rintro _
  grind

end Usa1973P4

-- ═══ Usa1974P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Maximiliano Onofre Martínez
-/





/-!
# USA Mathematical Olympiad 1974, Problem 1

Let a, b, c be three distinct integers, and let P be a polynomial
with integer coefficients. Show that in this case the conditions
P (a) = b, P (b) = c, P (c) = a cannot be satisfied simultaneously.
-/

open Int

open Polynomial

namespace Usa1974P1

theorem usa1974_p1 {P : Polynomial ℤ} (a b c : ℤ) (h_neq : a ≠ b ∧ b ≠ c ∧ c ≠ a) :
  ¬(P.eval a = b ∧ P.eval b = c ∧ P.eval c = a) := by
  intro h
  rcases h with ⟨h_a, h_b, h_c⟩

  have h_ab_bc : a - b ∣ b - c := by
    nth_rw 2 [← h_a]; rw [← h_b]
    exact sub_dvd_eval_sub a b P

  have h_bc_ca : b - c ∣ c - a := by
    nth_rw 2 [← h_b]; rw [← h_c]
    exact sub_dvd_eval_sub b c P

  have h_ca_ab : c - a ∣ a - b := by
    nth_rw 2 [← h_c]; rw [← h_a]
    exact sub_dvd_eval_sub c a P

  have h_ab_ca : a - b ∣ c - a := dvd_trans h_ab_bc h_bc_ca

  have h_abs_ac : (a - b).natAbs = (c - a).natAbs := natAbs_eq_of_dvd_dvd h_ab_ca h_ca_ab
  rw [natAbs_eq_natAbs_iff] at h_abs_ac

  rcases h_abs_ac with h_eq_ac | h_neg_ac
  · rw [h_eq_ac] at h_ab_bc
    have h_abs_bc : (c - a).natAbs = (b - c).natAbs := natAbs_eq_of_dvd_dvd h_ab_bc h_bc_ca
    rw [natAbs_eq_natAbs_iff] at h_abs_bc
    rcases h_abs_bc with h_eq_bc | h_neg_bc <;> grind
  aesop

end Usa1974P1

-- ═══ Usa1974P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 1974, Problem 2

Prove that if a, b, and c are positive real numbers, then
a^a * b^b * c^c ≥ (abc)^((a+b+c)/3)
-/

namespace Usa1974P2



lemma usa1974_p2_wlog :
    ∀ (a b c : ℝ), a > 0 → b > 0 → c > 0 →
      a ≥ b → b ≥ c → a^a * b^b * c^c ≥ (a*b*c)^((a+b+c)/3) := by
  intro a b c ha hb hc hab hbc
  have habc : a * b * c > 0 := mul_pos (mul_pos ha hb) hc
  have h : (a ^ a * b ^ b * c ^ c) * (a ^ b * b ^ c * c ^ a) * (a ^ c * b ^ a * c ^ b) =
            (a * b * c) ^ (a + b + c) := by
    simp (discharger := positivity) only [Real.rpow_add, Real.mul_rpow]
    ring
  apply le_of_pow_le_pow_left₀ (by decide : 3 ≠ 0) (by positivity)
  rw [←Real.rpow_natCast]
  rw [←(Real.rpow_mul (le_of_lt habc))]
  norm_num
  rw [←h]
  rw [pow_three']
  have hab' := Real.log_le_log hb hab
  have hbc' := Real.log_le_log hc hbc
  -- ⊢ a ^ a * b ^ b * c ^ c * (a ^ b * b ^ c * c ^ a) * (a ^ c * b ^ a * c ^ b) ≤
  --   a ^ a * b ^ b * c ^ c * (a ^ a * b ^ b * c ^ c) * (a ^ a * b ^ b * c ^ c)
  gcongr ?_ * ?_ * ?_
  · rw [←(Real.log_le_log_iff (by positivity) (by positivity))]
    simp (discharger := positivity) only [Real.log_mul, Real.log_rpow]
    nlinarith only [hab', hbc', hab, hbc]
  · rw [←(Real.log_le_log_iff (by positivity) (by positivity))]
    simp (discharger := positivity) only [Real.log_mul, Real.log_rpow]
    nlinarith only [hab', hbc', hab, hbc]



theorem usa1974_p2 :
    ∀ (a b c : ℝ), a > 0 → b > 0 → c > 0 → a^a * b^b * c^c ≥ (a*b*c)^((a+b+c)/3) := by
  -- solution from
  -- https://artofproblemsolving.com/wiki/index.php/1974_USAMO_Problems/Problem_2
  intro a b c ha hb hc
  wlog hab : a ≥ b with Hab
  · move_add [←b]; move_mul [←b^b, ←b]
    refine Hab b a c hb ha hc (le_of_lt <| not_le.mp hab)
  · wlog hac : a ≥ c with Hac
    · move_add [←c]; move_mul [←c^c, ←c]
      have hca : c ≥ a := le_of_lt <| not_le.mp hac
      apply Hac c a b <;> try assumption
      trans a <;> assumption
    · wlog hbc : b ≥ c with Hbc
      · move_add [b]; move_mul [b^b, b]
        have hcb : c ≥ b := le_of_lt <| not_le.mp hbc
        apply Hbc a c b <;> try assumption
      · exact usa1974_p2_wlog a b c ha hb hc hab hbc


end Usa1974P2

-- ═══ Usa1978P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 1978, Problem 1

Given that a,b,c,d,e are real numbers such that

  a  + b  + c  + d  + e  = 8
  a² + b² + c² + d² + e² = 16,

noncomputable def the maximum value of e.
-/

namespace Usa1978P1

noncomputable determine max_e : ℝ := (16 : ℝ) / 5

abbrev IsGood (a b c d e : ℝ) : Prop :=
  a + b + c + d + e = 8 ∧ a^2 + b^2 + c^2 + d^2 + e^2 = 16

theorem usa1978_p1 :
    IsGreatest { e : ℝ | ∃ a b c d : ℝ, IsGood a b c d e } max_e := by
  -- solution 3 from
  -- https://artofproblemsolving.com/wiki/index.php/1978_USAMO_Problems/Problem_1
  unfold IsGreatest IsGood max_e upperBounds
  constructor
  · simp only [Set.mem_setOf_eq]
    use (6 / 5)
    use (6 / 5)
    use (6 / 5)
    use (6 / 5)
    constructor <;> norm_num
  · simp only [Set.mem_setOf_eq]
    intro e
    contrapose!
    intro he a b c d h1 h2
    apply not_le_of_gt he
    have h11 : (a + b + c + d) ^ 2 = (8 - e) ^ 2 := by
      rw [(by rw [←h1]; simp only [add_sub_cancel_right] : a + b + c + d = 8 - e)]
    have h12 :  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 16 - e ^ 2 := by
      rw [←h2]; simp only [add_sub_cancel_right]
    have h3 : (a - b)^2 + (a - c)^2 + (a - d)^2 +
              (b - c)^2 + (b - d)^2 + (c - d)^2 = 4 * (16 - e^2) - (8 - e)^2 := by
      linear_combination 4 * h12 - h11
    have h4 : 4 * (16 - e ^ 2) - (8 - e) ^ 2 ≥ 0 := by rw [←h3]; positivity
    revert h4
    rw [(by ring_nf : 4 * (16 - e ^ 2) - (8 - e) ^ 2 = e * (16 - 5 * e))]
    contrapose!
    intro _
    rw [mul_comm]
    apply mul_neg_of_neg_of_pos
    · linarith
    · positivity


end Usa1978P1

-- ═══ Usa1979P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 1979, Problem 1

Determine all non-negative integral solutions $(n_1,n_2,\dots , n_{14})$ if any,
apart from permutations, of the Diophantine Equation $n_1^4+n_2^4+\cdots +n_{14}^4=1599$.
-/

namespace Usa1979P1

/--
A type representing assignments to the variables $n_1$, $n_2$, ..., $n_{14}$,
quotiented by permutations of indices.
-/
structure MultisetNatOfLen14 where
  s : Multiset ℕ
  p : Multiset.card s = 14

noncomputable def SolutionSet : Set MultisetNatOfLen14 := ∅

theorem usa1979_p1 : ∀ e, e ∈ SolutionSet ↔ (e.s.map (fun x ↦ x ^ 4)).sum = 1599 := by
  -- solution from
  -- https://artofproblemsolving.com/wiki/index.php/1979_USAMO_Problems/Problem_1
  unfold SolutionSet
  intro e
  constructor
  · simp only [Set.mem_empty_iff_false, false_implies]
  · intro contra
    apply_fun (· % 16) at contra
    rw [Multiset.sum_nat_mod, Multiset.map_map] at contra
    simp only [Function.comp_apply, Nat.reduceMod] at contra
    suffices (Multiset.map (fun x ↦ x ^ 4 % 16) e.s).sum ≤ 14 by lia
    rw [show 14 = Multiset.card (e.s.map (fun x ↦ x ^ 4 % 16)) * 1 by rw [Multiset.card_map, e.p]]
    apply Multiset.sum_le_card_nsmul
    intro x
    rw [Multiset.mem_map]
    intro ⟨i, ⟨_, h⟩⟩
    rw [← h, Nat.pow_mod]
    mod_cases i % 16
    all_goals rw [H]; try norm_num

end Usa1979P1

-- ═══ Usa1980P5 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Goedel-Prover-V2
-/





/-!
# USA Mathematical Olympiad 1980, Problem 5

Let x,y,z be real numbers in the closed interval [0,1]. Show that

 x/(y + z + 1) + y/(z + x + 1) + z/(x + y + 1) ≤ 1 + (1 - x)(1 - y)(1 - z).
-/

namespace Usa1980P5

theorem usa1980_p5 (x y z : ℝ)
    (hx : x ∈ Set.Icc 0 1)
    (hy : y ∈ Set.Icc 0 1)
    (hz : z ∈ Set.Icc 0 1) :
    x / (y + z + 1) + y / (z + x + 1) + z / (x + y + 1) ≤
    1 + (1 - x) * (1 - y) * (1 - z) := by
  obtain ⟨hx₀, hx₁⟩ := hx
  obtain ⟨hy₀, hy₁⟩ := hy
  obtain ⟨hz₀, hz₁⟩ := hz
  have h_nonneg : (1 - x) * (1 - y) * (1 - z) ≥ 0 := by
    have h₁ : 0 ≤ 1 - x := by linarith
    have h₂ : 0 ≤ 1 - y := by linarith
    have h₃ : 0 ≤ 1 - z := by linarith
    positivity
  have h_sum_le_one : x / (y + z + 1) + y / (z + x + 1) + z / (x + y + 1) ≤ 1 := by
    have h₁ : 0 ≤ x := by linarith
    have h₂ : 0 ≤ y := by linarith
    have h₃ : 0 ≤ z := by linarith
    by_cases h₄ : (x + y + z : ℝ) = 0
    · have h₅ : x = 0 := by linarith
      have h₆ : y = 0 := by linarith
      have h₇ : z = 0 := by linarith
      rw [h₅, h₆, h₇]
      norm_num
    · have h₅ : 0 < x + y + z := by
        by_contra h
        have h₆ : x + y + z ≤ 0 := by linarith
        have h₇ : x + y + z = 0 := by linarith
        contradiction
      have h₆ : x / (y + z + 1) ≤ x / (x + y + z) := by
        have h₇ : 0 ≤ x := by linarith
        have h₈ : 0 < y + z + 1 := by linarith
        have h₉ : 0 < x + y + z := by linarith
        have h₁₀ : x + y + z ≤ y + z + 1 := by linarith only [hx₁, hy₁, hz₁]
        gcongr
      have h₇ : y / (z + x + 1) ≤ y / (x + y + z) := by
        have h₈ : 0 ≤ y := by linarith
        have h₉ : 0 < z + x + 1 := by linarith
        have h₁₀ : 0 < x + y + z := by linarith
        have h₁₁ : x + y + z ≤ z + x + 1 := by linarith only [hx₁, hy₁, hz₁]
        gcongr
      have h₈ : z / (x + y + 1) ≤ z / (x + y + z) := by
        have h₉ : 0 ≤ z := by linarith
        have h₁₀ : 0 < x + y + 1 := by linarith
        have h₁₁ : 0 < x + y + z := by linarith
        have h₁₂ : x + y + z ≤ x + y + 1 := by linarith only [hx₁, hy₁, hz₁]
        gcongr
      have h₉ : x / (y + z + 1) + y / (z + x + 1) + z / (x + y + 1) ≤ x / (x + y + z) + y / (x + y + z) + z / (x + y + z) := by
        linarith
      have h₁₀ : x / (x + y + z) + y / (x + y + z) + z / (x + y + z) = 1 := by
        have h₁₁ : x / (x + y + z) + y / (x + y + z) + z / (x + y + z) = (x + y + z) / (x + y + z) := by
          field_simp [h₅.ne']
        rw [h₁₁]
        exact (div_eq_one_iff_eq h₄).mpr rfl
      linarith
  exact le_add_of_le_of_nonneg h_sum_le_one h_nonneg

end Usa1980P5

-- ═══ Usa1981P5 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1981, Problem 5

Show that for any positive real number x and any nonnegative
integer n,

    ∑ₖ (⌊kx⌋/k) ≤ ⌊nx⌋

where the sum goes from k = 1 to k = n, inclusive.
-/

namespace Usa1981P5

theorem usa1981_p5 (x : ℝ) (n : ℕ) :
    ∑ k ∈ Finset.Icc 1 n, ((⌊k * x⌋:ℝ)/k) ≤ ⌊n * x⌋ := by
  -- We follow the solution from
  -- https://artofproblemsolving.com/wiki/index.php/1981_USAMO_Problems/Problem_5

  simp_rw [←Int.self_sub_fract, sub_div, mul_div_right_comm]
  rw [Finset.sum_sub_distrib]
  have h1 : ∀ x1 ∈ Finset.Icc 1 n, (x1 : ℝ) / (x1 : ℝ) * x = x := fun x1 hx ↦ by
    rw [Finset.mem_Icc] at hx
    replace hx := hx.1;
    field_simp
  rw [Finset.sum_congr rfl h1]
  have h2 : ∑ _x ∈ Finset.Icc 1 n, x = n * x := by
    rw [Finset.sum_const, Nat.card_Icc, add_tsub_cancel_right, nsmul_eq_mul]
  rw [h2]
  suffices H : Int.fract (↑n * x) ≤
               ∑ x_1 ∈ Finset.Icc 1 n, Int.fract (↑x_1 * x) / ↑x_1 from
    sub_le_sub_left H (↑n * x)

  let a : ℕ → ℝ := fun k ↦ Int.fract (k * x)

  have h4 : ∀ k m, a (k + m) ≤ a k + a m := fun k m ↦ by
    dsimp only [a]
    have h5 : ↑(k + m) * x = ↑ k * x + ↑m * x := by
      push_cast; exact add_mul (↑k) (↑m) x
    rw [h5]
    exact Int.fract_add_le (↑k * x) (↑m * x)

  change a n ≤ ∑ ii ∈ Finset.Icc 1 n, a ii / ii

  clear h1 h2
  induction' n using Nat.strongRecOn with n ih
  obtain rfl | hn := Nat.eq_zero_or_pos n
  · simp [a]

  have : Nonempty (Finset.Icc 1 n) :=
    ⟨1, Finset.left_mem_Icc.mpr (Nat.succ_le_of_lt hn)⟩
  obtain ⟨⟨m, hm1⟩, hm2⟩ :=
    Finite.exists_min (fun (m : Finset.Icc 1 n) ↦ a m / m)

  rw [Finset.mem_Icc] at hm1
  obtain ⟨hm3, hm4⟩ := hm1
  have h9 := ih (n - m) (Nat.sub_lt hn hm3)

  have h11 := h4 (n - m) m
  rw [Nat.sub_add_cancel hm4] at h11
  have h12 : 1 ≤ n - m + 1 := Nat.le_add_left 1 (n - m)
  have h13 : n - m + 1 ≤ n + 1 := by
    rw [Nat.add_le_add_iff_right]
    exact Nat.sub_le n m
  rw [show Finset.Icc 1 n = Finset.Ico 1 (n + 1) by rfl]
  rw [show Finset.Icc 1 (n - m) = Finset.Ico 1 (n - m + 1) by rfl] at h9
  rw [←Finset.sum_Ico_consecutive _ h12 h13]
  have h14 : a m ≤ ∑ i ∈ Finset.Ico (n - m + 1) (n + 1), a i / ↑i := by
    have h15 : m ≠ 0 := Nat.pos_iff_ne_zero.mp hm3
    have h16 : (m:ℝ) ≠ 0 := Nat.cast_ne_zero.mpr h15
    have h17 : a m = m * a m / m := CancelDenoms.cancel_factors_eq_div rfl h16
    rw [h17]
    have h18 : ∀ ii ∈ Finset.Ico (n - m + 1) (n + 1), a m / m ≤ a ii / ii := fun ii hii ↦ by
      have h22 : ii ∈ Finset.Icc 1 n := by
        rw [Finset.mem_Ico] at hii
        obtain ⟨hii1, hii2⟩ := hii
        rw [Finset.mem_Icc]
        constructor
        · exact Nat.one_le_of_lt hii1
        · exact Nat.lt_succ_iff.mp hii2
      exact hm2 ⟨ii, h22⟩
    have h19 : ∑ _i ∈ Finset.Ico (n - m + 1) (n + 1), a m / ↑m ≤
               ∑ i ∈ Finset.Ico (n - m + 1) (n + 1), a i / ↑i := Finset.sum_le_sum h18
    rw [Finset.sum_const, Nat.card_Ico, nsmul_eq_mul] at h19
    have h20 : n + 1 - (n - m + 1) = m := by
      rw [Nat.add_sub_add_right]
      exact Nat.sub_sub_self hm4
    rw [h20, ←mul_div_assoc] at h19
    exact h19
  calc _ ≤ a (n - m) + a m := h11
       _ ≤ _ := add_le_add h9 h14


end Usa1981P5

-- ═══ Usa1987P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1987, Problem 1

Determine all solutions to

     (m² + n)(m + n²) = (m - n)³

where m and n are non-zero integers.
-/

namespace Usa1987P1



lemma lemma2 {a b c : ℤ} (h : a * b^2 = c^2) : IsSquare a ∨ b = 0 := by
  obtain rfl | hb := eq_or_ne b 0
  · right; rfl
  simp only [hb, or_false]
  -- from Eric Wieser on Zulip
  -- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/a.20*.20b.5E2.20.3D.20c.5E2.20implies.20IsSquare.20a/near/406203283
  have h1 : b^2 ∣ c^2 := Dvd.intro_left a h
  rw [Int.pow_dvd_pow_iff two_ne_zero] at h1
  obtain ⟨k, rfl⟩ := h1
  rw [mul_pow, mul_comm, mul_right_inj' (pow_ne_zero _ hb)] at h
  rw [h]
  exact ⟨k, sq k⟩



noncomputable def solution_set : Set (ℤ × ℤ) :=
  { (-1, -1), (8, -10), (9, -6), (9, -21) }

theorem usa1987_p1 (m n : ℤ) :
    (m, n) ∈ solution_set ↔
    m ≠ 0 ∧ n ≠ 0 ∧ (m^2 + n) * (m + n^2) = (m - n)^3 := by
  -- Follows the informal solution at
  -- https://artofproblemsolving.com/wiki/index.php/1987_USAMO_Problems/Problem_1
  constructor
  · aesop
  · rintro ⟨h1, h2, h3⟩
    have h4 : n * (m  + m^2 * n + n^2) =
              n * (- 3* m^2 + 3 * m * n - n^2) := by linear_combination h3
    replace h4 : (m  + m^2 * n + n^2) =
              (- 3 * m^2 + 3 * m * n - n^2) := (Int.mul_eq_mul_left_iff h2).mp h4
    have h5 : 2 * (n * n)  + (m^2 - 3 * m) * n + (3 * m^2 + m) = 0 := by
      linarith
    have h6 := (quadratic_eq_zero_iff_discrim_eq_sq two_ne_zero n).mp h5
    have h7 : discrim 2 (m ^ 2 - 3 * m) (3 * m ^ 2 + m) =
              m * (m - 8) * (m + 1)^2 := by rw [discrim]; ring
    rw [h7] at h6; clear h7
    have h8 : IsSquare (m * (m - 8)) ∨ m + 1 = 0 := lemma2 h6
    obtain rfl | hm := eq_or_ne m (-1)
    · norm_num at h6
      obtain rfl : n = -1 := by linarith [eq_zero_of_pow_eq_zero h6.symm]
      simp only [Set.mem_insert_iff, true_or]
    have h9 : m + 1 ≠ 0 := fun hm1 ↦ hm (Int.sub_eq_zero.mp hm1)
    replace h8 := Or.resolve_right h8 h9
    obtain ⟨k, hk⟩ := h8
    have h11 : 1 * (m * m) + - 8 * m + - k * k = 0 := by linarith
    have h12 := (quadratic_eq_zero_iff_discrim_eq_sq one_ne_zero m).mp h11
    rw [discrim] at h12
    have h13 : 16 + (k * k) = (m -4) ^ 2 := by linarith only [h12]
    let m' := |m - 4|
    have hm' : (m - 4)^2 = m'^2 := (sq_abs _).symm
    have hm0' : 0 ≤ m' := abs_nonneg _

    let k' := |k|
    have hk' : k^2 = k'^2 := (sq_abs _).symm
    have hk0' : 0 ≤ k' := abs_nonneg _

    rw [ ←sq] at h13
    have h20 : k' < 8 := by
      by_contra! H
      rw [hm', hk'] at h13
      have h14 : k' < m' := by
        have h14' : k'^2 < m'^2 := by
          rw [←h13]; exact Int.lt_add_of_pos_left _ (by norm_num)
        exact lt_of_pow_lt_pow_left₀ 2 hm0' h14'
      have h15 : k' + 1 ≤ m' := h14
      have h16 : (k' + 1)^2 ≤ m'^2 := by gcongr
      rw [←h13] at h16
      have h17 : 2 * k' + 1 ≤ 16 := by linarith only [h16]
      have h18 : 2 * 8 + 1 ≤ 2 * k' + 1 := by gcongr
      have h19 := h18.trans h17
      norm_num at h19
    interval_cases k' <;> rw [hk'] at h13 <;> norm_num at h13
    · rw [hm'] at h13
      have h21 : m' = 4 := by nlinarith only [h13, hm0']
      obtain h25 | h25 := eq_or_eq_neg_of_abs_eq h21
      · obtain rfl : m = 8 := eq_add_of_sub_eq h25
        norm_num at h6
        obtain rfl : n = -10 := by linarith [eq_zero_of_pow_eq_zero h6.symm]
        simp only [Set.mem_insert_iff, true_or, or_true]
      · exact (h1 (sub_eq_neg_self.mp h25)).elim
    · rw [hm'] at h13
      have h21 : 4^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 4 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 5^2 := by rw [←h13]; norm_num
      have h24 : m' < 5 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim
    · rw [hm'] at h13
      have h21 : 4^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 4 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 5^2 := by rw [←h13]; norm_num
      have h24 : m' < 5 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim
    · rw [hm'] at h13
      have h21 : m' = 5 := by nlinarith only [hm0', h13]
      obtain h25 | h25 := eq_or_eq_neg_of_abs_eq h21
      · have h26 : m = 9 := eq_add_of_sub_eq h25
        rw [h26] at h6 ⊢
        norm_num at h6
        have h27 : (30:ℤ)^2 = (4 * n + 54) ^2 := by linear_combination h6
        obtain h28 | h28 := eq_or_eq_neg_of_sq_eq_sq _ _ h27
        · obtain rfl : n = -6 := by linarith only [h28]
          simp only [Set.mem_insert_iff, true_or, or_true]
        · obtain rfl : n = -21 := by linarith only [h28]
          simp only [Set.mem_insert_iff, Set.mem_singleton_iff, or_true]
      · lia
    · rw [hm'] at h13
      have h21 : 5^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 5 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 6^2 := by rw [←h13]; norm_num
      have h24 : m' < 6 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim
    · rw [hm'] at h13
      have h21 : 6^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 6 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 7^2 := by rw [←h13]; norm_num
      have h24 : m' < 7 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim
    · rw [hm'] at h13
      have h21 : 7^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 7 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 8^2 := by rw [←h13]; norm_num
      have h24 : m' < 8 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim
    · rw [hm'] at h13
      have h21 : 8^2 < m'^2 := by rw [←h13]; norm_num
      have h23 : 8 < m' := lt_of_pow_lt_pow_left₀ 2 hm0' h21
      have h22 : m'^2 < 9^2 := by rw [←h13]; norm_num
      have h24 : m' < 9 := lt_of_pow_lt_pow_left₀ 2 (by norm_num) h22
      exact (Int.not_le.mpr h24 h23).elim


end Usa1987P1

-- ═══ Usa1989P1 ═══

/-
Copyright (c) 2025 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shalev Wengrowsky
-/





/-!
# USA Mathematical Olympiad 1989, Problem 1

For each positive integer n, let
  Sn = 1 + 1/2 + 1/3 + ··· + 1/n
  Tn = S1 + S2 + S3 + ··· + Sn
  Un = T1/2 + T2/3 + T3/4 + ··· + Tn/(n+1)
Find, with proof, integers 0 < a, b, c, d < 1000000 such that
  T1988 = a * S1989 - b
  U1988 = c * S1989 - d
-/

namespace Usa1989P1

def s (n : ℕ) : ℚ := ∑i ∈ Finset.Icc 1 n, 1 / i
def t (n : ℕ) : ℚ := ∑i ∈ Finset.Icc 1 n, s i
def u (n : ℕ) : ℚ := ∑i ∈ Finset.Icc 1 n, t i / (i + 1)


-- based on solution from
-- https://artofproblemsolving.com/wiki/index.php/1989_USAMO_Problems/Problem_1

def extract_one {n : ℕ} {f : ℕ → ℚ} :
    (Finset.Icc 1 (n + 1)).sum f = f (n + 1) + (Finset.Icc 1 n).sum f := by
  rw [← Finset.insert_Icc_right_eq_Icc_add_one (by simp)]
  rw [Finset.sum_insert (by simp)]



lemma l1 (n : ℕ) : t (n - 1) = n * s n - n := by
  induction n with
  | zero => simp [t]
  | succ n ih =>
    by_cases h : n = 0
    · simp [t, s, h]
    · rw [Nat.sub_add_comm (Nat.one_le_iff_ne_zero.mpr h)]
      rw [t, extract_one, ← t]
      have h1 : ↑(n + 1) * s (n + 1) = s n + n * s n + 1 := by
        rw [s, extract_one, ← s]
        rw [mul_add, mul_one_div_cancel (by apply NeZero.ne)]
        grind
      grind [t]

lemma l2 (n : ℕ) : u (n - 1) = (n + 1) * s n - 2 * n := by
  induction n with
  | zero => simp [u, t, s]
  | succ n ih =>
    by_cases h : n = 0
    · simp [u, s, h]; ring
    · rw [Nat.sub_add_comm (Nat.one_le_iff_ne_zero.mpr h), u, extract_one, ← u]
      rw [ih]
      rw [← Nat.sub_add_comm (Nat.one_le_iff_ne_zero.mpr h), l1]
      rw [(by rfl : n + 1 - 1 = n), ← Nat.cast_add_one]
      nth_rewrite 2 [← mul_one ((@Nat.cast ℚ Rat.instNatCast) (n + 1))]
      rw [← mul_sub, mul_comm, Rat.mul_div_cancel (by apply NeZero.ne)]
      rw [add_mul]
      nth_rewrite 3 [s]
      rw [extract_one, ← s, mul_add, mul_one_div_cancel (by apply NeZero.ne)]
      grind



noncomputable def solutions : (ℕ × ℕ × ℕ × ℕ) := (1989, 1989, 1990, 2*1989)

theorem usa1989_p1 :
    t 1988 = solutions.1 * s 1989 - solutions.2.1 ∧
    u 1988 = solutions.2.2.1 * s 1989 - solutions.2.2.2 := by
  unfold solutions
  simp
  constructor
  · change t (1989 - 1) = 1989 * s 1989 - 1989
    exact l1 1989
  · change u (1989 - 1) = 1990 * s 1989 - 3978
    rw [(by grind : (3978:ℚ) = 2 * 1989)]
    rw [l2 1989]
    simp
    left
    ring


end Usa1989P1

-- ═══ Usa1992P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1992, Problem 1

Find, as a function of n, the sum of the digits of

     9 × 99 × 9999 × ... × (10^2ⁿ - 1),

where each factor has twice as many digits as the last one.
-/

namespace Usa1992P1



-- TODO add a generalization of this mathlib?
lemma digits_pow (m : ℕ) : (Nat.digits 10 (10^m)).length = m + 1 := by
  induction' m with m ih
  · simp
  rw [pow_succ, Nat.digits_def' (by norm_num) (by positivity)]
  rw [mul_div_cancel_right₀ _ (by norm_num), List.length_cons]
  rw [ih]

lemma lemma2 {m y: ℕ} (hy : y < 10^m) : (Nat.digits 10 y).length < m + 1 := by
  induction m generalizing y with
  | zero => simp [show y = 0 by lia]
  | succ m ih =>
    obtain rfl | hyp := Nat.eq_zero_or_pos y
    · simp
    rw [Nat.digits_def' (by norm_num) hyp]
    rw [List.length_cons, add_lt_add_iff_right]
    have h2 : y / 10 < 10 ^ m := by lia
    exact ih h2

lemma digits_sum_mul_pow {m x : ℕ} :
    (Nat.digits 10 (x * 10 ^ m)).sum = (Nat.digits 10 x).sum := by
  cases x with
  | zero => simp
  | succ x =>
    rw [mul_comm, Nat.digits_base_pow_mul (by lia) (by lia)]
    simp

lemma digits_sum (m x y : ℕ)
    (h1 : y < 10^m) :
    (Nat.digits 10 (x * 10^m + y)).sum =
    (Nat.digits 10 (x * 10^m)).sum + (Nat.digits 10 y).sum := by
  cases x with | zero => simp | succ x =>
  -- choose k such that (digits 10 y).length + k = m
  have h3 : (Nat.digits 10 y).length ≤ m := by
    have h4 := lemma2 h1
    exact Nat.le_of_lt_succ h4
  have ⟨k, hk⟩ : ∃ k, (Nat.digits 10 y).length + k = m := Nat.le.dest h3
  nth_rewrite 1 [add_comm, mul_comm]
  nth_rewrite 1 [←hk]
  have one_lt_ten : 1 < 10 := by norm_num
  rw [←Nat.digits_append_zeroes_append_digits one_lt_ten (Nat.zero_lt_succ x)]
  simp only [List.sum_append, List.sum_replicate, smul_eq_mul, mul_zero, add_zero]
  rw [digits_sum_mul_pow]
  ring

lemma Finset.prod_odd {α : Type} [DecidableEq α] {f : α → ℕ} {s : Finset α}
    (hs : ∀ i ∈ s, Odd (f i)) : Odd (∏ i ∈ s, f i) := by
  revert hs
  induction s using Finset.induction
  case empty => simp
  case insert a s' ha ih =>
    intro hs'
    rw [Finset.prod_insert ha, Nat.odd_mul]
    simp only [Finset.mem_insert, forall_eq_or_imp] at hs'
    specialize ih hs'.2
    exact ⟨hs'.1, ih⟩

lemma lemma3 {m : ℕ} (hm : (m % 10) + 1 < 10) :
    (Nat.digits 10 (m + 1)).sum = (Nat.digits 10 m).sum + 1 := by
  rw [Nat.digits_eq_cons_digits_div (by norm_num) (by lia)]
  by_cases h : m = 0
  · simp [h]
  nth_rw 2 [Nat.digits_eq_cons_digits_div (by norm_num) (by exact h)]
  simp only [List.sum_cons]
  lia

theorem lemma6 {b : ℕ} {l1 l2 : List ℕ} (hg : List.Forall₂ (· ≥ ·) l1 l2) :
    Nat.ofDigits b l1 ≥ Nat.ofDigits b l2 := by
  induction l1 generalizing l2 with
  | nil => simp_all [Nat.ofDigits]
  | cons hd₁ tl₁ ih₁ =>
    induction l2 generalizing tl₁ with
    | nil => simp_all
    | cons hd₂ tl₂ _ =>
      simp only [Nat.ofDigits_cons]
      have htl : List.Forall₂ (fun x1 x2 ↦ x1 ≥ x2) tl₁ tl₂ := by
        simp_all only [ge_iff_le, List.forall₂_cons]
      specialize ih₁ htl
      have h1 : hd₁ ≥ hd₂ := by simp_all only [ge_iff_le, List.forall₂_cons, and_true]
      gcongr

/-- The subtraction of ofDigits of two lists is equal to ofDigits of digit-wise subtraction of them -/
theorem ofDigits_sub_ofDigits_eq_ofDigits_zipWith {b : ℕ} {l1 l2 : List ℕ}
    (hg : List.Forall₂ (· ≥ ·) l1 l2) :
    Nat.ofDigits b l1 - Nat.ofDigits b l2 =
    Nat.ofDigits b (l1.zipWith (· - ·) l2) := by
  induction l1 generalizing l2 with
  | nil => simp_all [Nat.ofDigits]
  | cons hd₁ tl₁ ih₁ =>
    induction l2 generalizing tl₁ with
    | nil => simp_all
    | cons hd₂ tl₂ ih₂ =>
      simp_all only [Nat.ofDigits_cons, List.zipWith_cons_cons]
      have htl : List.Forall₂ (fun x1 x2 ↦ x1 ≥ x2) tl₁ tl₂ := by
        simp_all only [ge_iff_le, List.forall₂_cons]
      specialize ih₁ htl
      rw [← ih₁, Nat.mul_sub]
      have h1 : hd₁ ≥ hd₂ := by simp_all only [ge_iff_le, List.forall₂_cons, and_true]
      have h2 : b * Nat.ofDigits b tl₁ ≥ b * Nat.ofDigits b tl₂ := by
        have : Nat.ofDigits b tl₁ ≥ Nat.ofDigits b tl₂ := lemma6 htl
        gcongr
      lia

lemma lemma8 {n : ℕ} : 10 ^ n - 1 = Nat.ofDigits 10 (List.replicate n 9) := by
  induction n with
  | zero => simp
  | succ n ih =>
    rw [List.replicate_succ, Nat.ofDigits_cons]
    replace ih : 10 ^ n = Nat.ofDigits 10 (List.replicate n 9) + 1 := by
      have : 1 ≤ 10 ^ n := Nat.one_le_pow' n 9
      lia
    rw [pow_succ, ih]
    lia

lemma lemma9 {m n : ℕ} (hm : m < 10^n) : (Nat.digits 10 m).length ≤ n := by
  exact (Nat.digits_length_le_iff (by norm_num) m).mpr hm

def padList (l : List ℕ) (n : ℕ) : List ℕ := l ++ List.replicate (n - l.length) 0

lemma padList_cons {hd n : ℕ} {tl : List ℕ} : padList (hd::tl) (n + 1) = hd :: padList tl n := by
  simp [padList]

def digitsPadded (b m n : ℕ) : List ℕ := padList (Nat.digits b m) n

theorem digitsPadded_lt_base {b m n d : ℕ} (hb : 1 < b)
    (hd : d ∈ digitsPadded b m n) :
    d < b := by
  unfold digitsPadded padList at hd
  simp only [List.mem_append, List.mem_replicate, ne_eq] at hd
  obtain hd | hd := hd
  · exact Nat.digits_lt_base hb hd
  · lia

theorem digitsPaddedLength (b m n : ℕ) (hm : (Nat.digits b m).length ≤ n) :
     (digitsPadded b m n).length = n := by
  unfold digitsPadded padList
  simp only [List.length_append, List.length_replicate]
  exact Nat.add_sub_of_le hm

theorem exists_prefix (L : List ℕ) :
    ∃ l1 : List ℕ, (∀ hl1 : l1 ≠ [], l1.getLast hl1 ≠ 0) ∧
      ∃ m : ℕ, L = l1 ++ List.replicate m 0 := by
  induction L with
  | nil => simp
  | cons hd tl ih =>
    obtain ⟨l2, hl20, m, hm⟩ := ih
    by_cases hnil : l2 ≠ []
    · specialize hl20 hnil
      subst hm
      use hd :: l2
      have h5 : ∀ (hl1 : hd :: l2 ≠ []), (hd :: l2).getLast hl1 ≠ 0 := by simp_all
      refine ⟨h5, m, ?_⟩
      simp
    · simp only [ne_eq, Decidable.not_not] at hnil
      subst hnil
      simp only [List.nil_append] at hm
      subst hm
      cases hd with
      | zero =>
        use []
        constructor
        · simp
        · use m + 1
          rw [List.replicate_succ, List.nil_append]
      | succ hd =>
        use [hd + 1]
        constructor
        · simp
        · use m
          simp

theorem digitsPadded_ofDigits (b n : ℕ) (h : 1 < b) (L : List ℕ) (w₁ : ∀ l ∈ L, l < b)
    (hn : L.length ≤ n) :
    digitsPadded b (Nat.ofDigits b L) n = padList L n := by
  have ⟨l1, hl1, m, hm⟩ := exists_prefix L
  subst hm
  rw [Nat.ofDigits_append_replicate_zero]
  unfold digitsPadded
  have hl : ∀ l ∈ l1, l < b := by simp_all
  have hl3 : ∀ (h : l1 ≠ []), l1.getLast h ≠ 0 := by simp_all
  rw [Nat.digits_ofDigits b h _ hl hl3]
  simp only [padList, List.length_append, List.length_replicate, List.append_assoc,
             List.replicate_append_replicate, List.append_cancel_left_eq, List.replicate_inj,
             or_true, and_true]
  simp only [List.length_append, List.length_replicate] at hn
  lia

theorem digitsPadded_sum (b m n : ℕ) :
    (digitsPadded b m n).sum = (Nat.digits b m).sum := by
  simp [digitsPadded, padList]

lemma List.map_eq_zip (x : ℕ) (l : List ℕ) (f : ℕ → ℕ → ℕ)
    : (List.map (f x) l) = List.zipWith f (List.replicate l.length x) l := by
  induction l with
  | nil => simp
  | cons hd tl ih =>
    simp only [List.map_cons, List.length_cons, ih]
    rfl

lemma lemma5 {m n : ℕ} (hm : m < 10^n) :
    digitsPadded 10 (10^n - 1 - m) n =
    (digitsPadded 10 m n).map (fun d ↦ 9 - d) := by
  let m_digits := Nat.digits 10 m
  let padding := List.replicate (n - m_digits.length) 0
  let m_digits_padded := m_digits ++ padding
  let complement_digits := m_digits_padded.map (λ d ↦ 9 - d)
  have h_length : m_digits_padded.length = n := by
    rw [List.length_append, List.length_replicate]
    have : m_digits.length ≤ n := lemma9 hm
    lia

  have h_sub2 : m = Nat.ofDigits 10 m_digits_padded := by
    unfold m_digits_padded padding m_digits
    rw [Nat.ofDigits_append, Nat.ofDigits_digits, Nat.ofDigits_replicate_zero,
        mul_zero, add_zero]

  have h_length2 : (List.replicate n 9).length = m_digits_padded.length := by
    rw [h_length]
    exact List.length_replicate

  have ha : List.Forall₂ (fun x1 x2 ↦ x1 ≥ x2) (List.replicate n 9) m_digits_padded := by
    unfold m_digits_padded padding
    rw [List.forall₂_iff_get]
    refine ⟨h_length2, ?_⟩
    intro i h1 h2
    simp only [List.get_eq_getElem, List.getElem_replicate, ge_iff_le]
    obtain hl | hr := Nat.lt_or_ge i m_digits.length
    · rw [List.getElem_append_left hl]
      unfold m_digits
      have h3 : (Nat.digits 10 m)[i] ∈ Nat.digits 10 m := List.getElem_mem hl
      have : (Nat.digits 10 m)[i] < 10 := Nat.digits_lt_base' h3
      exact Nat.le_of_lt_succ this
    · rw [List.getElem_append_right hr]
      simp

  have h_sub : 10^n - 1 - m = Nat.ofDigits 10 complement_digits := by
    have h1 := ofDigits_sub_ofDigits_eq_ofDigits_zipWith (b := 10) ha
    have h2 : List.zipWith (fun x1 x2 ↦ x1 - x2) (List.replicate n 9) m_digits_padded =
           List.map (fun d ↦ 9 - d) m_digits_padded := by
      have h5 := List.map_eq_zip 9 m_digits_padded (fun x y ↦ x - y)
      rw [h5]
      rw [h_length]
    rw [h2] at h1
    unfold complement_digits
    rw [←h1, ←lemma8, h_sub2]
  rw [h_sub]
  have h12 : ∀ l ∈ complement_digits, l < 10 := by
    intro x hx
    simp only [List.map_append, List.mem_append, List.mem_map, complement_digits, m_digits_padded,
               padding, m_digits] at hx
    lia
  have h14 : complement_digits.length ≤ n := by
    simp only [List.map_append, List.length_append, List.length_map, complement_digits,
               m_digits_padded, padding, List.length_replicate, m_digits]
    have : (Nat.digits 10 m).length ≤ n := lemma9 hm
    simp_all
  have h13 := digitsPadded_ofDigits 10 n (by norm_num) complement_digits h12 h14
  rw [h13]

  have h16 : (Nat.digits 10 m).length ≤ n := lemma9 hm
  simp [digitsPadded, padList, List.map_append, List.map_replicate, tsub_zero, complement_digits,
        m_digits_padded, padding, m_digits, h16]

lemma List.sum_map_sub_aux (l1 l2 : List ℕ) (h2 : List.Forall₂ (· ≥ ·) l1 l2) :
    (List.zipWith (fun x1 x2 ↦ x1 - x2) l1 l2).sum = l1.sum - l2.sum ∧ l1.sum ≥ l2.sum := by
match l1, l2 with
| [], [] => simp
| [], h :: tl => simp_all
| h :: tl, [] => simp_all
| hd1 :: tl1, hd2 :: tl2 =>
  have hp : List.Forall₂ (fun x1 x2 ↦ x1 ≥ x2) tl1 tl2 := by simp_all only [List.forall₂_cons]
  have ih := List.sum_map_sub_aux tl1 tl2 hp
  simp only [List.zipWith_cons_cons, List.sum_cons]
  rw [ih.1]
  have h3 : hd1 ≥ hd2 := (List.forall₂_cons.mp h2).1
  lia

lemma List.sum_map_sub (l1 l2 : List ℕ) (h2 : List.Forall₂ (· ≥ ·) l1 l2) :
    (List.zipWith (fun x1 x2 ↦ x1 - x2) l1 l2).sum = l1.sum - l2.sum :=
  (List.sum_map_sub_aux l1 l2 h2).1

lemma lemma4 {m n : ℕ} (hm : m < 10^n) :
    (Nat.digits 10 (10^n - 1 - m)).sum = 9 * n - (Nat.digits 10 m).sum := by
  rw [←digitsPadded_sum, lemma5 hm]
  have h2 := List.map_eq_zip 9 (digitsPadded 10 m n) (fun x y ↦ x - y)
  rw [h2]
  have h5 : List.Forall₂ (· ≥ ·)
              (List.replicate (digitsPadded 10 m n).length 9) (digitsPadded 10 m n) := by
     rw [List.forall₂_iff_get]
     refine ⟨List.length_replicate, ?_⟩
     intro x1 hx1 hx2
     simp only [List.get_eq_getElem, List.getElem_replicate, ge_iff_le]
     have h7 := digitsPadded_lt_base (show 1 < 10 by norm_num) (List.getElem_mem hx2)
     lia
  have h4 := List.sum_map_sub _ _ h5
  simp only [List.sum_replicate, smul_eq_mul] at h4
  rw [mul_comm]
  have h6 := digitsPaddedLength _ _ _ (lemma9 hm)
  rw [h6] at h4 ⊢
  rw [digitsPadded_sum] at h4
  exact h4



noncomputable def solution : ℕ → ℕ := fun n ↦ 9 * 2 ^ n

theorem usa1992_p1 (n : ℕ) :
    (Nat.digits 10
     (∏ i ∈ Finset.range (n + 1), (10^(2^i) - 1))).sum = solution n := by
  -- We follow the informal proof from
  -- https://prase.cz/kalva/usa/usoln/usol921.html

  induction' n with n ih
  · simp

  let a i := 10^(2^i) - 1

  -- Obviously, for all i, a i < 10^(2^i).
  have h1 : ∀ i, a i < 10 ^ (2 ^ i) := fun i ↦ by
    dsimp [a]
    have h2 : 0 < 10 ^ 2 ^ i := by positivity
    lia

  have ha1 : ∀ i, 1 ≤ a i := fun i ↦ by
    dsimp [a]
    have h3 : 1 ≤ 2 ^ i := Nat.one_le_two_pow
    have h4 : 10 ^ 1 ≤ 10 ^ (2 ^ i) :=
      Nat.pow_le_pow_right (by norm_num) h3
    lia

  let b : ℕ → ℕ := fun m ↦ ∏ i ∈ Finset.range (m + 1), a i
  change (Nat.digits 10 (b (n +1))).sum = solution (n + 1)

  -- So, for all m, `b m < 10^(1 + 2 + 2^2 + ... + 2^m)`.
  have h2 : ∀ m, b m < 10^(∑ i ∈ Finset.range (m + 1), 2^i) := fun m ↦ by
    dsimp [b]
    rw [←Finset.prod_pow_eq_pow_sum]
    refine Finset.prod_lt_prod_of_nonempty ?_ ?_ Finset.nonempty_range_add_one
    · intro i hi
      exact ha1 i
    · intro i hi
      exact h1 i

  -- ... < 10^(2^m).
  have h3 : ∀ m, 10^(∑ i ∈ Finset.range m, 2^i) < 10^(2^m) := fun m ↦ by
    have h4 : ∑ i ∈ Finset.range m, 2 ^ i < 2 ^ m :=
      Nat.geomSum_lt (le_refl _) fun _ hk ↦ Finset.mem_range.mp hk
    exact (Nat.pow_lt_pow_iff_right (by norm_num)).mpr h4

  have bn_ge_nine : 9 ≤ b n := by
    clear ih
    dsimp [b, a]
    induction n
    case zero => simp
    case succ n ih2 =>
      rw [Finset.prod_range_succ]
      exact le_mul_of_le_of_one_le ih2 (ha1 (n + 1))

  -- Now b (n + 1) = (b n) * 10^N - b n, where N = 2^(n + 1).
  have h4 : b (n + 1) = b n * 10^(2^(n+1)) - b n := by
    nth_rewrite 2 [←mul_one (b n)]
    rw [←Nat.mul_sub_left_distrib]
    dsimp [b]
    rw [Finset.prod_range_succ]

  -- But b n < 10^N,
  have h5 : b n < 10 ^ 2 ^ (n + 1) := by
    calc _ < 10 ^ ∑ i ∈ Finset.range (n + 1), 2 ^ i := h2 _
         _ < 10 ^ 2 ^ (n + 1) := h3 (n + 1)

  have h7 : 1 ≤ b n := by
    dsimp [b]
    exact Finset.one_le_prod' fun i a ↦ ha1 i

  -- ... so b (n + 1) = (b n - 1)10^N + (10^N - b n)
  have h6 : b (n + 1) = (b n - 1) * 10 ^(2^(n+1)) + (10 ^(2^(n+1)) - b n) := by
    rw [h4]
    -- TODO: simpler version via zify
    have h5' := h5.le
    have h8 : 10 ^ 2 ^ (n + 1) ≤ b n * 10 ^ 2 ^ (n + 1) :=
      Nat.le_mul_of_pos_left (10 ^ 2 ^ (n + 1)) h7
    rw [←Nat.add_sub_assoc h5']
    nth_rewrite 2 [add_comm]
    rw [Nat.mul_sub_right_distrib, one_mul, Nat.add_sub_of_le h8]

  -- ... and the digit sum of b (n + 1) is just
  -- the digit sum of (b n - 1)·10^N plus the digit sum of (10^N - b n).
  have h8 : (Nat.digits 10 (b (n + 1))).sum =
            (Nat.digits 10 ((b n - 1) * 10 ^ 2 ^ (n+1))).sum +
            (Nat.digits 10 (10^2^(n+1) - b n)).sum := by
   have h9 : 0 < b n := h7
   have h10 := digits_sum (2^(n+1)) (b n - 1) (10^2^(n+1) - b n)
             (Nat.sub_lt_self h9 h5.le) -- ..
   rw [←h10, h4]
   congr 2
   lia

  -- b n is odd
  have h9 : ∀ n, Odd (b n) := by
    intro n
    unfold b a
    suffices H : ∀ i ∈ Finset.range (n + 1), Odd (a i) from Finset.prod_odd H
    intro i hi
    rw [Nat.odd_iff]
    have h32 : (10 ^ 2 ^ i) % 2 = 0 := by
      rw [show 10 = 5 * 2 by rfl]
      rw [mul_pow, Nat.mul_mod, Nat.pow_mod]
      simp
    rw [←Nat.even_iff] at h32
    rw [←Nat.odd_iff]
    have h33 : Odd 1 := Nat.odd_iff.mpr rfl
    have h34 : 1 ≤ 10 ^ 2 ^ i := Nat.one_le_pow' (2 ^ i) 9
    exact Nat.Even.sub_odd h34 h32 h33

  -- ... so its last digit is non-zero,
  have h10 : (Nat.digits 10 (b n)).head! ≠ 0 := by
    rw [Nat.head!_digits (by norm_num)]
    intro h11
    have h13 : 2 ∣ b n := by lia
    have h14 : ¬ 2 ∣ b n := Odd.not_two_dvd_nat (h9 _)
    contradiction

  have one_lt_ten : 1 < 10 := by norm_num

  -- ... so the digit sum of `b n - 1` is one less than the digit sum of `b n`,
  have h11 : (Nat.digits 10 (b n - 1)).sum = (Nat.digits 10 (b n)).sum - 1 := by
    rw [Nat.digits_def' one_lt_ten (by lia)]
    nth_rewrite 2 [Nat.digits_def' one_lt_ten (by lia)]
    rw [List.sum_cons, List.sum_cons]
    have h13 : b n % 10 ≠ 0 := by
      intro h11
      have h13 : 2 ∣ b n := by lia
      have h14 : ¬ 2 ∣ b n := Odd.not_two_dvd_nat (h9 _)
      contradiction

    have h12 : (b n - 1) / 10 = b n / 10 := by lia
    rw [h12]
    suffices H : (b n - 1) % 10 + 1 = b n % 10 by lia
    lia

  -- ... and hence is 9·2^n - 1.
  rw [ih, solution] at h11

  -- Multiplying by 10^N does not change the digit sum.
  rw [digits_sum_mul_pow, h11] at h8
  clear h11

  -- (10^N - 1) - b n has 2^(n+1) digits,
  -- each 9 minus the corresponding digit of b n,
  -- so its digit sum is 9·2^(n+1) - 9·2^n.
  have h12 : (Nat.digits 10 (10 ^ 2 ^ (n + 1) - 1 - b n)).sum = 9 * 2^(n + 1) - 9 * 2^n := by
    change (Nat.digits 10 (b n)).sum = 9 * 2^n at ih
    rw [lemma4 h5, ih]

  -- b n is odd, so its last digit is not 0,
  -- and hence the last digit of (10^N - 1) - b n is not 9.
  -- So the digit sum of 10^N - b n is 9·2^(n + 1) - 9·2^n + 1.
  have h13 : (Nat.digits 10 (10 ^ 2 ^ (n + 1) - b n)).sum = 9 * 2^(n + 1) - 9 * 2^n + 1 := by
    have h15 : ((10 ^ 2 ^ (n + 1) - 1 - b n) % 10) + 1 < 10 := by
      by_contra! H
      replace H : 9 % 10 = (10 ^ 2 ^ (n + 1) - 1 - b n) % 10 := by lia
      change _ ≡ _ [MOD 10] at H
      rw [show 10 = 2 * 5 by rfl] at H
      have h40 : Nat.Coprime 2 5 := by norm_num
      rw [←Nat.modEq_and_modEq_iff_modEq_mul h40] at H
      obtain ⟨H1, -⟩ := H
      change _ % _ = _ % _ at H1
      simp only [Nat.reduceMod, Nat.reduceMul] at H1
      symm at H1
      rw [←Nat.odd_iff] at H1
      have h42 : (10 ^ 2 ^ (n+1)) % 2 = 0 := by
        rw [show 10 = 5 * 2 by rfl]
        rw [mul_pow, Nat.mul_mod, Nat.pow_mod]
        simp
      rw [←Nat.even_iff] at h42
      have h43 : Odd 1 := Nat.odd_iff.mpr rfl
      have h44 : 1 ≤ 10 ^ 2 ^ (n+1) := Nat.one_le_pow' _ _
      have h45 : Odd (10 ^ 2 ^ (n + 1) - 1) := Nat.Even.sub_odd h44 h42 h43
      have h47 : Even (10 ^ 2 ^ (n + 1) - 1 - b n) := Nat.Odd.sub_odd h45 (h9 n)
      rw [Nat.even_iff] at h47
      rw [Nat.odd_iff] at H1
      simp [H1] at h47
    apply_fun (· + 1) at h12
    rw [←lemma3 h15] at h12
    have h17 : 10 ^ 2 ^ (n + 1) - 1 - b n + 1 = 10 ^ 2 ^ (n + 1) - b n := by lia
    rw [←h17]
    exact h12

  rw [h13] at h8
  rw [h8, solution]

  -- Hence b n has digit sum (9·2^n - 1) + (9·2^(n+1) - 9·2^n + 1) = 9·2^(n+1).
  have h14 : 1 ≤ 2 ^ n := Nat.one_le_two_pow
  lia

end Usa1992P1

-- ═══ Usa1992P2 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 1992, Problem 2

Prove that

1 / cos 0° / cos 1° + 1 / cos 1° / cos 2° + ... + 1 / cos 88° / cos 99° = cos 1° / sin² 1°
-/

namespace Usa1992P2

open Real

theorem usa1992_p2 :
  ∑ i ∈ Finset.range 89, 1 / cos (i * π / 180) / cos ((i + 1) * π / 180) =
  cos (π / 180) / sin (π / 180) ^ 2 := by

  have cosi : ∀ {i : ℕ}, i < 90 → (↑i * π / 180).cos ≠ 0 := by
    intro i hi
    rw [Real.cos_ne_zero_iff]
    intro k
    cancel_denoms
    norm_cast
    lia

  have ha : sin (π / 180) ≠ 0 := by
    rw [← Real.cos_pi_div_two_sub]
    rw [show (π / 2 - π / 180) = (89 * π / 180) by ring]
    exact cosi (show 89 < 90 by norm_num)

  norm_cast
  rw [sq, div_mul_eq_div_div, ← (mul_right_inj' ha), mul_div_assoc',
      mul_div_right_comm, div_self ha, one_mul, Finset.mul_sum]
  conv => lhs; arg 2; intro i; rw [div_div, mul_div_assoc', mul_one]
  suffices new_goal :
    ∑ i ∈ Finset.range 89, (π / 180).sin / ((↑i * π / 180).cos * (↑(i + 1) * π / 180).cos) =
    ∑ i ∈ Finset.range 89, (((↑(i + 1)) * π / 180).sin / ((↑(i + 1)) * π / 180).cos -
                             (↑i * π / 180).sin / (↑i * π / 180).cos)
  · rw [new_goal]
    rw [Finset.sum_range_sub (fun i ↦ (↑i * π / 180).sin / (↑i * π / 180).cos) 89]
    simp only [Nat.cast_ofNat, CharP.cast_eq_zero, zero_mul, zero_div,
               sin_zero, cos_zero, div_one, sub_zero]
    rw [← Real.cos_pi_div_two_sub, ← Real.cos_pi_div_two_sub]
    rw [show (π / 2 - 89 * π / 180) = π / 180 by ring]
    rw [show (π / 2 - π / 180) = 89 * π / 180 by ring]

  apply Finset.sum_congr rfl
  simp only [Finset.mem_range]
  intro i hi
  rw [show (π / 180) = ((i + 1) : ℝ) * π / 180 - (i : ℝ) * π / 180 by ring]
  rw [Real.sin_sub, sub_div]
  norm_cast
  rw [div_mul_eq_div_div]
  rw [mul_div_cancel_right₀ _ (cosi (show i < 90 by lia))]
  rw [mul_comm (cos (↑(i + 1) * π / 180)) (sin (↑i * π / 180))]
  rw [mul_comm (cos (↑i * π / 180)) (cos (↑(i + 1) * π / 180))]
  rw [div_mul_eq_div_div]
  rw [mul_div_cancel_right₀ _ (cosi (show (i+1) < 90 by lia))]

end Usa1992P2

-- ═══ Usa1993P1 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1993, Problem 1

For each integer n ≥ 2, determine whether a or b is larger,
where a and b are positive real numbers satisfying

            aⁿ = a + 1,     b²ⁿ = b + 3a.
-/

namespace Usa1993P1

noncomputable def a_is_larger : ℕ → Bool := fun _ ↦ true

theorem usa1993_p1 (n : ℕ) (hn : 2 ≤ n) (a b : ℝ) (ha : 0 < a) (hb : 0 < b)
    (han : a^n = a + 1) (hbn : b^(2 * n) = b + 3 * a) :
    if a_is_larger n then b < a else a < b := by
  -- informal proof outline taken from
  -- https://artofproblemsolving.com/wiki/index.php/1993_USAMO_Problems/Problem_1
  simp only [a_is_larger, ite_true]
  have h1 : a^(2 * n) - a = a^2 + a + 1 := by
    have h2 : a^n * a^n = (a + 1) * (a + 1) :=
      abs_eq_iff_mul_self_eq.mp (congrArg abs han)
    linear_combination h2
  have h3 : b ^ (2 * n) - b = 3 * a := sub_eq_of_eq_add' hbn
  have h4 : a - 1 ≠ 0 := by
    intro H
    obtain rfl : a = 1 := by linarith only [H]
    norm_num at han
  have h5 : 0 < (a - 1)^2 := by positivity
  have h6 : 3 * a < a^2 + a + 1 := by linarith only [h5]
  have h7 : b ^ (2 * n) - b < a^(2 * n) - a := by linarith only [h1, h3, h6]
  cases n with | zero => norm_num at hn | succ n =>
  have h11 : 0 ≤ a := LT.lt.le ha
  have h20 : 0 ≤ b := LT.lt.le hb

  have h8 : 1 < a := by
    rw[pow_succ] at han
    have h9 : a < a * a^n := by linarith only [han, ha]
    have h10 : 1 < a^n := (lt_mul_iff_one_lt_right ha).mp h9
    rw [←one_pow n] at h10
    exact lt_of_pow_lt_pow_left₀ n h11 h10
  obtain h12 | rfl | h14 := lt_trichotomy a b
  · exfalso
    have h15 : a^(2*n + 1) - 1 < b^(2* n + 1) - 1 := by
      have h15' : a^(2*n + 1) < b^(2* n + 1) :=
        pow_lt_pow_left₀ h12 h11 (Nat.succ_ne_zero (2 * n))
      exact sub_lt_sub_right h15' 1
    have h16 : 0 < a ^(2 * n + 1) - 1 := by
      suffices H : 1 < a ^ (2 * n + 1) from sub_pos.mpr H
      exact one_lt_pow₀ h8 (Nat.succ_ne_zero (2 * n))
    have h17 : a * (a^(2*n + 1) - 1) < b * (b^(2* n + 1) - 1) :=
      mul_lt_mul_of_pos' h12 h15 h16 hb
    have h18 : a * (a ^ (2 * n + 1) - 1) = a^(2*(n + 1)) - a := by ring
    have h19 : b * (b ^ (2 * n + 1) - 1) = b^(2*(n + 1)) - b := by ring
    order
  · linarith only [h7]
  · exact h14


end Usa1993P1

-- ═══ Usa1993P3 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1993, Problem 3

Consider functions f : [0,1] → ℝ which satisfy

  (i)   f(x) ≥ 0 for all x ∈ [0,1]
  (ii)  f(1) = 1
  (iii) f(x) + f(y) ≤ f (x + y) whenever x, y and x + y are all in [0,1].

Determine the smallest constant c such that

       f(x) ≤ cx

for every function satisfying (i) - (iii) and every x ∈ [0,1].
-/

namespace Usa1993P3



-- This lemma was proved automatically by Kimina-Prover 72B
theorem lemma1 (c1 : ℝ) :
  let f := fun x : (Set.Icc (0:ℝ) 1) ↦ if (x:ℝ) ≤ 1 / 2 then 0 else 1;
  (∀ (a : ℝ) (ha : 0 ≤ a ∧ a ≤ 1), f ⟨a, ha⟩ ≤ c1 * a) →
    (∀ (x : ↑(Set.Icc 0 1)), 0 ≤ f x) →
      f 1 = 1 →
        (∀ (x y : ↑(Set.Icc 0 1)) (h : (x:ℝ) + (y:ℝ) ∈ Set.Icc 0 1), f x + f y ≤ f ⟨↑x + ↑y, h⟩) →
           2 ≤ c1 := by
  intro f h1 h2 h3 h4
  by_contra h
  push_neg at h
  have hc1 : c1 ≥ 0 := by
    have h1' := h1 (1 / 2 : ℝ) (by norm_num)
    have h5 : f ⟨(1 / 2 : ℝ), by norm_num⟩ = (0 : ℝ) := by
      simp [f]
    have h6 : (0 : ℝ) ≤ c1 * (1 / 2 : ℝ) := by
      have h7 : f ⟨(1 / 2 : ℝ), by norm_num⟩ ≤ c1 * (1 / 2 : ℝ) := by
        simpa using h1'
      rw [h5] at h7
      exact h7
    linarith
  have h9 : ∃ a : ℝ, a > (1 / 2 : ℝ) ∧ a ≤ (1 : ℝ) ∧ 1 > c1 * a := by
    use (1 + (2 - c1) / 4) / 2
    constructor
    · -- Show a > 1/2
      linarith
    constructor
    · -- Show a ≤ 1
      linarith
    · -- Show 1 > c1 * a
      linarith [sq_nonneg (c1 - 1), sq_nonneg ((1 + (2 - c1) / 4) / 2 - 1 / 2), hc1]
  rcases h9 with ⟨a, ha1, ha2, h10⟩
  have h1' := h1 a ⟨by linarith, ha2⟩
  lia

private lemma dyadicBracket
    (x : ℝ) (hx0 : 0 < x) (hxhalf : x ≤ (1 : ℝ) / 2) :
    ∃ m : ℕ, (1 : ℝ) / (2 : ℝ)^(m+1) < x ∧ x ≤ 1 / (2 : ℝ)^m := by
  obtain ⟨m, hm1, hm2⟩ :=
    exists_nat_pow_near_of_lt_one hx0 (by grind) (show 0 < (1:ℝ)/2 by norm_num) (by norm_num)
  use m
  refine ⟨?_, ?_⟩
  · field_simp at hm1
    simp only [one_div, inv_pow] at hm1 ⊢
    exact hm1
  · field_simp at hm2
    simp only [one_div, inv_pow] at hm2 ⊢
    exact hm2

/-
This lemma was proved by GPT5, with some help from dwrensha to fix
up some errors.
-/
theorem lemma2 (f : ↑(Set.Icc 0 1) → ℝ) (x : ℝ) (hx : 0 ≤ x ∧ x ≤ 1)
    (h1 : ∀ (x : ↑(Set.Icc 0 1)), 0 ≤ f x) (h2 : f 1 = 1)
    (h3 : ∀ (x y : ↑(Set.Icc 0 1)) (h : x.val + y.val ∈ Set.Icc 0 1),
               f x + f y ≤ f ⟨x.val + y.val, h⟩)
    (h4 : ∀ (x : ↑(Set.Icc (0 : ℝ) 1)), 1 - x.val ∈ Set.Icc 0 1)
    (h5 : ∀ (x : ↑(Set.Icc (0 : ℝ) 1)), f x + f ⟨1 - x.val, h4 x⟩ ≤ 1)
    (h6 : ∀ (x : ↑(Set.Icc (0 : ℝ) 1)), f x ≤ 1)
    (h8 : ∀ n : ℕ, ∀ x : Set.Icc (0 : ℝ) (1/2^n), 2^n * (x : ℝ) ∈ Set.Icc (0:ℝ) 1)
    : f ⟨x, hx⟩ ≤ 2 * x := by
  classical
  -- f(0) = 0
  have f0 : f ⟨0, by simp [Set.mem_Icc]⟩ = 0 := by
    have := h5 (1 : ↑(Set.Icc (0 : ℝ) 1))
    have : 1 + f ⟨0, by simp [Set.mem_Icc]⟩ ≤ 1 := by simpa [h2, sub_self] using this
    have h0le : f ⟨0, by simp [Set.mem_Icc]⟩ ≤ 0 := by linarith
    have h0ge : 0 ≤ f ⟨0, by simp [Set.mem_Icc]⟩ := h1 ⟨0, by simp [Set.mem_Icc]⟩
    exact le_antisymm h0le (by simpa using h0ge)

  by_cases hx0 : x = 0
  · subst hx0; simp [mul_zero]; exact le_of_eq f0

  have hxpos : 0 < x := lt_of_le_of_ne' hx.1 hx0

  -- Large x: x ≥ 1/2 ⇒ f(x) ≤ 1 ≤ 2x
  by_cases hxhalf : x ≤ (1 : ℝ)/2
  · -- Small x: use dyadic doubling throughout (this is the part simplified by h8).
    -- Pick m with 2^{-(m+1)} < x ≤ 2^{-m}.
    obtain ⟨m, hx_lower, hx_upper⟩ := dyadicBracket x hxpos hxhalf

    -- For k ≤ m we have x ≤ 1 / 2^k.
    have hx_le_k : ∀ {k}, k ≤ m → x ≤ 1 / (2 : ℝ)^k := by
      intro k hk
      -- since k ≤ m, 2^k ≤ 2^m and thus 1/2^m ≤ 1/2^k
      have : (1 : ℝ) / (2 : ℝ)^m ≤ 1 / (2 : ℝ)^k := by
        -- monotone of (n ↦ (2^n)) with base ≥ 1
        have hk' : (2 : ℝ)^k ≤ (2 : ℝ)^m := by
          have : (1 : ℝ) ≤ (2 : ℝ) := by norm_num
          exact pow_le_pow_right₀ this hk
        have hpos : 0 < (2 : ℝ)^k := by simp
        exact one_div_le_one_div_of_le hpos hk'
      exact hx_upper.trans this

    -- Every 2^k x is in [0,1], by h8.
    have mem_pow (k : ℕ) (hk : k ≤ m) :
        (2 : ℝ)^k * x ∈ Set.Icc (0 : ℝ) 1 := by
      have : x ∈ Set.Icc (0 : ℝ) (1 / (2 : ℝ)^k) := ⟨hx.1, hx_le_k hk⟩
      simpa using h8 k ⟨x, this⟩

    -- Key dyadic superadditivity:  (2^k) f(x) ≤ f(2^k x)  for k ≤ m.
    have super_pow :
        ∀ k, (hk : k ≤ m) → (2 : ℝ)^k * f ⟨x, hx⟩ ≤ f ⟨(2 : ℝ)^k * x, mem_pow k hk⟩ := by
      intro k hk
      induction' k with k ih
      · simp
      · have hk' : k ≤ m := Nat.le_of_succ_le hk
        have memk  := mem_pow k hk'
        have memkp := mem_pow (k+1) hk
        -- multiply IH by 2, then apply h3 at the same point (self + self)
        have step1 :
          (2 : ℝ) * ((2 : ℝ)^k * f ⟨x, hx⟩) ≤
          (2 : ℝ) * f ⟨(2 : ℝ)^k * x, memk⟩ :=
          by
            have : 0 ≤ (2 : ℝ) := by norm_num
            exact mul_le_mul_of_nonneg_left (ih hk') this
        have step2 :
          (2 : ℝ) * f ⟨(2 : ℝ)^k * x, memk⟩ ≤
          f ⟨(2 : ℝ)^(k+1) * x, memkp⟩ := by
          -- h3 applied to the same point adds values
          grind

        -- rewrite 2^(k+1) and combine
        simpa [pow_succ, mul_comm, mul_left_comm, mul_assoc] using step1.trans step2

    -- At k = m we get (2^m) f(x) ≤ f(2^m x) ≤ 1.
    have two_pow_f_le_one :
        (2 : ℝ)^m * f ⟨x, hx⟩ ≤ 1 := by
      have := super_pow m le_rfl
      exact this.trans (h6 ⟨(2 : ℝ)^m * x, mem_pow m le_rfl⟩)

    -- Divide by 2^m > 0:
    have fx_le : f ⟨x, hx⟩ ≤ 1 / (2 : ℝ)^m := by
      have hpos : 0 < (2 : ℝ)^m := by simp
      exact (le_div_iff₀' hpos).mpr two_pow_f_le_one

    -- And 1 / 2^m ≤ 2x because 1 / 2^(m+1) < x  ⇒  (1 / 2^m) = 2 * (1 / 2^(m+1)) < 2x.
    have one_over_le_twox : 1 / (2 : ℝ)^m ≤ 2 * x := by
      have : 1 / (2 : ℝ)^m < 2 * x := by
        have : (2 : ℝ) * (1 / (2 : ℝ)^(m+1)) < (2 : ℝ) * x :=
          mul_lt_mul_of_pos_left hx_lower (by norm_num)
        simpa [pow_succ, one_div, mul_comm, mul_left_comm, mul_assoc] using this
      exact this.le

    exact fx_le.trans one_over_le_twox

  · -- large x
    have : (1 : ℝ) ≤ 2 * x := by
      have : (1 : ℝ)/2 < x := lt_of_le_of_ne (le_of_not_ge hxhalf) (by grind)
      grind
    exact (h6 ⟨x, hx⟩).trans this



def valid (f : Set.Icc (0 : ℝ) 1 → ℝ) : Prop :=
  (∀ x, 0 ≤ f x) ∧
  f 1 = 1 ∧
  ∀ x y, (h : x.val + y.val ∈ Set.Icc 0 1) → f x + f y ≤ f ⟨x.val + y.val, h⟩

noncomputable def min_c : ℝ := 2

theorem usa1993_p3 :
    IsLeast {c | ∀ f, valid f → ∀ x, f x ≤ c * x } min_c := by
  simp only [Subtype.forall, Set.mem_Icc]
  constructor
  · simp only [Set.mem_setOf_eq]
    intro f hf x hx
    obtain ⟨h1, h2, h3⟩ := hf
    unfold min_c
    have h4 : ∀ x : Set.Icc (0:ℝ) 1, (1 - (x:ℝ)) ∈ Set.Icc (0:ℝ) 1 := by
       rintro ⟨x, hx⟩; exact Set.Icc.mem_iff_one_sub_mem.mp hx
    have h5 : ∀ x, f x + f ⟨1 - x, h4 x⟩ ≤ 1 := by
      intro x
      specialize h3 x ⟨1 - x, h4 x⟩
      simp only [add_sub_cancel, Set.mem_Icc, zero_le_one, le_refl, and_self, Set.Icc.mk_one,
        forall_const] at h3
      grw [h3, h2]
    have h6 : ∀ x, f x ≤ 1 :=
      fun x ↦ le_of_add_le_of_nonneg_left (h5 x) (h1 ⟨1 - x, h4 x⟩)
    have h8 : ∀ n : ℕ, ∀ x : Set.Icc (0:ℝ) (1/2^n), 2^n * (x : ℝ) ∈ Set.Icc (0:ℝ) 1 := by
      rintro n ⟨x, hx1, hx2⟩; clear h3; simp at hx ⊢
      refine ⟨hx1, ?_⟩
      grw [hx2]; simp
    exact lemma2 f x hx h1 h2 h3 h4 h5 h6 h8
  · rw [mem_lowerBounds]
    intro c1 hc1
    simp only [Set.mem_setOf_eq] at hc1
    let f : Set.Icc (0 : ℝ) 1 → ℝ := fun x ↦ if x.val ≤ 1/2 then 0 else 1
    have hf : valid f := by
      refine ⟨?_, ?_, ?_⟩
      · intro x
        positivity
      · unfold f; norm_num
      · intro x y hx
        obtain ⟨x, hxx⟩ := x
        obtain ⟨y, hyy⟩ := y
        simp only [Set.mem_Icc] at hx hxx hyy
        obtain ⟨hx1, hx2⟩ := hx
        unfold f
        split_ifs with h1 h2 h3 h4 h5 h6 <;> linarith
    specialize hc1 f hf
    obtain ⟨h1, h2, h3⟩ := hf
    exact lemma1 c1 hc1 h1 h2 h3


end Usa1993P3

-- ═══ Usa1996P1 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 1996, Problem 1

Prove that the average of the numbers n⬝sin(n π / 180)
for n ∈ {2,4,6,…,180} is 1/tan(π/180).
-/

namespace Usa1996P1

theorem usa1996_p1 :
    (1 / (90:ℝ)) * ∑ n ∈ Finset.range 90, (2 * (n+1)) * Real.sin ((2 * (n+1)) * Real.pi / 180)
    = 1 / Real.tan (Real.pi / 180) := by
  have sin1 : Real.sin (Real.pi / 180) ≠ 0 := by
    refine (Real.sin_eq_zero_iff_of_lt_of_lt ?_ ?_).not.mpr ?_ <;> linarith [Real.pi_pos]
  have cos_add : ∀ (x y : ℝ), x + y = Real.pi → Real.cos x + Real.cos y = 0 := by
    intro x y h; rw [(by linarith only [h] : y = Real.pi - x)]; rw [Real.cos_pi_sub, add_neg_cancel]
  apply mul_left_cancel₀ sin1
  rw [mul_comm, mul_assoc, Finset.sum_mul]
  rw [Real.tan_eq_sin_div_cos]
  convert_to 1 / (90:ℝ) * ∑ n ∈ Finset.range 90, (↑n + 1) *
      (Real.cos ((2 * (↑n + 1) - 1) * Real.pi / 180) -
       Real.cos ((2 * (↑n + 1) + 1) * Real.pi / 180)) = Real.cos (Real.pi / 180)
  · congr! 2 with n _
    rw [Real.cos_sub_cos]
    ring_nf
    simp [neg_div]
  · field_simp [mul_comm]
  · simp [field]
    convert_to (∑ n ∈ Finset.range 45, (Real.cos (((89 - n) * 2 + 1) * Real.pi / 180) +
                                         Real.cos ((n * 2 + 1) * Real.pi / 180)))
        - 90 * Real.cos (181 * Real.pi / 180) = _
    · rw [Finset.sum_congr rfl (fun n a ↦ mul_sub_left_distrib _ _ _)]
      rw [Finset.sum_sub_distrib]
      nth_rewrite 2 [Finset.sum_range_succ]
      have h1 : ∑ x ∈ Finset.range 89, (↑x + 1) * Real.cos ((2 * (↑x + 1) + 1) * Real.pi / 180) =
             ∑ x ∈ Finset.range 90, (↑x) * Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180) := by
        nth_rewrite 2 [Finset.sum_range_succ']
        simp only [Nat.cast_add, Nat.cast_one, CharP.cast_eq_zero,
                   zero_add, mul_one, zero_mul, add_zero]
        apply Finset.sum_congr rfl
        intro x _
        have h3 : 2 * ((x:ℝ) + 1) + 1 = 2 * (↑x + 1 + 1) - 1 := by ring
        rw [h3]
      rw [h1]; clear h1
      rw [sub_add_eq_sub_sub, ←Finset.sum_sub_distrib]
      have h4 : ∀ x ∈ Finset.range 90,
         ((↑x + 1) * Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180) -
           ↑x * Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180)) =
          Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180) := by
        intro x _; ring
      rw [Finset.sum_congr rfl h4]; clear h4
      have h5 : ∑ x ∈ Finset.range 90, Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180)
          = ∑ n ∈ Finset.range 45, (Real.cos (((89 - ↑n) * 2 + 1) * Real.pi / 180) +
                                     Real.cos ((↑n * 2 + 1) * Real.pi / 180)) := by
        rw [Finset.sum_add_distrib]
        simp only [Finset.range_eq_Ico]
        have h6 : 0 ≤ 45 := by norm_num
        have h7 : 45 ≤ 90 := by norm_num
        rw [←Finset.sum_Ico_consecutive
             (f := (fun x ↦ Real.cos ((2 * (↑x + 1) - 1) * Real.pi / 180))) h6 h7]
        have h8 : ∀ i ∈ Finset.Ico (0:ℕ) 45,
             Real.cos ((2 * (↑i + 1) - 1) * Real.pi / 180) =
                        Real.cos ((↑i * 2 + 1) * Real.pi / 180) := by
          intro i _
          have h10 : 2 * ((i:ℝ) + 1) - 1 = ↑i * 2 + 1 := by ring
          rw [h10]
        rw [Finset.sum_congr rfl h8]; clear h8
        have h9 :
            ∑ i ∈ Finset.Ico (45:ℕ) 90, Real.cos ((2 * (↑i + 1) - 1) * Real.pi / 180) =
            ∑ x ∈ Finset.Ico (0:ℕ) 45, Real.cos (((89 - ↑x) * 2 + 1) * Real.pi / 180) := by
          have h15 : 45 = 89 + 1 - 45 := by norm_num
          have h16 : 90 = 89 + 1 - 0 := by norm_num
          nth_rewrite 1 [h15, h16]
          rw [←Finset.sum_Ico_reflect _ 0 h7]
          apply Finset.sum_congr rfl
          intro x hx
          apply congrArg
          have h18 : (((89 - x) : ℕ) : ℝ) = 89 - x := by
            apply Nat.cast_sub
            rw [Finset.mem_Ico] at hx
            lia
          rw [h18]
          ring
        rw [h9]; clear h9
        exact add_comm _ _
      rw [←h5]
      norm_num1
      ring
    · rw [mul_comm]
      rw [Finset.sum_eq_zero]
      · simp only [zero_sub]
        rw [←neg_mul, ←Real.cos_sub_pi]
        ring_nf
      intro n _
      rw [cos_add]
      ring


end Usa1996P1

-- ═══ Usa1997P5 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/





/-!
# USA Mathematical Olympiad 1997, Problem 5

Let a, b, c be positive reals.
Prove that
1 / (a³ + b³ + abc) + 1 / (b³ + c³ + abc) + 1 / (c³ + a³ + abc) ≤ 1 / abc
-/

open Real

namespace Usa1997P5

variable {a b c : ℝ}



-- Follows the solution at https://web.evanchen.cc/exams/USAMO-1997-notes.pdf
-- One just cyclically sums 1 / (a³ + b³ + abc) ≤ 1 / (ab(a+b) + abc)

-- Bounding the individual fraction
lemma bound (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    1 / (a^3 + b^3 + a*b*c) ≤ 1 / (a^2*b + a*b^2 + a*b*c) := by
  field_simp -- clear denominators
  have h : 0 ≤ (a-b)^2*(a+b) := by positivity
  linarith

-- Add the three bounds together
def main_sum (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :=
  let h1 := bound ha hb hc
  let h2 := bound hb hc ha
  let h3 := bound hc ha hb
  add_le_add h1 (add_le_add h2 h3)



theorem usa1997_p5 (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    1 / (a^3 + b^3 + a*b*c) + 1 / (b^3 + c^3 + a*b*c) + 1 / (c^3 + a^3 + a*b*c) ≤ 1 / (a*b*c) := by
  convert main_sum ha hb hc using 1
  · ring -- LHS of main sum = LHS of desired
  · field -- RHS of main sum = RHS of desired

end Usa1997P5

-- ═══ Usa1998P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1998, Problem 1

Suppose that the set { 1, 2, ..., 1998 } has been partitioned into disjoint
pairs {aᵢ, bᵢ}, where 1 ≤ i ≤ 999, so that for all i, |aᵢ - bᵢ| = 1 or 6.

Prove that the sum

  |a₁ - b₁| + |a₂ - b₂| + ... + |a₉₉₉ - b₉₉₉|

ends in the digit 9.
-/

namespace Usa1998P1



lemma zmod_eq (a b c : ℤ) : a ≡ b [ZMOD c] ↔ a % c = b % c := by rfl

lemma mod2_abs (a : ℤ) : |a| % 2 = a % 2 := by
  obtain h | h := abs_cases a <;> rw [h.1]
  rw [Int.neg_emod_two]

-- For integers M,N we have |M-N| ≡ M-N ≡ M+N MOD 2.
lemma mod2_diff (a b : ℤ) : |a - b| % 2 = (a + b) % 2 := by
  rw [mod2_abs, Int.sub_eq_add_neg, Int.add_emod, Int.neg_emod_two, ←Int.add_emod]

lemma lemma0 (n : ℕ) : (∑ x ∈ Finset.Icc 1 (4 * n + 2), (x:ℤ) % 2) % 2 = 1 := by
  norm_cast
  induction n with
  | zero => simp +arith +decide
  | succ n ih =>
    rw [show 4 * (n + 1) + 2 = (4 * n + 2) + 4 by lia]
    rw [Finset.sum_Icc_succ_top (by norm_num)]
    rw [Finset.sum_Icc_succ_top (by norm_num)]
    rw [Finset.sum_Icc_succ_top (by norm_num)]
    rw [Finset.sum_Icc_succ_top (by norm_num)]
    lia



/--
 `ab 0 i` is aᵢ and `ab 1 i` is `bᵢ`
-/
theorem usa1998_p1
    (ab : Fin 2 → Fin 999 → Finset.Icc 1 1998)
    (hab : (ab.uncurry).Bijective)
    (habd : ∀ i : Fin 999,
              |(ab 0 i : ℤ) - (ab 1 i : ℤ)| = 1 ∨
              |(ab 0 i : ℤ) - (ab 1 i : ℤ)| = 6) :
    (∑ i : Fin 999, |(ab 0 i : ℤ) - (ab 1 i : ℤ)|) % 10 = 9 := by
  -- Informal solution from
  -- https://artofproblemsolving.com/wiki/index.php/1998_USAMO_Problems/Problem_1
  -- Notice that |aᵢ-bᵢ| ≡ 1 MOD 5,
  have h1 : ∀ i : Fin 999, |(ab 0 i : ℤ) - ab 1 i| % 5 = 1 % 5 := fun i ↦ by
    obtain habd | habd := habd i
    · rw [habd]
    · rw [habd]; rfl

  -- so S=|a₁-b₁|+|a₂-b₂|+ ⋯ +|a₉₉₉ - b₉₉₉| ≡ 1+1+ ⋯ + 1 ≡ 999 ≡ 4 MOD 5.
  have h2 : (∑ i : Fin 999, |ab 0 i - ab 1 i|) ≡ 4 [ZMOD 5] :=
  by rw [zmod_eq, Finset.sum_int_mod, Fintype.sum_congr _ _ h1]
     rw [Finset.sum_const, Finset.card_univ, Fintype.card_fin]
     decide

  --
  -- Also, for integers M,N we have |M-N| ≡ M-N ≡ M+N MOD 2.
  -- (see mod2_diff above).
  --
  -- Thus, we also have
  -- S ≡ a₁ + b₁ + a₂ + b₂ + ⋯ + a₉₉₉ + b₉₉₉ [MOD 2]
  --   ≡ 1 + 2 + ⋯ + 1998 [MOD 2]
  --   ≡ 999*1999 ≡ 1 [MOD 2]
  have h3 : ∑ i : Fin 999, |(ab 0 i : ℤ) - ab 1 i| ≡ 1 [ZMOD 2] := by
    rw [zmod_eq, Finset.sum_int_mod]
    have h4 : ∀ i : Fin 999,
        |(ab 0 i : ℤ) - ab 1 i| % 2 = ((ab 0 i % 2) + (ab 1 i % 2)) % 2 := by
      intro i
      rw [mod2_diff, Int.add_emod]

    rw [Fintype.sum_congr _ _ h4, ←Finset.sum_int_mod, Finset.sum_add_distrib]

    have h9 : ∑ x : Fin 999, ((ab 0 x : ℤ) % 2) + ∑ x : Fin 999, ((ab 1 x : ℤ) % 2) =
         ∑ x : Fin 2 × Fin 999, (↑↑(ab.uncurry x) % 2) := by
      rw [← Fin.sum_univ_two (f := fun i ↦ ∑ x : Fin 999, ((ab i x : ℤ) % 2)),
          ← Finset.univ_product_univ, ← Finset.sum_product']
      rfl

    have h10 : ∑ x : Fin 2 × Fin 999, ((ab.uncurry x : ℤ) % 2) =
              ∑ x : Finset.Icc 1 1998, (x : ℤ) % 2 :=
      by apply Fintype.sum_bijective _ hab
         · exact congr_fun rfl
    rw [h9, h10]
    simp only [Finset.univ_eq_attach, Int.one_emod_two,
               Finset.sum_attach (Finset.Icc 1 1998) (fun (x:ℕ) => (x : ℤ) % 2)]
    rw [lemma0 499]

  -- Combining these facts gives S ≡ 9 MOD 10.
  have hmn : Nat.Coprime (Int.natAbs 2) (Int.natAbs 5) := by norm_cast
  rw [show (9:ℤ) = 9 % 10 by decide,
      ← zmod_eq,
      show (10:ℤ) = 2 * 5 by norm_num]

  rw [←Int.modEq_and_modEq_iff_modEq_mul hmn, zmod_eq, zmod_eq, h3, h2]
  decide

end Usa1998P1

-- ═══ Usa1998P3 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1998, Problem 3

Let a₀,a₁,...,aₙ be real numbers from the interval (0,π/2) such that

  tan(a₀ - π/4) + tan(a₁ - π/4) + ... + tan(aₙ - π/4) ≥ n - 1.

Prove that

  tan(a₀)tan(a₁)...tan(aₙ) ≥ nⁿ⁺¹.

-/

namespace Usa1998P3



lemma lemma0 : Set.Icc (-Real.pi / 4) (Real.pi / 4) ⊆
               Set.Ioo (-(Real.pi / 2)) (Real.pi/2) := by
   intro a ha
   exact ⟨by linarith[ha.1, Real.pi_pos], by linarith[ha.2, Real.pi_pos]⟩

lemma lemma1 (x : ℝ) (hx : x ∈ Set.Ioo 0 (Real.pi / 2)) :
    Real.tan (x - Real.pi / 4) < 1 := by
  let y' x := Real.tan (x - Real.pi / 4)
  have h4 : Real.tan (Real.pi / 4) = y' (Real.pi / 2) := by
    dsimp only [y']
    rw [Real.tan_pi_div_two_sub, Real.tan_pi_div_four, one_eq_inv]
  rw [← Real.tan_pi_div_four]
  rw [h4]
  let y1 x := x - Real.pi / 4
  have h5 : StrictMonoOn y1 (Set.Icc 0 (Real.pi / 2)) := by
    intro a _ b _ hab
    exact sub_lt_sub_right hab _

  have h6 : StrictMonoOn y' (Set.Icc 0 (Real.pi / 2)) := by
    apply StrictMonoOn.comp (g := Real.tan) (f := y1)
         (t := (Set.Icc (-Real.pi / 4) (Real.pi / 4)))
         (StrictMonoOn.mono Real.strictMonoOn_tan lemma0)
         h5
    · intro a ha
      obtain ⟨ha1, ha2⟩ := ha
      constructor
      · dsimp [y1]; linarith
      · dsimp [y1]; linarith

  apply h6
  · exact Set.mem_Icc_of_Ioo hx
  · constructor
    · exact le_of_lt Real.pi_div_two_pos
    · exact Eq.le rfl
  · exact hx.2

lemma lemma2' (n : ℕ) : Finset.erase (Finset.range (n + 1)) n = Finset.range n :=
by rw [←Nat.succ_eq_add_one, Finset.range_add_one]; simp

lemma lemma2 (n : ℕ) (f : ℕ → ℝ) :
    ∏ i ∈ Finset.range (n + 1), ∏ j ∈ Finset.erase (Finset.range (n + 1)) i, f j =
    ∏ i ∈ Finset.range (n + 1), (f i)^(n:ℝ) := by
  induction n with
  | zero => simp
  | succ n ih =>
    have h1 : ∏ i ∈ Finset.range (Nat.succ n + 1), f i ^ ((Nat.succ n):ℝ) =
            (∏ i ∈ Finset.range (n + 1), f i ^ ((Nat.succ n):ℝ)) * f (n + 1) ^ ((Nat.succ n):ℝ) :=
     by rw [Finset.prod_range_succ]
    rw [h1]; clear h1
    have h2 : ∏ i ∈ Finset.range (n + 1), f i ^ ((Nat.succ n):ℝ) =
              ∏ i ∈ Finset.range (n + 1), (f i ^ (n:ℝ) * f i) := by
       congr; funext x
       norm_cast
    rw [h2]; clear h2
    rw [Finset.prod_mul_distrib]

    rw [Finset.prod_range_succ, lemma2']

    have h3 :
       (∏ x ∈ Finset.range (n + 1),
          ∏ j ∈ Finset.erase (Finset.range (Nat.succ n + 1)) x, f j) =
        ∏ x ∈ Finset.range (n + 1),
          ((∏ j ∈ Finset.erase (Finset.range (n + 1)) x, f j) * f (n + 1)) := by
      apply Finset.prod_congr rfl
      intro x hx
      have h7' : (n + 1) ∉ (Finset.erase (Finset.range (n + 1)) x) := by simp_all
      have h7 : Finset.erase (Finset.range (Nat.succ n + 1)) x =
          insert (n + 1) (Finset.erase (Finset.range (n + 1)) x)  := by
        ext y
        constructor
        · intro hy
          rw [Finset.mem_erase, Finset.mem_range] at hy
          rw [Finset.mem_insert, Finset.mem_erase, Finset.mem_range]
          lia
        · intro hy
          rw [Finset.mem_insert, Finset.mem_erase, Finset.mem_range] at hy
          rw [Finset.mem_range] at hx
          rw [Finset.mem_erase, Finset.mem_range]
          lia
      rw [h7, Finset.prod_insert h7']
      ring
    rw [h3]

    have h4 :
        ∏ x ∈ Finset.range (n + 1),
          ((∏ j ∈ Finset.erase (Finset.range (n + 1)) x, f j) * f (n + 1)) =
         (∏ x ∈ Finset.range (n + 1),
            ∏ j ∈ Finset.erase (Finset.range (n + 1)) x, f j) * f (n + 1) ^ (n+1) := by
      rw [Finset.prod_mul_distrib, Finset.prod_const, Finset.card_range]
    rw [h4, ih, mul_right_comm]
    norm_cast



theorem usa1998_p3
    (n : ℕ)
    (a : ℕ → ℝ)
    (ha : ∀ i ∈ Finset.range (n + 1), a i ∈ Set.Ioo 0 (Real.pi / 2))
    (hs : n - 1 ≤ ∑ i ∈ Finset.range (n + 1), Real.tan (a i - (Real.pi / 4)))
    : n ^ (n + 1) ≤ ∏ i ∈ Finset.range (n + 1), Real.tan (a i) := by

  obtain h0 | h0 := eq_or_ne n 0
  · simp_all
    exact Real.tan_nonneg_of_nonneg_of_le_pi_div_two
            (le_of_lt ha.1)
            (le_of_lt ha.2)

  -- informal solution from artofproblemsolving.com
  --
  -- Let yᵢ = tan(aᵢ - π/4), where 0 ≤ i ≤ n.
  let y : ℕ → ℝ := λ i ↦ Real.tan (a i - Real.pi / 4)

  --  1 + yᵢ ≥ ∑_{j ≠ i} (1 - yⱼ)
  have h2 : ∀ i ∈ Finset.range (n + 1),
      ∑ j ∈ (Finset.range (n + 1)).erase i, (1 - y j) ≤ 1 + y i := by
    intro i hi
    rw [Finset.sum_erase_eq_sub hi]
    simp only [Finset.sum_sub_distrib, Finset.sum_const, Finset.card_range,
               nsmul_eq_mul, Nat.cast_add, Nat.cast_one]
    linarith

  --  (1 + yᵢ)/n ≥ (1/n) ∑_{j ≠ i} (1 - yⱼ)
  have h3 : ∀ i ∈ Finset.range (n + 1),
      (1/(n:ℝ)) * ∑ j ∈ (Finset.range (n + 1)).erase i, (1 - y j)
          ≤ (1 + y i)/n := by
    intro i hi
    have hn : 0 ≤ (n : ℝ) := Nat.cast_nonneg n
    rw [div_mul_eq_mul_div, one_mul]
    exact div_le_div_of_nonneg_right (h2 i hi) hn

  --
  -- Then, by AM-GM,
  -- (1/n) ∑_{j ≠ i} (1 - yⱼ) ≥ ∏_{j ≠ i} (1 - yⱼ)^{1/n}
  have h4 : ∀ i ∈ Finset.range (n + 1),
     ∏ j ∈ (Finset.range (n + 1)).erase i, (1 - y j)^(1 / (n : ℝ)) ≤
     (1/(n:ℝ)) * ∑ j ∈ (Finset.range (n + 1)).erase i, (1 - y j) := by
    intro i hi
    let w : ℕ → ℝ := fun i ↦ 1 / (n:ℝ)
    have hw' : ∑ _j ∈ (Finset.range (n + 1)).erase i, w i = 1 := by
       simp [w, Finset.card_erase_of_mem hi]
       field_simp
    have hw : ∀ j ∈ (Finset.range (n + 1)).erase i, 0 ≤ w j := by
      intro j _hj
      simp only [w, one_div, inv_nonneg, Nat.cast_nonneg]
    have hz : ∀ j ∈ (Finset.range (n + 1)).erase i, 0 ≤ 1 - y j := by
      intro j hj
      rw [Finset.mem_erase] at hj
      exact sub_nonneg.mpr (le_of_lt (lemma1 (a j) (ha j hj.2)))

    have h5 := Real.geom_mean_le_arith_mean_weighted
              ((Finset.range (n + 1)).erase i)
              w (λ j ↦ 1 - y j)
              hw hw' hz
    rw [Finset.mul_sum]
    exact h5

  -- (1 + yᵢ)/n ≥ ∏_{j ≠ i} (1 - yⱼ)^{1/n}
  have h5 : ∀ i ∈ Finset.range (n + 1),
      ∏ j ∈ Finset.erase (Finset.range (n + 1)) i, (1 - y j) ^ (1 / (n:ℝ)) ≤
      (1 + y i) / ↑n := fun i hi ↦ (h4 i hi).trans (h3 i hi)

  -- ∏ᵢ(1 + yᵢ)/n ≥ ∏ᵢ∏_{j ≠ i} (1 - yⱼ)^{1/n}
  -- ∏ᵢ(1 + yᵢ)/n ≥ ∏ᵢ(1 - yᵢ)
  -- ∏ᵢ(1 + yᵢ)/(1 - yᵢ) ≥ ∏ᵢn
  -- ∏ᵢ(1 + yᵢ)/(1-yᵢ) ≥ nⁿ⁺¹
  have h6 : (n:ℝ) ^ ((n:ℝ) + 1) ≤ ∏ j ∈ Finset.range (n + 1), (1 + y j) / (1 - y j) := by
    have h20 : ∀ i ∈ Finset.range (n + 1),
        0 ≤ ∏ j ∈ Finset.erase (Finset.range (n + 1)) i, (1 - y j) ^ (1 / (n:ℝ)) := by
      intro i _hi
      apply Finset.prod_nonneg
      intro ii hii
      rw [Finset.mem_erase] at hii
      have := sub_nonneg.mpr (le_of_lt (lemma1 (a ii) (ha ii hii.2)))
      have := Real.rpow_nonneg this (1 / ↑n)
      exact this -- if I try to collapse this to the previous line, i get timeouts.
    have h21 := Finset.prod_le_prod h20 h5
    have h23 : ∏ i ∈ Finset.range (n + 1),
                ∏ j ∈ Finset.erase (Finset.range (n + 1)) i, (1 - y j) ^ (1 / (n:ℝ))
                = ∏ i ∈ Finset.range (n + 1), (1 - y i) := by
      rw [lemma2]
      apply Finset.prod_congr rfl
      intro x hx
      have h30 : 0 ≤ 1 - y x := sub_nonneg.mpr (le_of_lt (lemma1 (a x) (ha x hx)))
      have h31 : (1:ℝ) / n * n = n / n := by field_simp
      have h32 : (n:ℝ) / n = 1 := by field_simp
      rw [←Real.rpow_mul h30, h31, h32, Real.rpow_one]
    rw [h23] at h21; clear h23
    have h24 : ∏ i ∈ Finset.range (n + 1), (1 + y i) / ↑n =
                 (∏ i ∈ Finset.range (n + 1), (1 + y i)) / (↑n)^((n:ℝ) + 1) := by
      have h41 : ∏ i ∈ Finset.range (n + 1), (1 + y i) / ↑n =
                   ∏ i ∈ Finset.range (n + 1), (1 + y i) * (1 / (n:ℝ)) := by
        apply Finset.prod_congr rfl
        intro x _hx
        exact div_eq_mul_one_div _ _
      rw [h41]; clear h41
      rw [Finset.prod_mul_distrib, Finset.prod_const, Finset.card_range]
      have h43 : HPow.hPow ((1:ℝ) / (n:ℝ)) (n + 1) = (1:ℝ) / (↑n ^ ((n:ℝ) + 1)) := by
        norm_cast
        rw [div_pow, one_pow]
        norm_cast
      rw [h43]
      exact mul_one_div _ _
    rw [h24] at h21; clear h24
    rw [Finset.prod_div_distrib]
    have h25 : 0 < (n:ℝ) ^ ((n:ℝ) + 1) := by
      norm_cast
      exact Nat.pow_pos (Nat.zero_lt_of_ne_zero h0)
    have h26 : 0 < ∏ x ∈ Finset.range (n + 1), (1 - y x) := by
      apply Finset.prod_pos
      intro x hx
      exact sub_pos.mpr (lemma1 (a x) (ha x hx))
    rw [le_div_iff₀ h26, ←le_div_iff₀' h25]
    exact h21

  -- by the addition formula for tangents,
  -- tan(aᵢ) = tan((aᵢ - π/4) + π/4) = (1 + tan(aᵢ - π/4))/(1 - tan(aᵢ-π/4))
  --     ... = (1 + yᵢ)/(1 - yᵢ)
  have h7 : ∀ i ∈ Finset.range (n + 1), Real.tan (a i) = (1 + y i) / (1 - y i) := by
    intro i hi
    have h8 : a i = a i - Real.pi / 4 + Real.pi / 4 := eq_add_of_sub_eq rfl
    rw [h8]
    have h10 : (∀ (k : ℤ), a i - Real.pi / 4 ≠ (2 * ↑k + 1) * Real.pi / 2) ∧
                ∀ (l : ℤ), Real.pi / 4 ≠ (2 * ↑l + 1) * Real.pi / 2 := by
      have ⟨ha1, ha2⟩ := ha i hi
      constructor
      · intro k hk
        field_simp at hk
        have hkk : ∃ kk : ℝ, ↑k = kk := ⟨↑k, rfl⟩
        have ⟨kk, hkk'⟩ := hkk
        rw [hkk'] at hk
        obtain hk' | hk' := lt_or_ge k 0
        · have hk2 : k ≤ -1 := Iff.mp Int.lt_add_one_iff hk'
          have : kk ≤ -1 := by rw [← hkk']; norm_cast
          nlinarith only [Real.pi_pos, ha1, hk2, this, hk]
        · have : 0 ≤ kk := by rw [← hkk']; norm_cast
          nlinarith only [Real.pi_pos, ha2, this, hk]
      · intro k hk
        field_simp at hk
        have hkk : ∃ kk : ℝ, ↑k = kk := ⟨↑k, rfl⟩
        have ⟨kk, hkk'⟩ := hkk
        rw [hkk'] at hk
        obtain hk' | hk' | hk' := lt_trichotomy k 0
        · have hk2 : k ≤ -1 := Iff.mp Int.lt_add_one_iff hk'
          have : kk ≤ -1 := by rw [← hkk']; norm_cast
          nlinarith only [Real.pi_pos, ha1, hk2, this, hk]
        · have hk0 : kk = 0 := by rw [←hkk']; norm_cast
          rw [hk0] at hk
          norm_num at hk
        · have hk2 : 1 ≤ k := hk'
          have : 1 ≤ kk := by rw [← hkk']; norm_cast
          nlinarith only [Real.pi_pos, ha1, hk2, this, hk]
    have h11 := Real.tan_add' h10
    have h12 : Real.tan (a i - Real.pi / 4) + 1 =
                 1 + Real.tan (a i - Real.pi / 4) := add_comm _ _

    rw [Real.tan_pi_div_four, mul_one, h12] at h11
    exact h11

  -- so ∏ᵢ(1 + yᵢ)/(1-yᵢ) = ∏ᵢtan(aᵢ) ≥ nⁿ⁺¹, as desired
  have h8 : ∏ i ∈ Finset.range (n + 1), Real.tan (a i) =
              ∏ j ∈ Finset.range (n + 1), (1 + y j) / (1 - y j) :=
     Finset.prod_congr rfl (fun x hx ↦ h7 x hx)
  have h9 : (n:ℝ) ^ ((n:ℝ) + 1) = n ^ (n + 1) := by norm_cast
  rw [h8, ←h9]
  exact h6


end Usa1998P3

-- ═══ Usa1998P5 ═══

/-
Copyright (c) 2023 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 1998, Problem 5

Prove that for each n ≥ 2, there is a set S of n integers such that
(a-b)² divides ab for every distinct a,b ∈ S.
-/

namespace Usa1998P5

theorem usa1998_p5 (n : ℕ) (_hn : 2 ≤ n) :
    ∃ S : Finset ℤ,
       S.card = n ∧
       ∀ a ∈ S, ∀ b ∈ S, a ≠ b → (a - b)^2 ∣ a * b := by
  -- (Adaptation of informal proof from Andreescu & Feng.)
  suffices H : ∃ S : Finset ℤ, (∀ x ∈ S, 0 ≤ x) ∧
       S.card = n ∧
       ∀ a ∈ S, ∀ b ∈ S, a ≠ b → (a - b)^2 ∣ a * b by
    obtain ⟨S, _, hS2⟩ := H
    exact ⟨S, hS2⟩
  clear _hn
  induction n with
  | zero => use ∅; simp
  | succ n ih =>
    obtain ⟨Sp, sp_nonnegative, sp_card, hsp⟩ := ih
    let L : ℤ := ∏ s ∈ Sp, ∏ t ∈ Sp.erase s, (s-t)^2

    have L_pos : 0 < L := by
      refine Finset.prod_pos fun s _ ↦ Finset.prod_pos ?_
      intro t ht
      obtain ⟨t_ne_s, _⟩ := Finset.mem_erase.mp ht
      have : s - t ≠ 0 := sub_ne_zero_of_ne t_ne_s.symm
      positivity

    -- Define Sₙ₊₁ = { L + a : a ∈ Sₙ } ∪ { 0 }.
    let S : Finset ℤ := Sp.map (addLeftEmbedding L) ∪ {0}
    use S

    constructor
    · -- all elements are nonnegative
      intro x hx
      rw [Finset.mem_union] at hx
      cases hx with
      | inl hx =>
        rw [Finset.mem_map] at hx
        obtain ⟨w, hw1, hw2⟩ := hx
        have := sp_nonnegative w hw1
        replace hw2 : L + w = x := hw2
        lia
      | inr hx => simp_all
    · constructor
      · --cardinality is n + 1
        grind
      · intro α hα β hβ α_ne_β
        rw [Finset.mem_union, Finset.mem_map] at hα hβ
        -- If α,β ∈ Sₙ₊₁ and either α or β is zero, then (α - β)² divides αβ.
        cases hα with
        | inr hα => simp_all
        | inl hα =>
          cases hβ with
          | inr hβ => simp_all
          | inl hβ =>
            obtain ⟨a, ha, ha2⟩ := hα
            replace ha2 : L + a = α := ha2
            obtain ⟨b, hb, hb2⟩ := hβ
            replace hb2 : L + b = β := hb2
            have a_ne_b : a ≠ b := by lia
            have ih := hsp a ha b hb a_ne_b
            have h5 : L = (∏ t ∈ Sp.erase a, (a-t)^2) *
                         ∏ s ∈ Sp.erase a, ∏ t ∈ Sp.erase s, (s-t)^2 :=
              (Finset.mul_prod_erase Sp _ ha).symm
            have hbb := Finset.mem_erase.mpr ⟨a_ne_b.symm, hb⟩
            have h6 : (a-b)^2 * ∏ t ∈ (Sp.erase a).erase b, (a-t)^2 =
                      ∏ t ∈ Sp.erase a, (a-t)^2 :=
               Finset.mul_prod_erase (Sp.erase a) (fun x ↦ (a-x)^2) hbb
            have Lmod : L % (a - b)^2 = 0 := by
                 rw [h5, ←h6, mul_assoc, Int.mul_emod, Int.emod_self]
                 norm_num
            have Lmod' : (L + a) * (L + b) % (a-b)^2 = 0 := by
               have h7 : (L + a) * (L + b) = L * (L + a + b) + a * b := by ring
               rw [h7, Int.add_emod]
               have h8 : L * (L + a + b) % (a - b) ^ 2 = 0 := by
                 rw [Int.mul_emod, Lmod]
                 norm_num
               have h9 :  a * b % (a - b) ^ 2 = 0 := Int.emod_eq_zero_of_dvd ih
               rw [h8, h9]
               norm_num
            have hab : a - b = α - β := by lia
            rw [ha2, hb2, hab] at Lmod'
            exact Int.dvd_of_emod_eq_zero Lmod'


end Usa1998P5

-- ═══ Usa2000P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
USA Mathematical Olympiad 2000, Problem 1

A function f : ℝ → ℝ is called "very convex" if it satisfies

  ∀ x y : ℝ, (f(x) + f(y))/2 ≥  f((x + y)/2) + |x - y|.

Show that there exist no very convex functions.
-/

namespace Usa2000P1

theorem usa2000_p1 :
    ¬∃ f : ℝ → ℝ,
      ∀ x y : ℝ, f ((x + y) / 2) + |x - y| ≤ (f x + f y) / 2 := by
  -- Informal solution from artofproblemsolving.com
  -- Suppose, for the sake of contradiction, that f is very convex.
  rw [not_exists]
  intro f hc

  -- Notice that f(x) is very convex if and only if f(x) + C is convex, where C
  -- is any constant. Thus, we can set f(0) = 0 for convenience.

  wlog hf0 : f 0 = 0 with H
  · apply H (fun x ↦ f x - f 0)
    · intro x y
      have := hc x y
      linarith
    · exact sub_self (f 0)

  -- Suppose that f(1) = A and f(-1) = B.

  let A := f 1
  let B := f (-1)

  -- By the very convex condition, (f(0) + f(2⁻ⁿ))/2 ≥ f(2⁻⁽ⁿ⁺¹⁾) + 1/2ⁿ
  have h1 : ∀ n : ℕ,
      f (2 ^ (-((n:ℝ) + 1))) + 1 / 2^(n:ℝ) ≤ (f 0 + f (2 ^ (-(n:ℝ)))) / 2 := by
    intro n
    have h2 := hc 0 (2 ^ (-(n:ℝ)))
    have h2p : (0:ℝ) < 2 := by norm_num
    have h3 : ((0:ℝ) + (2:ℝ) ^ (-(n:ℝ))) / 2 = 2 ^ (-((n:ℝ) + 1)) := by
      rw [zero_add]
      have h4 : -((n : ℝ) + 1) = - (n : ℝ) - 1 := by ring
      rw [h4, div_eq_mul_one_div]
      have h5 : (1:ℝ) / 2 = 2 ^ (-(1:ℝ)) := by norm_num
      rw [h5, ←Real.rpow_add h2p]
      congr
    rw [h3] at h2
    rw [←neg_eq_zero_sub, abs_neg] at h2
    have h6 : 0 < (2:ℝ) ^ (-(n:ℝ)) := Real.rpow_pos_of_pos h2p _
    rw [abs_of_pos h6] at h2
    have h7 : (2:ℝ) ^ (- (n : ℝ)) = 1 / 2^(n:ℝ) := by
      have h9 : (0:ℝ) ≤ (2:ℝ) := by norm_num
      rw [Real.rpow_neg h9]
      exact inv_eq_one_div _
    nth_rewrite 1 [h7] at h2
    exact h2

  have h1' : ∀ n : ℕ,
      f (-2 ^ (-((n:ℝ) + 1))) + 1 / 2^(n:ℝ) ≤ (f 0 + f (-2 ^ (-(n:ℝ)))) / 2 := by
    intro n
    have h2 := hc 0 (-2 ^ (-(n:ℝ)))
    have h2p : (0:ℝ) < 2 := by norm_num
    have h3 : ((0:ℝ) + -(2:ℝ) ^ (-(n:ℝ))) / 2 = -2 ^ (-((n:ℝ) + 1)) := by
      rw [zero_add]
      have h4 : -((n : ℝ) + 1) = - (n : ℝ) - 1 := by ring
      rw [h4, div_eq_mul_one_div]
      have h5 : (1:ℝ) / 2 = 2 ^ (-(1:ℝ)) := by norm_num
      rw [h5, neg_mul, ←Real.rpow_add h2p]
      congr
    rw [h3] at h2; clear h3
    rw [←neg_eq_zero_sub, abs_neg] at h2
    have h6 : -(2:ℝ) ^ (-(n:ℝ)) < 0 := neg_lt_zero.mpr (Real.rpow_pos_of_pos h2p _)
    rw [abs_of_neg h6, neg_neg] at h2
    have h7 : (2:ℝ) ^ (- (n : ℝ)) = 1 / 2^(n:ℝ) := by
      have h9 : (0:ℝ) ≤ (2:ℝ) := by norm_num
      rw [Real.rpow_neg h9]
      exact inv_eq_one_div _
    nth_rewrite 1 [h7] at h2
    exact h2

  -- A straightforward induction shows that f(2⁻ⁿ) ≤ (A - 2n) / 2ⁿ
  -- for all nonnegative integers n.
  have h2 : ∀ n : ℕ, f (2 ^ (- (n : ℝ))) ≤ (A - 2 * (n:ℝ)) / 2^(n:ℝ) := by
    intro n
    induction n with
    | zero => aesop
    | succ n hpn =>
      have h6 : (2:ℝ) ^ (n.succ : ℝ) = 2 ^ (n : ℝ) * 2 := by norm_cast
      replace hpn : f (2 ^ (-(n:ℝ)))/2 ≤ (A - 2 * (n:ℝ)) / 2 ^ (n.succ:ℝ) := by
         rw [h6, div_mul_eq_div_div]; linarith
      have h4 : f (2 ^ (-((Nat.succ n):ℝ)))
            = f (2 ^ (-((n:ℝ) + 1))) := by congr; norm_cast
      rw [h4]
      have h2ne0 : (2: ℝ) ≠ 0 := by norm_num
      have h7 : (1:ℝ) / 2 ^ (n:ℝ) = 2 / 2 ^ (n.succ:ℝ) := by
        rw [h6, div_mul_cancel_right₀ h2ne0, one_div]

      have h8' : (n.succ : ℝ) = (n:ℝ) + 1 := by norm_cast
      have h8 : A - 2 * ↑n - 2 = A - 2 * ↑n.succ := by
        rw [Nat.succ_eq_add_one, h8']; ring

      calc _ ≤ _ := le_sub_iff_add_le.mpr (h1 n)
           _ = _ := by rw [hf0, zero_add]
           _ ≤ (A - 2 * (n:ℝ)) / 2 ^ (n.succ:ℝ) - 1 / 2 ^ (n:ℝ) := sub_le_sub_right hpn _
           _ ≤ _ := by rw [h7, ←sub_div, h8]

  -- Using a similar line of reasoning as above, f(-2⁻ⁿ) ≤ (B - 2n)/2ⁿ.

  have h3 : ∀ n : ℕ, f (- 2 ^ (- (n : ℝ))) ≤ (B - 2 * (n:ℝ)) / 2^(n:ℝ) := by
    intro n
    induction n with
    | zero => aesop
    | succ n hpn =>
      have h6 : (2:ℝ) ^ (n.succ : ℝ) = 2 ^ (n : ℝ) * 2 := by norm_cast
      replace hpn : f (-2 ^ (-(n:ℝ)))/2 ≤ (B - 2 * ↑n) / 2 ^ (n.succ:ℝ) := by
         rw [h6, div_mul_eq_div_div]; linarith
      have h4 : f (-2 ^ (-((Nat.succ n):ℝ)))
            = f (-2 ^ (-((n:ℝ) + 1))) := by congr; norm_cast
      rw [h4]
      have h2ne0 : (2: ℝ) ≠ 0 := by norm_num
      have h7 : (1:ℝ) / 2 ^ (n:ℝ) = 2 / 2 ^ (n.succ:ℝ) := by
        rw [h6, div_mul_cancel_right₀, one_div]
        exact h2ne0

      have h8' : (n.succ : ℝ) = (n:ℝ) + 1 := by norm_cast
      have h8 : B - 2 * ↑n - 2 = B - 2 * ↑n.succ := by
        rw [Nat.succ_eq_add_one, h8']; ring
      calc _ ≤ _ := le_sub_iff_add_le.mpr (h1' n)
           _ = _ := by rw [hf0, zero_add]
           _ ≤ (B - 2 * (n:ℝ)) / 2 ^ (n.succ:ℝ) - 1 / 2 ^ (n:ℝ) := sub_le_sub_right hpn _
           _ ≤ _ := by rw [h7, ←sub_div, h8]

  -- Therefore, for every nonnegative integer n, f(2⁻ⁿ) + f(-2⁻ⁿ) ≤ (A+B-4n)/2ⁿ.
  have h4 : ∀ n : ℕ,
      f (2^(-(n:ℝ))) + f (-2^(-(n:ℝ))) ≤ (A + B - 4 * n) / 2^(n:ℝ) := by
    intro n
    have h5 := add_le_add (h2 n) (h3 n)
    have h6 : A - 2 * ↑n + (B - 2 * ↑n) = A + B - 4 * ↑n := by ring
    rwa [←add_div, h6] at h5

  -- Now, we choose n large enough such that n > (A+B)/4 - 1.
  let N := Nat.ceil ((A + B) / 4)
  -- It follows that f(2⁻ⁿ) + f(-2⁻ⁿ) < 1/2ⁿ⁻².
  have h7 : f (2 ^ (-(N:ℝ))) + f (-2 ^ (-(N:ℝ))) < 1 / 2^((N:ℝ) - 2) := by
     have h10 : (0:ℝ) < 2 := by norm_num
     have h130 : (0:ℝ) ≤ (2:ℝ)^(N:ℝ) := by norm_num
     have h8' : (A + B) / 4 ≤ N := Nat.le_ceil _
     have h8 : A + B - 4 * ↑N ≤ 0 := by linarith
     have h9 : (A + B - 4 * ↑N) / 2 ^ (N : ℝ) ≤ 0 := div_nonpos_of_nonpos_of_nonneg h8 h130
     calc _ ≤ _ := h4 N
          _ ≤ 0 := h9
          _ < _ := by rw [one_div_pos]; exact Real.rpow_pos_of_pos h10 _

  -- However, by the very convex condition, f(2⁻ⁿ) + f(-2⁻ⁿ) ≥ 1/2ⁿ⁻².
  have h20 := hc (2 ^(-(N:ℝ))) (-2 ^(-(N:ℝ)))

  -- This is a contradiction.
  rw [add_neg_cancel, zero_div, hf0, zero_add, sub_neg_eq_add, ←two_mul] at h20
  nth_rewrite 1 [show (2:ℝ) = (2:ℝ) ^ (1:ℝ) by norm_num] at h20
  rw [←Real.rpow_add (by norm_num)] at h20
  have h21 := calc _ ≤ _ := le_abs_self ((2 : ℝ) ^ (1 + -(N : ℝ)))
               _ ≤ _ := h20
  replace h20 : (2:ℝ) * 2^(1 + -(N:ℝ)) ≤ f ((2:ℝ)^(-(N:ℝ))) + f (-(2:ℝ) ^ (-(N:ℝ))) := by linarith
  nth_rewrite 1 [show (2:ℝ) = (2:ℝ) ^ (1:ℝ) by norm_num] at h20
  rw [←Real.rpow_add (by norm_num)] at h20
  have h22 : (1 + (1 + -(N:ℝ))) = -((N : ℝ) - 2) := by ring
  have h23 : (0 :ℝ) ≤ 2 := by norm_num
  rw [h22, Real.rpow_neg h23, inv_eq_one_div] at h20
  exact not_lt.mpr h20 h7


end Usa2000P1

-- ═══ Usa2001P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 2001, Problem 1

Each of eight boxes contains six balls.
Each ball has been colored with one of n colors, such that no two balls
in the same box are the same color, and no two colors occur together in
more than one box. Determine, with justification, the smallest integer n
for which this is possible.
-/

namespace Usa2001P1

def possible_num_colors : Set ℕ :=
{ n : ℕ | ∃ f : Fin 8 → Finset (Fin n),
    (∀ i, (f i).card = 6) ∧
    (∀ x y : Fin n, ∀ i j : Fin 8,
      i ≠ j → x ∈ f i → y ∈ f i → x ≠ y →
        (¬ (x ∈ f j ∧ y ∈ f j))) }

noncomputable def min_colors : ℕ := 23



/--
  if
    a₁, ... a₆ is positive, ∑ (i=1 to 6), aᵢ ≤ 13
  then
    ∑ (i=1 to 6) (1 / aᵢ) ≥ 36/13
-/
lemma usa2001_p1_lemma {α} (s : Finset α) (sz : s.card = 6) (gen : α -> ℕ)
    (gt : ∀ i ∈ s, gen i > 0) (sum : (∑ i ∈ s, gen i) ≤ 13) :
    (36:ℝ)/(13:ℝ) ≤ (∑ i ∈ s, 1 / (gen i:ℝ)) := by
  let f := fun (i : α) ↦ √(gen i : ℝ)
  let g := fun (i : α) ↦ (1 : ℝ) / √(gen i : ℝ)
  have h := Finset.sum_mul_sq_le_sq_mul_sq s f g
  unfold f g at h
  have : ∑ x ∈ s, √(gen x : ℝ) * (1 / √(gen x : ℝ)) = ∑ x ∈ s, 1 := by
    apply Finset.sum_congr rfl
    intro x hx
    have := gt x hx
    field_simp
  rw [this] at h
  simp only [Finset.sum_const, sz, nsmul_eq_mul, Nat.cast_ofNat, mul_one, Nat.cast_nonneg,
    Real.sq_sqrt, one_div, inv_pow] at h
  have : (∑ x ∈ s, (gen x:ℝ)⁻¹) = (∑ x ∈ s, 1 / (gen x : ℝ)) := by congr; simp
  rw [this] at h
  set aa := (∑ x ∈ s, (gen x : ℝ)) with haa
  set bb := (∑ x ∈ s, (1 / (gen x : ℝ))) with hbb
  rify at sum
  rw [←haa] at sum
  norm_num1 at h
  have : aa ≥ 0 := by positivity
  have : bb ≥ 0 := by positivity
  field_simp
  trans aa * bb
  · exact h
  · gcongr



theorem usa2001_p1 : IsLeast possible_num_colors min_colors := by
  -- Informal solution from
  -- https://artofproblemsolving.com/wiki/index.php/2001_USAMO_Problems/Problem_1
  constructor
  · rw [possible_num_colors]
    let f : Fin 8 → Finset (Fin 23)
        | 0 => {1, 2, 3, 4, 5, 6}
        | 1 => {1, 7, 8, 9, 10, 11}
        | 2 => {1, 12, 13, 14, 15, 16}
        | 3 => {2, 7, 12, 17, 18, 19}
        | 4 => {3, 8, 13, 17, 20, 21}
        | 5 => {4, 9, 14, 17, 22, 23}
        | 6 => {5, 10, 15, 18, 20, 22}
        | 7 => {6, 11, 16, 19, 21, 23}
    use f
    constructor
    · intro i
      fin_cases i <;> simp +decide only [Fin.isValue, Fin.zero_eta, Finset.mem_insert, not_false_eq_true,
    Finset.card_insert_of_notMem, Finset.mem_singleton, Finset.card_singleton, Nat.reduceAdd, f]
    · suffices ∀ (x y : Fin min_colors) (i j : Fin 8), i ≠ j → (f i ∩ f j).card ≤ 1 by
        rintro x y i j hij hx hy hxy ⟨h₁, h₂⟩
        specialize this x y i j hij
        have h₃ : x ∈ f i ∩ f j := Finset.mem_inter_of_mem hx h₁
        have h₄ : y ∈ f i ∩ f j := Finset.mem_inter_of_mem hy h₂
        have h₅ : {x, y} ⊆ f i ∩ f j := by
          intro z hz
          simp only [Finset.mem_insert, Finset.mem_singleton] at hz
          obtain rfl | rfl := hz <;> assumption
        have h₆ : Finset.card {x, y} = 2 := by grind
        have h₇ : 2 ≤ (f i ∩ f j).card := by rw [←h₆]; exact Finset.card_le_card h₅
        lia
      rintro x y i j hij
      fin_cases i <;> fin_cases j <;> dsimp only at hij ⊢ <;> (try contradiction) <;> decide
  · rw [min_colors, mem_lowerBounds]
    by_contra! ⟨n, ⟨f, ⟨h1, h2⟩⟩, ha_lt⟩
    suffices (22 : ℝ) < n by norm_cast at this; lia
    clear ha_lt
    let count color i := if color ∈ f i then 1 else 0
    let count_k : Fin n → ℕ := λ color ↦ ∑ i : Fin 8, count color i
    have : (∑ (k : Fin n), ∑ i : Fin 8, ((count k i):ℝ) / ((count_k k):ℝ)) ≤ n := by
      have nsum : n = ∑ (k : Fin n), 1 := by simp only [Finset.sum_const, Finset.card_univ, Fintype.card_fin, smul_eq_mul, mul_one]
      conv => rhs; rw [nsum]
      push_cast
      gcongr with i a; unfold count_k; rw [← Finset.sum_div]; norm_cast
      by_cases h : (∑ x, count i x) = 0
      · rw [h]; simp only [CharP.cast_eq_zero, div_zero, zero_le_one]
      · apply le_of_eq; rw [div_self]; norm_cast
    refine lt_of_lt_of_le ?_ this; clear this
    rw [Finset.sum_comm]
    apply lt_of_lt_of_le (by norm_num : (22 < ∑ (i : Fin 8), ((36:ℝ) / (13:ℝ))))
    gcongr with i a
    rw [← Finset.sum_subset (by simp : f i ⊆ Finset.univ) (by intros; simp [count, *])]
    have : ∀ k ∈ f i, (count k i) = 1 := by intro k hk; simp [count, hk]
    rw [Finset.sum_congr (g := λ k ↦ 1 / ((count_k k):ℝ)) rfl (λ k hk ↦ by congr; norm_cast; exact this k hk)]
    refine usa2001_p1_lemma _ (h1 i) count_k ?_ ?_
    · intro ii hii
      apply Finset.sum_pos'
      · intros; simp [count]
      · use i; simp [count, hii]
    have : (∑ x ∈ f i, count x i) = 6 := by simp [count, *]
    rw [Finset.sum_comm, ← Finset.sum_erase_add (h := a), this]
    simp only [Nat.reduceLeDiff, ge_iff_le]
    have : (∑ x ∈ Finset.univ.erase i, 1) = 7 := by simp
    rw [← this]
    gcongr with j a
    rw [Finset.mem_erase] at a
    by_contra!
    rw [← Finset.sum_filter, Finset.sum_const, smul_eq_mul, mul_one, Finset.one_lt_card] at this
    simp only [Finset.mem_filter] at this
    obtain ⟨ex, ⟨⟨p1, p4⟩, ⟨ey, ⟨⟨p2, p5⟩, p3⟩⟩⟩⟩ := this
    refine h2 ex ey i j a.1.symm p1 p2 p3 ⟨p4,p5⟩

end Usa2001P1

-- ═══ Usa2001P3 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 2001, Problem 3

Let a,b,c ≥ 0 be real numbers satsifying

        a² + b² + c² + abc = 4.

Show that

        0 ≤ ab + bc + ca - abc ≤ 2.
-/

namespace Usa2001P3



@[reducible]
noncomputable def f (a b c : ℝ) : ℝ := a^2 + b^2 + c^2 + a * b * c
@[reducible]
def g (a b c : ℝ) : ℝ := a * b + b * c + c * a - a * b * c

theorem feq (a b c : ℝ) : f a b c = a^2 + b^2 + c^2 + a * b * c := rfl
theorem geq (a b c : ℝ) : g a b c = a * b + b * c + c * a - a * b * c := rfl

lemma usa2001_p3_lemma (a b c : ℝ) (ha : 0 ≤ a)
    (h : a ^ 2 + b ^ 2 + c ^ 2 + a * b * c = 4)
    (hbc : (b - 1) * (c - 1) ≥ 0) :
    a * b + b * c + c * a - a * b * c ≤ 2 := by
  have eq1 := calc
    (2 + a) * (2 - a) = 4 - a ^ 2 := by ring_nf
    _ = a ^ 2 + b ^ 2 + c ^ 2 + a * b * c - a ^ 2 := by rw [h]
    _ = (b ^ 2 + c ^ 2) + a * b * c := by ring_nf
    _ ≥ 2 * b * c + a * b * c := by rel [two_mul_le_add_sq b c]
    _ = (2 + a) * (b * c) := by ring_nf
  have a2gt0 : 2 + a > 0 := by linarith
  have bc := (mul_le_mul_iff_right₀ a2gt0).mp eq1
  calc
    a * b + b * c + c * a - a * b * c = a * b + b * c + a * c * (1 - b) := by ring_nf
    _ ≤ a * b + (2 - a) + a * c * (1 - b) := by gcongr
    _ = 2 - a * ((b - 1) * (c - 1)) := by ring_nf
    _ ≤ 2 - 0 := by gcongr; positivity
    _ = 2 := by norm_num



theorem usa2001_p3 (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c)
    (h : a^2 + b^2 + c^2 + a * b * c = 4) :
    0 ≤ a * b + b * c + c * a - a * b * c ∧
    a * b + b * c + c * a - a * b * c ≤ 2 := by
  rw [←feq] at h
  rw [←geq]
  wlog ha1 : a≤1 generalizing a b c with Ha
  · by_cases hb1 : b ≤ 1
    · rw [(by ring_nf : g a b c = g b a c)]
      exact Ha b a c hb ha hc (by rw [←h]; unfold f; ring_nf) hb1
    by_cases hc1 : c ≤ 1
    · rw [(by ring_nf : g a b c = g c b a)]
      exact Ha c b a hc hb ha (by rw [←h]; unfold f; ring_nf) hc1
    apply False.elim (ne_of_not_le _ h)
    unfold f
    rw [not_le]
    rw [not_le] at ha1 hb1 hc1
    rw [(by norm_num : ((4 : ℝ) = 1 ^ 2 + 1 ^ 2 + 1 ^ 2 + 1 * 1 * 1))]
    gcongr
  constructor
  · unfold g
    have : (1 - a ≥ 0) := by linarith
    have : a * b + b * c + c * a - a * b * c = a * b + b * c * (1 - a) + c * a := by ring_nf
    rw [this]
    positivity
  · wlog hb1 : b ≤ 1 generalizing b c with Hb
    · by_cases hc1 : c ≤ 1
      · rw [(by ring_nf : g a b c = g a c b)]
        exact Hb c b hc hb (by rw [←h]; unfold f; ring_nf) hc1
      · apply usa2001_p3_lemma a b c ha h
        have : (b - 1 > 0) := by linarith
        have : (c - 1 > 0) := by linarith
        positivity
    · rw [(by ring_nf : g a b c = g c a b)]
      apply usa2001_p3_lemma c a b hc (by rw [←h]; unfold f; ring_nf)
      rw [(by ring_nf : (a - 1) * (b - 1) = (1 - a) * (1 - b))]
      have : (1 - a ≥ 0) := by linarith
      have : (1 - b ≥ 0) := by linarith
      positivity


end Usa2001P3

-- ═══ Usa2001P4 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 2001, Problem 4

Let ABC be a triangle and P be any point such that PA, PB, PC
are the sides of an obtuse triangle, with PA the longest side.
Prove that ∠BAC is acute.
-/

namespace Usa2001P4

open scoped EuclideanGeometry



lemma lemma1 (a b c d : ℝ) : a * c + b * d ≤ Real.sqrt (a^2 + b^2) * Real.sqrt (c^2 + d^2) := by
  let v1 : EuclideanSpace ℝ (Fin 2) := !₂[a, b]
  let v2 : EuclideanSpace ℝ (Fin 2) := !₂[c, d]
  have h2 : a * c + b * d ≤ |a * c + b * d| := le_abs_self _
  have h1 := abs_real_inner_le_norm v1 v2
  simp [EuclideanSpace.norm_eq, v1, v2, inner] at h1
  rw [mul_comm c a, mul_comm d b] at h1
  exact h2.trans h1



theorem usa2001_p4
    (A B C P X Y Z : EuclideanSpace ℝ (Fin 2))
    (hABC : AffineIndependent ℝ ![A, B, C])
    (hXYZ : AffineIndependent ℝ ![X, Y, Z])
    (hPA : dist X Y = dist P A)
    (hPB : dist Y Z = dist P B)
    (hPC : dist Z X = dist P C)
    (hObtuse : Real.pi / 2 < ∠ X Z Y)
    : ∠ B A C < Real.pi / 2 := by
  -- https://web.evanchen.cc/exams/USAMO-2001-notes.pdf
  have h9 : ¬Collinear ℝ {X, Y, Z} := affineIndependent_iff_not_collinear_set.mp hXYZ
  have h11 : 0 < dist X Z := dist_pos.mpr (ne₁₃_of_not_collinear h9)
  have h12 : 0 < dist Y Z := dist_pos.mpr (ne₂₃_of_not_collinear h9)
  have h18 : 0 < dist X Y := dist_pos.mpr (ne₁₂_of_not_collinear h9)

  rw [dist_comm Z X] at hPC

  have h1 : (dist Y Z)^2 + (dist X Z)^2 < (dist X Y)^2 := by
    have h2 := EuclideanGeometry.law_cos X Z Y
    have h3 : Real.cos (∠ X Z Y) < 0 := by
      have h4 : 0 < ∠ X Z Y - Real.pi / 2 := sub_pos.mpr hObtuse
      have h10 : ({X, Y, Z} : Set _) = {X, Z, Y} :=
        congrArg (Set.insert _) (Set.pair_comm _ _)
      have h8 : ¬ Collinear ℝ {X, Z, Y} := by rwa [←h10]
      have h7 : ∠ X Z Y < Real.pi := EuclideanGeometry.angle_lt_pi_of_not_collinear h8
      have h5 : ∠ X Z Y < Real.pi + Real.pi / 2 := by linarith only [h4, h7]
      exact Real.cos_neg_of_pi_div_two_lt_of_lt hObtuse h5
    simp only [←sq] at h2
    have h13 : 2 * dist X Z * dist Y Z * Real.cos (∠ X Z Y) < 0 := by
      have h14 : 0 < 2 * dist X Z * dist Y Z := by positivity
      exact mul_neg_iff.mpr (Or.inl ⟨h14, h3⟩)

    calc _ < _ := by linarith only [h13]
         _ = _ := h2.symm
  rw [hPA, hPB, hPC] at h1
  rw [hPA] at h18; rw [hPC] at h11; rw [hPB] at h12
  clear! X Y Z
  have ptolemy := EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist P B A C
  have h2 := lemma1 (dist P B) (dist P C) (dist A C) (dist B A)
  rw [mul_comm (dist P C)] at h2
  have h50 : ¬Collinear ℝ {A, B, C} := affineIndependent_iff_not_collinear_set.mp hABC
  have h42 : 0 < dist A B := dist_pos.mpr (ne₁₂_of_not_collinear h50)
  rw [dist_comm] at h42
  have h43 : 0 < dist A C := dist_pos.mpr (ne₁₃_of_not_collinear h50)
  have h23 := calc
    _ ≤ _ := ptolemy
    _ ≤ _ := h2
    _ < Real.sqrt (dist P A ^ 2) * _ :=
          (mul_lt_mul_iff_left₀ (by positivity)).mpr
            (Real.sqrt_lt_sqrt (by positivity) h1)
    _ = dist P A * _ := by rw [Real.sqrt_sq dist_nonneg]
  replace h23 : dist B C < Real.sqrt (dist A C ^ 2 + dist B A ^ 2) :=
    (mul_lt_mul_iff_right₀ h18).mp h23
  replace h23 : dist B C ^2 < (Real.sqrt (dist A C ^ 2 + dist B A ^ 2))^2 :=
    pow_lt_pow_left₀ h23 dist_nonneg (by norm_num)
  rw [Real.sq_sqrt (by positivity)] at h23
  have h30 := EuclideanGeometry.law_cos B A C
  simp only [←sq] at h30
  rw [h30] at h23; clear h30
  rw [dist_comm C A] at h23
  have h31 : 0 < 2 * dist B A * dist A C * Real.cos (∠ B A C) := by linarith only [h23]
  have h44 : 0 < 2 * dist B A * dist A C := by positivity
  have h45 : 0 < Real.cos (∠ B A C) := (mul_pos_iff_of_pos_left h44).mp h31
  by_contra! H
  have h48 : ∠ B A C ≤ Real.pi + Real.pi / 2 := by
    linarith [EuclideanGeometry.angle_le_pi B A C]
  have h49 : Real.cos (∠ B A C) ≤ 0 := Real.cos_nonpos_of_pi_div_two_le_of_le H h48
  exact not_lt.mpr h49 h45


end Usa2001P4

-- ═══ Usa2002P4 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/




/-!
# USA Mathematical Olympiad 2002, Problem 4

Find all functions f : ℝ → ℝ such that for all x, y ∈ ℝ:
f(x² - y²) = x f(x) - y f(y).
-/

namespace Usa2002P4

def FE (f : ℝ → ℝ) : Prop :=
  ∀ x y, f (x^2 - y^2) = x * (f x) - y * (f y)



-- Following https://web.evanchen.cc/exams/USAMO-2002-notes.pdf

-- f(0)=0
lemma f_zero {f : ℝ → ℝ} (hf : FE f) : f 0 = 0 := by
  simpa using hf 0 0

-- f(x^2) = xf(x)
lemma squarish {f : ℝ → ℝ} (hf : FE f) (x : ℝ) : f (x^2) = x * f x := by
  simpa [f_zero hf] using hf x 0

-- f(x^2) = f(x^2)-f(y^2)
lemma square_additive {f : ℝ → ℝ} (hf : FE f) (x : ℝ) (y : ℝ)  :
    f (x^2 - y^2) = f (x^2) - f (y^2) := by
  simp [squarish hf]
  apply hf

-- f is odd
lemma f_odd {f : ℝ → ℝ} (hf : FE f) (x : ℝ)  :
    -f x = f (-x) := by
  by_cases hx : x ≥ 0
  · have h := square_additive hf 0 (Real.sqrt x)
    simp_all [f_zero hf]
  · replace hx : - x ≥ 0 := by grind only
    have h := square_additive hf 0 (Real.sqrt (- x))
    simp_all [f_zero hf]

-- f(x+y) = f(x)+f(y) with x,y ≥ 0 first
lemma additive_pos {f : ℝ → ℝ} (hf : FE f) {x : ℝ} {y : ℝ} (hx : 0 ≤ x) (hy : 0 ≤ y):
    f (x + y) = f x + f y := by
  have h := square_additive hf (Real.sqrt (x + y)) (Real.sqrt y)
  grind only [usr Real.sq_sqrt', = max_def]

-- Now show Cauchy FE holds with x,y not necessarily positive (lots of cases)
lemma additive {f : ℝ → ℝ} (hf : FE f) (x : ℝ) (y : ℝ)  :
    f (x + y) = f x + f y := by
  wlog hwlog : x ≤ y generalizing x y with H
  · have h := H y x
    simp [show y ≤ x by grind only] at h
    convert h using 1
    · rw [add_comm]
    · grind only
  by_cases hx : 0 ≤ x
  · exact additive_pos hf hx (show 0 ≤ y by grind only)
  · replace hx : 0 ≤ -x := by grind only
    by_cases hy : 0 ≤ y
    · by_cases hxy : 0 ≤ x + y
      · have h := additive_pos hf hxy hx
        rw [← f_odd hf] at h
        simp_all
      · have h := additive_pos hf (show 0 ≤ -(x+y) by grind only) hy
        simp at h
        rw [show -y+-x = -(x+y) by ring] at h
        rw [← f_odd hf x, ← f_odd hf (x+y)] at h
        linarith
    · have h := additive_pos hf hx (show 0 ≤ -y by grind only)
      rw [show -x+-y = -(x+y) by ring] at h
      rw [← f_odd hf x, ← f_odd hf y, ← f_odd hf (x+y)] at h
      linarith

-- Apply Cauchy four times to f
lemma four_additive {f : ℝ → ℝ} (hf : FE f) (a : ℝ) (b : ℝ) (c : ℝ) (d : ℝ) :
    f (a + b + c + d) = f a + f b + f c + f d := by
  have h1 := additive hf (a+b+c) d
  have h2 := additive hf (a+b) c
  have h3 := additive hf a b
  linarith

-- Show the FE implies f(x) = f(1)*x
lemma main_proof {f : ℝ → ℝ} (hf : FE f) (x : ℝ)  :
    f x = f 1 * x := by
  have h := squarish hf (x+1)
  rw [show (f (x+1)) = _ by exact additive hf x 1] at h
  rw [show (x+1)^2 = x^2 + x + x + 1 by ring] at h
  rw [four_additive hf] at h
  rw [squarish hf] at h
  grind only



noncomputable def solution_set : Set (ℝ → ℝ) := { f | ∃ c : ℝ, ∀ x, f x = c * x }

theorem usa2002_p4 (f : ℝ → ℝ) :
    f ∈ solution_set ↔ FE f := by
  constructor
  · -- trivial direction: show that linear functions work
    unfold FE
    grind only [usr Set.mem_setOf_eq]
  · -- conversely, if f obeys the FE, then choose c = f(1)
    intro hf
    use f 1 -- c = f(1)
    apply main_proof
    exact hf

end Usa2002P4

-- ═══ Usa2003P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/






/-!
# USA Mathematical Olympiad 2003, Problem 1

Prove that for every positive integer n there exists an n-digit
number divisible by 5ⁿ, all of whose digits are odd.
-/

namespace Usa2003P1



lemma nat_mod_inv (a : ℕ) : ∃ b, (a + b) % 5 = 0 := ⟨5 - (a % 5), by lia⟩

lemma lemma2 (a b c : ℕ) (hb : 0 < b) (h : Nat.Coprime a b) : ∃ k, k < b ∧ a * k ≡ c [MOD b] := by
  let ⟨N, HN1, HN2⟩ := Nat.chineseRemainder h 0 c
  have ⟨x, hx⟩ : a ∣ N := Nat.modEq_zero_iff_dvd.mp HN1
  use x % b
  constructor
  · exact Nat.mod_lt _ hb
  · change N % b = c % b at HN2
    change (a * (x % b)) % b = c % b
    rw [← HN2, hx, Nat.mul_mod, Nat.mod_mod, ←Nat.mul_mod]



theorem usa2003_p1 (n : ℕ) :
    ∃ m, (Nat.digits 10 m).length = n ∧
          5^n ∣ m ∧ (Nat.digits 10 m).all (Odd ·) := by
  -- Informal solution from artofproblemsolving.com
  --
  -- We proceed by induction.
  induction' n with n ih
  · -- For our base case, n=0, the digits are [] and the theorem
    -- is vacuously true.
    use 0; simp
  · --
    -- Now, suppose that there exists some number a·5ⁿ with n digits,
    -- all of which are odd.
    --
    obtain ⟨pm, hpm1, ⟨a, ha⟩, hpm3⟩ := ih

    -- It is then sufficient to prove that there exists
    -- an odd digit k such that 5ⁿ⬝a + 10ⁿ⬝k = 5ⁿ(k·2ⁿ + a) is
    -- divisible by 5ⁿ⁺¹.
    suffices h : ∃ k, Odd k ∧ k < 10 ∧ 5^(n + 1) ∣ 5 ^ n * a + 10 ^ n * k by
      obtain ⟨k, hk0, hk1, hk2⟩ := h
      use 5 ^ n * a + 10 ^ n * k
      have hkn : k ≠ 0 := Nat.ne_of_odd_add hk0
      have h1 := Nat.digits_append_digits (m := k) (n := pm) (Nat.succ_pos 9)
      rw[hpm1, ha, Nat.digits_of_lt 10 k hkn hk1] at h1
      grind

    -- This is equivalent to proving that there exists an odd digit k such that
    -- k·2ⁿ + a is divisible by 5...
    suffices h : ∃ k, Odd k ∧ k < 10 ∧ 5 ∣ (2^n * k + a) by
      obtain ⟨k, hk1, hk2, kk, hkk⟩ := h
      refine ⟨k, hk1, hk2, kk, ?_⟩
      rw [Nat.pow_succ, Nat.mul_assoc, ←hkk, Nat.mul_pow 5 2 n]
      ring

    -- ...which is true when k ≡ -3ⁿ⬝a MOD 5.
    -- Since there is an odd digit in each of the residue classes MOD 5,
    -- k exists and the induction is complete.

    suffices h : ∃ j, j < 5 ∧ 5 ∣ (2^n * (2 * j + 1) + a) by
      obtain ⟨j, hj1, hj2⟩ := h
      refine ⟨2 * j + 1, odd_two_mul_add_one j, ?_, hj2⟩
      · lia
    clear ha hpm1 hpm3

    obtain ⟨b, hb⟩ : ∃ b, ((2^n + a) + b) % 5 = 0 := nat_mod_inv (2^n + a)
    have h11 : ¬ 2^(n + 1) ≡ 0 [MOD 5] := by
      have h14 : Nat.Coprime 5 2 := by norm_num
      have h15 : Nat.Coprime 5 (2^(n+1)) := Nat.Coprime.pow_right (n + 1) h14
      have h16 := (Nat.Prime.coprime_iff_not_dvd Nat.prime_five).mp h15
      intro h17
      have h18 : 5 ∣ 2 ^ (n + 1) := Iff.mp Nat.modEq_zero_iff_dvd h17
      exact (h16 h18).elim
    obtain ⟨aa, haa1, haa2⟩ := lemma2 (2^(n + 1)) 5 b (Nat.succ_pos 4)
      ((Nat.Prime.coprime_iff_not_dvd Nat.prime_five).mpr
        (Nat.modEq_zero_iff_dvd.not.mp h11)).symm
    use aa
    constructor
    · exact haa1
    · have h12 : (2^n + a + 2 ^ (n + 1) * aa) % 5 = (2^n + a + b) % 5 := Nat.ModEq.add rfl haa2
      rw[hb] at h12
      have h13 : (2 ^ n + a + 2 ^ (n + 1) * aa) = 2 ^ n * (2 * aa + 1) + a := by ring
      rw[h13] at h12
      exact Nat.dvd_of_mod_eq_zero h12

end Usa2003P1

-- ═══ Usa2003P5 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/





/-!
# USA Mathematical Olympiad 2003, Problem 5

Prove that for a,b,c > 0:
(2a+b+c)² / (2a²+(b+c)²) + (2b+c+a)² / (2b²+(c+a)²) + (2c+a+b)² / (2c²+(a+b)²) ≤ 8
-/

namespace Usa2003P5



-- This is the solution at https://web.evanchen.cc/exams/USAMO-2003-notes.pdf
-- We skip the homogenization step and directly encode it in the inequality with x=(a+b+c)/3
-- to make life easier on the Lean side

lemma bound {a b c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    (2*a+b+c)^2/(2*a^2+(b+c)^2) ≤ 4*a/(a+b+c) + 4/3 := by
  field_simp
  have h : 0 ≤ (2*a-b-c)^2 * (5*a+b+c) := by positivity
  linarith



theorem usa2003_p5 {a b c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    (2*a+b+c)^2/(2*a^2+(b+c)^2) + (2*b+c+a)^2/(2*b^2+(c+a)^2) +
    (2*c+a+b)^2/(2*c^2+(a+b)^2) ≤ 8 := by
  have h1 := bound ha hb hc
  have h2 := bound hb hc ha
  have h3 := bound hc ha hb
  have h := add_le_add h1 (add_le_add h2 h3)
  convert h using 1 <;> field

end Usa2003P5

-- ═══ Usa2004P5 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/





/-!
# USA Mathematical Olympiad 2004, Problem 5

Prove that for a,b,c > 0,
(a⁵ - a² + 3) (b⁵ - b² + 3) (c⁵ - c² + 3) ≥ (a + b + c)³.
-/

namespace Usa2004P5



-- This is the solution at https://web.evanchen.cc/exams/USAMO-2004-notes.pdf

-- Main estimate that lets us convert into Holder
lemma poly_bound {x : ℝ} (hx : 0 < x) : x^3 + 2 ≤ x^5 - x^2 + 3 := by
  have h1 : (x-1)^2 ≥ 0 := by positivity
  have h2 : (x+1) * (x^2+x+1) ≥ 0 := by positivity
  nlinarith

-- It's not obvious a priori that x⁵ - x² + 3 is even positive
-- and this will make life annoying later when we try to multiply ineq's together
-- Thus, define a corollary that follows from the above
lemma poly_nonneg {x : ℝ} (hx : 0 < x) : 0 ≤ x^5 - x^2 + 3 := by
  exact (show 0 ≤ x^3 + 2 by positivity).trans (poly_bound hx)

-- Multiply these all together to get to the intermediate (a³+2)(b³+2)(c³+2)
lemma multiplied_bound {a b c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    (a^3 + 2) * (b^3 + 2) * (c^3 + 2) ≤ (a^5 - a^2 + 3) * (b^5 - b^2 + 3) * (c^5 - c^2 + 3) := by
  -- multiply first two ineq's together
  have h := mul_le_mul (poly_bound ha) (poly_bound hb) (by positivity) (poly_nonneg ha)
  -- multiply the third inequality on
  apply mul_le_mul h (poly_bound hc) (by positivity)
  exact mul_nonneg (poly_nonneg ha) (poly_nonneg hb)

-- 3-variable Holder inequality (the painful part...)
lemma holder_conjugate_3 : Real.HolderConjugate (3/2 : ℝ) 3 := by
  rw [@Real.holderConjugate_iff (3/2 : ℝ) 3]
  norm_num
theorem triple_holder (S : Finset ℕ) (f1 f2 f3 : ℕ → NNReal) :
    (∑ i ∈ S, (f1 i) * (f2 i) * (f3 i)) ^ 3
    ≤ (∑ i ∈ S, (f1 i) ^ 3) * (∑ i ∈ S, (f2 i) ^ 3) * (∑ i ∈ S, (f3 i) ^ 3) := by
  have h1 := NNReal.inner_le_Lp_mul_Lq S (f1 * f2) f3 holder_conjugate_3
  have h2 := NNReal.inner_le_Lp_mul_Lq S (f1 ^ (3/2 : ℝ)) (f2 ^ (3/2 : ℝ)) Real.HolderConjugate.two_two
  -- Cube both sides of h1, square both sides of h2
  replace h1 := NNReal.rpow_le_rpow h1 (by norm_num : (0 : ℝ) ≤ 3)
  replace h2 := NNReal.rpow_le_rpow h2 (by norm_num : (0 : ℝ) ≤ 2)
  -- Fight through exponent hell
  simp_all only [NNReal.mul_rpow, ← NNReal.rpow_natCast, ← NNReal.rpow_mul]
  norm_num at h1 h2 ⊢
  -- if at first you don't succeed, try try again
  -- (by which i mean copy paste the same two lines and pray to the mathlib gods)
  simp_all only [NNReal.mul_rpow, ← NNReal.rpow_natCast, ← NNReal.rpow_mul]
  norm_num at h1 h2 ⊢
  apply h1.trans (mul_le_mul_left h2 _)

lemma key_holder (a b c : NNReal) : (a+b+c)^3 ≤ (a^3 + 2) * (b^3 + 2) * (c^3 + 2) := by
  -- only need values at 0 1 2 for these, the rest are junk values
  -- (the mathlib holder seems to demand you define the function on all of ℕ)
  have h := triple_holder (Finset.range 3)
    (fun | 0 => a | _ => 1) -- a, 1, 1
    (fun | 1 => b | _ => 1) -- 1, b, 1
    (fun | 2 => c | _ => 1) -- 1, 1, c
  simp only [← Fin.sum_univ_eq_sum_range, Fin.sum_univ_three] at h
  convert h using 1 <;> ring

lemma key_holder_real {a b c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    (a + b + c)^3 ≤ (a^3 + 2) * (b^3 + 2) * (c^3 + 2) := by
  rw [← Real.coe_toNNReal a ha.le, ← Real.coe_toNNReal b hb.le, ← Real.coe_toNNReal c hc.le]
  exact key_holder a.toNNReal b.toNNReal c.toNNReal



theorem usa2004_p5 {a b c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :
    (a + b + c) ^ 3 ≤ (a^5 - a^2 + 3) * (b^5 - b^2 + 3) * (c^5 - c^2 + 3) := by
  exact (key_holder_real ha hb hc).trans (multiplied_bound ha hb hc)
end Usa2004P5

-- ═══ Usa2005P2 ═══

/-
Copyright (c) 2024 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 2005, Problem 2

Prove that there do not exist integers x,y,z such that

        x⁶ + x³ + x³y + y = 147¹⁵⁷
        x³ + x³y + y² + y + z⁹ = 157¹⁴⁷.
-/

namespace Usa2005P2



lemma lemma1 (x : ZMod 13) :
    x^3 = 0 ∨ x^3 = 1 ∨ x^3 = -1 ∨ x^3 = 5 ∨ x^3 = -5 := by
  reduce_mod_char
  fin_cases x <;> decide



theorem usa2005_p2 :
    ¬∃ (x y z : ℤ),
       x^6 + x^3 + x^3 * y + y = 147^157 ∧
       x^3 + x^3 * y + y^2 + y + z^9 = 157^147 := by
  -- we follow
  -- https://artofproblemsolving.com/wiki/index.php/2005_USAMO_Problems/Problem_2
  push_neg
  intro x' y' z' h1 h2
  with_reducible generalize hM : ((147:ℤ) ^ 157) = M at h1
  with_reducible generalize hN : ((157:ℤ) ^ 147) = N at h2
  -- move into zmod 13
  apply_fun (fun x : ℤ ↦ (x : ZMod 13)) at h1 h2
  push_cast at h1 h2
  generalize (x' : ZMod 13) = x at *
  generalize (y' : ZMod 13) = y at *
  generalize (z' : ZMod 13) = z at *
  clear! x' y' z'
  rw [←hM] at h1; rw [←hN] at h2
  have h3 : (x^3 + y + 1)^2 + z^9 = 147^157 + 157^147 + 1 := by
    linear_combination h1 + h2
  have h4 : (x^3 + 1) * (x^3 + y) = 147^157 := by linear_combination h1
  reduce_mod_char at h3 h4
  have h7 : x^3 ≠ -1 := by
    by_contra! H
    rw [H] at h4
    norm_num at h4
    simp +arith +decide at h4
  have h8 : x^3 + y = 4 ∨ x^3 + y = 2 ∨ x^3 + y = 5 ∨ x^3 + y = -1 := by
    obtain h5 | h5 | h5 | h5 | h5 := lemma1 x
    · rw [h5] at h4 ⊢
      left
      linear_combination h4
    · rw [h5] at h4 ⊢
      right; left
      have h10 : 2 * (1 + y) = 2 * 2 := by linear_combination h4
      apply_fun (· * 7) at h10
      have h11 : 2 * (1 + y) * 7 = 14 * (1 + y) := by ring
      rw [h11] at h10
      reduce_mod_char at h10
      exact h10
    · exact (h7 h5).elim
    · rw [h5] at h4 ⊢
      have h10 : 6 * (5 + y) = 4 := by linear_combination h4
      apply_fun (11 * ·) at h10
      have h11 : 11 * (6 * (5 + y)) = 66 * (5 + y) := by ring
      rw [h11] at h10
      reduce_mod_char at h10
      right; right; left
      exact h10
    · rw [h5] at h4 ⊢
      have h10 : (-4) * (-5 + y) = 4 := by linear_combination h4
      apply_fun (3 * ·) at h10
      have h11 : 3 * ((-4) * (-5 + y)) = (-12) * (-5 + y) := by ring
      rw [h11] at h10
      right; right; right
      reduce_mod_char at h10 ⊢
      exact h10
  have h6 := lemma1 (z^3)
  rw [show (z^3)^3 = z^9 by ring] at h6
  obtain h9 | h9 | h9 | h9 := h8
      <;> obtain h6 | h6 | h6 | h6 | h6 := h6
      <;> simp (config := { decide := true }) [h6, h9] at h3


end Usa2005P2

-- ═══ Usa2008P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/





/-!
# USA Mathematical Olympiad 2008, Problem 1

Prove that for each positive integer n, there are pairwise relatively prime
integers k₀,k₁,...,kₙ, all strictly greater than 1, such that k₀k₁...kₙ - 1
is a product of two consecutive integers.
-/

namespace Usa2008P1



-- This follows the ad-hoc second solution in
-- https://web.evanchen.cc/exams/USAMO-2008-notes.pdf

-- Define the two main sequences
def kseq (n : ℕ) : ℕ :=
  if n = 0 then 7 else 2 ^ (2 ^ n) - 2 ^ (2 ^ (n - 1)) + 1
def xseq (n : ℕ) : ℕ := 2 ^ (2 ^ n)

lemma k_greater_than_one (n : ℕ) : 1 < kseq n := by
  unfold kseq
  split_ifs -- split on n = 0 and n > 0
  · norm_num
  · have : 2^(2^(n-1)) < 2^(2^n) := by gcongr <;> lia
    lia

-- Main identity k₀k₁...kₙ - 1 = xₙ (xₙ + 1)
lemma quartic_polynomial_identity (t : ℕ) :
    (t^2 + t + 1) * (t^2 - t + 1) = t^4 + t^2 + 1 := by
  zify [show t ≤ t^2 by nlinarith]
  ring

lemma main_identity (n : ℕ) :
  (∏ i : Fin (n+1), (kseq ↑i)) = (xseq n) ^ 2 + (xseq n) + 1 := by
  induction n with
  | zero => decide
  | succ n ih =>
      rw [Fin.prod_univ_castSucc]
      simp only [Fin.val_castSucc, Fin.val_last]
      rw [ih]
      simp only [kseq, Nat.add_eq_zero_iff, one_ne_zero, and_false, ↓reduceIte,
        add_tsub_cancel_right]
      rw [show 2 ^ 2 ^ (n + 1) = (xseq n)^2 by unfold xseq; ring]
      rw [show xseq (n + 1) = (xseq n)^2 by unfold xseq; ring]
      rw [show 2 ^ 2 ^ n = xseq n from rfl]
      rw [quartic_polynomial_identity (xseq n)]
      ring

-- kₙ₊₁ = xₙ² - xₙ + 1
lemma kseq_succ_eq (n : ℕ) : kseq (n + 1) = xseq n ^ 2 - xseq n + 1 := by
  unfold kseq xseq
  simp only [Nat.add_sub_cancel, if_neg (Nat.succ_ne_zero n)]
  ring_nf

-- gcd(x² + x + 1, x² - x + 1) = 1
lemma gcd_quad_identity (x : ℤ) :
    Int.gcd (x^2 + x + 1) (x^2 - x + 1) = 1 := by
  -- Apply Euclidean algorithm one step
  rw [show x^2 + x + 1 = 2 * x + (x^2 - x + 1) by ring, Int.gcd_add_self_left, Int.gcd_comm]
  -- Now we need to show x^2-x+1 is coprime to 2x, so we split into two
  have h1 : Int.gcd (x^2 - x + 1) x = 1 := by simp
  have h2 : Int.gcd (x^2 - x + 1) 2 = 1 := by
    have h_odd: (x^2 - x + 1) % 2 = 1 := by
      rcases Int.even_or_odd x with ⟨k, hk⟩ | ⟨k, hk⟩ <;>
      · subst hk; ring_nf; lia
    rw [← Int.gcd_emod, h_odd]
    decide
  rw [Int.gcd_mul_right_right_of_gcd_eq_one h2]
  exact h1

-- we also need an ℕ version of the previous identity
lemma gcd_quad_identity_nat (x : ℕ) :
    Nat.gcd (x^2 + x + 1) (x^2 - x + 1) = 1 := by
  convert gcd_quad_identity (x : ℤ)
  · have : x ≤ x^2 := by nlinarith
    norm_cast

-- kₙ₊₁ is coprime to the product k₀...kₙ
lemma k_coprime_with_product (n : ℕ) :
    Nat.Coprime (∏ i : Fin (n + 1), kseq ↑i) (kseq (n + 1)) := by
  rw [main_identity, kseq_succ_eq, Nat.coprime_iff_gcd_eq_one]
  apply gcd_quad_identity_nat (xseq n)

-- Show the main coprime lemma
-- Strategy: kⱼ is coprime to product P := k₀...kⱼ₋₁, and kseq i divides that product
lemma k_are_coprime (i j : ℕ) (hij: i < j) : Nat.Coprime (kseq i) (kseq j) := by
  obtain ⟨n, rfl⟩ : ∃ n, j = n + 1 := ⟨j - 1, by lia⟩
  let P := ∏ k : Fin (n + 1), kseq ↑k  -- the product k₀ ... kₙ
  have hdvd : kseq i ∣ P := by
    apply Finset.dvd_prod_of_mem (fun j : Fin (n+1) => kseq ↑j) (Finset.mem_univ ⟨i, by lia⟩)
  have hcop : Nat.Coprime P (kseq (n + 1)) := k_coprime_with_product n
  exact Nat.Coprime.coprime_dvd_left hdvd hcop



theorem usa2008_p1 (n : ℕ) (_hn : 0 < n) :
    ∃ k : Fin (n + 1) → ℕ,
      (∀ i, 1 < k i) ∧
      (∀ i j, i ≠ j → Nat.Coprime (k i) (k j)) ∧
      ∃ m, ∏ i : Fin (n + 1), k i = 1 + m * (m + 1) := by
  use fun i ↦ kseq i -- choose k
  refine ⟨?_, ?_, ?_⟩
  · intro i -- check kₙ > 1
    exact k_greater_than_one ↑i
  · intro i j hij  -- check coprime
    have hij' : (↑i : ℕ) ≠ ↑j := Fin.val_injective.ne hij
    obtain h | h := lt_or_gt_of_ne hij'
    · exact k_are_coprime ↑i ↑j h
    · exact (k_are_coprime ↑j ↑i h).symm
  · use xseq n -- choose m = xₙ and finish up
    rw [main_identity n]
    ring

end Usa2008P1

-- ═══ Usa2014P1 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/





/-!
# USA Mathematical Olympiad 2014, Problem 1

Let a, b, c, d be real numbers such that b-d ≥ 5 and all zeros
x₁, x₂, x₃, x₄ of x⁴+ax³+bx²+cx+d are real.
Find the smallest value the product $(x₁²+1)(x₂²+1)(x₃²+1)(x₄²+1)$ can take.
-/

namespace Usa2014P1

open Polynomial

noncomputable def Objective (x : Fin 4 → ℝ) : ℝ := ∏ i, ((x i)^2 + 1)

def Conditions (x : Fin 4 → ℝ) : Prop := ∃ a b c d : ℝ, (5 ≤ b - d) ∧
    ((X - C (x 0)) * (X - C (x 1)) * (X - C (x 2)) * (X - C (x 3))
    = X^4 + C a * X^3 + C b * X^2 + C c * X + C d)



-- This follows the solution in
-- https://web.evanchen.cc/exams/USAMO-2014-notes.pdf
-- The basic idea is to show the desired product equals (b-d-1)^2 + (a-c)^2
-- which makes the problem obvious.

-- For construction, set all roots to 1 and check it gives 16
lemma construction_for_16 : exists x, Conditions x ∧ Objective x = 16 := by
  use fun _ => 1 -- Set every x_i to 1
  constructor
  · unfold Conditions
    use -4, 6, -4, 1 -- a=4, b=6, c=4, d=1
    constructor
    · -- Checks b-d=5
      norm_num
    · -- Checks (X-1)^4 = X^4 - 4X^3 + 6X^2 - 4X + 1
      simp only [map_one]
      -- i can't figure out how to kill the C's without actually specifying them like this
      rw [show (C (-4 : ℝ) : ℝ[X]) = -4 by norm_cast]
      rw [show (C (6 : ℝ) : ℝ[X]) = 6 by norm_cast]
      ring
  · unfold Objective
    simp only [one_pow, Finset.prod_const, Finset.card_univ, Fintype.card_fin]
    norm_num -- (1+1)^4 = 16

-- Vieta formulas for b and d (we don't actually need them for a and c)
lemma vieta (x: Fin 4 → ℝ) (a : ℝ) (b : ℝ) (c : ℝ) (d : ℝ)
    (hpoly : (X - C (x 0)) * (X - C (x 1)) * (X - C (x 2)) * (X - C (x 3))
    = X^4 + C a * X^3 + C b * X^2 + C c * X + C d) :
    d = (x 0) * (x 1) * (x 2) * (x 3) ∧ b = (x 0) * (x 1) + (x 0) * (x 2)
    + (x 0) * (x 3) + (x 1) * (x 2) + (x 1) * (x 3) + (x 2) * (x 3) := by
  constructor
  · apply_fun (·.eval 0) at hpoly
    simp_all
  · apply_fun (·.derivative.derivative.eval 0) at hpoly
    simp at hpoly -- this looks truly hideous when expanded
    linarith

-- Now use Vieta relation to prove the key bound
lemma main_bound {x} (hx : Conditions x) : 16 ≤ Objective x := by
  rcases hx with ⟨a, b, c, d, hbd, hpoly⟩
  -- we need the actual b and d from the condition, so we have b-d ≥ 5
  apply vieta at hpoly -- replace hpoly with the Vieta relations
  -- we'll just define a and c to be the Vieta ones we want
  -- since it's not actually needed to tie them to coeffs of polynomial
  clear a
  clear c
  let a := (x 0) + (x 1) + (x 2) + (x 3)
  let c := (x 0) * (x 1) * (x 2) + (x 1) * (x 2) * (x 3) + (x 2) * (x 3) * (x 0) + (x 3) * (x 0) * (x 1)
  have key_identity : Objective x = (b-d-1)^2 + (a-c)^2 := by
    unfold Objective
    rw [hpoly.1, hpoly.2] -- apply Vieta for b and d
    rw [Fin.prod_univ_four] -- thank god
    ring -- in the informal solution, this is proved using a trick with i = sqrt(-1)
  rw [key_identity]
  linarith [show 16 ≤ (b-d-1)^2 by nlinarith, show 0 ≤ (a-c)^2 by positivity]


noncomputable determine solution : ℝ := 16

theorem usa2014_p1 : IsLeast (Objective '' { x | Conditions x }) solution := by
  constructor
  · simp [construction_for_16]
  · rintro _ ⟨x, hcond, rfl⟩
    exact main_bound hcond
end Usa2014P1

-- ═══ Usa2014P2 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ansar Azhdarov
-/





/-!
# USA Mathematical Olympiad 2014, Problem 2

Let ℤ be the set of integers. Find all functions f : ℤ → ℤ such that
x * f(2 * f(y) - x) + y ^ 2 * f(2 * x - f(y)) = (f(x) ^ 2) / x + f(y * f(y))
for all x, y ∈ ℤ with x ≠ 0.
-/

namespace Usa2014P2

def P (f : ℤ → ℤ) :=
    ∀ x y, x ≠ 0 → x * f (2 * f y - x) + y ^ 2 * f (2 * x - f y) = (f x ^ 2 : ℚ) / x + f (y * f y)

noncomputable def S : Set (ℤ → ℤ) := {0, fun x ↦ x ^ 2}



lemma mpr {f : ℤ → ℤ} : f ∈ S → P f := by
  intro h x y hx
  rcases h with rfl | rfl
  · simp
  · grind

lemma exists_prime_and_not_dvd {n : ℤ} (hn : n ≠ 0) : ∃ p, Prime p ∧ ¬ p ∣ n := by
  obtain ⟨p, hp1, hp2⟩ := Nat.exists_infinite_primes (n.natAbs + 1)
  refine ⟨p, Nat.prime_iff_prime_int.mp hp2, ?_⟩
  rw [Nat.succ_le_iff] at hp1
  intro hpn
  rw [← Int.dvd_natAbs, Int.ofNat_dvd] at hpn
  apply Nat.le_of_dvd (Int.natAbs_pos.mpr hn) at hpn
  lia



theorem usa2014_p2 {f : ℤ → ℤ} : P f ↔ f ∈ S := by
  -- The solution is adapted from https://web.evanchen.cc/exams/USAMO-2014-notes.pdf
  refine ⟨?_ , mpr⟩
  intro h

  have h1 : f 0 = 0 := by
    by_contra! hg
    obtain ⟨p, hp, hp1⟩ := exists_prime_and_not_dvd hg
    have hp2 : p ≠ 0 := Prime.ne_zero hp
    specialize h p 0 hp2
    simp at h
    field_simp at h
    have : p ∣ f p := by
      have : p ∣ f p ^ 2:= by
        use p * f (2 * f 0 - p) - f 0
        qify
        linarith
      exact Prime.dvd_of_dvd_pow hp this
    obtain ⟨k, hk⟩ := this
    apply congrArg (· / (p : ℚ)) at h
    simp [hk] at h
    field_simp at h
    have : p ∣ f 0 := by
      use f (2 * f 0 - p) - k ^ 2
      qify
      linarith
    contradiction

  have h2 (x : ℤ) : x ^ 2 * f (-x) = f x ^ 2 := by
    by_cases! hx : x = 0
    · simp [hx, h1]
    · specialize h x 0 hx
      simp [h1] at h
      field_simp at h
      qify
      lia

  have h3 (x : ℤ) : x ^ 2 * f x = f (-x) ^ 2 := by
    specialize h2 (-x)
    rw [neg_neg] at h2
    linarith

  have h4 (x : ℤ) : f x = f (-x) := by
    by_cases! hx : x = 0
    · simp [hx, h1]
    · by_contra! hg
      have := congrArg₂ (fun x y ↦ x - y) (h2 x) (h3 x)
      have : f x + f (-x) = - x ^ 2 := by
        simp only at this
        rw [← mul_sub, sq_sub_sq, ← neg_sub, ← neg_mul_comm] at this
        apply Int.eq_of_mul_eq_mul_right (sub_ne_zero_of_ne hg) at this
        lia
      have hx1 : 0 < x ^ 2 := sq_pos_of_ne_zero hx
      have : 0 ≤ f x := by
        apply nonneg_of_mul_nonneg_right _ hx1
        simp [h3 x, sq_nonneg]
      have : 0 ≤ f (-x) := by
        apply nonneg_of_mul_nonneg_right _ hx1
        simp [h2 x, sq_nonneg]
      lia

  have h5 (x : ℤ) (hx : f x ≠ 0) : f x = x ^ 2 := by
    simpa [← h4, pow_two (f x), hx] using (h3 x).symm

  wlog h6 : ∃ t, t ≠ 0 ∧ f t = 0
  · push_neg at h6
    right
    funext x
    by_cases! hx : x = 0
    · simp [hx, h1]
    · exact h5 x (h6 x hx)

  left

  have h7 (x : ℤ) : f (2 * x) = 0 := by
    by_cases! hx : x = 0
    · simp [hx, h1]
    · obtain ⟨t, ht, ht1⟩ := h6
      specialize h x t hx
      apply congrArg ((x : ℚ) * ·) at h
      field_simp at h
      qify at h2
      rw [mul_add, ← mul_assoc, ← pow_two] at h
      simpa [ht1, h1, h2, hx, ht] using h

  funext m
  by_contra! hm
  rw [Pi.zero_apply] at hm

  have hm1 : m ≠ 0 := by
    contrapose! hm
    simp [hm, h1]

  have hm2 : m ^ 2 ≠ 0 := pow_ne_zero 2 hm1

  have hm3 : f m = m ^ 2 := h5 m hm

  have hm4 : Odd m := by
    by_contra! hg
    rw [Int.not_odd_iff_even, even_iff_exists_two_mul] at hg
    obtain ⟨k, rfl⟩ := hg
    exact hm (h7 k)

  have h8 (k y : ℤ) (hk : k ≠ 0) : y ^ 2 * f (4 * k - f y) = f (y * f y) := by
    qify
    specialize h (2 * k) y (mul_ne_zero two_ne_zero hk)
    rw [← mul_sub, ← mul_assoc, ← pow_two] at h
    simpa [h7] using h

  have h9 (k : ℤ) (hk : k ≠ 0) : m ^ 2 * f (4 * k - m ^ 2) = f (m ^ 3) := by
    simpa [hm3, ← Int.pow_succ'] using h8 k m hk

  have h10 : f (m ^ 3) = 0 := by
    by_contra! hg
    have _h (k : ℤ) (hk : k ≠ 0) : f (4 * k - m ^ 2) = (4 * k - m ^ 2) ^ 2 := by
      specialize h9 k hk
      rw [← h9, mul_ne_zero_iff] at hg
      exact h5 (4 * k - m ^ 2) hg.right
    have _hm : f (m ^ 3) = m ^ 6 := by
      simpa [← pow_mul] using h5 (m ^ 3) hg
    specialize h9 (m ^ 2) hm2
    simp [_h, _hm, hm2] at h9
    ring_nf at h9
    lia

  have h11 (k : ℤ) (hk : k ≠ 0) : f (4 * k - m ^ 2) = 0 := by
    specialize h9 k hk
    simpa [h10, hm2] using h9

  have h12 (k : ℤ) (hk : k ≠ 0) : f (m ^ 2 - 4 * k) = 0 := by
    rw [← neg_sub, ← h4, h11 k hk]

  have hm5 : ∃ k, 4 * k + 1 = m ^ 2 := by
    obtain ⟨k, hk⟩ := hm4
    use k ^ 2 + k
    rw [hk]
    ring

  obtain ⟨l, hl⟩ := hm5

  have h13 (k : ℤ) (hk : l ≠ k) : f (4 * k + 1) = 0 := by
    specialize h12 (l - k) (sub_ne_zero_of_ne hk)
    simp [← hl] at h12
    ring_nf at h12
    rw [add_comm, mul_comm, h12]

  have h14 (k : ℤ) (hk : l + (k + 1) ≠ 0) : f (4 * k + 3) = 0 := by
    specialize h11 (l + (k + 1)) hk
    simp [← hl] at h11
    ring_nf at h11
    rw [add_comm, mul_comm, h11]

  have hm6 : ∃ k, 4 * k + 1 = m ∨ 4 * k + 3 = m := by
    obtain ⟨k, rfl⟩ := hm4
    rcases Int.even_or_odd k with ⟨n, rfl⟩ | ⟨n, rfl⟩
    · exact ⟨n, by left; ring⟩
    · exact ⟨n, by right; ring⟩

  obtain ⟨n, hn⟩ := hm6

  rcases hn with hn | hn
  · have : l = n := by
      by_contra! hg
      specialize h13 n hg
      rw [hn] at h13
      contradiction
    have : m = m ^ 2 := by
      rw [← hl, ← hn, this]
    grind
  · have : l + (n + 1) = 0 := by
      by_contra! hg
      specialize h14 n hg
      rw [hn] at h14
      contradiction
    have : m = - m ^ 2 := by
      rw [← hl, ← hn]
      lia
    grind

end Usa2014P2

-- ═══ Usa2014P3 ═══

/-
Copyright (c) 2025 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen
-/




/-!
# USA Mathematical Olympiad 2014, Problem 3

Prove that there exists an infinite set of points

… , P₋₃, P₋₂, P₋₁, P₀, P₁, P₂, P₃, …

in the plane with the following property:
For any three distinct integers a, b, and c,
points Pₐ, P_b, P_c are collinear if and only if a+b+c=2014.
-/

notation "Pt" => EuclideanSpace ℝ (Fin 2)

namespace Usa2014P3



open Finset

-- Following https://web.evanchen.cc/exams/USAMO-2014-notes.pdf

-- Our construction (valid for x ∈ ℝ) is P_x := (x-2014/3, (x-2014/3)^3).
noncomputable def f (x : ℝ) : Pt :=
  !₂[x - (2014 / 3), (x - (2014 / 3)) ^ 3]

-- f is in an injective function (needed for Finset later)
lemma f_injective {x y : ℝ} (hxy : x ≠ y) :
    f x ≠ f y := by
  by_contra
  unfold f at this
  simp_all

lemma collinear_iff_sum {a b c : ℝ} (hab : a ≠ b) (hbc : b ≠ c) (hca : c ≠ a) :
    Collinear ℝ {(f a), (f b), (f c)}
    ↔ (a + b + c = 2014) := by
  set A := f a
  set B := f b
  set C := f c
  have hAB : A ≠ B := f_injective hab
  have hBC : B ≠ C := f_injective hbc
  have hCA : C ≠ A := f_injective hca
  let S : Finset Pt := {A, B, C}
  -- convert collinearity condition into a rank condition on A-C and B-C
  rw [collinear_iff_finrank_le_one]
  rw [show {A, B, C} = (S : Set Pt) by simp [S]]
  rw [vectorSpan_eq_span_vsub_finset_right_ne ℝ (show C ∈ S by simp [S])]
  rw [show S.erase C = {A, B} by grind only [= mem_erase, = mem_insert, = mem_singleton]]
  rw [image_insert, image_singleton]
  simp only [vsub_eq_sub]
  -- grab the dimension n = rank vector span of {A-C, B-C}
  let n : ℕ := ?_
  change n ≤ 1 ↔ _
  have hn : n ≤ 1 ↔ 2 ≠ n := by
    have : n ≤ 2 := (finrank_span_le_card _).trans (by simp [card_le_two])
    lia
  rw [hn]
  -- type cast like crazy
  let X : Fin 2 → Pt := ![A - C, B - C]
  have h := linearIndependent_iff_card_eq_finrank_span (b := X) (R := ℝ)
  simp only [Fintype.card_fin] at h
  rw [show Set.range X = ({A-C, B-C}: Finset Pt) by aesop] at h
  refine h.not.symm.trans ?_
  let isom := WithLp.linearEquiv 2 ℝ (Fin 2 → ℝ)
  rw [← LinearMap.linearIndependent_iff isom.toLinearMap (by simp)]
  simp only [LinearEquiv.coe_coe]
  let M : Matrix (Fin 2) (Fin 2) ℝ := .of (isom ∘ X)
  rw [show isom ∘ X = M.row by rfl]
  rw [Matrix.linearIndependent_rows_iff_isUnit, Matrix.isUnit_iff_isUnit_det, isUnit_iff_ne_zero]
  -- Write the explicit matrix
  have hM : M = !![a-c, (a-(2014/3))^3-(c-(2014/3))^3; b-c, (b-(2014/3))^3-(c-(2014/3))^3] := by
    rw [← Matrix.ext_iff, Fin.forall_fin_succ]
    simp [M, isom, X, A, B, C, f]
  rw [hM]
  simp [Matrix.det_fin_two]
  grind only -- this line does like 90% of the mathematical work (e.g. factoring determinant)



theorem usamo2014_p3 : ∃ P : ℤ → Pt, ∀ a b c : ℤ,
    a ≠ b ∧ b ≠ c ∧ c ≠ a → (Collinear ℝ {P a, P b, P c} ↔ a + b + c = 2014) := by
  use fun n ↦ f (n : ℝ)
  intro a b c
  simp only [and_imp]
  intro hab hbc hca
  rify at hab hbc hca
  convert (collinear_iff_sum hab hbc hca) using 1
  rify
end Usa2014P3

-- ═══ Usa2015P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 2015, Problem 1

Solve in integers the equation x² + xy + y² = ((x + y) / 3 + 1)³.
-/

namespace Usa2015P1



lemma iff_comm {a b c : Prop} : (a → c) → (b → c) → (c → (a ↔ b)) → (a ↔ b) := by
  grind

lemma abc { a b c : ℤ } (hb : b ≠ 0) : a ^ 2 = b ^ 2 * c → ∃ d, c = d ^ 2 := by
  intro h
  have h1 : b ^ 2 ∣ a ^ 2 := by simp_all only [ne_eq, dvd_mul_right]
  have h2 : b ∣ a := by apply (Int.pow_dvd_pow_iff (by positivity)).mp h1
  obtain ⟨d, rfl⟩ := h2
  rw [mul_pow, mul_right_inj' (by positivity)] at h
  use d
  exact h.symm



noncomputable def SolutionSet : Set (ℤ × ℤ) :=
  {⟨x, y⟩ | ∃ n, x = n ^ 3 + 3 * n ^ 2 - 1 ∧ y = -n ^ 3 + 3 * n + 1} ∪
  {⟨x, y⟩ | ∃ n, y = n ^ 3 + 3 * n ^ 2 - 1 ∧ x = -n ^ 3 + 3 * n + 1}

theorem usa2015_p1 (x y : ℤ) :
    ⟨x, y⟩ ∈ SolutionSet ↔
    x^2 + x * y + y^2 = ((x + y) / (3 : ℚ) + 1)^3 := by
  unfold SolutionSet
  apply iff_comm (c := ∃ t, x + y = 3 * t)
  · simp; intro h; obtain h | h := h
    all_goals obtain ⟨h, hx, hy⟩ := h; rw [hx, hy]; ring_nf; use (h + h ^ 2); ring_nf
  · intro h; apply_fun (· * 3 ^ 3) at h; rw [←mul_pow, (add_mul _ 1)] at h; simp at h
    norm_num at h; norm_cast at h
    suffices (x + y) % 3 = 0 by rw [←dvd_def]; exact Int.dvd_of_emod_eq_zero this
    have h1 : (x ^ (2 : ℕ) + x * y + y ^ (2 : ℕ)) * (27 : ℤ) % 3 =
              (x + y + (3 : ℤ)) ^ (3 : ℕ) % 3 := by rw [h]
    clear h
    have h2 : (x ^ (2 : ℕ) + x * y + y ^ (2 : ℕ)) * (27 : ℤ) % 3 = 0 := by lia
    rw [h2] at h1
    clear h2
    have h3 : (x + y + (3 : ℤ)) ^ (3 : ℕ) =
              (x + y) ^ 3 + 3 * (x + y) * 3 * 3 + 3 * (x + y)^2 * 3 + 3 * 3 * 3 := by ring
    rw [h3] at h1
    clear h3
    simp only [Int.add_mul_emod_self_right] at h1
    exact Int.emod_eq_zero_of_dvd <|
      Prime.dvd_of_dvd_pow Int.prime_three (Int.dvd_of_emod_eq_zero h1.symm)
  intro ht
  obtain ⟨t, ht⟩ := ht
  have ht2 : t = (x + y) / 3 := by rw [ht]; simp
  rw [← Rat.intCast_add, ht]
  rw [(by cancel_denoms : ((3 * t) : ℤ) / (3 : ℚ) = t)]
  norm_cast
  rw [(by rw [←ht]; linarith only : (x ^ 2 + x * y + y ^ 2) = (3 * t) ^ 2 + x * (x - 3 * t))]
  trans (2 * x - 3 * t) ^ 2 = (t - 2) ^ 2 * (4 * t + 1)
  swap; constructor <;> intro h <;> linarith only [h]
  constructor
  · intro h
    simp at h
    obtain ⟨n, h1, h2⟩ | ⟨n, h1, h2⟩ := h
    all_goals have ht : t = n ^ 2 + n := by rw [ht2, h1, h2]; ring_nf; rw [←add_mul]; simp
    all_goals rw [ht]; (first | rw [h1] | rw [h2]); ring_nf
  · intro ht3
    by_cases ht4 : (t = 2)
    · rw [ht4] at ht3; norm_num at ht3
      have : x = 3 := by linarith only [ht3]
      rw [this, ht4] at ht
      have : y = 3 := by linarith only [ht]
      simp [*]; use 1; simp
    · obtain ⟨d, hd⟩ := abc (sub_ne_zero_of_ne ht4) ht3
      have Odd_dd : Odd (d ^ 2) := by
        rw [←hd]; apply Even.add_one; apply Even.mul_right; exact Int.even_iff.mpr rfl
      have Odd_d  : Odd d := (Int.odd_pow' (by positivity)).mp Odd_dd
      set n := d / 2 with hn
      have nd : d = 2 * n + 1 := by rw [hn]; symm; exact Int.two_mul_ediv_two_add_one_of_odd Odd_d
      have ht5 := nd ▸ hd
      rw [add_sq, mul_pow] at ht5
      have ht6 : 4 * t = 4 * (n * (n + 1)) := by linear_combination 1 * ht5
      clear ht5
      have htn : t = n * (n + 1) := (Int.mul_eq_mul_left_iff (by positivity)).mp ht6
      rw [htn] at ht3
      have ht7 : (2 * x - 3 * n * n - 3 * n) ^ 2 = ((n * n + n - 2) * (2 * n + 1)) ^ 2 := by
        linear_combination 1 * ht3
      clear ht3
      rw [sq_eq_sq_iff_eq_or_eq_neg] at ht7
      simp only [Set.mem_union, Set.mem_setOf_eq]
      obtain h | h := ht7
      · left; use n; lia
      · right; use n; lia


end Usa2015P1

-- ═══ Usa2015P5 ═══

/-
Copyright (c) 2026 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Evan Chen, Kenny Lau, Jujian Zhang
-/





/-!
# USA Mathematical Olympiad 2015, Problem 5

Let a, b, c, d, e be distinct positive integers such that a⁴+b⁴ = c⁴+d⁴ = e⁵.
Show that ac+bd is a composite number.
-/

namespace Usa2015P5

variable { a b c d e p : ℕ }
    (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) (he : 0 < e)
    (habe : a ^ 4 + b ^ 4 = e ^ 5)
    (hcde : c ^ 4 + d ^ 4 = e ^ 5)
    (hab : a ≠ b) (hac : a ≠ c) (had : a ≠ d) (hae : a ≠ e)
    (hbc : b ≠ c) (hbd : b ≠ d) (hbe : b ≠ e)
    (hcd : c ≠ d) (hce : c ≠ e)
    (hde : d ≠ e)



-- Follows the solution at https://web.evanchen.cc/exams/USAMO-2015-notes.pdf

set_option quotPrecheck false
local notation3 "p" => a * c + b * d

include habe hcde in
lemma p_divis : ((a - d) * (a + d) * (a ^ 2 + d ^ 2) * e ^ 5 : ZMod p) = 0 := by
  replace habe := congr(($habe : ZMod p))
  replace hcde := congr(($hcde : ZMod p))
  simp_all
  have : (a * c + b * d : ZMod p) = 0 := by simp [← Nat.cast_mul, ← Nat.cast_add]
  grind only

include ha hb hc hd habe in
lemma e_lt_p : e < p := by
  have h : e ^ 5 < p ^ 5 := calc
    _ = a ^ 4 + b ^ 4 := habe.symm
    _ ≤ a ^ 5 + b ^ 5 := by gcongr 1 <;> exact Nat.pow_le_pow_right ‹_› (by norm_num)
    _ < (a + b) ^ 5 := by group; simp_all
    _ ≤ _ := by gcongr <;> nlinarith
  exact lt_of_pow_lt_pow_left' 5 h

include ha hb hc hd he habe in
lemma not_p_dvd_e :  ¬ p ∣ e :=
  Nat.not_dvd_of_pos_of_lt he (e_lt_p ha hb hc hd habe)

include ha hb hc hd he habe in
lemma not_p_dvd_e_pow_5 (hp: Nat.Prime p) : ¬ p ∣ e ^ 5 := by
  have h := not_p_dvd_e ha hb hc hd he habe
  contrapose! h
  exact Nat.Prime.dvd_of_dvd_pow hp h

include ha hb hc hd he habe hcde had in
lemma p_le_aa_plus_dd (hp : Nat.Prime p) : p ≤ a ^ 2 + d ^ 2 := by
  wlog h_d_le_a : d ≤ a
  · grind only
  have h_d_lt_a : d < a := Nat.lt_of_le_of_ne h_d_le_a (id (Ne.symm had))
  have h := p_divis habe hcde
  simp only [← Nat.cast_sub h_d_le_a, ← Nat.cast_npow, ← Nat.cast_add, ← Nat.cast_mul] at h
  rw [ZMod.natCast_eq_zero_iff] at h
  rw [Nat.Prime.dvd_mul hp] at h
  -- At this point, p ∣ (a-d)(a+d)(a²+d²)e⁵
  -- Cut off the e at the far right
  replace h := h.resolve_right (by apply not_p_dvd_e_pow_5 <;> assumption)
  simp only [Nat.Prime.dvd_mul hp] at h
  clear hb hc he habe hcde h_d_le_a
  -- At this point, p ∣ (a-d)(a+d)(a²+d²)
  -- Break into a ton of cases based on which factor is divided; most are easy
  rcases h with ((h|h)|h) <;> apply Nat.le_of_dvd at h <;> try nlinarith
  · refine h.trans ?_
    calc
      _ ≤ a + d := by lia
      _ ≤ _ := by gcongr <;> apply Nat.le_pow <;> norm_num
  · simp_all


include ha hb hc hd he habe hcde had hbc hac in
theorem usa2015_p5 : ¬ Nat.Prime (a * c + b * d) ∧ (1 < a * c + b * d) := by
  constructor
  · wlog h_a_le_c : a ≤ c
    · rw [show a * c + b * d = c * a + d * b by ring]
      apply this hc hd ha hb he <;> try {symm; assumption} <;> linarith
    have h_a_lt_c : a < c := Nat.lt_of_le_of_ne h_a_le_c hac
    clear h_a_le_c hac
    by_contra
    have : a * c + b * d ≤ a ^ 2 + d ^ 2 := by apply p_le_aa_plus_dd <;> assumption
    clear had hbc
    have h_d_lt_b : d < b := by
      rw [← hcde] at habe
      have : a ^ 4 < c ^ 4 := by gcongr
      exact lt_of_pow_lt_pow_left' 4 (by grind only)
    nlinarith
  · nlinarith

end Usa2015P5

-- ═══ Usa2017P6 ═══

/-
Copyright (c) 2025 Jeremy Tan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan
-/




/-!
# USA Mathematical Olympiad 2017, Problem 6

Find the minimum possible value of
`a / (b³ + 4) + b / (c³ + 4) + c / (d³ + 4) + d / (a³ + 4)`
given that `a, b, c, d` are nonnegative real numbers such that `a + b + c + d = 4`.
-/

namespace Usa2017P6

noncomputable def f (x : Fin 4 → ℝ) : ℝ :=
  ∑ i, x i / (x (i + 1) ^ 3 + 4)

def Conditions (x : Fin 4 → ℝ) : Prop :=
  0 ≤ x ∧ ∑ i, x i = 4



lemma one_direction : ∃ x, Conditions x ∧ f x = 2 / 3 := by
  use fun | 0 => 2 | 1 => 2 | 2 => 0 | 3 => 0
  rw [Conditions, f]
  refine ⟨⟨?_, ?_⟩, ?_⟩
  · rw [Pi.le_def]; intro i; fin_cases i <;> norm_num
  all_goals rw [Fin.sum_univ_four]; simp; norm_num

lemma other_direction {x} (hx : Conditions x) : 2 / 3 ≤ f x := by
  obtain ⟨h₁, h₂⟩ := hx
  have aux₁ {k : ℝ} (hk : 0 ≤ k) : 1 / 4 - k / 12 ≤ 1 / (k ^ 3 + 4) := by
    rw [show 1 / 4 - k / 12 = (3 - k) / 12 by ring, div_le_div_iff₀ (by norm_num) (by positivity),
      one_mul, ← sub_nonneg, show 12 - (3 - k) * (k ^ 3 + 4) = k * (k + 1) * (k - 2) ^ 2 by ring]
    positivity
  have aux₂ : ∑ i, x i * x (i + 1) ≤ 4 := by
    rw [Fin.sum_univ_four]; simp only [Fin.reduceAdd]
    rw [show x 0 * x 1 + x 1 * x 2 + x 2 * x 3 + x 3 * x 0 = (x 0 + x 2) * (x 1 + x 3) by ring]
    have iden := four_mul_le_sq_add (x 0 + x 2) (x 1 + x 3)
    rw [show x 0 + x 2 + (x 1 + x 3) = x 0 + x 1 + x 2 + x 3 by ring,
      ← Fin.sum_univ_four, h₂] at iden
    linarith
  calc
    _ ≥ ∑ i, (x i / 4 - x i * x (i + 1) / 12) := by
      rw [f]; gcongr with i
      rw [mul_div_assoc, div_eq_mul_one_div, ← mul_sub, div_eq_mul_one_div (x i)]
      exact mul_le_mul_of_nonneg_left (aux₁ (h₁ (i + 1))) (h₁ i)
    _ = 1 - (∑ i, x i * x (i + 1)) / 12 := by
      rw [Finset.sum_sub_distrib, ← Finset.sum_div, h₂, ← Finset.sum_div, div_self four_ne_zero]
    _ ≥ _ := by linarith



noncomputable determine solution : ℝ := 2 / 3

theorem usa2017_p6 : IsLeast (f '' {x | Conditions x}) solution := by
  constructor
  · simp [one_direction]
  · simp_rw [lowerBounds, Set.mem_image, Set.mem_setOf, forall_exists_index, and_imp,
      forall_apply_eq_imp_iff₂]
    exact fun x hx ↦ other_direction hx

end Usa2017P6

-- ═══ Usa2018P1 ═══

/-
Copyright (c) 2024 The Compfiles Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hongyu Ouyang
-/





/-!
# USA Mathematical Olympiad 2018, Problem 1

Given that a,b,c are positive real numbers such that

  a + b + c = 4 ∛(abc)

prove that 2(ab + bc + ca) + 4min(a²,b²,c²) ≥ a² + b² + c²
-/

namespace Usa2018P1



lemma am_gm (a b : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) :
    2 * (a * b) ^ ((1 : ℝ) / 2) ≤ a + b := by
  have hw : (0 : ℝ) ≤ 1/2 := by norm_num
  rw [Real.mul_rpow ha hb]
  linarith [Real.geom_mean_le_arith_mean2_weighted hw hw ha hb (by norm_num)]




theorem usa2018_p1 (a b c : ℝ) :
    a > 0 → b > 0 → c > 0 → a + b + c = 4 * (a * b * c) ^ ((1 : ℝ) / 3) →
    2 * (a * b + b * c + c * a) +
     4 * (min (min (a * a) (b * b)) (c * c)) ≥ a^2 + b^2 + c^2 := by
  -- solution 1 from
  -- https://artofproblemsolving.com/wiki/index.php/2018_USAMO_Problems/Problem_1
  intro ha hb hc heq
  wlog h1 : a ≤ b with H1
  · grind only [= min_def]
  · wlog h2 : a ≤ c with H2
    · move_add [←(c^2)]; move_add [(a^2)]
      convert (H2 c b a hc hb ha ?_ ?_ ?_) using 3
      · ring_nf
      · exact inf_left_right_swap _ _ _
      · linear_combination (norm := (ring_nf)) 1 * heq
      · linarith
      · linarith
    · wlog h3 : b ≤ c with H3
      · move_add [(b^2)]
        convert (H3 a c b ha hc hb ?_ h2 h1 ?_) using 3
        · linarith
        · rw [min_comm, ←min_assoc, min_comm (a*a)]
        · linear_combination (norm := (field_simp; ring_nf)) 1 * heq
        · linarith
      · have aabb : a * a ≤ b * b := mul_self_le_mul_self (le_of_lt ha) h1
        have aacc : a * a ≤ c * c := mul_self_le_mul_self (le_of_lt ha) h2
        simp only [aabb, aacc, min_eq_left]
        apply le_of_add_le_add_right (a := 2 * (a * b + b * c + c * a))
        convert_to (a + b + c) ^ 2 ≤ 4 * (a * (a + b + c) + b * c)
        · ring_nf
        · ring_nf
        rw [heq]
        have amgm := am_gm (a * ((4 : ℝ) * (a * b * c) ^ ((1 : ℝ) / 3))) (b * c)
                           (by positivity) (by positivity)
        rw [←mul_le_mul_iff_right₀ zero_lt_four] at amgm
        convert amgm
        ring_nf
        nth_rw 2 [(by simp : a * b * c = (a * b * c) ^ (1 : ℕ))]
        rw [←Real.rpow_two, ←Real.rpow_mul (by positivity)]
        rw [mul_comm ((a * b * c) ^ (1 : ℕ)), ←Real.rpow_add_natCast (by positivity)]
        norm_num
        nth_rw 2 [Real.mul_rpow (by positivity) (by positivity)]
        rw [←Real.rpow_mul (by positivity)]
        norm_num
        rw [(mul_assoc _ _ 8)]
        simp only [mul_eq_mul_left_iff]
        left
        norm_num1


end Usa2018P1

-- ═══ Usa2019P1 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/






/-!
# USA Mathematical Olympiad 2019, Problem 1

Let ℕ+ be the set of positive integers.
A function f: ℕ+ → ℕ+ satisfies the equation

  fᶠ⁽ⁿ⁾(n)⬝f²(n) = n^2

for all positive integers n, where fᵏ(m) means f iterated k times on m.
Given this information, determine all possible values of f(1000).
-/

namespace Usa2019P1



lemma f_injective
    (f : ℕ+ → ℕ+)
    (hf : ∀ n, f^[f n] n * f (f n) = n ^ 2) :
    f.Injective := by
  intro p q hpq
  -- If f(p)=f(q), then f^2(p)=f^2(q) and f^{f(p)}(p) = f^{f(q)}(q)
  have h1 : f^[2] p = f^[2] q := by
    apply_fun f at hpq
    exact hpq

  have h2 : ∀ n : ℕ+, f^[n] p = f^[n] q := by
    intro n
    obtain ⟨n, hn⟩ := n
    cases n <;> aesop

  have h3 : f^[f p] p = f^[f q] q := by rw[hpq]; exact h2 (f q)

  -- ⇒ p^2 = f^2(p) ⬝ f^{f(p)}(p) = f^2(q) ⬝ f^{f(q)}(q) = q^2
  have h4 :=
    calc p^2
      = f^[f p] p * f^[2] p := (hf p).symm
    _ = f^[f q] q * f^[2] q := by rw[h3, h1]
    _ = q^2 := hf q

  -- ⇒ p = q
  obtain ⟨p, hp⟩ := p
  obtain ⟨q, hq⟩ := q
  congr
  apply_fun (fun x ↦ x.val) at h4
  rw [PNat.pow_coe, PNat.pow_coe, PNat.mk_coe, PNat.mk_coe] at h4
  rw [pow_left_inj₀ (le_of_lt hp) (le_of_lt hq) two_ne_zero] at h4
  exact h4

lemma lemma_1
    (f : ℕ+ → ℕ+)
    (hf : ∀ n, f^[f n] n * f (f n) = n ^ 2)
    (a b : ℕ+)
    (r : ℕ)
    (fab1 : f^[r] b = a)
    (fab2 : f a = a) :
    b = a := by
  have h1 : ∀ s, f^[s] a = a := fun s ↦ Function.iterate_fixed fab2 s

  have h2 := calc f^[r] b
      = a := fab1
    _ = f^[r] a := (h1 r).symm

  -- which implies b=a by injectivity of f^r.
  exact Function.Injective.iterate (f_injective f hf) r h2

lemma lemma_2
    (f : ℕ+ → ℕ+)
    (hf : ∀ n, f^[f n] n * f (f n) = n ^ 2)
    (m : ℕ+)
    (hm1 : f^[2] m = f^[f m] m)
    (hm2 : f^[f m] m = m)
    (hm3 : Odd m.val) :
    f m = m := by
  -- Let f(m)=k.
  let k := f m
  -- Since f^2(m)=m, f(k)=m.
  have h1 : f k = m := by
    unfold k; dsimp at hm1 hm2; rw[hm1, hm2]

  -- So, f^2(k)=k.
  have h2 : f^[2] k = k := by dsimp; rw[h1]

  -- f^2(k) · f^{f(k)}(k) = k^2.
  have h3 : f^[f k] k * f^[2] k = k^2 := hf k
  rw [h2] at h3

  -- Since k≠0, f^{f(k)}(k)=k.
  have h4 : f^[f k] k = k := by
    rwa [sq k, mul_left_inj] at h3

  -- ⇒ f^m(k)=k
  rw [h1] at h4

  -- ⇒ f^{gcd(m, 2)}(k)=k
  -- ⇒ f(k)=k
  have h6 : ∀ r , f^[2*r] k = k := fun r ↦ by
    induction' r with r ih
    · simp
    · rw [Nat.mul_succ]
      rw [Function.iterate_add]
      change f^[2 * r] (f^[2] k) = k
      rw[h2]
      exact ih
  obtain ⟨m', hm'⟩ := hm3
  rw [hm', add_comm, Function.iterate_add, Function.iterate_one] at h4
  change f (f^[2 * m'] k) = k at h4
  rw [h6 m'] at h4

  rw [h1] at h4
  exact h4.symm

lemma pnat_odd_mul {a b c : ℕ+} (h : a * b = c * c) (hc : Odd c.val) :
    Odd a.val ∧ Odd b.val := by
  obtain ⟨a, ha⟩ := a
  obtain ⟨b, hb⟩ := b
  obtain ⟨c, hc⟩ := c
  simp only [PNat.mk_coe]
  rw [PNat.mk_coe] at hc
  apply_fun (fun x ↦ x.val) at h
  dsimp at h
  have h1 : Odd (c * c) := Odd.mul hc hc
  rw [←h] at h1
  exact Nat.odd_mul.mp h1

lemma lemma_3
    (f : ℕ+ → ℕ+)
    (hf : ∀ n, f^[f n] n * f (f n) = n ^ 2)
    (m : ℕ+)
    (hm3 : Odd m.val) :
    f m = m := by
  -- Otherwise, let m be the least counterexample.
  -- Since f^2(m)⬝f^{f(m)}(m)=m^2, either
  --  (1) f^2(m) = k < m, contradicted by Lemma 1 since k is odd and therefore f(k)=k.
  --  (2) f^{f(m)}(m) = k<m, also contradicted by Lemma 1 by similar logic.
  --  (3) f^2(m)=m and f^{f(m)}(m)=m, which implies that f(m)=m by Lemma 2.

  induction' m using PNat.strongInductionOn with m2 ih

  have h1 := hf m2
  rw [sq] at h1
  by_cases h2 : f^[2] m2 < m2
  · let k := f^[2] m2
    have hkodd : Odd k.val := (pnat_odd_mul h1 hm3).2
    have h3 : f k = k := ih k h2 hkodd
    rw[lemma_1 f hf k m2 2 rfl h3]
    exact h3
  · by_cases h4 : f^[f m2] m2 < m2
    · let k := f^[f m2] m2
      have hkodd : Odd k.val := (pnat_odd_mul h1 hm3).1
      have h3 : f k = k := ih k h4 hkodd
      rw[lemma_1 f hf k m2 _ rfl h3]
      exact h3
    · have h5 : f^[2] m2 = m2 ∧ f^[f m2] m2 = m2 := by
         simp only [Function.iterate_succ, Function.comp_apply, not_lt] at h2 h4
         by_contra H
         rw [not_and_or] at H
         obtain h9 | h9 := H
         · replace h2 : m2 < f (f m2) := Ne.lt_of_le' h9 h2
           have h10 : m2 * m2 < f^[↑(f m2)] m2 * f (f m2) := mul_lt_mul_of_le_of_lt h4 h2
           rw [←h1] at h10
           exact LT.lt.false h10
         · replace h4 : m2 < f^[f m2] m2 := Ne.lt_of_le' h9 h4
           have h10 : m2 * m2 < f^[↑(f m2)] m2 * f (f m2) := mul_lt_mul_of_lt_of_le h4 h2
           rw [←h1] at h10
           exact LT.lt.false h10
      obtain ⟨h6, h7⟩ := h5
      have h8 : f^[2] m2 = f^[↑(f m2)] m2 := by rw[h7]; exact h6
      exact lemma_2 f hf _ h8 h7 hm3



noncomputable def solution_set : Set ℕ+ := { x : ℕ+ | Even x.val }

theorem usa2019_p1 (m : ℕ+) :
   m ∈ solution_set ↔
    (∃ f : ℕ+ → ℕ+,
      (∀ n, f^[f n] n * f (f n) = n ^ 2) ∧
      m = f 1000) := by
  -- (informal proof outline from artofproblemsolving.com)
  -- 0. prove that f is injective.
  -- 1. prove that if f^r(b)=a and f(a)=a, then b=a.
  -- 2. prove that if f^2(m)=f^{f(m)}(m)=m and m is odd, then f(m)=m.
  -- 3. prove by contradiction that f(m)=m for all odd m.
  -- 4. by injectivity, f(1000) is not odd.
  -- 5. prove that f(1000) can equal any even number.
  constructor
  · intro hm
    simp only [Set.mem_setOf_eq] at hm
    obtain ⟨f, hf⟩ : ∃ f : ℕ+ → ℕ+, f = fun x ↦ if x = m then 1000 else (if x = 1000 then m else x)
      := exists_eq
    have hmeq : m = f 1000 := by
      simp only [hf, ite_true]
      obtain heq | hne := eq_or_ne 1000 m
      · rw [heq]; simp
      · simp_rw[eq_false hne]
        simp
    have hmeq1 : f m = 1000 := by simp [hf]
    have hmsq : f^[2] m = m := by simp [hf]
    have hmsq' : f^[2] 1000 = 1000 := by simp [hf]

    use f
    constructor
    · intro n
      obtain heq | hne := eq_or_ne n 1000
      · rw [heq, ←hmeq, hmeq1]
        obtain ⟨m', hm'⟩ := hm
        rw [←Nat.two_mul] at hm'
        rw [hm', Function.iterate_mul, Function.iterate_fixed hmsq']
        decide
      · obtain heq' | hne' := eq_or_ne n m
        · rw [heq', hmeq1]
          rw [← hmeq]
          rw [show ((1000:ℕ+):ℕ) = 2 * 500 by rfl]
          rw [Function.iterate_mul, Function.iterate_fixed hmsq]
          exact (sq m).symm
        · have hn : f n = n := by
            simp only [hf]
            simp_rw [eq_false hne']
            simp only [ite_false, ite_eq_right_iff]; intro h2; exact (hne h2).elim
          rw [hn, hn]
          rw [Function.iterate_fixed hn]
          exact (sq n).symm
    · exact hmeq
  · intro h
    obtain ⟨f, hf1, hf2⟩ := h
    suffices h : Even m.val by exact h
    by_contra H
    have h1 : Odd m.val := Nat.not_even_iff_odd.mp H
    have h2 := lemma_3 f hf1 m h1
    rw [hf2] at h2
    rw [hf2, f_injective f hf1 h2] at h1
    simp (config := {decide := true}) only at h1


end Usa2019P1

-- ═══ Usa2022P4 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 2022, Problem 4

Determine all pairs of primes (p, q) where p - q and pq - q
are both perfect squares.
-/

namespace Usa2022P4

noncomputable def solution_set : Set (ℕ × ℕ) := {(3, 2)}

theorem usa2022_p4 (p q : ℕ) :
    (p, q) ∈ solution_set ↔
    p.Prime ∧ q.Prime ∧
    ∃ a, a^2 + q = p ∧ ∃ b, b^2 + q = p * q := by
  constructor
  · -- easy direction
    intro hpq
    obtain ⟨rfl, rfl⟩ := hpq
    exact ⟨by norm_num, by norm_num, 1, by norm_num, 2, by norm_num⟩

  -- Informal proof outline taken from
  -- https://web.evanchen.cc/exams/USAMO-2022-notes.pdf
  rintro ⟨hpp, hpq, a, ha, b, hb⟩

  -- Note that 0 < p and 0 < q because they are prime.
  have hp_pos : 0 < p := Nat.Prime.pos hpp
  have hq_pos : 0 < q := Nat.Prime.pos hpq

  -- Note that we then have 0 < a < p, and 0 < b < p (because q ≤ p).
  have hqlep : q ≤ p := (Nat.le_add_left q (a ^ 2)).trans_eq ha

  have hbp : b < p := by
    by_contra! H
    have h2 : p^2 ≤ b^2 := Nat.pow_le_pow_left H 2
    have h6 :=
      calc p * p = p^2 := (Nat.pow_two p).symm
           _ < p^2 + q := Nat.lt_add_of_pos_right hq_pos
           _ ≤ _ := Nat.add_le_add_right h2 q
           _ = p * q := hb
    have h7 : p < q := (Nat.mul_lt_mul_left hp_pos).mp h6
    exact Nat.le_lt_asymm hqlep h7

  -- Subtracting our equations gives (b - a)(b + a) = b² - a² = p(q - 1),
  have h1 : (b + a) * (b - a) = p * (q - 1) := by
    rw [←Nat.sq_sub_sq, Nat.mul_sub_left_distrib, mul_one]
    have h2 : (b^2 + q) - (a^2 + q) = p * q - p :=
      Mathlib.Tactic.LinearCombination'.sub_pf hb ha
    rw [Nat.add_sub_add_right] at h2
    exact h2

  have hba : a < b := by
    have h2 : p < p * q := lt_mul_right hp_pos (Nat.Prime.one_lt hpq)
    have h3 := calc
              a^2 + q = p := ha
              _ < p * q := h2
              _ = b^2 + q := hb.symm
    have h4 : a^2 < b^2 := Nat.add_lt_add_iff_right.mp h3
    exact lt_of_pow_lt_pow_left' 2 h4
  have hba' : 0 < b - a := Nat.sub_pos_of_lt hba

  -- Since b - a < p and p is prime, we have that p divides b + a.
  have h2 : b - a < p := tsub_lt_of_lt hbp
  have h3 : ¬ p ∣ b - a := Nat.not_dvd_of_pos_of_lt hba' h2

  have h4 : p ∣ p * (q - 1) := Nat.dvd_mul_right p (q - 1)
  rw [←h1, mul_comm] at h4
  have h5 : p ∣ b + a := Or.resolve_left ((Nat.Prime.dvd_mul hpp).mp h4) h3

  -- Since and b + a < 2p, we have that a + b must in fact equal p.
  have h6 : b + a < 2 * p := by lia
  have h7 : b + a = p := by
    obtain ⟨k, hk⟩ := h5
    rw [mul_comm, hk] at h6
    have : k < 2 := (Nat.mul_lt_mul_left hp_pos).mp h6
    interval_cases k <;> lia

  -- Hence q - 1 = b - a.
  have h8 : q - 1 = b - a := by
    rw [h7] at h1
    exact (Nat.eq_of_mul_eq_mul_left hp_pos h1).symm

  -- Note that b - a and b + a have the same parity.
  -- Therefore p and q - 1 have the same parity.
  -- If they are both even, then q > p, contradiction.
  -- Therefore, they are both odd, and q = 2.
  have h9 : q = 2 := by
    have h10 : (b + a) % 2 = (b - a) % 2 := by
      have h11 : b + a = b - a + 2 * a := by
        rw [Nat.two_mul, ←add_assoc, add_left_inj]
        exact Nat.eq_add_of_sub_eq (Nat.le_of_lt hba) rfl
      rw [h11, Nat.add_mod]
      simp only [Nat.mul_mod_right, add_zero, Nat.mod_mod]
    rw [h7, ←h8] at h10
    cases h : p % 2 with
    | zero =>
      have h14 : p = 2 := by
        have h15 : 2 ∣ p := Nat.modEq_zero_iff_dvd.mp h
        obtain h16 | h16 := Nat.Prime.eq_one_or_self_of_dvd hpp _ h15
        · norm_num at h16
        · exact h16.symm
      lia
    | succ p' =>
      cases p' with
      | zero =>
        norm_num at h
        rw [h] at h10
        apply_fun (fun x ↦ (x + (1%2))%2) at h10
        rw [←Nat.add_mod, Nat.sub_add_cancel hq_pos] at h10
        norm_num at h10
        have h15 : 2 ∣ q := Nat.modEq_zero_iff_dvd.mp h10.symm
        obtain h16 | h16 := Nat.Prime.eq_one_or_self_of_dvd hpq _ h15
        · norm_num at h16
        · exact h16.symm
      | succ _ => lia
  have h11 : p = 3 := by
    have h20 : b - a = 1 := by rw [h9] at h8; exact h8.symm
    have h22 : a ≤ b := Nat.le_of_lt hba
    have h21 : b = 1 + a := Nat.eq_add_of_sub_eq h22 h20
    have h23 : p = 2 * a + 1 := by
      rw [h21, add_assoc, ←Nat.two_mul, add_comm] at h7
      exact h7.symm
    rw [h23, h9, Nat.succ_inj] at ha
    have h30 : a = 1 := by
      zify at ha
      have h26 : ((a:ℤ) - 1)^2 = 0 := by linear_combination ha
      have h27 : (a:ℤ) - 1 = 0 := eq_zero_of_pow_eq_zero h26
      have h28 : (a:ℤ) = 1 := Int.sub_eq_zero.mp h27
      exact Int.ofNat_inj.mp h28
    rw [h30] at h23
    exact h23

  simp (config := {decide := true}) only [h9, h11]


end Usa2022P4

-- ═══ Usa2023P2 ═══

/-
Copyright (c) 2023 David Renshaw. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw
-/





/-!
# USA Mathematical Olympiad 2023, Problem 2

Let ℝ+ be the set of positive real numbers.
Find all functions f: ℝ+ → ℝ+ that satisfy the equation

  f(x⬝y + f(x)) = x⬝f(y) + 2

for all x,y ∈ ℝ+.
-/

namespace Usa2023P2

abbrev PosReal : Type := { x : ℝ // 0 < x }

notation "ℝ+" => PosReal



-- Should this be in mathlib as `Positive.val_div`?
lemma val_div (a b : ℝ+) : (a / b).val = a.val / b.val := by rfl

lemma lemma_1 (a b c : ℝ+) : (a + b)/c = a/c + b/c := by
  rw [division_def, add_mul, ←division_def, ←division_def]

lemma lemma_3 {a b c : ℝ+} (h : a = b + c) : c < a := by
  rw [h, ←Subtype.coe_lt_coe, Positive.coe_add]
  exact lt_add_of_pos_left _ b.2



noncomputable def solution_set : Set (ℝ+ → ℝ+) := { fun x ↦ x + 1 }

theorem usa2023_p2 (f : ℝ+ → ℝ+) :
    f ∈ solution_set ↔
    ∀ x y, f (x * y + (f x)) = x * (f y) + ⟨2, two_pos⟩ := by
  constructor
  · intro hf
    rw [solution_set, Set.mem_singleton_iff] at hf
    intro x y
    rw [hf]
    dsimp only
    rw [mul_add, ←add_assoc (x*y), mul_one, add_assoc (x * y + x)]
    congr
    rw [Subtype.mk_eq_mk]
    norm_num
  · -- proof outline megarnie on AOPS:
    -- https://artofproblemsolving.com/community/c5h3038298p27349430

    -- It suffices to show that f must be a linear function.
    intro P
    suffices h : ∃ a b : ℝ, 0 < a ∧ ∀ x, (f x).val = a * x.val + b by
      rw [solution_set, Set.mem_singleton_iff]
      obtain ⟨a, b, ha, hab⟩ := h
      funext x
      rw [←Subtype.coe_inj]

      suffices h : a = 1 ∧ b = 1 by simp [hab, h]

      have P1 : ∀ x : ℝ+, a^2 * x.val + a * b + b = b * x.val + 2 := by
        intro x
        have P2 := P x 1
        simp only at P2
        rw [←Subtype.coe_inj] at P2
        simp only [mul_one, Positive.coe_add, Positive.val_mul, hab, Positive.val_one] at P2
        linarith

      have P3 : ∀ x : ℝ, 0 < x → a^2 * x + a * b + b = b * x + 2 := by
        intro x hx
        have hp1 := P1 ⟨x, hx⟩
        exact hp1

      have hp1 := P3 1 zero_lt_one
      have hp2 := P3 2 zero_lt_two

      have h0 : a^2 = b := by linear_combination hp2 - hp1

      rw [←h0] at hp1 hp2
      have h1 : a = 1 := by nlinarith
      rw [h1, sq, mul_one] at h0
      exact ⟨h1, h0.symm⟩

    let c := f 1

    have h6 : ∀ y, f (y + c) = f y + ⟨2, two_pos⟩ := by
      intro y
      have h7 := P 1 y
      rw [one_mul, one_mul] at h7
      exact h7

    have h5 : ∀ x, f (x + f x) = x * c + ⟨2, two_pos⟩ := by
      intro x
      have h7 := P x 1
      rw [mul_one] at h7
      exact h7

    have h7 : ∀ x, f (x + f x) = x * f (c / x + 1) := by
      intro x
      have h8 := P x (c / x + 1)
      have h9 : x * (c / x + 1) + f x = x + f x + c := by
        rw [mul_add, mul_div_cancel, mul_one]
        exact add_rotate c x (f x)
      rw [h9] at h8; clear h9
      rw [h6 (x + f x), add_left_inj] at h8
      rw [h8]

    have h8 : ∀ x, f (c / x + 1) = c + ⟨2, two_pos⟩ / x := by
      intro x
      have h9 := h7 x
      rw [h5 x] at h9
      apply_fun (· / x) at h9
      rw [mul_div_cancel_left] at h9
      rw [← h9]; clear h9
      rw [lemma_1, mul_div_cancel_left]

    have h9 : ∀ x, f (x + 1) = c + ⟨2,two_pos⟩ * x / c := by
      intro x
      have h10 := h8 (c/x)
      rwa [div_div_cancel, div_div_eq_mul_div] at h10

    have h10 : 1 ≤ c := by
      by_contra! H
      have h11 : 0 < 1 - (f 1).val := Iff.mpr sub_pos H
      have h12 := P 1 ⟨1 - (f 1).val, h11⟩
      rw [one_mul, one_mul] at h12
      have h13 : ⟨1 - (f 1).val, h11⟩ + f 1 = 1 := by
        rw [←Subtype.coe_inj]; simp only [Positive.coe_add, sub_add_cancel, Positive.val_one]
      rw [h13] at h12; clear h13
      have h14 : ⟨2, two_pos⟩ < f 1 := lemma_3 h12
      have h15 : (1:ℝ+) < ⟨2, two_pos⟩ := by rw [Subtype.mk_lt_mk]; exact one_lt_two
      exact ((H.trans h15).trans h14).false

    have h11 : ∀ x : ℝ+, 0 < (x + c).val - 1 := by
      intro x
      obtain ⟨c, hc⟩ := c
      obtain ⟨x, hx⟩ := x
      change 1 ≤ c at h10
      simp only [Positive.coe_add, sub_pos]
      exact lt_add_of_pos_of_le hx h10

    have h12 : ∀ x, c + ⟨2,two_pos⟩ * ⟨(x + c).val - 1, h11 _⟩ / c = f x + ⟨2, two_pos⟩ := by
      intro x
      rw [← h6]
      symm
      have h20 := h9 ⟨(x + c).val - 1, h11 _⟩
      have h21 : (⟨(x + c).val - 1, h11 _⟩ : ℝ+) + 1 = x + c := by
        obtain ⟨x, hx⟩ := x
        obtain ⟨cc, hcc⟩ := c
        rw [←Subtype.coe_inj]
        simp
      rw [h21] at h20
      exact h20

    refine ⟨2 / c.val, c.val - 2 / c.val, div_pos two_pos c.prop, ?_⟩
    intro x

    have h15 := h12 x
    rw [←Subtype.coe_inj] at h15
    rw [Positive.coe_add] at h15
    rw [val_div, Positive.val_mul, @Subtype.coe_mk _ _ 2] at h15
    rw [Subtype.coe_mk]
    obtain ⟨x, hx⟩ := x
    simp only [Positive.coe_add] at h15
    simp only
    obtain ⟨cc, rfl⟩ : ∃ cc, cc = f 1 := exists_eq
    rw [mul_sub, mul_add, mul_one, sub_div, add_div] at h15
    have h18 : (f 1).val ≠ 0 := ne_of_gt (f 1).prop
    rw [mul_div_cancel_right₀ 2 h18] at h15
    symm
    linear_combination h15


end Usa2023P2

